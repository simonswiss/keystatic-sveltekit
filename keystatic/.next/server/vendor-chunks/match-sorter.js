"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/match-sorter";
exports.ids = ["vendor-chunks/match-sorter"];
exports.modules = {

/***/ "(ssr)/./node_modules/match-sorter/dist/match-sorter.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/match-sorter/dist/match-sorter.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultBaseSortFn: () => (/* binding */ defaultBaseSortFn),\n/* harmony export */   matchSorter: () => (/* binding */ matchSorter),\n/* harmony export */   rankings: () => (/* binding */ rankings)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var remove_accents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! remove-accents */ \"(ssr)/./node_modules/remove-accents/index.js\");\n/* harmony import */ var remove_accents__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(remove_accents__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar rankings = {\n    CASE_SENSITIVE_EQUAL: 7,\n    EQUAL: 6,\n    STARTS_WITH: 5,\n    WORD_STARTS_WITH: 4,\n    CONTAINS: 3,\n    ACRONYM: 2,\n    MATCHES: 1,\n    NO_MATCH: 0\n};\nmatchSorter.rankings = rankings;\nvar defaultBaseSortFn = function defaultBaseSortFn(a, b) {\n    return String(a.rankedValue).localeCompare(String(b.rankedValue));\n};\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */ function matchSorter(items, value, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, keys = _options.keys, _options$threshold = _options.threshold, threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold, _options$baseSort = _options.baseSort, baseSort = _options$baseSort === void 0 ? defaultBaseSortFn : _options$baseSort, _options$sorter = _options.sorter, sorter = _options$sorter === void 0 ? function(matchedItems) {\n        return matchedItems.sort(function(a, b) {\n            return sortRankedValues(a, b, baseSort);\n        });\n    } : _options$sorter;\n    var matchedItems = items.reduce(reduceItemsToRanked, []);\n    return sorter(matchedItems).map(function(_ref) {\n        var item = _ref.item;\n        return item;\n    });\n    function reduceItemsToRanked(matches, item, index) {\n        var rankingInfo = getHighestRanking(item, keys, value, options);\n        var rank = rankingInfo.rank, _rankingInfo$keyThres = rankingInfo.keyThreshold, keyThreshold = _rankingInfo$keyThres === void 0 ? threshold : _rankingInfo$keyThres;\n        if (rank >= keyThreshold) {\n            matches.push((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, rankingInfo, {\n                item: item,\n                index: index\n            }));\n        }\n        return matches;\n    }\n}\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */ function getHighestRanking(item, keys, value, options) {\n    if (!keys) {\n        // if keys is not specified, then we assume the item given is ready to be matched\n        var stringItem = item;\n        return {\n            // ends up being duplicate of 'item' in matches but consistent\n            rankedValue: stringItem,\n            rank: getMatchRanking(stringItem, value, options),\n            keyIndex: -1,\n            keyThreshold: options.threshold\n        };\n    }\n    var valuesToRank = getAllValuesToRank(item, keys);\n    return valuesToRank.reduce(function(_ref2, _ref3, i) {\n        var rank = _ref2.rank, rankedValue = _ref2.rankedValue, keyIndex = _ref2.keyIndex, keyThreshold = _ref2.keyThreshold;\n        var itemValue = _ref3.itemValue, attributes = _ref3.attributes;\n        var newRank = getMatchRanking(itemValue, value, options);\n        var newRankedValue = rankedValue;\n        var minRanking = attributes.minRanking, maxRanking = attributes.maxRanking, threshold = attributes.threshold;\n        if (newRank < minRanking && newRank >= rankings.MATCHES) {\n            newRank = minRanking;\n        } else if (newRank > maxRanking) {\n            newRank = maxRanking;\n        }\n        if (newRank > rank) {\n            rank = newRank;\n            keyIndex = i;\n            keyThreshold = threshold;\n            newRankedValue = itemValue;\n        }\n        return {\n            rankedValue: newRankedValue,\n            rank: rank,\n            keyIndex: keyIndex,\n            keyThreshold: keyThreshold\n        };\n    }, {\n        rankedValue: item,\n        rank: rankings.NO_MATCH,\n        keyIndex: -1,\n        keyThreshold: options.threshold\n    });\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */ function getMatchRanking(testString, stringToRank, options) {\n    testString = prepareValueForComparison(testString, options);\n    stringToRank = prepareValueForComparison(stringToRank, options); // too long\n    if (stringToRank.length > testString.length) {\n        return rankings.NO_MATCH;\n    } // case sensitive equals\n    if (testString === stringToRank) {\n        return rankings.CASE_SENSITIVE_EQUAL;\n    } // Lower casing before further comparison\n    testString = testString.toLowerCase();\n    stringToRank = stringToRank.toLowerCase(); // case insensitive equals\n    if (testString === stringToRank) {\n        return rankings.EQUAL;\n    } // starts with\n    if (testString.startsWith(stringToRank)) {\n        return rankings.STARTS_WITH;\n    } // word starts with\n    if (testString.includes(\" \" + stringToRank)) {\n        return rankings.WORD_STARTS_WITH;\n    } // contains\n    if (testString.includes(stringToRank)) {\n        return rankings.CONTAINS;\n    } else if (stringToRank.length === 1) {\n        // If the only character in the given stringToRank\n        //   isn't even contained in the testString, then\n        //   it's definitely not a match.\n        return rankings.NO_MATCH;\n    } // acronym\n    if (getAcronym(testString).includes(stringToRank)) {\n        return rankings.ACRONYM;\n    } // will return a number between rankings.MATCHES and\n    // rankings.MATCHES + 1 depending  on how close of a match it is.\n    return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */ function getAcronym(string) {\n    var acronym = \"\";\n    var wordsInString = string.split(\" \");\n    wordsInString.forEach(function(wordInString) {\n        var splitByHyphenWords = wordInString.split(\"-\");\n        splitByHyphenWords.forEach(function(splitByHyphenWord) {\n            acronym += splitByHyphenWord.substr(0, 1);\n        });\n    });\n    return acronym;\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */ function getClosenessRanking(testString, stringToRank) {\n    var matchingInOrderCharCount = 0;\n    var charNumber = 0;\n    function findMatchingCharacter(matchChar, string, index) {\n        for(var j = index, J = string.length; j < J; j++){\n            var stringChar = string[j];\n            if (stringChar === matchChar) {\n                matchingInOrderCharCount += 1;\n                return j + 1;\n            }\n        }\n        return -1;\n    }\n    function getRanking(spread) {\n        var spreadPercentage = 1 / spread;\n        var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n        var ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;\n        return ranking;\n    }\n    var firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n    if (firstIndex < 0) {\n        return rankings.NO_MATCH;\n    }\n    charNumber = firstIndex;\n    for(var i = 1, I = stringToRank.length; i < I; i++){\n        var matchChar = stringToRank[i];\n        charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n        var found = charNumber > -1;\n        if (!found) {\n            return rankings.NO_MATCH;\n        }\n    }\n    var spread = charNumber - firstIndex;\n    return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */ function sortRankedValues(a, b, baseSort) {\n    var aFirst = -1;\n    var bFirst = 1;\n    var aRank = a.rank, aKeyIndex = a.keyIndex;\n    var bRank = b.rank, bKeyIndex = b.keyIndex;\n    var same = aRank === bRank;\n    if (same) {\n        if (aKeyIndex === bKeyIndex) {\n            // use the base sort function as a tie-breaker\n            return baseSort(a, b);\n        } else {\n            return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n        }\n    } else {\n        return aRank > bRank ? aFirst : bFirst;\n    }\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */ function prepareValueForComparison(value, _ref4) {\n    var keepDiacritics = _ref4.keepDiacritics;\n    // value might not actually be a string at this point (we don't get to choose)\n    // so part of preparing the value for comparison is ensure that it is a string\n    value = \"\" + value; // toString\n    if (!keepDiacritics) {\n        value = remove_accents__WEBPACK_IMPORTED_MODULE_1___default()(value);\n    }\n    return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */ function getItemValues(item, key) {\n    if (typeof key === \"object\") {\n        key = key.key;\n    }\n    var value;\n    if (typeof key === \"function\") {\n        value = key(item);\n    } else if (item == null) {\n        value = null;\n    } else if (Object.hasOwnProperty.call(item, key)) {\n        value = item[key];\n    } else if (key.includes(\".\")) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        return getNestedValues(key, item);\n    } else {\n        value = null;\n    } // because `value` can also be undefined\n    if (value == null) {\n        return [];\n    }\n    if (Array.isArray(value)) {\n        return value;\n    }\n    return [\n        String(value)\n    ];\n}\n/**\n * Given path: \"foo.bar.baz\"\n * And item: {foo: {bar: {baz: 'buzz'}}}\n *   -> 'buzz'\n * @param path a dot-separated set of keys\n * @param item the item to get the value from\n */ function getNestedValues(path, item) {\n    var keys = path.split(\".\");\n    var values = [\n        item\n    ];\n    for(var i = 0, I = keys.length; i < I; i++){\n        var nestedKey = keys[i];\n        var nestedValues = [];\n        for(var j = 0, J = values.length; j < J; j++){\n            var nestedItem = values[j];\n            if (nestedItem == null) continue;\n            if (Object.hasOwnProperty.call(nestedItem, nestedKey)) {\n                var nestedValue = nestedItem[nestedKey];\n                if (nestedValue != null) {\n                    nestedValues.push(nestedValue);\n                }\n            } else if (nestedKey === \"*\") {\n                // ensure that values is an array\n                nestedValues = nestedValues.concat(nestedItem);\n            }\n        }\n        values = nestedValues;\n    }\n    if (Array.isArray(values[0])) {\n        // keep allowing the implicit wildcard for an array of strings at the end of\n        // the path; don't use `.flat()` because that's not available in node.js v10\n        var result = [];\n        return result.concat.apply(result, values);\n    } // Based on our logic it should be an array of strings by now...\n    // assuming the user's path terminated in strings\n    return values;\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */ function getAllValuesToRank(item, keys) {\n    var allValues = [];\n    for(var j = 0, J = keys.length; j < J; j++){\n        var key = keys[j];\n        var attributes = getKeyAttributes(key);\n        var itemValues = getItemValues(item, key);\n        for(var i = 0, I = itemValues.length; i < I; i++){\n            allValues.push({\n                itemValue: itemValues[i],\n                attributes: attributes\n            });\n        }\n    }\n    return allValues;\n}\nvar defaultKeyAttributes = {\n    maxRanking: Infinity,\n    minRanking: -Infinity\n};\n/**\n * Gets all the attributes for the given key\n * @param key - the key from which the attributes will be retrieved\n * @return object containing the key's attributes\n */ function getKeyAttributes(key) {\n    if (typeof key === \"string\") {\n        return defaultKeyAttributes;\n    }\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, defaultKeyAttributes, key);\n}\n/*\neslint\n  no-continue: \"off\",\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWF0Y2gtc29ydGVyL2Rpc3QvbWF0Y2gtc29ydGVyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEQ7QUFDZjtBQUUzQyxJQUFJRSxXQUFXO0lBQ2JDLHNCQUFzQjtJQUN0QkMsT0FBTztJQUNQQyxhQUFhO0lBQ2JDLGtCQUFrQjtJQUNsQkMsVUFBVTtJQUNWQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsVUFBVTtBQUNaO0FBQ0FDLFlBQVlULFFBQVEsR0FBR0E7QUFFdkIsSUFBSVUsb0JBQW9CLFNBQVNBLGtCQUFrQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3JELE9BQU9DLE9BQU9GLEVBQUVHLFdBQVcsRUFBRUMsYUFBYSxDQUFDRixPQUFPRCxFQUFFRSxXQUFXO0FBQ2pFO0FBQ0E7Ozs7OztDQU1DLEdBR0QsU0FBU0wsWUFBWU8sS0FBSyxFQUFFQyxLQUFLLEVBQUVDLE9BQU87SUFDeEMsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUsQ0FBQztJQUNiO0lBRUEsSUFBSUMsV0FBV0QsU0FDWEUsT0FBT0QsU0FBU0MsSUFBSSxFQUNwQkMscUJBQXFCRixTQUFTRyxTQUFTLEVBQ3ZDQSxZQUFZRCx1QkFBdUIsS0FBSyxJQUFJckIsU0FBU08sT0FBTyxHQUFHYyxvQkFDL0RFLG9CQUFvQkosU0FBU0ssUUFBUSxFQUNyQ0EsV0FBV0Qsc0JBQXNCLEtBQUssSUFBSWIsb0JBQW9CYSxtQkFDOURFLGtCQUFrQk4sU0FBU08sTUFBTSxFQUNqQ0EsU0FBU0Qsb0JBQW9CLEtBQUssSUFBSSxTQUFVRSxZQUFZO1FBQzlELE9BQU9BLGFBQWFDLElBQUksQ0FBQyxTQUFVakIsQ0FBQyxFQUFFQyxDQUFDO1lBQ3JDLE9BQU9pQixpQkFBaUJsQixHQUFHQyxHQUFHWTtRQUNoQztJQUNGLElBQUlDO0lBQ0osSUFBSUUsZUFBZVgsTUFBTWMsTUFBTSxDQUFDQyxxQkFBcUIsRUFBRTtJQUN2RCxPQUFPTCxPQUFPQyxjQUFjSyxH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U0FBUzdELG1CQUFtQmIsSUFBSSxFQUFFZCxJQUFJO0lBQ3BDLElBQUlnRyxZQUFZLEVBQUU7SUFFbEIsSUFBSyxJQUFJckMsSUFBSSxHQUFHQyxJQUFJNUQsS0FBS3dDLE1BQU0sRUFBRW1CLElBQUlDLEdBQUdELElBQUs7UUFDM0MsSUFBSXFCLE1BQU1oRixJQUFJLENBQUMyRCxFQUFFO1FBQ2pCLElBQUkzQixhQUFhaUUsaUJBQWlCakI7UUFDbEMsSUFBSWtCLGFBQWFuQixjQUFjakUsTUFBTWtFO1FBRXJDLElBQUssSUFBSWxELElBQUksR0FBR3NDLElBQUk4QixXQUFXMUQsTUFBTSxFQUFFVixJQUFJc0MsR0FBR3RDLElBQUs7WUFDakRrRSxVQUFVMUUsSUFBSSxDQUFDO2dCQUNiUyxXQUFXbUUsVUFBVSxDQUFDcEUsRUFBRTtnQkFDeEJFLFlBQVlBO1lBQ2Q7UUFDRjtJQUNGO0lBRUEsT0FBT2dFO0FBQ1Q7QUFFQSxJQUFJRyx1QkFBdUI7SUFDekIvRCxZQUFZZ0U7SUFDWmpFLFlBQVksQ0FBQ2lFO0FBQ2Y7QUFDQTs7OztDQUlDLEdBRUQsU0FBU0gsaUJBQWlCakIsR0FBRztJQUMzQixJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUMzQixPQUFPbUI7SUFDVDtJQUVBLE9BQU96SCw4RUFBUUEsQ0FBQyxDQUFDLEdBQUd5SCxzQkFBc0JuQjtBQUM1QztBQUNBOzs7QUFHQSxHQUVvRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9tYXRjaC1zb3J0ZXIvZGlzdC9tYXRjaC1zb3J0ZXIuZXNtLmpzPzg3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHJlbW92ZUFjY2VudHMgZnJvbSAncmVtb3ZlLWFjY2VudHMnO1xuXG52YXIgcmFua2luZ3MgPSB7XG4gIENBU0VfU0VOU0lUSVZFX0VRVUFMOiA3LFxuICBFUVVBTDogNixcbiAgU1RBUlRTX1dJVEg6IDUsXG4gIFdPUkRfU1RBUlRTX1dJVEg6IDQsXG4gIENPTlRBSU5TOiAzLFxuICBBQ1JPTllNOiAyLFxuICBNQVRDSEVTOiAxLFxuICBOT19NQVRDSDogMFxufTtcbm1hdGNoU29ydGVyLnJhbmtpbmdzID0gcmFua2luZ3M7XG5cbnZhciBkZWZhdWx0QmFzZVNvcnRGbiA9IGZ1bmN0aW9uIGRlZmF1bHRCYXNlU29ydEZuKGEsIGIpIHtcbiAgcmV0dXJuIFN0cmluZyhhLnJhbmtlZFZhbHVlKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiLnJhbmtlZFZhbHVlKSk7XG59O1xuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBpdGVtcyBhbmQgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSB3aXRoIHRoZSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBnaXZlbiB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gaXRlbXMgLSB0aGUgaXRlbXMgdG8gc29ydFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHVzZSBmb3IgcmFua2luZ1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBTb21lIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSBzb3J0ZXJcbiAqIEByZXR1cm4ge0FycmF5fSAtIHRoZSBuZXcgc29ydGVkIGFycmF5XG4gKi9cblxuXG5mdW5jdGlvbiBtYXRjaFNvcnRlcihpdGVtcywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBrZXlzID0gX29wdGlvbnMua2V5cyxcbiAgICAgIF9vcHRpb25zJHRocmVzaG9sZCA9IF9vcHRpb25zLnRocmVzaG9sZCxcbiAgICAgIHRocmVzaG9sZCA9IF9vcHRpb25zJHRocmVzaG9sZCA9PT0gdm9pZCAwID8gcmFua2luZ3MuTUFUQ0hFUyA6IF9vcHRpb25zJHRocmVzaG9sZCxcbiAgICAgIF9vcHRpb25zJGJhc2VTb3J0ID0gX29wdGlvbnMuYmFzZVNvcnQsXG4gICAgICBiYXNlU29ydCA9IF9vcHRpb25zJGJhc2VTb3J0ID09PSB2b2lkIDAgPyBkZWZhdWx0QmFzZVNvcnRGbiA6IF9vcHRpb25zJGJhc2VTb3J0LFxuICAgICAgX29wdGlvbnMkc29ydGVyID0gX29wdGlvbnMuc29ydGVyLFxuICAgICAgc29ydGVyID0gX29wdGlvbnMkc29ydGVyID09PSB2b2lkIDAgPyBmdW5jdGlvbiAobWF0Y2hlZEl0ZW1zKSB7XG4gICAgcmV0dXJuIG1hdGNoZWRJdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gc29ydFJhbmtlZFZhbHVlcyhhLCBiLCBiYXNlU29ydCk7XG4gICAgfSk7XG4gIH0gOiBfb3B0aW9ucyRzb3J0ZXI7XG4gIHZhciBtYXRjaGVkSXRlbXMgPSBpdGVtcy5yZWR1Y2UocmVkdWNlSXRlbXNUb1JhbmtlZCwgW10pO1xuICByZXR1cm4gc29ydGVyKG1hdGNoZWRJdGVtcykubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGl0ZW0gPSBfcmVmLml0ZW07XG4gICAgcmV0dXJuIGl0ZW07XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHJlZHVjZUl0ZW1zVG9SYW5rZWQobWF0Y2hlcywgaXRlbSwgaW5kZXgpIHtcbiAgICB2YXIgcmFua2luZ0luZm8gPSBnZXRIaWdoZXN0UmFua2luZyhpdGVtLCBrZXlzLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgdmFyIHJhbmsgPSByYW5raW5nSW5mby5yYW5rLFxuICAgICAgICBfcmFua2luZ0luZm8ka2V5VGhyZXMgPSByYW5raW5nSW5mby5rZXlUaHJlc2hvbGQsXG4gICAgICAgIGtleVRocmVzaG9sZCA9IF9yYW5raW5nSW5mbyRrZXlUaHJlcyA9PT0gdm9pZCAwID8gdGhyZXNob2xkIDogX3JhbmtpbmdJbmZvJGtleVRocmVzO1xuXG4gICAgaWYgKHJhbmsgPj0ga2V5VGhyZXNob2xkKSB7XG4gICAgICBtYXRjaGVzLnB1c2goX2V4dGVuZHMoe30sIHJhbmtpbmdJbmZvLCB7XG4gICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGhpZ2hlc3QgcmFua2luZyBmb3IgdmFsdWUgZm9yIHRoZSBnaXZlbiBpdGVtIGJhc2VkIG9uIGl0cyB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBrZXlzXG4gKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgaXRlbSB0byByYW5rXG4gKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gdGhlIGtleXMgdG8gZ2V0IHZhbHVlcyBmcm9tIHRoZSBpdGVtIGZvciB0aGUgcmFua2luZ1xuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHJhbmsgYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRvIGNvbnRyb2wgdGhlIHJhbmtpbmdcbiAqIEByZXR1cm4ge3tyYW5rOiBOdW1iZXIsIGtleUluZGV4OiBOdW1iZXIsIGtleVRocmVzaG9sZDogTnVtYmVyfX0gLSB0aGUgaGlnaGVzdCByYW5raW5nXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRIaWdoZXN0UmFua2luZyhpdGVtLCBrZXlzLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIWtleXMpIHtcbiAgICAvLyBpZiBrZXlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gd2UgYXNzdW1lIHRoZSBpdGVtIGdpdmVuIGlzIHJlYWR5IHRvIGJlIG1hdGNoZWRcbiAgICB2YXIgc3RyaW5nSXRlbSA9IGl0ZW07XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGVuZHMgdXAgYmVpbmcgZHVwbGljYXRlIG9mICdpdGVtJyBpbiBtYXRjaGVzIGJ1dCBjb25zaXN0ZW50XG4gICAgICByYW5rZWRWYWx1ZTogc3RyaW5nSXRlbSxcbiAgICAgIHJhbms6IGdldE1hdGNoUmFua2luZyhzdHJpbmdJdGVtLCB2YWx1ZSwgb3B0aW9ucyksXG4gICAgICBrZXlJbmRleDogLTEsXG4gICAgICBrZXlUaHJlc2hvbGQ6IG9wdGlvbnMudGhyZXNob2xkXG4gICAgfTtcbiAgfVxuXG4gIHZhciB2YWx1ZXNUb1JhbmsgPSBnZXRBbGxWYWx1ZXNUb1JhbmsoaXRlbSwga2V5cyk7XG4gIHJldHVybiB2YWx1ZXNUb1JhbmsucmVkdWNlKGZ1bmN0aW9uIChfcmVmMiwgX3JlZjMsIGkpIHtcbiAgICB2YXIgcmFuayA9IF9yZWYyLnJhbmssXG4gICAgICAgIHJhbmtlZFZhbHVlID0gX3JlZjIucmFua2VkVmFsdWUsXG4gICAgICAgIGtleUluZGV4ID0gX3JlZjIua2V5SW5kZXgsXG4gICAgICAgIGtleVRocmVzaG9sZCA9IF9yZWYyLmtleVRocmVzaG9sZDtcbiAgICB2YXIgaXRlbVZhbHVlID0gX3JlZjMuaXRlbVZhbHVlLFxuICAgICAgICBhdHRyaWJ1dGVzID0gX3JlZjMuYXR0cmlidXRlcztcbiAgICB2YXIgbmV3UmFuayA9IGdldE1hdGNoUmFua2luZyhpdGVtVmFsdWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICB2YXIgbmV3UmFua2VkVmFsdWUgPSByYW5rZWRWYWx1ZTtcbiAgICB2YXIgbWluUmFua2luZyA9IGF0dHJpYnV0ZXMubWluUmFua2luZyxcbiAgICAgICAgbWF4UmFua2luZyA9IGF0dHJpYnV0ZXMubWF4UmFua2luZyxcbiAgICAgICAgdGhyZXNob2xkID0gYXR0cmlidXRlcy50aHJlc2hvbGQ7XG5cbiAgICBpZiAobmV3UmFuayA8IG1pblJhbmtpbmcgJiYgbmV3UmFuayA+PSByYW5raW5ncy5NQVRDSEVTKSB7XG4gICAgICBuZXdSYW5rID0gbWluUmFua2luZztcbiAgICB9IGVsc2UgaWYgKG5ld1JhbmsgPiBtYXhSYW5raW5nKSB7XG4gICAgICBuZXdSYW5rID0gbWF4UmFua2luZztcbiAgICB9XG5cbiAgICBpZiAobmV3UmFuayA+IHJhbmspIHtcbiAgICAgIHJhbmsgPSBuZXdSYW5rO1xuICAgICAga2V5SW5kZXggPSBpO1xuICAgICAga2V5VGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgICAgbmV3UmFua2VkVmFsdWUgPSBpdGVtVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJhbmtlZFZhbHVlOiBuZXdSYW5rZWRWYWx1ZSxcbiAgICAgIHJhbms6IHJhbmssXG4gICAgICBrZXlJbmRleDoga2V5SW5kZXgsXG4gICAgICBrZXlUaHJlc2hvbGQ6IGtleVRocmVzaG9sZFxuICAgIH07XG4gIH0sIHtcbiAgICByYW5rZWRWYWx1ZTogaXRlbSxcbiAgICByYW5rOiByYW5raW5ncy5OT19NQVRDSCxcbiAgICBrZXlJbmRleDogLTEsXG4gICAga2V5VGhyZXNob2xkOiBvcHRpb25zLnRocmVzaG9sZFxuICB9KTtcbn1cbi8qKlxuICogR2l2ZXMgYSByYW5raW5ncyBzY29yZSBiYXNlZCBvbiBob3cgd2VsbCB0aGUgdHdvIHN0cmluZ3MgbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVzdFN0cmluZyAtIHRoZSBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nVG9SYW5rIC0gdGhlIHN0cmluZyB0byByYW5rXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIHRoZSBtYXRjaCAobGlrZSBrZWVwRGlhY3JpdGljcyBmb3IgY29tcGFyaXNvbilcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSByYW5raW5nIGZvciBob3cgd2VsbCBzdHJpbmdUb1JhbmsgbWF0Y2hlcyB0ZXN0U3RyaW5nXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRNYXRjaFJhbmtpbmcodGVzdFN0cmluZywgc3RyaW5nVG9SYW5rLCBvcHRpb25zKSB7XG4gIHRlc3RTdHJpbmcgPSBwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uKHRlc3RTdHJpbmcsIG9wdGlvbnMpO1xuICBzdHJpbmdUb1JhbmsgPSBwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uKHN0cmluZ1RvUmFuaywgb3B0aW9ucyk7IC8vIHRvbyBsb25nXG5cbiAgaWYgKHN0cmluZ1RvUmFuay5sZW5ndGggPiB0ZXN0U3RyaW5nLmxlbmd0aCkge1xuICAgIHJldHVybiByYW5raW5ncy5OT19NQVRDSDtcbiAgfSAvLyBjYXNlIHNlbnNpdGl2ZSBlcXVhbHNcblxuXG4gIGlmICh0ZXN0U3RyaW5nID09PSBzdHJpbmdUb1JhbmspIHtcbiAgICByZXR1cm4gcmFua2luZ3MuQ0FTRV9TRU5TSVRJVkVfRVFVQUw7XG4gIH0gLy8gTG93ZXIgY2FzaW5nIGJlZm9yZSBmdXJ0aGVyIGNvbXBhcmlzb25cblxuXG4gIHRlc3RTdHJpbmcgPSB0ZXN0U3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gIHN0cmluZ1RvUmFuayA9IHN0cmluZ1RvUmFuay50b0xvd2VyQ2FzZSgpOyAvLyBjYXNlIGluc2Vuc2l0aXZlIGVxdWFsc1xuXG4gIGlmICh0ZXN0U3RyaW5nID09PSBzdHJpbmdUb1JhbmspIHtcbiAgICByZXR1cm4gcmFua2luZ3MuRVFVQUw7XG4gIH0gLy8gc3RhcnRzIHdpdGhcblxuXG4gIGlmICh0ZXN0U3RyaW5nLnN0YXJ0c1dpdGgoc3RyaW5nVG9SYW5rKSkge1xuICAgIHJldHVybiByYW5raW5ncy5TVEFSVFNfV0lUSDtcbiAgfSAvLyB3b3JkIHN0YXJ0cyB3aXRoXG5cblxuICBpZiAodGVzdFN0cmluZy5pbmNsdWRlcyhcIiBcIiArIHN0cmluZ1RvUmFuaykpIHtcbiAgICByZXR1cm4gcmFua2luZ3MuV09SRF9TVEFSVFNfV0lUSDtcbiAgfSAvLyBjb250YWluc1xuXG5cbiAgaWYgKHRlc3RTdHJpbmcuaW5jbHVkZXMoc3RyaW5nVG9SYW5rKSkge1xuICAgIHJldHVybiByYW5raW5ncy5DT05UQUlOUztcbiAgfSBlbHNlIGlmIChzdHJpbmdUb1JhbmsubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gSWYgdGhlIG9ubHkgY2hhcmFjdGVyIGluIHRoZSBnaXZlbiBzdHJpbmdUb1JhbmtcbiAgICAvLyAgIGlzbid0IGV2ZW4gY29udGFpbmVkIGluIHRoZSB0ZXN0U3RyaW5nLCB0aGVuXG4gICAgLy8gICBpdCdzIGRlZmluaXRlbHkgbm90IGEgbWF0Y2guXG4gICAgcmV0dXJuIHJhbmtpbmdzLk5PX01BVENIO1xuICB9IC8vIGFjcm9ueW1cblxuXG4gIGlmIChnZXRBY3JvbnltKHRlc3RTdHJpbmcpLmluY2x1ZGVzKHN0cmluZ1RvUmFuaykpIHtcbiAgICByZXR1cm4gcmFua2luZ3MuQUNST05ZTTtcbiAgfSAvLyB3aWxsIHJldHVybiBhIG51bWJlciBiZXR3ZWVuIHJhbmtpbmdzLk1BVENIRVMgYW5kXG4gIC8vIHJhbmtpbmdzLk1BVENIRVMgKyAxIGRlcGVuZGluZyAgb24gaG93IGNsb3NlIG9mIGEgbWF0Y2ggaXQgaXMuXG5cblxuICByZXR1cm4gZ2V0Q2xvc2VuZXNzUmFua2luZyh0ZXN0U3RyaW5nLCBzdHJpbmdUb1JhbmspO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWNyb255bSBmb3IgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0aGUgc3RyaW5nIGZvciB3aGljaCB0byBwcm9kdWNlIHRoZSBhY3JvbnltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgYWNyb255bVxuICovXG5cblxuZnVuY3Rpb24gZ2V0QWNyb255bShzdHJpbmcpIHtcbiAgdmFyIGFjcm9ueW0gPSAnJztcbiAgdmFyIHdvcmRzSW5TdHJpbmcgPSBzdHJpbmcuc3BsaXQoJyAnKTtcbiAgd29yZHNJblN0cmluZy5mb3JFYWNoKGZ1bmN0aW9uICh3b3JkSW5TdHJpbmcpIHtcbiAgICB2YXIgc3BsaXRCeUh5cGhlbldvcmRzID0gd29yZEluU3RyaW5nLnNwbGl0KCctJyk7XG4gICAgc3BsaXRCeUh5cGhlbldvcmRzLmZvckVhY2goZnVuY3Rpb24gKHNwbGl0QnlIeXBoZW5Xb3JkKSB7XG4gICAgICBhY3JvbnltICs9IHNwbGl0QnlIeXBoZW5Xb3JkLnN1YnN0cigwLCAxKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBhY3JvbnltO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc2NvcmUgYmFzZWQgb24gaG93IHNwcmVhZCBhcGFydCB0aGVcbiAqIGNoYXJhY3RlcnMgZnJvbSB0aGUgc3RyaW5nVG9SYW5rIGFyZSB3aXRoaW4gdGhlIHRlc3RTdHJpbmcuXG4gKiBBIG51bWJlciBjbG9zZSB0byByYW5raW5ncy5NQVRDSEVTIHJlcHJlc2VudHMgYSBsb29zZSBtYXRjaC4gQSBudW1iZXIgY2xvc2VcbiAqIHRvIHJhbmtpbmdzLk1BVENIRVMgKyAxIHJlcHJlc2VudHMgYSB0aWdodGVyIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd9IHRlc3RTdHJpbmcgLSB0aGUgc3RyaW5nIHRvIHRlc3QgYWdhaW5zdFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1RvUmFuayAtIHRoZSBzdHJpbmcgdG8gcmFua1xuICogQHJldHVybnMge051bWJlcn0gdGhlIG51bWJlciBiZXR3ZWVuIHJhbmtpbmdzLk1BVENIRVMgYW5kXG4gKiByYW5raW5ncy5NQVRDSEVTICsgMSBmb3IgaG93IHdlbGwgc3RyaW5nVG9SYW5rIG1hdGNoZXMgdGVzdFN0cmluZ1xuICovXG5cblxuZnVuY3Rpb24gZ2V0Q2xvc2VuZXNzUmFua2luZyh0ZXN0U3RyaW5nLCBzdHJpbmdUb1JhbmspIHtcbiAgdmFyIG1hdGNoaW5nSW5PcmRlckNoYXJDb3VudCA9IDA7XG4gIHZhciBjaGFyTnVtYmVyID0gMDtcblxuICBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdDaGFyYWN0ZXIobWF0Y2hDaGFyLCBzdHJpbmcsIGluZGV4KSB7XG4gICAgZm9yICh2YXIgaiA9IGluZGV4LCBKID0gc3RyaW5nLmxlbmd0aDsgaiA8IEo7IGorKykge1xuICAgICAgdmFyIHN0cmluZ0NoYXIgPSBzdHJpbmdbal07XG5cbiAgICAgIGlmIChzdHJpbmdDaGFyID09PSBtYXRjaENoYXIpIHtcbiAgICAgICAgbWF0Y2hpbmdJbk9yZGVyQ2hhckNvdW50ICs9IDE7XG4gICAgICAgIHJldHVybiBqICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYW5raW5nKHNwcmVhZCkge1xuICAgIHZhciBzcHJlYWRQZXJjZW50YWdlID0gMSAvIHNwcmVhZDtcbiAgICB2YXIgaW5PcmRlclBlcmNlbnRhZ2UgPSBtYXRjaGluZ0luT3JkZXJDaGFyQ291bnQgLyBzdHJpbmdUb1JhbmsubGVuZ3RoO1xuICAgIHZhciByYW5raW5nID0gcmFua2luZ3MuTUFUQ0hFUyArIGluT3JkZXJQZXJjZW50YWdlICogc3ByZWFkUGVyY2VudGFnZTtcbiAgICByZXR1cm4gcmFua2luZztcbiAgfVxuXG4gIHZhciBmaXJzdEluZGV4ID0gZmluZE1hdGNoaW5nQ2hhcmFjdGVyKHN0cmluZ1RvUmFua1swXSwgdGVzdFN0cmluZywgMCk7XG5cbiAgaWYgKGZpcnN0SW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLk5PX01BVENIO1xuICB9XG5cbiAgY2hhck51bWJlciA9IGZpcnN0SW5kZXg7XG5cbiAgZm9yICh2YXIgaSA9IDEsIEkgPSBzdHJpbmdUb1JhbmsubGVuZ3RoOyBpIDwgSTsgaSsrKSB7XG4gICAgdmFyIG1hdGNoQ2hhciA9IHN0cmluZ1RvUmFua1tpXTtcbiAgICBjaGFyTnVtYmVyID0gZmluZE1hdGNoaW5nQ2hhcmFjdGVyKG1hdGNoQ2hhciwgdGVzdFN0cmluZywgY2hhck51bWJlcik7XG4gICAgdmFyIGZvdW5kID0gY2hhck51bWJlciA+IC0xO1xuXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgcmV0dXJuIHJhbmtpbmdzLk5PX01BVENIO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzcHJlYWQgPSBjaGFyTnVtYmVyIC0gZmlyc3RJbmRleDtcbiAgcmV0dXJuIGdldFJhbmtpbmcoc3ByZWFkKTtcbn1cbi8qKlxuICogU29ydHMgaXRlbXMgdGhhdCBoYXZlIGEgcmFuaywgaW5kZXgsIGFuZCBrZXlJbmRleFxuICogQHBhcmFtIHtPYmplY3R9IGEgLSB0aGUgZmlyc3QgaXRlbSB0byBzb3J0XG4gKiBAcGFyYW0ge09iamVjdH0gYiAtIHRoZSBzZWNvbmQgaXRlbSB0byBzb3J0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0xIGlmIGEgc2hvdWxkIGNvbWUgZmlyc3QsIDEgaWYgYiBzaG91bGQgY29tZSBmaXJzdCwgMCBpZiBlcXVhbFxuICovXG5cblxuZnVuY3Rpb24gc29ydFJhbmtlZFZhbHVlcyhhLCBiLCBiYXNlU29ydCkge1xuICB2YXIgYUZpcnN0ID0gLTE7XG4gIHZhciBiRmlyc3QgPSAxO1xuICB2YXIgYVJhbmsgPSBhLnJhbmssXG4gICAgICBhS2V5SW5kZXggPSBhLmtleUluZGV4O1xuICB2YXIgYlJhbmsgPSBiLnJhbmssXG4gICAgICBiS2V5SW5kZXggPSBiLmtleUluZGV4O1xuICB2YXIgc2FtZSA9IGFSYW5rID09PSBiUmFuaztcblxuICBpZiAoc2FtZSkge1xuICAgIGlmIChhS2V5SW5kZXggPT09IGJLZXlJbmRleCkge1xuICAgICAgLy8gdXNlIHRoZSBiYXNlIHNvcnQgZnVuY3Rpb24gYXMgYSB0aWUtYnJlYWtlclxuICAgICAgcmV0dXJuIGJhc2VTb3J0KGEsIGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUtleUluZGV4IDwgYktleUluZGV4ID8gYUZpcnN0IDogYkZpcnN0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYVJhbmsgPiBiUmFuayA/IGFGaXJzdCA6IGJGaXJzdDtcbiAgfVxufVxuLyoqXG4gKiBQcmVwYXJlcyB2YWx1ZSBmb3IgY29tcGFyaXNvbiBieSBzdHJpbmdpZnlpbmcgaXQsIHJlbW92aW5nIGRpYWNyaXRpY3MgKGlmIHNwZWNpZmllZClcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBjbGVhblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB7a2VlcERpYWNyaXRpY3M6IHdoZXRoZXIgdG8gcmVtb3ZlIGRpYWNyaXRpY3N9XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwcmVwYXJlZCB2YWx1ZVxuICovXG5cblxuZnVuY3Rpb24gcHJlcGFyZVZhbHVlRm9yQ29tcGFyaXNvbih2YWx1ZSwgX3JlZjQpIHtcbiAgdmFyIGtlZXBEaWFjcml0aWNzID0gX3JlZjQua2VlcERpYWNyaXRpY3M7XG4gIC8vIHZhbHVlIG1pZ2h0IG5vdCBhY3R1YWxseSBiZSBhIHN0cmluZyBhdCB0aGlzIHBvaW50ICh3ZSBkb24ndCBnZXQgdG8gY2hvb3NlKVxuICAvLyBzbyBwYXJ0IG9mIHByZXBhcmluZyB0aGUgdmFsdWUgZm9yIGNvbXBhcmlzb24gaXMgZW5zdXJlIHRoYXQgaXQgaXMgYSBzdHJpbmdcbiAgdmFsdWUgPSBcIlwiICsgdmFsdWU7IC8vIHRvU3RyaW5nXG5cbiAgaWYgKCFrZWVwRGlhY3JpdGljcykge1xuICAgIHZhbHVlID0gcmVtb3ZlQWNjZW50cyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEdldHMgdmFsdWUgZm9yIGtleSBpbiBpdGVtIGF0IGFyYml0cmFyaWx5IG5lc3RlZCBrZXlwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSAtIHRoZSBpdGVtXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0ga2V5IC0gdGhlIHBvdGVudGlhbGx5IG5lc3RlZCBrZXlwYXRoIG9yIHByb3BlcnR5IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtBcnJheX0gLSBhbiBhcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZShzKSBhdCB0aGUgbmVzdGVkIGtleXBhdGhcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEl0ZW1WYWx1ZXMoaXRlbSwga2V5KSB7XG4gIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgIGtleSA9IGtleS5rZXk7XG4gIH1cblxuICB2YXIgdmFsdWU7XG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IGtleShpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtID09IG51bGwpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoaXRlbSwga2V5KSkge1xuICAgIHZhbHVlID0gaXRlbVtrZXldO1xuICB9IGVsc2UgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgIHJldHVybiBnZXROZXN0ZWRWYWx1ZXMoa2V5LCBpdGVtKTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH0gLy8gYmVjYXVzZSBgdmFsdWVgIGNhbiBhbHNvIGJlIHVuZGVmaW5lZFxuXG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gW1N0cmluZyh2YWx1ZSldO1xufVxuLyoqXG4gKiBHaXZlbiBwYXRoOiBcImZvby5iYXIuYmF6XCJcbiAqIEFuZCBpdGVtOiB7Zm9vOiB7YmFyOiB7YmF6OiAnYnV6eid9fX1cbiAqICAgLT4gJ2J1enonXG4gKiBAcGFyYW0gcGF0aCBhIGRvdC1zZXBhcmF0ZWQgc2V0IG9mIGtleXNcbiAqIEBwYXJhbSBpdGVtIHRoZSBpdGVtIHRvIGdldCB0aGUgdmFsdWUgZnJvbVxuICovXG5cblxuZnVuY3Rpb24gZ2V0TmVzdGVkVmFsdWVzKHBhdGgsIGl0ZW0pIHtcbiAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciB2YWx1ZXMgPSBbaXRlbV07XG5cbiAgZm9yICh2YXIgaSA9IDAsIEkgPSBrZXlzLmxlbmd0aDsgaSA8IEk7IGkrKykge1xuICAgIHZhciBuZXN0ZWRLZXkgPSBrZXlzW2ldO1xuICAgIHZhciBuZXN0ZWRWYWx1ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGogPSAwLCBKID0gdmFsdWVzLmxlbmd0aDsgaiA8IEo7IGorKykge1xuICAgICAgdmFyIG5lc3RlZEl0ZW0gPSB2YWx1ZXNbal07XG4gICAgICBpZiAobmVzdGVkSXRlbSA9PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5lc3RlZEl0ZW0sIG5lc3RlZEtleSkpIHtcbiAgICAgICAgdmFyIG5lc3RlZFZhbHVlID0gbmVzdGVkSXRlbVtuZXN0ZWRLZXldO1xuXG4gICAgICAgIGlmIChuZXN0ZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmVzdGVkVmFsdWVzLnB1c2gobmVzdGVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5lc3RlZEtleSA9PT0gJyonKSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHZhbHVlcyBpcyBhbiBhcnJheVxuICAgICAgICBuZXN0ZWRWYWx1ZXMgPSBuZXN0ZWRWYWx1ZXMuY29uY2F0KG5lc3RlZEl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlcyA9IG5lc3RlZFZhbHVlcztcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlc1swXSkpIHtcbiAgICAvLyBrZWVwIGFsbG93aW5nIHRoZSBpbXBsaWNpdCB3aWxkY2FyZCBmb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHBhdGg7IGRvbid0IHVzZSBgLmZsYXQoKWAgYmVjYXVzZSB0aGF0J3Mgbm90IGF2YWlsYWJsZSBpbiBub2RlLmpzIHYxMFxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXR1cm4gcmVzdWx0LmNvbmNhdC5hcHBseShyZXN1bHQsIHZhbHVlcyk7XG4gIH0gLy8gQmFzZWQgb24gb3VyIGxvZ2ljIGl0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIGJ5IG5vdy4uLlxuICAvLyBhc3N1bWluZyB0aGUgdXNlcidzIHBhdGggdGVybWluYXRlZCBpbiBzdHJpbmdzXG5cblxuICByZXR1cm4gdmFsdWVzO1xufVxuLyoqXG4gKiBHZXRzIGFsbCB0aGUgdmFsdWVzIGZvciB0aGUgZ2l2ZW4ga2V5cyBpbiB0aGUgZ2l2ZW4gaXRlbSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aG9zZSB2YWx1ZXNcbiAqIEBwYXJhbSBpdGVtIC0gdGhlIGl0ZW0gZnJvbSB3aGljaCB0aGUgdmFsdWVzIHdpbGwgYmUgcmV0cmlldmVkXG4gKiBAcGFyYW0ga2V5cyAtIHRoZSBrZXlzIHRvIHVzZSB0byByZXRyaWV2ZSB0aGUgdmFsdWVzXG4gKiBAcmV0dXJuIG9iamVjdHMgd2l0aCB7aXRlbVZhbHVlLCBhdHRyaWJ1dGVzfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0QWxsVmFsdWVzVG9SYW5rKGl0ZW0sIGtleXMpIHtcbiAgdmFyIGFsbFZhbHVlcyA9IFtdO1xuXG4gIGZvciAodmFyIGogPSAwLCBKID0ga2V5cy5sZW5ndGg7IGogPCBKOyBqKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tqXTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGdldEtleUF0dHJpYnV0ZXMoa2V5KTtcbiAgICB2YXIgaXRlbVZhbHVlcyA9IGdldEl0ZW1WYWx1ZXMoaXRlbSwga2V5KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBJID0gaXRlbVZhbHVlcy5sZW5ndGg7IGkgPCBJOyBpKyspIHtcbiAgICAgIGFsbFZhbHVlcy5wdXNoKHtcbiAgICAgICAgaXRlbVZhbHVlOiBpdGVtVmFsdWVzW2ldLFxuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWxsVmFsdWVzO1xufVxuXG52YXIgZGVmYXVsdEtleUF0dHJpYnV0ZXMgPSB7XG4gIG1heFJhbmtpbmc6IEluZmluaXR5LFxuICBtaW5SYW5raW5nOiAtSW5maW5pdHlcbn07XG4vKipcbiAqIEdldHMgYWxsIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgZ2l2ZW4ga2V5XG4gKiBAcGFyYW0ga2V5IC0gdGhlIGtleSBmcm9tIHdoaWNoIHRoZSBhdHRyaWJ1dGVzIHdpbGwgYmUgcmV0cmlldmVkXG4gKiBAcmV0dXJuIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXkncyBhdHRyaWJ1dGVzXG4gKi9cblxuZnVuY3Rpb24gZ2V0S2V5QXR0cmlidXRlcyhrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRLZXlBdHRyaWJ1dGVzO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBkZWZhdWx0S2V5QXR0cmlidXRlcywga2V5KTtcbn1cbi8qXG5lc2xpbnRcbiAgbm8tY29udGludWU6IFwib2ZmXCIsXG4qL1xuXG5leHBvcnQgeyBkZWZhdWx0QmFzZVNvcnRGbiwgbWF0Y2hTb3J0ZXIsIHJhbmtpbmdzIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJyZW1vdmVBY2NlbnRzIiwicmFua2luZ3MiLCJDQVNFX1NFTlNJVElWRV9FUVVBTCIsIkVRVUFMIiwiU1RBUlRTX1dJVEgiLCJXT1JEX1NUQVJUU19XSVRIIiwiQ09OVEFJTlMiLCJBQ1JPTllNIiwiTUFUQ0hFUyIsIk5PX01BVENIIiwibWF0Y2hTb3J0ZXIiLCJkZWZhdWx0QmFzZVNvcnRGbiIsImEiLCJiIiwiU3RyaW5nIiwicmFua2VkVmFsdWUiLCJsb2NhbGVDb21wYXJlIiwiaXRlbXMiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJfb3B0aW9ucyIsImtleXMiLCJfb3B0aW9ucyR0aHJlc2hvbGQiLCJ0aHJlc2hvbGQiLCJfb3B0aW9ucyRiYXNlU29ydCIsImJhc2VTb3J0IiwiX29wdGlvbnMkc29ydGVyIiwic29ydGVyIiwibWF0Y2hlZEl0ZW1zIiwic29ydCIsInNvcnRSYW5rZWRWYWx1ZXMiLCJyZWR1Y2UiLCJyZWR1Y2VJdGVtc1RvUmFua2VkIiwibWFwIiwiX3JlZiIsIml0ZW0iLCJtYXRjaGVzIiwiaW5kZXgiLCJyYW5raW5nSW5mbyIsImdldEhpZ2hlc3RSYW5raW5nIiwicmFuayIsIl9yYW5raW5nSW5mbyRrZXlUaHJlcyIsImtleVRocmVzaG9sZCIsInB1c2giLCJzdHJpbmdJdGVtIiwiZ2V0TWF0Y2hSYW5raW5nIiwia2V5SW5kZXgiLCJ2YWx1ZXNUb1JhbmsiLCJnZXRBbGxWYWx1ZXNUb1JhbmsiLCJfcmVmMiIsIl9yZWYzIiwiaSIsIml0ZW1WYWx1ZSIsImF0dHJpYnV0ZXMiLCJuZXdSYW5rIiwibmV3UmFua2VkVmFsdWUiLCJtaW5SYW5raW5nIiwibWF4UmFua2luZyIsInRlc3RTdHJpbmciLCJzdHJpbmdUb1JhbmsiLCJwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uIiwibGVuZ3RoIiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJnZXRBY3JvbnltIiwiZ2V0Q2xvc2VuZXNzUmFua2luZyIsInN0cmluZyIsImFjcm9ueW0iLCJ3b3Jkc0luU3RyaW5nIiwic3BsaXQiLCJmb3JFYWNoIiwid29yZEluU3RyaW5nIiwic3BsaXRCeUh5cGhlbldvcmRzIiwic3BsaXRCeUh5cGhlbldvcmQiLCJzdWJzdHIiLCJtYXRjaGluZ0luT3JkZXJDaGFyQ291bnQiLCJjaGFyTnVtYmVyIiwiZmluZE1hdGNoaW5nQ2hhcmFjdGVyIiwibWF0Y2hDaGFyIiwiaiIsIkoiLCJzdHJpbmdDaGFyIiwiZ2V0UmFua2luZyIsInNwcmVhZCIsInNwcmVhZFBlcmNlbnRhZ2UiLCJpbk9yZGVyUGVyY2VudGFnZSIsInJhbmtpbmciLCJmaXJzdEluZGV4IiwiSSIsImZvdW5kIiwiYUZpcnN0IiwiYkZpcnN0IiwiYVJhbmsiLCJhS2V5SW5kZXgiLCJiUmFuayIsImJLZXlJbmRleCIsInNhbWUiLCJfcmVmNCIsImtlZXBEaWFjcml0aWNzIiwiZ2V0SXRlbVZhbHVlcyIsImtleSIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImdldE5lc3RlZFZhbHVlcyIsIkFycmF5IiwiaXNBcnJheSIsInBhdGgiLCJ2YWx1ZXMiLCJuZXN0ZWRLZXkiLCJuZXN0ZWRWYWx1ZXMiLCJuZXN0ZWRJdGVtIiwibmVzdGVkVmFsdWUiLCJjb25jYXQiLCJyZXN1bHQiLCJhcHBseSIsImFsbFZhbHVlcyIsImdldEtleUF0dHJpYnV0ZXMiLCJpdGVtVmFsdWVzIiwiZGVmYXVsdEtleUF0dHJpYnV0ZXMiLCJJbmZpbml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/match-sorter/dist/match-sorter.esm.js\n");

/***/ })

};
;