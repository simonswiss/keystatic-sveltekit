"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate";
exports.ids = ["vendor-chunks/slate"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate/dist/index.es.js":
/*!*********************************************!*\
  !*** ./node_modules/slate/dist/index.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Operation: () => (/* binding */ Operation),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathRef: () => (/* binding */ PathRef),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PointRef: () => (/* binding */ PointRef),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeRef: () => (/* binding */ RangeRef),\n/* harmony export */   Scrubber: () => (/* binding */ Scrubber),\n/* harmony export */   Span: () => (/* binding */ Span),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transforms: () => (/* binding */ Transforms),\n/* harmony export */   createEditor: () => (/* binding */ createEditor)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.esm.mjs\");\n\n\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\nfunction ownKeys$9(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$9(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$9(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$9(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * Create a new Slate `Editor` object.\r\n */ var createEditor = ()=>{\n    var editor = {\n        children: [],\n        operations: [],\n        selection: null,\n        marks: null,\n        isInline: ()=>false,\n        isVoid: ()=>false,\n        markableVoid: ()=>false,\n        onChange: ()=>{},\n        apply: (op)=>{\n            for (var ref of Editor.pathRefs(editor)){\n                PathRef.transform(ref, op);\n            }\n            for (var _ref of Editor.pointRefs(editor)){\n                PointRef.transform(_ref, op);\n            }\n            for (var _ref2 of Editor.rangeRefs(editor)){\n                RangeRef.transform(_ref2, op);\n            }\n            var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n            var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n            var dirtyPaths;\n            var dirtyPathKeys;\n            var add = (path)=>{\n                if (path) {\n                    var key = path.join(\",\");\n                    if (!dirtyPathKeys.has(key)) {\n                        dirtyPathKeys.add(key);\n                        dirtyPaths.push(path);\n                    }\n                }\n            };\n            if (Path.operationCanTransformPath(op)) {\n                dirtyPaths = [];\n                dirtyPathKeys = new Set();\n                for (var path of oldDirtyPaths){\n                    var newPath = Path.transform(path, op);\n                    add(newPath);\n                }\n            } else {\n                dirtyPaths = oldDirtyPaths;\n                dirtyPathKeys = oldDirtyPathKeys;\n            }\n            var newDirtyPaths = editor.getDirtyPaths(op);\n            for (var _path of newDirtyPaths){\n                add(_path);\n            }\n            DIRTY_PATHS.set(editor, dirtyPaths);\n            DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n            Transforms.transform(editor, op);\n            editor.operations.push(op);\n            Editor.normalize(editor, {\n                operation: op\n            }); // Clear any formats applied to the cursor if the selection changes.\n            if (op.type === \"set_selection\") {\n                editor.marks = null;\n            }\n            if (!FLUSHING.get(editor)) {\n                FLUSHING.set(editor, true);\n                Promise.resolve().then(()=>{\n                    FLUSHING.set(editor, false);\n                    editor.onChange({\n                        operation: op\n                    });\n                    editor.operations = [];\n                });\n            }\n        },\n        addMark: (key, value)=>{\n            var { selection, markableVoid } = editor;\n            if (selection) {\n                var match = (node, path)=>{\n                    if (!Text.isText(node)) {\n                        return false; // marks can only be applied to text\n                    }\n                    var [parentNode, parentPath] = Editor.parent(editor, path);\n                    return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n                };\n                var expandedSelection = Range.isExpanded(selection);\n                var markAcceptingVoidSelected = false;\n                if (!expandedSelection) {\n                    var [selectedNode, selectedPath] = Editor.node(editor, selection);\n                    if (selectedNode && match(selectedNode, selectedPath)) {\n                        var [parentNode] = Editor.parent(editor, selectedPath);\n                        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n                    }\n                }\n                if (expandedSelection || markAcceptingVoidSelected) {\n                    Transforms.setNodes(editor, {\n                        [key]: value\n                    }, {\n                        match,\n                        split: true,\n                        voids: true\n                    });\n                } else {\n                    var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, {\n                        [key]: value\n                    });\n                    editor.marks = marks;\n                    if (!FLUSHING.get(editor)) {\n                        editor.onChange();\n                    }\n                }\n            }\n        },\n        deleteBackward: (unit)=>{\n            var { selection } = editor;\n            if (selection && Range.isCollapsed(selection)) {\n                Transforms.delete(editor, {\n                    unit,\n                    reverse: true\n                });\n            }\n        },\n        deleteForward: (unit)=>{\n            var { selection } = editor;\n            if (selection && Range.isCollapsed(selection)) {\n                Transforms.delete(editor, {\n                    unit\n                });\n            }\n        },\n        deleteFragment: (direction)=>{\n            var { selection } = editor;\n            if (selection && Range.isExpanded(selection)) {\n                Transforms.delete(editor, {\n                    reverse: direction === \"backward\"\n                });\n            }\n        },\n        getFragment: ()=>{\n            var { selection } = editor;\n            if (selection) {\n                return Node.fragment(editor, selection);\n            }\n            return [];\n        },\n        insertBreak: ()=>{\n            Transforms.splitNodes(editor, {\n                always: true\n            });\n        },\n        insertSoftBreak: ()=>{\n            Transforms.splitNodes(editor, {\n                always: true\n            });\n        },\n        insertFragment: (fragment)=>{\n            Transforms.insertFragment(editor, fragment);\n        },\n        insertNode: (node)=>{\n            Transforms.insertNodes(editor, node);\n        },\n        insertText: (text)=>{\n            var { selection, marks } = editor;\n            if (selection) {\n                if (marks) {\n                    var node = _objectSpread$9({\n                        text\n                    }, marks);\n                    Transforms.insertNodes(editor, node);\n                } else {\n                    Transforms.insertText(editor, text);\n                }\n                editor.marks = null;\n            }\n        },\n        normalizeNode: (entry)=>{\n            var [node, path] = entry; // There are no core normalizations for text nodes.\n            if (Text.isText(node)) {\n                return;\n            } // Ensure that block and inline nodes have at least one text child.\n            if (Element.isElement(node) && node.children.length === 0) {\n                var child = {\n                    text: \"\"\n                };\n                Transforms.insertNodes(editor, child, {\n                    at: path.concat(0),\n                    voids: true\n                });\n                return;\n            } // Determine whether the node should have block or inline children.\n            var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n            // index that accounts for any added/removed nodes.\n            var n = 0;\n            for(var i = 0; i < node.children.length; i++, n++){\n                var currentNode = Node.get(editor, path);\n                if (Text.isText(currentNode)) continue;\n                var _child = node.children[i];\n                var prev = currentNode.children[n - 1];\n                var isLast = i === node.children.length - 1;\n                var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n                // that only contain block nodes. Similarly, only allow inline nodes in\n                // other inline nodes, or parent blocks that only contain inlines and\n                // text.\n                if (isInlineOrText !== shouldHaveInlines) {\n                    Transforms.removeNodes(editor, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n--;\n                } else if (Element.isElement(_child)) {\n                    // Ensure that inline nodes are surrounded by text nodes.\n                    if (editor.isInline(_child)) {\n                        if (prev == null || !Text.isText(prev)) {\n                            var newChild = {\n                                text: \"\"\n                            };\n                            Transforms.insertNodes(editor, newChild, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n++;\n                        } else if (isLast) {\n                            var _newChild = {\n                                text: \"\"\n                            };\n                            Transforms.insertNodes(editor, _newChild, {\n                                at: path.concat(n + 1),\n                                voids: true\n                            });\n                            n++;\n                        }\n                    }\n                } else {\n                    // Merge adjacent text nodes that are empty or match.\n                    if (prev != null && Text.isText(prev)) {\n                        if (Text.equals(_child, prev, {\n                            loose: true\n                        })) {\n                            Transforms.mergeNodes(editor, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n--;\n                        } else if (prev.text === \"\") {\n                            Transforms.removeNodes(editor, {\n                                at: path.concat(n - 1),\n                                voids: true\n                            });\n                            n--;\n                        } else if (_child.text === \"\") {\n                            Transforms.removeNodes(editor, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n--;\n                        }\n                    }\n                }\n            }\n        },\n        removeMark: (key)=>{\n            var { selection } = editor;\n            if (selection) {\n                var match = (node, path)=>{\n                    if (!Text.isText(node)) {\n                        return false; // marks can only be applied to text\n                    }\n                    var [parentNode, parentPath] = Editor.parent(editor, path);\n                    return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n                };\n                var expandedSelection = Range.isExpanded(selection);\n                var markAcceptingVoidSelected = false;\n                if (!expandedSelection) {\n                    var [selectedNode, selectedPath] = Editor.node(editor, selection);\n                    if (selectedNode && match(selectedNode, selectedPath)) {\n                        var [parentNode] = Editor.parent(editor, selectedPath);\n                        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n                    }\n                }\n                if (expandedSelection || markAcceptingVoidSelected) {\n                    Transforms.unsetNodes(editor, key, {\n                        match,\n                        split: true,\n                        voids: true\n                    });\n                } else {\n                    var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n                    delete marks[key];\n                    editor.marks = marks;\n                    if (!FLUSHING.get(editor)) {\n                        editor.onChange();\n                    }\n                }\n            }\n        },\n        /**\r\n     * Get the \"dirty\" paths generated from an operation.\r\n     */ getDirtyPaths: (op)=>{\n            switch(op.type){\n                case \"insert_text\":\n                case \"remove_text\":\n                case \"set_node\":\n                    {\n                        var { path } = op;\n                        return Path.levels(path);\n                    }\n                case \"insert_node\":\n                    {\n                        var { node, path: _path2 } = op;\n                        var levels = Path.levels(_path2);\n                        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), (_ref3)=>{\n                            var [, p] = _ref3;\n                            return _path2.concat(p);\n                        });\n                        return [\n                            ...levels,\n                            ...descendants\n                        ];\n                    }\n                case \"merge_node\":\n                    {\n                        var { path: _path3 } = op;\n                        var ancestors = Path.ancestors(_path3);\n                        var previousPath = Path.previous(_path3);\n                        return [\n                            ...ancestors,\n                            previousPath\n                        ];\n                    }\n                case \"move_node\":\n                    {\n                        var { path: _path4, newPath } = op;\n                        if (Path.equals(_path4, newPath)) {\n                            return [];\n                        }\n                        var oldAncestors = [];\n                        var newAncestors = [];\n                        for (var ancestor of Path.ancestors(_path4)){\n                            var p = Path.transform(ancestor, op);\n                            oldAncestors.push(p);\n                        }\n                        for (var _ancestor of Path.ancestors(newPath)){\n                            var _p = Path.transform(_ancestor, op);\n                            newAncestors.push(_p);\n                        }\n                        var newParent = newAncestors[newAncestors.length - 1];\n                        var newIndex = newPath[newPath.length - 1];\n                        var resultPath = newParent.concat(newIndex);\n                        return [\n                            ...oldAncestors,\n                            ...newAncestors,\n                            resultPath\n                        ];\n                    }\n                case \"remove_node\":\n                    {\n                        var { path: _path5 } = op;\n                        var _ancestors = Path.ancestors(_path5);\n                        return [\n                            ..._ancestors\n                        ];\n                    }\n                case \"split_node\":\n                    {\n                        var { path: _path6 } = op;\n                        var _levels = Path.levels(_path6);\n                        var nextPath = Path.next(_path6);\n                        return [\n                            ..._levels,\n                            nextPath\n                        ];\n                    }\n                default:\n                    {\n                        return [];\n                    }\n            }\n        },\n        shouldNormalize: (_ref4)=>{\n            var { iteration, initialDirtyPathsLength } = _ref4;\n            var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n            if (iteration > maxIterations) {\n                throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n            }\n            return true;\n        }\n    };\n    return editor;\n};\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */ var getCharacterDistance = function getCharacterDistance(str) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var isLTR = !isRTL;\n    var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n    var left = CodepointType.None;\n    var right = CodepointType.None;\n    var distance = 0; // Evaluation of these conditions are deferred.\n    var gb11 = null; // Is GB11 applicable?\n    var gb12Or13 = null; // Is GB12 or GB13 applicable?\n    for (var char of codepoints){\n        var code = char.codePointAt(0);\n        if (!code) break;\n        var type = getCodepointType(char, code);\n        [left, right] = isLTR ? [\n            right,\n            type\n        ] : [\n            type,\n            left\n        ];\n        if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n            if (isLTR) {\n                gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n            } else {\n                gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n            }\n            if (!gb11) break;\n        }\n        if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n            if (gb12Or13 !== null) {\n                gb12Or13 = !gb12Or13;\n            } else {\n                if (isLTR) {\n                    gb12Or13 = true;\n                } else {\n                    gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n                }\n            }\n            if (!gb12Or13) break;\n        }\n        if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n            break;\n        }\n        distance += char.length;\n    }\n    return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */ var getWordDistance = function getWordDistance(text) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var dist = 0;\n    var started = false;\n    while(text.length > 0){\n        var charDist = getCharacterDistance(text, isRTL);\n        var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n        if (isWordCharacter(char, remaining, isRTL)) {\n            started = true;\n            dist += charDist;\n        } else if (!started) {\n            dist += charDist;\n        } else {\n            break;\n        }\n        text = remaining;\n    }\n    return dist;\n};\n/**\r\n * Split a string in two parts at a given distance starting from the end when\r\n * `isRTL` is set to `true`.\r\n */ var splitByCharacterDistance = (str, dist, isRTL)=>{\n    if (isRTL) {\n        var at = str.length - dist;\n        return [\n            str.slice(at, str.length),\n            str.slice(0, at)\n        ];\n    }\n    return [\n        str.slice(0, dist),\n        str.slice(dist)\n    ];\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */ var isWordCharacter = function isWordCharacter(char, remaining) {\n    var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (SPACE.test(char)) {\n        return false;\n    } // Chameleons count as word characters as long as they're in a word, so\n    // recurse to see if the next one is a word character or not.\n    if (CHAMELEON.test(char)) {\n        var charDist = getCharacterDistance(remaining, isRTL);\n        var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n        if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n            return true;\n        }\n    }\n    if (PUNCTUATION.test(char)) {\n        return false;\n    }\n    return true;\n};\n/**\r\n * Iterate on codepoints from right to left.\r\n */ var codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n    var end = str.length - 1;\n    for(var i = 0; i < str.length; i++){\n        var char1 = str.charAt(end - i);\n        if (isLowSurrogate(char1.charCodeAt(0))) {\n            var char2 = str.charAt(end - i - 1);\n            if (isHighSurrogate(char2.charCodeAt(0))) {\n                yield char2 + char1;\n                i++;\n                continue;\n            }\n        }\n        yield char1;\n    }\n};\n/**\r\n * Is `charCode` a high surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */ var isHighSurrogate = (charCode)=>{\n    return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\r\n * Is `charCode` a low surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */ var isLowSurrogate = (charCode)=>{\n    return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function(CodepointType) {\n    CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n    CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n    CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n    CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n    CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n    CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n    CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n    CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n    CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n    CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n    CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n    CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n    CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = (char, code)=>{\n    var type = CodepointType.Any;\n    if (char.search(reExtend) !== -1) {\n        type |= CodepointType.Extend;\n    }\n    if (code === 0x200d) {\n        type |= CodepointType.ZWJ;\n    }\n    if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n        type |= CodepointType.RI;\n    }\n    if (char.search(rePrepend) !== -1) {\n        type |= CodepointType.Prepend;\n    }\n    if (char.search(reSpacingMark) !== -1) {\n        type |= CodepointType.SpacingMark;\n    }\n    if (char.search(reL) !== -1) {\n        type |= CodepointType.L;\n    }\n    if (char.search(reV) !== -1) {\n        type |= CodepointType.V;\n    }\n    if (char.search(reT) !== -1) {\n        type |= CodepointType.T;\n    }\n    if (char.search(reLV) !== -1) {\n        type |= CodepointType.LV;\n    }\n    if (char.search(reLVT) !== -1) {\n        type |= CodepointType.LVT;\n    }\n    if (char.search(reExtPict) !== -1) {\n        type |= CodepointType.ExtPict;\n    }\n    return type;\n};\nfunction intersects(x, y) {\n    return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n    [\n        CodepointType.L,\n        CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT\n    ],\n    [\n        CodepointType.LV | CodepointType.V,\n        CodepointType.V | CodepointType.T\n    ],\n    [\n        CodepointType.LVT | CodepointType.T,\n        CodepointType.T\n    ],\n    [\n        CodepointType.Any,\n        CodepointType.Extend | CodepointType.ZWJ\n    ],\n    [\n        CodepointType.Any,\n        CodepointType.SpacingMark\n    ],\n    [\n        CodepointType.Prepend,\n        CodepointType.Any\n    ],\n    [\n        CodepointType.ZWJ,\n        CodepointType.ExtPict\n    ],\n    [\n        CodepointType.RI,\n        CodepointType.RI\n    ]\n];\nfunction isBoundaryPair(left, right) {\n    return NonBoundaryPairs.findIndex((r)=>intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = (str)=>{\n    return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = (str)=>{\n    var match = str.match(endingRIs);\n    if (match === null) {\n        return false;\n    } else {\n        // A RI is represented by a surrogate pair.\n        var numRIs = match[0].length / 2;\n        return numRIs % 2 === 1;\n    }\n};\n/**\r\n * Shared the function with isElementType utility\r\n */ var isElement = (value)=>{\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n}; // eslint-disable-next-line no-redeclare\nvar Element = {\n    /**\r\n   * Check if a value implements the 'Ancestor' interface.\r\n   */ isAncestor (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children);\n    },\n    /**\r\n   * Check if a value implements the `Element` interface.\r\n   */ isElement,\n    /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */ isElementList (value) {\n        return Array.isArray(value) && value.every((val)=>Element.isElement(val));\n    },\n    /**\r\n   * Check if a set of props is a partial of Element.\r\n   */ isElementProps (props) {\n        return props.children !== undefined;\n    },\n    /**\r\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\r\n   * Default it check to `type` key value\r\n   */ isElementType: function isElementType(value, elementVal) {\n        var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"type\";\n        return isElement(value) && value[elementKey] === elementVal;\n    },\n    /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */ matches (element, props) {\n        for(var key in props){\n            if (key === \"children\") {\n                continue;\n            }\n            if (element[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\nvar _excluded$4 = [\n    \"text\"\n], _excluded2$3 = [\n    \"text\"\n];\nfunction ownKeys$8(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$8(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$8(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$8(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar IS_EDITOR_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\nvar Editor = {\n    /**\r\n   * Get the ancestor above a location in the document.\r\n   */ above (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { voids = false, mode = \"lowest\", at = editor.selection, match } = options;\n        if (!at) {\n            return;\n        }\n        var path = Editor.path(editor, at);\n        var reverse = mode === \"lowest\";\n        for (var [n, p] of Editor.levels(editor, {\n            at: path,\n            voids,\n            match,\n            reverse\n        })){\n            if (Text.isText(n)) continue;\n            if (Range.isRange(at)) {\n                if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n                    return [\n                        n,\n                        p\n                    ];\n                }\n            } else {\n                if (!Path.equals(path, p)) {\n                    return [\n                        n,\n                        p\n                    ];\n                }\n            }\n        }\n    },\n    /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */ addMark (editor, key, value) {\n        editor.addMark(key, value);\n    },\n    /**\r\n   * Get the point after a location.\r\n   */ after (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var anchor = Editor.point(editor, at, {\n            edge: \"end\"\n        });\n        var focus = Editor.end(editor, []);\n        var range = {\n            anchor,\n            focus\n        };\n        var { distance = 1 } = options;\n        var d = 0;\n        var target;\n        for (var p of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            at: range\n        }))){\n            if (d > distance) {\n                break;\n            }\n            if (d !== 0) {\n                target = p;\n            }\n            d++;\n        }\n        return target;\n    },\n    /**\r\n   * Get the point before a location.\r\n   */ before (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var anchor = Editor.start(editor, []);\n        var focus = Editor.point(editor, at, {\n            edge: \"start\"\n        });\n        var range = {\n            anchor,\n            focus\n        };\n        var { distance = 1 } = options;\n        var d = 0;\n        var target;\n        for (var p of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            at: range,\n            reverse: true\n        }))){\n            if (d > distance) {\n                break;\n            }\n            if (d !== 0) {\n                target = p;\n            }\n            d++;\n        }\n        return target;\n    },\n    /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */ deleteBackward (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { unit = \"character\" } = options;\n        editor.deleteBackward(unit);\n    },\n    /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */ deleteForward (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { unit = \"character\" } = options;\n        editor.deleteForward(unit);\n    },\n    /**\r\n   * Delete the content in the current selection.\r\n   */ deleteFragment (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { direction = \"forward\" } = options;\n        editor.deleteFragment(direction);\n    },\n    /**\r\n   * Get the start and end points of a location.\r\n   */ edges (editor, at) {\n        return [\n            Editor.start(editor, at),\n            Editor.end(editor, at)\n        ];\n    },\n    /**\r\n   * Get the end point of a location.\r\n   */ end (editor, at) {\n        return Editor.point(editor, at, {\n            edge: \"end\"\n        });\n    },\n    /**\r\n   * Get the first node at a location.\r\n   */ first (editor, at) {\n        var path = Editor.path(editor, at, {\n            edge: \"start\"\n        });\n        return Editor.node(editor, path);\n    },\n    /**\r\n   * Get the fragment at a location.\r\n   */ fragment (editor, at) {\n        var range = Editor.range(editor, at);\n        var fragment = Node.fragment(editor, range);\n        return fragment;\n    },\n    /**\r\n   * Check if a node has block children.\r\n   */ hasBlocks (editor, element) {\n        return element.children.some((n)=>Element.isElement(n) && Editor.isBlock(editor, n));\n    },\n    /**\r\n   * Check if a node has inline and text children.\r\n   */ hasInlines (editor, element) {\n        return element.children.some((n)=>Text.isText(n) || Editor.isInline(editor, n));\n    },\n    /**\r\n   * Check if a node has text children.\r\n   */ hasTexts (editor, element) {\n        return element.children.every((n)=>Text.isText(n));\n    },\n    /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertBreak (editor) {\n        editor.insertBreak();\n    },\n    /**\r\n   * Insert a soft break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertSoftBreak (editor) {\n        editor.insertSoftBreak();\n    },\n    /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertFragment (editor, fragment) {\n        editor.insertFragment(fragment);\n    },\n    /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertNode (editor, node) {\n        editor.insertNode(node);\n    },\n    /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertText (editor, text) {\n        editor.insertText(text);\n    },\n    /**\r\n   * Check if a value is a block `Element` object.\r\n   */ isBlock (editor, value) {\n        return !editor.isInline(value);\n    },\n    /**\r\n   * Check if a value is an `Editor` object.\r\n   */ isEditor (value) {\n        var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n        if (cachedIsEditor !== undefined) {\n            return cachedIsEditor;\n        }\n        if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n            return false;\n        }\n        var isEditor = typeof value.addMark === \"function\" && typeof value.apply === \"function\" && typeof value.deleteBackward === \"function\" && typeof value.deleteForward === \"function\" && typeof value.deleteFragment === \"function\" && typeof value.insertBreak === \"function\" && typeof value.insertSoftBreak === \"function\" && typeof value.insertFragment === \"function\" && typeof value.insertNode === \"function\" && typeof value.insertText === \"function\" && typeof value.isInline === \"function\" && typeof value.isVoid === \"function\" && typeof value.normalizeNode === \"function\" && typeof value.onChange === \"function\" && typeof value.removeMark === \"function\" && typeof value.getDirtyPaths === \"function\" && (value.marks === null || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n        IS_EDITOR_CACHE.set(value, isEditor);\n        return isEditor;\n    },\n    /**\r\n   * Check if a point is the end point of a location.\r\n   */ isEnd (editor, point, at) {\n        var end = Editor.end(editor, at);\n        return Point.equals(point, end);\n    },\n    /**\r\n   * Check if a point is an edge of a location.\r\n   */ isEdge (editor, point, at) {\n        return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n    },\n    /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */ isEmpty (editor, element) {\n        var { children } = element;\n        var [first] = children;\n        return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === \"\" && !editor.isVoid(element);\n    },\n    /**\r\n   * Check if a value is an inline `Element` object.\r\n   */ isInline (editor, value) {\n        return editor.isInline(value);\n    },\n    /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */ isNormalizing (editor) {\n        var isNormalizing = NORMALIZING.get(editor);\n        return isNormalizing === undefined ? true : isNormalizing;\n    },\n    /**\r\n   * Check if a point is the start point of a location.\r\n   */ isStart (editor, point, at) {\n        // PERF: If the offset isn't `0` we know it's not the start.\n        if (point.offset !== 0) {\n            return false;\n        }\n        var start = Editor.start(editor, at);\n        return Point.equals(point, start);\n    },\n    /**\r\n   * Check if a value is a void `Element` object.\r\n   */ isVoid (editor, value) {\n        return editor.isVoid(value);\n    },\n    /**\r\n   * Get the last node at a location.\r\n   */ last (editor, at) {\n        var path = Editor.path(editor, at, {\n            edge: \"end\"\n        });\n        return Editor.node(editor, path);\n    },\n    /**\r\n   * Get the leaf text node at a location.\r\n   */ leaf (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var node = Node.leaf(editor, path);\n        return [\n            node,\n            path\n        ];\n    },\n    /**\r\n   * Iterate through all of the levels at a location.\r\n   */ *levels (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { at = editor.selection, reverse = false, voids = false } = options;\n        var { match } = options;\n        if (match == null) {\n            match = ()=>true;\n        }\n        if (!at) {\n            return;\n        }\n        var levels = [];\n        var path = Editor.path(editor, at);\n        for (var [n, p] of Node.levels(editor, path)){\n            if (!match(n, p)) {\n                continue;\n            }\n            levels.push([\n                n,\n                p\n            ]);\n            if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n                break;\n            }\n        }\n        if (reverse) {\n            levels.reverse();\n        }\n        yield* levels;\n    },\n    /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */ marks (editor) {\n        var { marks, selection } = editor;\n        if (!selection) {\n            return null;\n        }\n        if (marks) {\n            return marks;\n        }\n        if (Range.isExpanded(selection)) {\n            var [match] = Editor.nodes(editor, {\n                match: Text.isText\n            });\n            if (match) {\n                var [_node] = match;\n                var _rest = _objectWithoutProperties(_node, _excluded$4);\n                return _rest;\n            } else {\n                return {};\n            }\n        }\n        var { anchor } = selection;\n        var { path } = anchor;\n        var [node] = Editor.leaf(editor, path);\n        if (anchor.offset === 0) {\n            var prev = Editor.previous(editor, {\n                at: path,\n                match: Text.isText\n            });\n            var markedVoid = Editor.above(editor, {\n                match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n)\n            });\n            if (!markedVoid) {\n                var block = Editor.above(editor, {\n                    match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n)\n                });\n                if (prev && block) {\n                    var [prevNode, prevPath] = prev;\n                    var [, blockPath] = block;\n                    if (Path.isAncestor(blockPath, prevPath)) {\n                        node = prevNode;\n                    }\n                }\n            }\n        }\n        var rest = _objectWithoutProperties(node, _excluded2$3);\n        return rest;\n    },\n    /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */ next (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { mode = \"lowest\", voids = false } = options;\n        var { match, at = editor.selection } = options;\n        if (!at) {\n            return;\n        }\n        var pointAfterLocation = Editor.after(editor, at, {\n            voids\n        });\n        if (!pointAfterLocation) return;\n        var [, to] = Editor.last(editor, []);\n        var span = [\n            pointAfterLocation.path,\n            to\n        ];\n        if (Path.isPath(at) && at.length === 0) {\n            throw new Error(\"Cannot get the next node from the root node!\");\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                var [parent] = Editor.parent(editor, at);\n                match = (n)=>parent.children.includes(n);\n            } else {\n                match = ()=>true;\n            }\n        }\n        var [next] = Editor.nodes(editor, {\n            at: span,\n            match,\n            mode,\n            voids\n        });\n        return next;\n    },\n    /**\r\n   * Get the node at a location.\r\n   */ node (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var node = Node.get(editor, path);\n        return [\n            node,\n            path\n        ];\n    },\n    /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */ *nodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { at = editor.selection, mode = \"all\", universal = false, reverse = false, voids = false } = options;\n        var { match } = options;\n        if (!match) {\n            match = ()=>true;\n        }\n        if (!at) {\n            return;\n        }\n        var from;\n        var to;\n        if (Span.isSpan(at)) {\n            from = at[0];\n            to = at[1];\n        } else {\n            var first = Editor.path(editor, at, {\n                edge: \"start\"\n            });\n            var last = Editor.path(editor, at, {\n                edge: \"end\"\n            });\n            from = reverse ? last : first;\n            to = reverse ? first : last;\n        }\n        var nodeEntries = Node.nodes(editor, {\n            reverse,\n            from,\n            to,\n            pass: (_ref)=>{\n                var [n] = _ref;\n                return voids ? false : Element.isElement(n) && Editor.isVoid(editor, n);\n            }\n        });\n        var matches = [];\n        var hit;\n        for (var [node, path] of nodeEntries){\n            var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n            if (mode === \"highest\" && isLower) {\n                continue;\n            }\n            if (!match(node, path)) {\n                // If we've arrived at a leaf text node that is not lower than the last\n                // hit, then we've found a branch that doesn't include a match, which\n                // means the match is not universal.\n                if (universal && !isLower && Text.isText(node)) {\n                    return;\n                } else {\n                    continue;\n                }\n            } // If there's a match and it's lower than the last, update the hit.\n            if (mode === \"lowest\" && isLower) {\n                hit = [\n                    node,\n                    path\n                ];\n                continue;\n            } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n            var emit = mode === \"lowest\" ? hit : [\n                node,\n                path\n            ];\n            if (emit) {\n                if (universal) {\n                    matches.push(emit);\n                } else {\n                    yield emit;\n                }\n            }\n            hit = [\n                node,\n                path\n            ];\n        } // Since lowest is always emitting one behind, catch up at the end.\n        if (mode === \"lowest\" && hit) {\n            if (universal) {\n                matches.push(hit);\n            } else {\n                yield hit;\n            }\n        } // Universal defers to ensure that the match occurs in every branch, so we\n        // yield all of the matches after iterating.\n        if (universal) {\n            yield* matches;\n        }\n    },\n    /**\r\n   * Normalize any dirty objects in the editor.\r\n   */ normalize (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { force = false, operation } = options;\n        var getDirtyPaths = (editor)=>{\n            return DIRTY_PATHS.get(editor) || [];\n        };\n        var getDirtyPathKeys = (editor)=>{\n            return DIRTY_PATH_KEYS.get(editor) || new Set();\n        };\n        var popDirtyPath = (editor)=>{\n            var path = getDirtyPaths(editor).pop();\n            var key = path.join(\",\");\n            getDirtyPathKeys(editor).delete(key);\n            return path;\n        };\n        if (!Editor.isNormalizing(editor)) {\n            return;\n        }\n        if (force) {\n            var allPaths = Array.from(Node.nodes(editor), (_ref2)=>{\n                var [, p] = _ref2;\n                return p;\n            });\n            var allPathKeys = new Set(allPaths.map((p)=>p.join(\",\")));\n            DIRTY_PATHS.set(editor, allPaths);\n            DIRTY_PATH_KEYS.set(editor, allPathKeys);\n        }\n        if (getDirtyPaths(editor).length === 0) {\n            return;\n        }\n        Editor.withoutNormalizing(editor, ()=>{\n            /*\r\n        Fix dirty elements with no children.\r\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n        Running an initial pass avoids the catch-22 race condition.\r\n      */ for (var dirtyPath of getDirtyPaths(editor)){\n                if (Node.has(editor, dirtyPath)) {\n                    var entry = Editor.node(editor, dirtyPath);\n                    var [node, _] = entry;\n                    /*\r\n            The default normalizer inserts an empty text node in this scenario, but it can be customised.\r\n            So there is some risk here.\r\n                       As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\r\n            by definition adding children to an empty node can't cause other paths to change.\r\n          */ if (Element.isElement(node) && node.children.length === 0) {\n                        editor.normalizeNode(entry, {\n                            operation\n                        });\n                    }\n                }\n            }\n            var dirtyPaths = getDirtyPaths(editor);\n            var initialDirtyPathsLength = dirtyPaths.length;\n            var iteration = 0;\n            while(dirtyPaths.length !== 0){\n                if (!editor.shouldNormalize({\n                    dirtyPaths,\n                    iteration,\n                    initialDirtyPathsLength,\n                    operation\n                })) {\n                    return;\n                }\n                var _dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.\n                if (Node.has(editor, _dirtyPath)) {\n                    var _entry = Editor.node(editor, _dirtyPath);\n                    editor.normalizeNode(_entry, {\n                        operation\n                    });\n                }\n                iteration++;\n                dirtyPaths = getDirtyPaths(editor);\n            }\n        });\n    },\n    /**\r\n   * Get the parent node of a location.\r\n   */ parent (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var parentPath = Path.parent(path);\n        var entry = Editor.node(editor, parentPath);\n        return entry;\n    },\n    /**\r\n   * Get the path of a location.\r\n   */ path (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { depth, edge } = options;\n        if (Path.isPath(at)) {\n            if (edge === \"start\") {\n                var [, firstPath] = Node.first(editor, at);\n                at = firstPath;\n            } else if (edge === \"end\") {\n                var [, lastPath] = Node.last(editor, at);\n                at = lastPath;\n            }\n        }\n        if (Range.isRange(at)) {\n            if (edge === \"start\") {\n                at = Range.start(at);\n            } else if (edge === \"end\") {\n                at = Range.end(at);\n            } else {\n                at = Path.common(at.anchor.path, at.focus.path);\n            }\n        }\n        if (Point.isPoint(at)) {\n            at = at.path;\n        }\n        if (depth != null) {\n            at = at.slice(0, depth);\n        }\n        return at;\n    },\n    hasPath (editor, path) {\n        return Node.has(editor, path);\n    },\n    /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ pathRef (editor, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { affinity = \"forward\" } = options;\n        var ref = {\n            current: path,\n            affinity,\n            unref () {\n                var { current } = ref;\n                var pathRefs = Editor.pathRefs(editor);\n                pathRefs.delete(ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.pathRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */ pathRefs (editor) {\n        var refs = PATH_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            PATH_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Get the start or end point of a location.\r\n   */ point (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { edge = \"start\" } = options;\n        if (Path.isPath(at)) {\n            var path;\n            if (edge === \"end\") {\n                var [, lastPath] = Node.last(editor, at);\n                path = lastPath;\n            } else {\n                var [, firstPath] = Node.first(editor, at);\n                path = firstPath;\n            }\n            var node = Node.get(editor, path);\n            if (!Text.isText(node)) {\n                throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n            }\n            return {\n                path,\n                offset: edge === \"end\" ? node.text.length : 0\n            };\n        }\n        if (Range.isRange(at)) {\n            var [start, end] = Range.edges(at);\n            return edge === \"start\" ? start : end;\n        }\n        return at;\n    },\n    /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ pointRef (editor, point) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { affinity = \"forward\" } = options;\n        var ref = {\n            current: point,\n            affinity,\n            unref () {\n                var { current } = ref;\n                var pointRefs = Editor.pointRefs(editor);\n                pointRefs.delete(ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.pointRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */ pointRefs (editor) {\n        var refs = POINT_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            POINT_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Return all the positions in `at` range where a `Point` can be placed.\r\n   *\r\n   * By default, moves forward by individual offsets at a time, but\r\n   * the `unit` option can be used to to move by character, word, line, or block.\r\n   *\r\n   * The `reverse` option can be used to change iteration direction.\r\n   *\r\n   * Note: By default void nodes are treated as a single point and iteration\r\n   * will not happen inside their content unless you pass in true for the\r\n   * `voids` option, then iteration will occur.\r\n   */ *positions (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { at = editor.selection, unit = \"offset\", reverse = false, voids = false } = options;\n        if (!at) {\n            return;\n        }\n        /**\r\n     * Algorithm notes:\r\n     *\r\n     * Each step `distance` is dynamic depending on the underlying text\r\n     * and the `unit` specified.  Each step, e.g., a line or word, may\r\n     * span multiple text nodes, so we iterate through the text both on\r\n     * two levels in step-sync:\r\n     *\r\n     * `leafText` stores the text on a text leaf level, and is advanced\r\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n     *\r\n     * `blockText` stores the text on a block level, and is shortened\r\n     * by `distance` every time it is advanced.\r\n     *\r\n     * We only maintain a window of one blockText and one leafText because\r\n     * a block node always appears before all of its leaf nodes.\r\n     */ var range = Editor.range(editor, at);\n        var [start, end] = Range.edges(range);\n        var first = reverse ? end : start;\n        var isNewBlock = false;\n        var blockText = \"\";\n        var distance = 0; // Distance for leafText to catch up to blockText.\n        var leafTextRemaining = 0;\n        var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n        // of block nodes in blockText, and text nodes in leafText.\n        // Exploits the fact that nodes are sequenced in such a way that we first\n        // encounter the block node, then all of its text nodes, so when iterating\n        // through the blockText and leafText we just need to remember a window of\n        // one block node and leaf node, respectively.\n        for (var [node, path] of Editor.nodes(editor, {\n            at,\n            reverse,\n            voids\n        })){\n            /*\r\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\r\n       */ if (Element.isElement(node)) {\n                // Void nodes are a special case, so by default we will always\n                // yield their first point. If the `voids` option is set to true,\n                // then we will iterate over their content.\n                if (!voids && editor.isVoid(node)) {\n                    yield Editor.start(editor, path);\n                    continue;\n                } // Inline element nodes are ignored as they don't themselves\n                // contribute to `blockText` or `leafText` - their parent and\n                // children do.\n                if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.\n                if (Editor.hasInlines(editor, node)) {\n                    // We always exhaust block nodes before encountering a new one:\n                    //   console.assert(blockText === '',\n                    //     `blockText='${blockText}' - `+\n                    //     `not exhausted before new block node`, path)\n                    // Ensure range considered is capped to `range`, in the\n                    // start/end edge cases where block extends beyond range.\n                    // Equivalent to this, but presumably more performant:\n                    //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n                    //   blockRange = Range.intersection(range, blockRange) // intersect\n                    //   blockText = Editor.string(editor, blockRange, { voids })\n                    var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n                    var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n                    blockText = Editor.string(editor, {\n                        anchor: s,\n                        focus: e\n                    }, {\n                        voids\n                    });\n                    isNewBlock = true;\n                }\n            }\n            /*\r\n       * TEXT LEAF NODE - Iterate through text content, yielding\r\n       * positions every `distance` offset according to `unit`.\r\n       */ if (Text.isText(node)) {\n                var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n                //   console.assert(leafTextRemaining <= 0,\n                //     `leafTextRemaining=${leafTextRemaining} - `+\n                //     `not exhausted before new leaf text node`, path)\n                // Reset `leafText` counters for new text node.\n                if (isFirst) {\n                    leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n                    leafTextOffset = first.offset; // Works for reverse too.\n                } else {\n                    leafTextRemaining = node.text.length;\n                    leafTextOffset = reverse ? leafTextRemaining : 0;\n                } // Yield position at the start of node (potentially).\n                if (isFirst || isNewBlock || unit === \"offset\") {\n                    yield {\n                        path,\n                        offset: leafTextOffset\n                    };\n                    isNewBlock = false;\n                } // Yield positions every (dynamically calculated) `distance` offset.\n                while(true){\n                    // If `leafText` has caught up with `blockText` (distance=0),\n                    // and if blockText is exhausted, break to get another block node,\n                    // otherwise advance blockText forward by the new `distance`.\n                    if (distance === 0) {\n                        if (blockText === \"\") break;\n                        distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the\n                        // remaining string for the next iteration.\n                        blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n                    } // Advance `leafText` by the current `distance`.\n                    leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n                    leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n                    // and set distance to the overflow amount, so we'll (maybe)\n                    // catch up to blockText in the next leaf text node.\n                    if (leafTextRemaining < 0) {\n                        distance = -leafTextRemaining;\n                        break;\n                    } // Successfully walked `distance` offsets through `leafText`\n                    // to catch up with `blockText`, so we can reset `distance`\n                    // and yield this position in this node.\n                    distance = 0;\n                    yield {\n                        path,\n                        offset: leafTextOffset\n                    };\n                }\n            }\n        } // Proof that upon completion, we've exahusted both leaf and block text:\n        //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n        //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n        // Helper:\n        // Return the distance in offsets for a step of size `unit` on given string.\n        function calcDistance(text, unit, reverse) {\n            if (unit === \"character\") {\n                return getCharacterDistance(text, reverse);\n            } else if (unit === \"word\") {\n                return getWordDistance(text, reverse);\n            } else if (unit === \"line\" || unit === \"block\") {\n                return text.length;\n            }\n            return 1;\n        }\n    },\n    /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */ previous (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { mode = \"lowest\", voids = false } = options;\n        var { match, at = editor.selection } = options;\n        if (!at) {\n            return;\n        }\n        var pointBeforeLocation = Editor.before(editor, at, {\n            voids\n        });\n        if (!pointBeforeLocation) {\n            return;\n        }\n        var [, to] = Editor.first(editor, []); // The search location is from the start of the document to the path of\n        // the point before the location passed in\n        var span = [\n            pointBeforeLocation.path,\n            to\n        ];\n        if (Path.isPath(at) && at.length === 0) {\n            throw new Error(\"Cannot get the previous node from the root node!\");\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                var [parent] = Editor.parent(editor, at);\n                match = (n)=>parent.children.includes(n);\n            } else {\n                match = ()=>true;\n            }\n        }\n        var [previous] = Editor.nodes(editor, {\n            reverse: true,\n            at: span,\n            match,\n            mode,\n            voids\n        });\n        return previous;\n    },\n    /**\r\n   * Get a range of a location.\r\n   */ range (editor, at, to) {\n        if (Range.isRange(at) && !to) {\n            return at;\n        }\n        var start = Editor.start(editor, at);\n        var end = Editor.end(editor, to || at);\n        return {\n            anchor: start,\n            focus: end\n        };\n    },\n    /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ rangeRef (editor, range) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { affinity = \"forward\" } = options;\n        var ref = {\n            current: range,\n            affinity,\n            unref () {\n                var { current } = ref;\n                var rangeRefs = Editor.rangeRefs(editor);\n                rangeRefs.delete(ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.rangeRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */ rangeRefs (editor) {\n        var refs = RANGE_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            RANGE_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */ removeMark (editor, key) {\n        editor.removeMark(key);\n    },\n    /**\r\n   * Manually set if the editor should currently be normalizing.\r\n   *\r\n   * Note: Using this incorrectly can leave the editor in an invalid state.\r\n   *\r\n   */ setNormalizing (editor, isNormalizing) {\n        NORMALIZING.set(editor, isNormalizing);\n    },\n    /**\r\n   * Get the start point of a location.\r\n   */ start (editor, at) {\n        return Editor.point(editor, at, {\n            edge: \"start\"\n        });\n    },\n    /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: by default the text of void nodes is considered to be an empty\r\n   * string, regardless of content, unless you pass in true for the voids option\r\n   */ string (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { voids = false } = options;\n        var range = Editor.range(editor, at);\n        var [start, end] = Range.edges(range);\n        var text = \"\";\n        for (var [node, path] of Editor.nodes(editor, {\n            at: range,\n            match: Text.isText,\n            voids\n        })){\n            var t = node.text;\n            if (Path.equals(path, end.path)) {\n                t = t.slice(0, end.offset);\n            }\n            if (Path.equals(path, start.path)) {\n                t = t.slice(start.offset);\n            }\n            text += t;\n        }\n        return text;\n    },\n    /**\r\n   * Convert a range into a non-hanging one.\r\n   */ unhangRange (editor, range) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { voids = false } = options;\n        var [start, end] = Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.\n        if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n            return range;\n        }\n        var endBlock = Editor.above(editor, {\n            at: end,\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            voids\n        });\n        var blockPath = endBlock ? endBlock[1] : [];\n        var first = Editor.start(editor, start);\n        var before = {\n            anchor: first,\n            focus: end\n        };\n        var skip = true;\n        for (var [node, path] of Editor.nodes(editor, {\n            at: before,\n            match: Text.isText,\n            reverse: true,\n            voids\n        })){\n            if (skip) {\n                skip = false;\n                continue;\n            }\n            if (node.text !== \"\" || Path.isBefore(path, blockPath)) {\n                end = {\n                    path,\n                    offset: node.text.length\n                };\n                break;\n            }\n        }\n        return {\n            anchor: start,\n            focus: end\n        };\n    },\n    /**\r\n   * Match a void node in the current branch of the editor.\r\n   */ void (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n)\n        }));\n    },\n    /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */ withoutNormalizing (editor, fn) {\n        var value = Editor.isNormalizing(editor);\n        Editor.setNormalizing(editor, false);\n        try {\n            fn();\n        } finally{\n            Editor.setNormalizing(editor, value);\n        }\n        Editor.normalize(editor);\n    }\n};\nvar Location = {\n    /**\r\n   * Check if a value implements the `Location` interface.\r\n   */ isLocation (value) {\n        return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n    }\n}; // eslint-disable-next-line no-redeclare\nvar Span = {\n    /**\r\n   * Check if a value implements the `Span` interface.\r\n   */ isSpan (value) {\n        return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n    }\n};\nvar _excluded$3 = [\n    \"children\"\n], _excluded2$2 = [\n    \"text\"\n];\nvar IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\nvar Node = {\n    /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */ ancestor (root, path) {\n        var node = Node.get(root, path);\n        if (Text.isText(node)) {\n            throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go bottom-up.\r\n   */ *ancestors (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        for (var p of Path.ancestors(path, options)){\n            var n = Node.ancestor(root, p);\n            var entry = [\n                n,\n                p\n            ];\n            yield entry;\n        }\n    },\n    /**\r\n   * Get the child of a node at a specific index.\r\n   */ child (root, index) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n        }\n        var c = root.children[index];\n        if (c == null) {\n            throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n        }\n        return c;\n    },\n    /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */ *children (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { reverse = false } = options;\n        var ancestor = Node.ancestor(root, path);\n        var { children } = ancestor;\n        var index = reverse ? children.length - 1 : 0;\n        while(reverse ? index >= 0 : index < children.length){\n            var child = Node.child(ancestor, index);\n            var childPath = path.concat(index);\n            yield [\n                child,\n                childPath\n            ];\n            index = reverse ? index - 1 : index + 1;\n        }\n    },\n    /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */ common (root, path, another) {\n        var p = Path.common(path, another);\n        var n = Node.get(root, p);\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */ descendant (root, path) {\n        var node = Node.get(root, path);\n        if (Editor.isEditor(node)) {\n            throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */ *descendants (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        for (var [node, path] of Node.nodes(root, options)){\n            if (path.length !== 0) {\n                // NOTE: we have to coerce here because checking the path's length does\n                // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n                yield [\n                    node,\n                    path\n                ];\n            }\n        }\n    },\n    /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */ *elements (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        for (var [node, path] of Node.nodes(root, options)){\n            if (Element.isElement(node)) {\n                yield [\n                    node,\n                    path\n                ];\n            }\n        }\n    },\n    /**\r\n   * Extract props from a Node.\r\n   */ extractProps (node) {\n        if (Element.isAncestor(node)) {\n            var properties = _objectWithoutProperties(node, _excluded$3);\n            return properties;\n        } else {\n            var properties = _objectWithoutProperties(node, _excluded2$2);\n            return properties;\n        }\n    },\n    /**\r\n   * Get the first node entry in a root node from a path.\r\n   */ first (root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                n = n.children[0];\n                p.push(0);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */ fragment (root, range) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n        }\n        var newRoot = (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)({\n            children: root.children\n        }, (r)=>{\n            var [start, end] = Range.edges(range);\n            var nodeEntries = Node.nodes(r, {\n                reverse: true,\n                pass: (_ref)=>{\n                    var [, path] = _ref;\n                    return !Range.includes(range, path);\n                }\n            });\n            for (var [, path] of nodeEntries){\n                if (!Range.includes(range, path)) {\n                    var parent = Node.parent(r, path);\n                    var index = path[path.length - 1];\n                    parent.children.splice(index, 1);\n                }\n                if (Path.equals(path, end.path)) {\n                    var leaf = Node.leaf(r, path);\n                    leaf.text = leaf.text.slice(0, end.offset);\n                }\n                if (Path.equals(path, start.path)) {\n                    var _leaf = Node.leaf(r, path);\n                    _leaf.text = _leaf.text.slice(start.offset);\n                }\n            }\n            if (Editor.isEditor(r)) {\n                r.selection = null;\n            }\n        });\n        return newRoot.children;\n    },\n    /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */ get (root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n            }\n            node = node.children[p];\n        }\n        return node;\n    },\n    /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */ has (root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                return false;\n            }\n            node = node.children[p];\n        }\n        return true;\n    },\n    /**\r\n   * Check if a value implements the `Node` interface.\r\n   */ isNode (value) {\n        return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n    },\n    /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */ isNodeList (value) {\n        if (!Array.isArray(value)) {\n            return false;\n        }\n        var cachedResult = IS_NODE_LIST_CACHE.get(value);\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n        var isNodeList = value.every((val)=>Node.isNode(val));\n        IS_NODE_LIST_CACHE.set(value, isNodeList);\n        return isNodeList;\n    },\n    /**\r\n   * Get the last node entry in a root node from a path.\r\n   */ last (root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                var i = n.children.length - 1;\n                n = n.children[i];\n                p.push(i);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */ leaf (root, path) {\n        var node = Node.get(root, path);\n        if (!Text.isText(node)) {\n            throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */ *levels (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        for (var p of Path.levels(path, options)){\n            var n = Node.get(root, p);\n            yield [\n                n,\n                p\n            ];\n        }\n    },\n    /**\r\n   * Check if a node matches a set of props.\r\n   */ matches (node, props) {\n        return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n    },\n    /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */ *nodes (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { pass, reverse = false } = options;\n        var { from = [], to } = options;\n        var visited = new Set();\n        var p = [];\n        var n = root;\n        while(true){\n            if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n                break;\n            }\n            if (!visited.has(n)) {\n                yield [\n                    n,\n                    p\n                ];\n            } // If we're allowed to go downward and we haven't descended yet, do.\n            if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([\n                n,\n                p\n            ]) === false)) {\n                visited.add(n);\n                var nextIndex = reverse ? n.children.length - 1 : 0;\n                if (Path.isAncestor(p, from)) {\n                    nextIndex = from[p.length];\n                }\n                p = p.concat(nextIndex);\n                n = Node.get(root, p);\n                continue;\n            } // If we're at the root and we can't go down, we're done.\n            if (p.length === 0) {\n                break;\n            } // If we're going forward...\n            if (!reverse) {\n                var newPath = Path.next(p);\n                if (Node.has(root, newPath)) {\n                    p = newPath;\n                    n = Node.get(root, p);\n                    continue;\n                }\n            } // If we're going backward...\n            if (reverse && p[p.length - 1] !== 0) {\n                var _newPath = Path.previous(p);\n                p = _newPath;\n                n = Node.get(root, p);\n                continue;\n            } // Otherwise we're going upward...\n            p = Path.parent(p);\n            n = Node.get(root, p);\n            visited.add(n);\n        }\n    },\n    /**\r\n   * Get the parent of a node at a specific path.\r\n   */ parent (root, path) {\n        var parentPath = Path.parent(path);\n        var p = Node.get(root, parentPath);\n        if (Text.isText(p)) {\n            throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n        }\n        return p;\n    },\n    /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */ string (node) {\n        if (Text.isText(node)) {\n            return node.text;\n        } else {\n            return node.children.map(Node.string).join(\"\");\n        }\n    },\n    /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */ *texts (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        for (var [node, path] of Node.nodes(root, options)){\n            if (Text.isText(node)) {\n                yield [\n                    node,\n                    path\n                ];\n            }\n        }\n    }\n};\nfunction ownKeys$7(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$7(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$7(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$7(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Operation = {\n    /**\r\n   * Check if a value is a `NodeOperation` object.\r\n   */ isNodeOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_node\");\n    },\n    /**\r\n   * Check if a value is an `Operation` object.\r\n   */ isOperation (value) {\n        if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n            return false;\n        }\n        switch(value.type){\n            case \"insert_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"insert_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"merge_node\":\n                return typeof value.position === \"number\" && Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n            case \"move_node\":\n                return Path.isPath(value.path) && Path.isPath(value.newPath);\n            case \"remove_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"remove_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"set_node\":\n                return Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n            case \"set_selection\":\n                return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n            case \"split_node\":\n                return Path.isPath(value.path) && typeof value.position === \"number\" && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n            default:\n                return false;\n        }\n    },\n    /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */ isOperationList (value) {\n        return Array.isArray(value) && value.every((val)=>Operation.isOperation(val));\n    },\n    /**\r\n   * Check if a value is a `SelectionOperation` object.\r\n   */ isSelectionOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_selection\");\n    },\n    /**\r\n   * Check if a value is a `TextOperation` object.\r\n   */ isTextOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_text\");\n    },\n    /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */ inverse (op) {\n        switch(op.type){\n            case \"insert_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"remove_node\"\n                    });\n                }\n            case \"insert_text\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"remove_text\"\n                    });\n                }\n            case \"merge_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"split_node\",\n                        path: Path.previous(op.path)\n                    });\n                }\n            case \"move_node\":\n                {\n                    var { newPath, path } = op; // PERF: in this case the move operation is a no-op anyways.\n                    if (Path.equals(newPath, path)) {\n                        return op;\n                    } // If the move happens completely within a single parent the path and\n                    // newPath are stable with respect to each other.\n                    if (Path.isSibling(path, newPath)) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            path: newPath,\n                            newPath: path\n                        });\n                    } // If the move does not happen within a single parent it is possible\n                    // for the move to impact the true path to the location where the node\n                    // was removed from and where it was inserted. We have to adjust for this\n                    // and find the original path. We can accomplish this (only in non-sibling)\n                    // moves by looking at the impact of the move operation on the node\n                    // after the original move path.\n                    var inversePath = Path.transform(path, op);\n                    var inverseNewPath = Path.transform(Path.next(path), op);\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        path: inversePath,\n                        newPath: inverseNewPath\n                    });\n                }\n            case \"remove_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"insert_node\"\n                    });\n                }\n            case \"remove_text\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"insert_text\"\n                    });\n                }\n            case \"set_node\":\n                {\n                    var { properties, newProperties } = op;\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        properties: newProperties,\n                        newProperties: properties\n                    });\n                }\n            case \"set_selection\":\n                {\n                    var { properties: _properties, newProperties: _newProperties } = op;\n                    if (_properties == null) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: null\n                        });\n                    } else if (_newProperties == null) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: null,\n                            newProperties: _properties\n                        });\n                    } else {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: _properties\n                        });\n                    }\n                }\n            case \"split_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"merge_node\",\n                        path: Path.next(op.path)\n                    });\n                }\n        }\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar Path = {\n    /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */ ancestors (path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var paths = Path.levels(path, options);\n        if (reverse) {\n            paths = paths.slice(1);\n        } else {\n            paths = paths.slice(0, -1);\n        }\n        return paths;\n    },\n    /**\r\n   * Get the common ancestor path of two paths.\r\n   */ common (path, another) {\n        var common = [];\n        for(var i = 0; i < path.length && i < another.length; i++){\n            var av = path[i];\n            var bv = another[i];\n            if (av !== bv) {\n                break;\n            }\n            common.push(av);\n        }\n        return common;\n    },\n    /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */ compare (path, another) {\n        var min = Math.min(path.length, another.length);\n        for(var i = 0; i < min; i++){\n            if (path[i] < another[i]) return -1;\n            if (path[i] > another[i]) return 1;\n        }\n        return 0;\n    },\n    /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */ endsAfter (path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av > bv;\n    },\n    /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */ endsAt (path, another) {\n        var i = path.length;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        return Path.equals(as, bs);\n    },\n    /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */ endsBefore (path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av < bv;\n    },\n    /**\r\n   * Check if a path is exactly equal to another.\r\n   */ equals (path, another) {\n        return path.length === another.length && path.every((n, i)=>n === another[i]);\n    },\n    /**\r\n   * Check if the path of previous sibling node exists\r\n   */ hasPrevious (path) {\n        return path[path.length - 1] > 0;\n    },\n    /**\r\n   * Check if a path is after another.\r\n   */ isAfter (path, another) {\n        return Path.compare(path, another) === 1;\n    },\n    /**\r\n   * Check if a path is an ancestor of another.\r\n   */ isAncestor (path, another) {\n        return path.length < another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is before another.\r\n   */ isBefore (path, another) {\n        return Path.compare(path, another) === -1;\n    },\n    /**\r\n   * Check if a path is a child of another.\r\n   */ isChild (path, another) {\n        return path.length === another.length + 1 && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */ isCommon (path, another) {\n        return path.length <= another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is a descendant of another.\r\n   */ isDescendant (path, another) {\n        return path.length > another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is the parent of another.\r\n   */ isParent (path, another) {\n        return path.length + 1 === another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check is a value implements the `Path` interface.\r\n   */ isPath (value) {\n        return Array.isArray(value) && (value.length === 0 || typeof value[0] === \"number\");\n    },\n    /**\r\n   * Check if a path is a sibling of another.\r\n   */ isSibling (path, another) {\n        if (path.length !== another.length) {\n            return false;\n        }\n        var as = path.slice(0, -1);\n        var bs = another.slice(0, -1);\n        var al = path[path.length - 1];\n        var bl = another[another.length - 1];\n        return al !== bl && Path.equals(as, bs);\n    },\n    /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */ levels (path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var list = [];\n        for(var i = 0; i <= path.length; i++){\n            list.push(path.slice(0, i));\n        }\n        if (reverse) {\n            list.reverse();\n        }\n        return list;\n    },\n    /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */ next (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n        }\n        var last = path[path.length - 1];\n        return path.slice(0, -1).concat(last + 1);\n    },\n    /**\r\n   * Returns whether this operation can affect paths or not. Used as an\r\n   * optimization when updating dirty paths during normalization\r\n   *\r\n   * NOTE: This *must* be kept in sync with the implementation of 'transform'\r\n   * below\r\n   */ operationCanTransformPath (operation) {\n        switch(operation.type){\n            case \"insert_node\":\n            case \"remove_node\":\n            case \"merge_node\":\n            case \"split_node\":\n            case \"move_node\":\n                return true;\n            default:\n                return false;\n        }\n    },\n    /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */ parent (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n        }\n        return path.slice(0, -1);\n    },\n    /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */ previous (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n        }\n        var last = path[path.length - 1];\n        if (last <= 0) {\n            throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n        }\n        return path.slice(0, -1).concat(last - 1);\n    },\n    /**\r\n   * Get a path relative to an ancestor.\r\n   */ relative (path, ancestor) {\n        if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n            throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n        }\n        return path.slice(ancestor.length);\n    },\n    /**\r\n   * Transform a path by an operation.\r\n   */ transform (path, operation) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!path) return null; // PERF: use destructing instead of immer\n        var p = [\n            ...path\n        ];\n        var { affinity = \"forward\" } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.\n        if (path.length === 0) {\n            return p;\n        }\n        switch(operation.type){\n            case \"insert_node\":\n                {\n                    var { path: op } = operation;\n                    if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n                        p[op.length - 1] += 1;\n                    }\n                    break;\n                }\n            case \"remove_node\":\n                {\n                    var { path: _op } = operation;\n                    if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n                        return null;\n                    } else if (Path.endsBefore(_op, p)) {\n                        p[_op.length - 1] -= 1;\n                    }\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var { path: _op2, position } = operation;\n                    if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                    } else if (Path.isAncestor(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                        p[_op2.length] += position;\n                    }\n                    break;\n                }\n            case \"split_node\":\n                {\n                    var { path: _op3, position: _position } = operation;\n                    if (Path.equals(_op3, p)) {\n                        if (affinity === \"forward\") {\n                            p[p.length - 1] += 1;\n                        } else if (affinity === \"backward\") ;\n                        else {\n                            return null;\n                        }\n                    } else if (Path.endsBefore(_op3, p)) {\n                        p[_op3.length - 1] += 1;\n                    } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n                        p[_op3.length - 1] += 1;\n                        p[_op3.length] -= _position;\n                    }\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var { path: _op4, newPath: onp } = operation; // If the old and new path are the same, it's a no-op.\n                    if (Path.equals(_op4, onp)) {\n                        return p;\n                    }\n                    if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n                        var copy = onp.slice();\n                        if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                            copy[_op4.length - 1] -= 1;\n                        }\n                        return copy.concat(p.slice(_op4.length));\n                    } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        } else {\n                            p[_op4.length - 1] += 1;\n                        }\n                    } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        }\n                        p[onp.length - 1] += 1;\n                    } else if (Path.endsBefore(_op4, p)) {\n                        if (Path.equals(onp, p)) {\n                            p[onp.length - 1] += 1;\n                        }\n                        p[_op4.length - 1] -= 1;\n                    }\n                    break;\n                }\n        }\n        return p;\n    }\n};\nvar PathRef = {\n    /**\r\n   * Transform the path ref's current value by an operation.\r\n   */ transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var path = Path.transform(current, op, {\n            affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nfunction ownKeys$6(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$6(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$6(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$6(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Point = {\n    /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */ compare (point, another) {\n        var result = Path.compare(point.path, another.path);\n        if (result === 0) {\n            if (point.offset < another.offset) return -1;\n            if (point.offset > another.offset) return 1;\n            return 0;\n        }\n        return result;\n    },\n    /**\r\n   * Check if a point is after another.\r\n   */ isAfter (point, another) {\n        return Point.compare(point, another) === 1;\n    },\n    /**\r\n   * Check if a point is before another.\r\n   */ isBefore (point, another) {\n        return Point.compare(point, another) === -1;\n    },\n    /**\r\n   * Check if a point is exactly equal to another.\r\n   */ equals (point, another) {\n        // PERF: ensure the offsets are equal first since they are cheaper to check.\n        return point.offset === another.offset && Path.equals(point.path, another.path);\n    },\n    /**\r\n   * Check if a value implements the `Point` interface.\r\n   */ isPoint (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.offset === \"number\" && Path.isPath(value.path);\n    },\n    /**\r\n   * Transform a point by an operation.\r\n   */ transform (point, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(point, (p)=>{\n            if (p === null) {\n                return null;\n            }\n            var { affinity = \"forward\" } = options;\n            var { path, offset } = p;\n            switch(op.type){\n                case \"insert_node\":\n                case \"move_node\":\n                    {\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"insert_text\":\n                    {\n                        if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === \"forward\")) {\n                            p.offset += op.text.length;\n                        }\n                        break;\n                    }\n                case \"merge_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            p.offset += op.position;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"remove_text\":\n                    {\n                        if (Path.equals(op.path, path) && op.offset <= offset) {\n                            p.offset -= Math.min(offset - op.offset, op.text.length);\n                        }\n                        break;\n                    }\n                case \"remove_node\":\n                    {\n                        if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n                            return null;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"split_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            if (op.position === offset && affinity == null) {\n                                return null;\n                            } else if (op.position < offset || op.position === offset && affinity === \"forward\") {\n                                p.offset -= op.position;\n                                p.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {\n                                    affinity: \"forward\"\n                                }));\n                            }\n                        } else {\n                            p.path = Path.transform(path, op, options);\n                        }\n                        break;\n                    }\n            }\n        });\n    }\n};\nvar PointRef = {\n    /**\r\n   * Transform the point ref's current value by an operation.\r\n   */ transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var point = Point.transform(current, op, {\n            affinity\n        });\n        ref.current = point;\n        if (point == null) {\n            ref.unref();\n        }\n    }\n};\nvar _excluded$2 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction ownKeys$5(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$5(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$5(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$5(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Range = {\n    /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */ edges (range) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var { anchor, focus } = range;\n        return Range.isBackward(range) === reverse ? [\n            anchor,\n            focus\n        ] : [\n            focus,\n            anchor\n        ];\n    },\n    /**\r\n   * Get the end point of a range.\r\n   */ end (range) {\n        var [, end] = Range.edges(range);\n        return end;\n    },\n    /**\r\n   * Check if a range is exactly equal to another.\r\n   */ equals (range, another) {\n        return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n    },\n    /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */ includes (range, target) {\n        if (Range.isRange(target)) {\n            if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n                return true;\n            }\n            var [rs, re] = Range.edges(range);\n            var [ts, te] = Range.edges(target);\n            return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n        }\n        var [start, end] = Range.edges(range);\n        var isAfterStart = false;\n        var isBeforeEnd = false;\n        if (Point.isPoint(target)) {\n            isAfterStart = Point.compare(target, start) >= 0;\n            isBeforeEnd = Point.compare(target, end) <= 0;\n        } else {\n            isAfterStart = Path.compare(target, start.path) >= 0;\n            isBeforeEnd = Path.compare(target, end.path) <= 0;\n        }\n        return isAfterStart && isBeforeEnd;\n    },\n    /**\r\n   * Get the intersection of a range with another.\r\n   */ intersection (range, another) {\n        var rest = _objectWithoutProperties(range, _excluded$2);\n        var [s1, e1] = Range.edges(range);\n        var [s2, e2] = Range.edges(another);\n        var start = Point.isBefore(s1, s2) ? s2 : s1;\n        var end = Point.isBefore(e1, e2) ? e1 : e2;\n        if (Point.isBefore(end, start)) {\n            return null;\n        } else {\n            return _objectSpread$5({\n                anchor: start,\n                focus: end\n            }, rest);\n        }\n    },\n    /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */ isBackward (range) {\n        var { anchor, focus } = range;\n        return Point.isAfter(anchor, focus);\n    },\n    /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */ isCollapsed (range) {\n        var { anchor, focus } = range;\n        return Point.equals(anchor, focus);\n    },\n    /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */ isExpanded (range) {\n        return !Range.isCollapsed(range);\n    },\n    /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */ isForward (range) {\n        return !Range.isBackward(range);\n    },\n    /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */ isRange (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n    },\n    /**\r\n   * Iterate through all of the point entries in a range.\r\n   */ *points (range) {\n        yield [\n            range.anchor,\n            \"anchor\"\n        ];\n        yield [\n            range.focus,\n            \"focus\"\n        ];\n    },\n    /**\r\n   * Get the start point of a range.\r\n   */ start (range) {\n        var [start] = Range.edges(range);\n        return start;\n    },\n    /**\r\n   * Transform a range by an operation.\r\n   */ transform (range, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(range, (r)=>{\n            if (r === null) {\n                return null;\n            }\n            var { affinity = \"inward\" } = options;\n            var affinityAnchor;\n            var affinityFocus;\n            if (affinity === \"inward\") {\n                // If the range is collapsed, make sure to use the same affinity to\n                // avoid the two points passing each other and expanding in the opposite\n                // direction\n                var isCollapsed = Range.isCollapsed(r);\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"backward\";\n                } else {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"forward\";\n                }\n            } else if (affinity === \"outward\") {\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = \"forward\";\n                } else {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = \"backward\";\n                }\n            } else {\n                affinityAnchor = affinity;\n                affinityFocus = affinity;\n            }\n            var anchor = Point.transform(r.anchor, op, {\n                affinity: affinityAnchor\n            });\n            var focus = Point.transform(r.focus, op, {\n                affinity: affinityFocus\n            });\n            if (!anchor || !focus) {\n                return null;\n            }\n            r.anchor = anchor;\n            r.focus = focus;\n        });\n    }\n};\nvar RangeRef = {\n    /**\r\n   * Transform the range ref's current value by an operation.\r\n   */ transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var path = Range.transform(current, op, {\n            affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nvar _scrubber = undefined;\n/**\r\n * This interface implements a stringify() function, which is used by Slate\r\n * internally when generating exceptions containing end user data. Developers\r\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\r\n * stringify() function.\r\n *\r\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\r\n *\r\n *    import { Scrubber } from 'slate';\r\n *    Scrubber.setScrubber((key, val) => {\r\n *      if (key === 'text') return '...scrubbed...'\r\n *      return val\r\n *    });\r\n *\r\n */ // eslint-disable-next-line no-redeclare\nvar Scrubber = {\n    setScrubber (scrubber) {\n        _scrubber = scrubber;\n    },\n    stringify (value) {\n        return JSON.stringify(value, _scrubber);\n    }\n};\n/*\r\n  Custom deep equal comparison for Slate nodes.\r\n\n  We don't need general purpose deep equality;\r\n  Slate only supports plain values, Arrays, and nested objects.\r\n  Complex values nested inside Arrays are not supported.\r\n\n  Slate objects are designed to be serialised, so\r\n  missing keys are deliberately normalised to undefined.\r\n */ var isDeepEqual = (node, another)=>{\n    for(var key in node){\n        var a = node[key];\n        var b = another[key];\n        if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(a) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(b)) {\n            if (!isDeepEqual(a, b)) return false;\n        } else if (Array.isArray(a) && Array.isArray(b)) {\n            if (a.length !== b.length) return false;\n            for(var i = 0; i < a.length; i++){\n                if (a[i] !== b[i]) return false;\n            }\n        } else if (a !== b) {\n            return false;\n        }\n    }\n    /*\r\n    Deep object equality is only necessary in one direction; in the reverse direction\r\n    we are only looking for keys that are missing.\r\n    As above, undefined keys are normalised to missing.\r\n  */ for(var _key in another){\n        if (node[_key] === undefined && another[_key] !== undefined) {\n            return false;\n        }\n    }\n    return true;\n};\nvar _excluded$1 = [\n    \"text\"\n], _excluded2$1 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction ownKeys$4(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$4(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$4(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$4(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Text = {\n    /**\r\n   * Check if two text nodes are equal.\r\n   *\r\n   * When loose is set, the text is not compared. This is\r\n   * used to check whether sibling text nodes can be merged.\r\n   */ equals (text, another) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { loose = false } = options;\n        function omitText(obj) {\n            var rest = _objectWithoutProperties(obj, _excluded$1);\n            return rest;\n        }\n        return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n    },\n    /**\r\n   * Check if a value implements the `Text` interface.\r\n   */ isText (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.text === \"string\";\n    },\n    /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */ isTextList (value) {\n        return Array.isArray(value) && value.every((val)=>Text.isText(val));\n    },\n    /**\r\n   * Check if some props are a partial of Text.\r\n   */ isTextProps (props) {\n        return props.text !== undefined;\n    },\n    /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */ matches (text, props) {\n        for(var key in props){\n            if (key === \"text\") {\n                continue;\n            }\n            if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    /**\r\n   * Get the leaves for a text node given decorations.\r\n   */ decorations (node, decorations) {\n        var leaves = [\n            _objectSpread$4({}, node)\n        ];\n        for (var dec of decorations){\n            var rest = _objectWithoutProperties(dec, _excluded2$1);\n            var [start, end] = Range.edges(dec);\n            var next = [];\n            var leafEnd = 0;\n            var decorationStart = start.offset;\n            var decorationEnd = end.offset;\n            for (var leaf of leaves){\n                var { length } = leaf.text;\n                var leafStart = leafEnd;\n                leafEnd += length; // If the range encompasses the entire leaf, add the range.\n                if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n                    Object.assign(leaf, rest);\n                    next.push(leaf);\n                    continue;\n                } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n                if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n                    next.push(leaf);\n                    continue;\n                } // Otherwise we need to split the leaf, at the start, end, or both,\n                // and add the range to the middle intersecting section. Do the end\n                // split first since we don't need to update the offset that way.\n                var middle = leaf;\n                var before = void 0;\n                var after = void 0;\n                if (decorationEnd < leafEnd) {\n                    var off = decorationEnd - leafStart;\n                    after = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                        text: middle.text.slice(off)\n                    });\n                    middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                        text: middle.text.slice(0, off)\n                    });\n                }\n                if (decorationStart > leafStart) {\n                    var _off = decorationStart - leafStart;\n                    before = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                        text: middle.text.slice(0, _off)\n                    });\n                    middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                        text: middle.text.slice(_off)\n                    });\n                }\n                Object.assign(middle, rest);\n                if (before) {\n                    next.push(before);\n                }\n                next.push(middle);\n                if (after) {\n                    next.push(after);\n                }\n            }\n            leaves = next;\n        }\n        return leaves;\n    }\n};\nfunction ownKeys$3(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$3(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$3(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar applyToDraft = (editor, selection, op)=>{\n    switch(op.type){\n        case \"insert_node\":\n            {\n                var { path, node } = op;\n                var parent = Node.parent(editor, path);\n                var index = path[path.length - 1];\n                if (index > parent.children.length) {\n                    throw new Error('Cannot apply an \"insert_node\" operation at path ['.concat(path, \"] because the destination is past the end of the node.\"));\n                }\n                parent.children.splice(index, 0, node);\n                if (selection) {\n                    for (var [point, key] of Range.points(selection)){\n                        selection[key] = Point.transform(point, op);\n                    }\n                }\n                break;\n            }\n        case \"insert_text\":\n            {\n                var { path: _path, offset, text } = op;\n                if (text.length === 0) break;\n                var _node = Node.leaf(editor, _path);\n                var before = _node.text.slice(0, offset);\n                var after = _node.text.slice(offset);\n                _node.text = before + text + after;\n                if (selection) {\n                    for (var [_point, _key] of Range.points(selection)){\n                        selection[_key] = Point.transform(_point, op);\n                    }\n                }\n                break;\n            }\n        case \"merge_node\":\n            {\n                var { path: _path2 } = op;\n                var _node2 = Node.get(editor, _path2);\n                var prevPath = Path.previous(_path2);\n                var prev = Node.get(editor, prevPath);\n                var _parent = Node.parent(editor, _path2);\n                var _index = _path2[_path2.length - 1];\n                if (Text.isText(_node2) && Text.isText(prev)) {\n                    prev.text += _node2.text;\n                } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n                    prev.children.push(..._node2.children);\n                } else {\n                    throw new Error('Cannot apply a \"merge_node\" operation at path ['.concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n                }\n                _parent.children.splice(_index, 1);\n                if (selection) {\n                    for (var [_point2, _key2] of Range.points(selection)){\n                        selection[_key2] = Point.transform(_point2, op);\n                    }\n                }\n                break;\n            }\n        case \"move_node\":\n            {\n                var { path: _path3, newPath } = op;\n                if (Path.isAncestor(_path3, newPath)) {\n                    throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n                }\n                var _node3 = Node.get(editor, _path3);\n                var _parent2 = Node.parent(editor, _path3);\n                var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n                // the same snapshot in time, there's a mismatch. After either\n                // removing the original position, the second step's path can be out\n                // of date. So instead of using the `op.newPath` directly, we\n                // transform `op.path` to ascertain what the `newPath` would be after\n                // the operation was applied.\n                _parent2.children.splice(_index2, 1);\n                var truePath = Path.transform(_path3, op);\n                var newParent = Node.get(editor, Path.parent(truePath));\n                var newIndex = truePath[truePath.length - 1];\n                newParent.children.splice(newIndex, 0, _node3);\n                if (selection) {\n                    for (var [_point3, _key3] of Range.points(selection)){\n                        selection[_key3] = Point.transform(_point3, op);\n                    }\n                }\n                break;\n            }\n        case \"remove_node\":\n            {\n                var { path: _path4 } = op;\n                var _index3 = _path4[_path4.length - 1];\n                var _parent3 = Node.parent(editor, _path4);\n                _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n                // node that was removed we need to update the range or remove it.\n                if (selection) {\n                    for (var [_point4, _key4] of Range.points(selection)){\n                        var result = Point.transform(_point4, op);\n                        if (selection != null && result != null) {\n                            selection[_key4] = result;\n                        } else {\n                            var _prev = void 0;\n                            var next = void 0;\n                            for (var [n, p] of Node.texts(editor)){\n                                if (Path.compare(p, _path4) === -1) {\n                                    _prev = [\n                                        n,\n                                        p\n                                    ];\n                                } else {\n                                    next = [\n                                        n,\n                                        p\n                                    ];\n                                    break;\n                                }\n                            }\n                            var preferNext = false;\n                            if (_prev && next) {\n                                if (Path.equals(next[1], _path4)) {\n                                    preferNext = !Path.hasPrevious(next[1]);\n                                } else {\n                                    preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                                }\n                            }\n                            if (_prev && !preferNext) {\n                                _point4.path = _prev[1];\n                                _point4.offset = _prev[0].text.length;\n                            } else if (next) {\n                                _point4.path = next[1];\n                                _point4.offset = 0;\n                            } else {\n                                selection = null;\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        case \"remove_text\":\n            {\n                var { path: _path5, offset: _offset, text: _text } = op;\n                if (_text.length === 0) break;\n                var _node4 = Node.leaf(editor, _path5);\n                var _before = _node4.text.slice(0, _offset);\n                var _after = _node4.text.slice(_offset + _text.length);\n                _node4.text = _before + _after;\n                if (selection) {\n                    for (var [_point5, _key5] of Range.points(selection)){\n                        selection[_key5] = Point.transform(_point5, op);\n                    }\n                }\n                break;\n            }\n        case \"set_node\":\n            {\n                var { path: _path6, properties, newProperties } = op;\n                if (_path6.length === 0) {\n                    throw new Error(\"Cannot set properties on the root node!\");\n                }\n                var _node5 = Node.get(editor, _path6);\n                for(var _key6 in newProperties){\n                    if (_key6 === \"children\" || _key6 === \"text\") {\n                        throw new Error('Cannot set the \"'.concat(_key6, '\" property of nodes!'));\n                    }\n                    var value = newProperties[_key6];\n                    if (value == null) {\n                        delete _node5[_key6];\n                    } else {\n                        _node5[_key6] = value;\n                    }\n                } // properties that were previously defined, but are now missing, must be deleted\n                for(var _key7 in properties){\n                    if (!newProperties.hasOwnProperty(_key7)) {\n                        delete _node5[_key7];\n                    }\n                }\n                break;\n            }\n        case \"set_selection\":\n            {\n                var { newProperties: _newProperties } = op;\n                if (_newProperties == null) {\n                    selection = _newProperties;\n                } else {\n                    if (selection == null) {\n                        if (!Range.isRange(_newProperties)) {\n                            throw new Error('Cannot apply an incomplete \"set_selection\" operation properties '.concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n                        }\n                        selection = _objectSpread$3({}, _newProperties);\n                    }\n                    for(var _key8 in _newProperties){\n                        var _value = _newProperties[_key8];\n                        if (_value == null) {\n                            if (_key8 === \"anchor\" || _key8 === \"focus\") {\n                                throw new Error('Cannot remove the \"'.concat(_key8, '\" selection property'));\n                            }\n                            delete selection[_key8];\n                        } else {\n                            selection[_key8] = _value;\n                        }\n                    }\n                }\n                break;\n            }\n        case \"split_node\":\n            {\n                var { path: _path7, position, properties: _properties } = op;\n                if (_path7.length === 0) {\n                    throw new Error('Cannot apply a \"split_node\" operation at path ['.concat(_path7, \"] because the root node cannot be split.\"));\n                }\n                var _node6 = Node.get(editor, _path7);\n                var _parent4 = Node.parent(editor, _path7);\n                var _index4 = _path7[_path7.length - 1];\n                var newNode;\n                if (Text.isText(_node6)) {\n                    var _before2 = _node6.text.slice(0, position);\n                    var _after2 = _node6.text.slice(position);\n                    _node6.text = _before2;\n                    newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n                        text: _after2\n                    });\n                } else {\n                    var _before3 = _node6.children.slice(0, position);\n                    var _after3 = _node6.children.slice(position);\n                    _node6.children = _before3;\n                    newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n                        children: _after3\n                    });\n                }\n                _parent4.children.splice(_index4 + 1, 0, newNode);\n                if (selection) {\n                    for (var [_point6, _key9] of Range.points(selection)){\n                        selection[_key9] = Point.transform(_point6, op);\n                    }\n                }\n                break;\n            }\n    }\n    return selection;\n}; // eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n    /**\r\n   * Transform the editor by an operation.\r\n   */ transform (editor, op) {\n        editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.children);\n        var selection = editor.selection && (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.selection);\n        try {\n            selection = applyToDraft(editor, selection, op);\n        } finally{\n            editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(editor.children);\n            if (selection) {\n                editor.selection = (0,immer__WEBPACK_IMPORTED_MODULE_1__.isDraft)(selection) ? (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(selection) : selection;\n            } else {\n                editor.selection = null;\n            }\n        }\n    }\n};\nvar _excluded = [\n    \"text\"\n], _excluded2 = [\n    \"children\"\n];\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar NodeTransforms = {\n    /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */ insertNodes (editor, nodes) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { hanging = false, voids = false, mode = \"lowest\" } = options;\n            var { at, match, select } = options;\n            if (Node.isNode(nodes)) {\n                nodes = [\n                    nodes\n                ];\n            }\n            if (nodes.length === 0) {\n                return;\n            }\n            var [node] = nodes; // By default, use the selection as the target location. But if there is\n            // no selection, insert at the end of the document since that is such a\n            // common use case when inserting from a non-selected state.\n            if (!at) {\n                if (editor.selection) {\n                    at = editor.selection;\n                } else if (editor.children.length > 0) {\n                    at = Editor.end(editor, []);\n                } else {\n                    at = [\n                        0\n                    ];\n                }\n                select = true;\n            }\n            if (select == null) {\n                select = false;\n            }\n            if (Range.isRange(at)) {\n                if (!hanging) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids\n                    });\n                }\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var [, end] = Range.edges(at);\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms.delete(editor, {\n                        at\n                    });\n                    at = pointRef.unref();\n                }\n            }\n            if (Point.isPoint(at)) {\n                if (match == null) {\n                    if (Text.isText(node)) {\n                        match = (n)=>Text.isText(n);\n                    } else if (editor.isInline(node)) {\n                        match = (n)=>Text.isText(n) || Editor.isInline(editor, n);\n                    } else {\n                        match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n                    }\n                }\n                var [entry] = Editor.nodes(editor, {\n                    at: at.path,\n                    match,\n                    mode,\n                    voids\n                });\n                if (entry) {\n                    var [, _matchPath] = entry;\n                    var pathRef = Editor.pathRef(editor, _matchPath);\n                    var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n                    Transforms.splitNodes(editor, {\n                        at,\n                        match,\n                        mode,\n                        voids\n                    });\n                    var path = pathRef.unref();\n                    at = isAtEnd ? Path.next(path) : path;\n                } else {\n                    return;\n                }\n            }\n            var parentPath = Path.parent(at);\n            var index = at[at.length - 1];\n            if (!voids && Editor.void(editor, {\n                at: parentPath\n            })) {\n                return;\n            }\n            for (var _node of nodes){\n                var _path = parentPath.concat(index);\n                index++;\n                editor.apply({\n                    type: \"insert_node\",\n                    path: _path,\n                    node: _node\n                });\n                at = Path.next(at);\n            }\n            at = Path.previous(at);\n            if (select) {\n                var point = Editor.end(editor, at);\n                if (point) {\n                    Transforms.select(editor, point);\n                }\n            }\n        });\n    },\n    /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */ liftNodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { at = editor.selection, mode = \"lowest\", voids = false } = options;\n            var { match } = options;\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            if (!at) {\n                return;\n            }\n            var matches = Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            });\n            var pathRefs = Array.from(matches, (_ref)=>{\n                var [, p] = _ref;\n                return Editor.pathRef(editor, p);\n            });\n            for (var pathRef of pathRefs){\n                var path = pathRef.unref();\n                if (path.length < 2) {\n                    throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n                }\n                var parentNodeEntry = Editor.node(editor, Path.parent(path));\n                var [parent, parentPath] = parentNodeEntry;\n                var index = path[path.length - 1];\n                var { length } = parent.children;\n                if (length === 1) {\n                    var toPath = Path.next(parentPath);\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: toPath,\n                        voids\n                    });\n                    Transforms.removeNodes(editor, {\n                        at: parentPath,\n                        voids\n                    });\n                } else if (index === 0) {\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: parentPath,\n                        voids\n                    });\n                } else if (index === length - 1) {\n                    var _toPath = Path.next(parentPath);\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: _toPath,\n                        voids\n                    });\n                } else {\n                    var splitPath = Path.next(path);\n                    var _toPath2 = Path.next(parentPath);\n                    Transforms.splitNodes(editor, {\n                        at: splitPath,\n                        voids\n                    });\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: _toPath2,\n                        voids\n                    });\n                }\n            }\n        });\n    },\n    /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */ mergeNodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { match, at = editor.selection } = options;\n            var { hanging = false, voids = false, mode = \"lowest\" } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                if (Path.isPath(at)) {\n                    var [parent] = Editor.parent(editor, at);\n                    match = (n)=>parent.children.includes(n);\n                } else {\n                    match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n                }\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            if (Range.isRange(at)) {\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var [, end] = Range.edges(at);\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms.delete(editor, {\n                        at\n                    });\n                    at = pointRef.unref();\n                    if (options.at == null) {\n                        Transforms.select(editor, at);\n                    }\n                }\n            }\n            var [current] = Editor.nodes(editor, {\n                at,\n                match,\n                voids,\n                mode\n            });\n            var prev = Editor.previous(editor, {\n                at,\n                match,\n                voids,\n                mode\n            });\n            if (!current || !prev) {\n                return;\n            }\n            var [node, path] = current;\n            var [prevNode, prevPath] = prev;\n            if (path.length === 0 || prevPath.length === 0) {\n                return;\n            }\n            var newPath = Path.next(prevPath);\n            var commonPath = Path.common(path, prevPath);\n            var isPreviousSibling = Path.isSibling(path, prevPath);\n            var levels = Array.from(Editor.levels(editor, {\n                at: path\n            }), (_ref2)=>{\n                var [n] = _ref2;\n                return n;\n            }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n            // result, in which case we'll want to remove it after merging.\n            var emptyAncestor = Editor.above(editor, {\n                at: path,\n                mode: \"highest\",\n                match: (n)=>levels.includes(n) && hasSingleChildNest(editor, n)\n            });\n            var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n            var properties;\n            var position; // Ensure that the nodes are equivalent, and figure out what the position\n            // and extra properties of the merge will be.\n            if (Text.isText(node) && Text.isText(prevNode)) {\n                var rest = _objectWithoutProperties(node, _excluded);\n                position = prevNode.text.length;\n                properties = rest;\n            } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n                var rest = _objectWithoutProperties(node, _excluded2);\n                position = prevNode.children.length;\n                properties = rest;\n            } else {\n                throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n            } // If the node isn't already the next sibling of the previous node, move\n            // it so that it is before merging.\n            if (!isPreviousSibling) {\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: newPath,\n                    voids\n                });\n            } // If there was going to be an empty ancestor of the node that was merged,\n            // we remove it from the tree.\n            if (emptyRef) {\n                Transforms.removeNodes(editor, {\n                    at: emptyRef.current,\n                    voids\n                });\n            } // If the target node that we're merging with is empty, remove it instead\n            // of merging the two. This is a common rich text editor behavior to\n            // prevent losing formatting when deleting entire nodes when you have a\n            // hanging selection.\n            // if prevNode is first child in parent,don't remove it.\n            if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === \"\" && prevPath[prevPath.length - 1] !== 0) {\n                Transforms.removeNodes(editor, {\n                    at: prevPath,\n                    voids\n                });\n            } else {\n                editor.apply({\n                    type: \"merge_node\",\n                    path: newPath,\n                    position,\n                    properties\n                });\n            }\n            if (emptyRef) {\n                emptyRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Move the nodes at a location to a new location.\r\n   */ moveNodes (editor, options) {\n        Editor.withoutNormalizing(editor, ()=>{\n            var { to, at = editor.selection, mode = \"lowest\", voids = false } = options;\n            var { match } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            var toRef = Editor.pathRef(editor, to);\n            var targets = Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            });\n            var pathRefs = Array.from(targets, (_ref3)=>{\n                var [, p] = _ref3;\n                return Editor.pathRef(editor, p);\n            });\n            for (var pathRef of pathRefs){\n                var path = pathRef.unref();\n                var newPath = toRef.current;\n                if (path.length !== 0) {\n                    editor.apply({\n                        type: \"move_node\",\n                        path,\n                        newPath\n                    });\n                }\n                if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n                    // When performing a sibling move to a later index, the path at the destination is shifted\n                    // to before the insertion point instead of after. To ensure our group of nodes are inserted\n                    // in the correct order we increment toRef to account for that\n                    toRef.current = Path.next(toRef.current);\n                }\n            }\n            toRef.unref();\n        });\n    },\n    /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */ removeNodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { hanging = false, voids = false, mode = \"lowest\" } = options;\n            var { at = editor.selection, match } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            var depths = Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            });\n            var pathRefs = Array.from(depths, (_ref4)=>{\n                var [, p] = _ref4;\n                return Editor.pathRef(editor, p);\n            });\n            for (var pathRef of pathRefs){\n                var path = pathRef.unref();\n                if (path) {\n                    var [node] = Editor.node(editor, path);\n                    editor.apply({\n                        type: \"remove_node\",\n                        path,\n                        node\n                    });\n                }\n            }\n        });\n    },\n    /**\r\n   * Set new properties on the nodes at a location.\r\n   */ setNodes (editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { match, at = editor.selection, compare, merge } = options;\n            var { hanging = false, mode = \"lowest\", split = false, voids = false } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            if (split && Range.isRange(at)) {\n                if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n                    // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n                    // set that won't get normalized away\n                    return;\n                }\n                var rangeRef = Editor.rangeRef(editor, at, {\n                    affinity: \"inward\"\n                });\n                var [start, end] = Range.edges(at);\n                var splitMode = mode === \"lowest\" ? \"lowest\" : \"highest\";\n                var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n                Transforms.splitNodes(editor, {\n                    at: end,\n                    match,\n                    mode: splitMode,\n                    voids,\n                    always: !endAtEndOfNode\n                });\n                var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n                Transforms.splitNodes(editor, {\n                    at: start,\n                    match,\n                    mode: splitMode,\n                    voids,\n                    always: !startAtStartOfNode\n                });\n                at = rangeRef.unref();\n                if (options.at == null) {\n                    Transforms.select(editor, at);\n                }\n            }\n            if (!compare) {\n                compare = (prop, nodeProp)=>prop !== nodeProp;\n            }\n            for (var [node, path] of Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            })){\n                var properties = {};\n                var newProperties = {}; // You can't set properties on the editor node.\n                if (path.length === 0) {\n                    continue;\n                }\n                var hasChanges = false;\n                for(var k in props){\n                    if (k === \"children\" || k === \"text\") {\n                        continue;\n                    }\n                    if (compare(props[k], node[k])) {\n                        hasChanges = true; // Omit new properties from the old properties list\n                        if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list\n                        if (merge) {\n                            if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n                        } else {\n                            if (props[k] != null) newProperties[k] = props[k];\n                        }\n                    }\n                }\n                if (hasChanges) {\n                    editor.apply({\n                        type: \"set_node\",\n                        path,\n                        properties,\n                        newProperties\n                    });\n                }\n            }\n        });\n    },\n    /**\r\n   * Split the nodes at a specific location.\r\n   */ splitNodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { mode = \"lowest\", voids = false } = options;\n            var { match, at = editor.selection, height = 0, always = false } = options;\n            if (match == null) {\n                match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            if (Range.isRange(at)) {\n                at = deleteRange(editor, at);\n            } // If the target is a path, the default height-skipping and position\n            // counters need to account for us potentially splitting at a non-leaf.\n            if (Path.isPath(at)) {\n                var path = at;\n                var point = Editor.point(editor, path);\n                var [parent] = Editor.parent(editor, path);\n                match = (n)=>n === parent;\n                height = point.path.length - path.length + 1;\n                at = point;\n                always = true;\n            }\n            if (!at) {\n                return;\n            }\n            var beforeRef = Editor.pointRef(editor, at, {\n                affinity: \"backward\"\n            });\n            var afterRef;\n            try {\n                var [highest] = Editor.nodes(editor, {\n                    at,\n                    match,\n                    mode,\n                    voids\n                });\n                if (!highest) {\n                    return;\n                }\n                var voidMatch = Editor.void(editor, {\n                    at,\n                    mode: \"highest\"\n                });\n                var nudge = 0;\n                if (!voids && voidMatch) {\n                    var [voidNode, voidPath] = voidMatch;\n                    if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n                        var after = Editor.after(editor, voidPath);\n                        if (!after) {\n                            var text = {\n                                text: \"\"\n                            };\n                            var afterPath = Path.next(voidPath);\n                            Transforms.insertNodes(editor, text, {\n                                at: afterPath,\n                                voids\n                            });\n                            after = Editor.point(editor, afterPath);\n                        }\n                        at = after;\n                        always = true;\n                    }\n                    var siblingHeight = at.path.length - voidPath.length;\n                    height = siblingHeight + 1;\n                    always = true;\n                }\n                afterRef = Editor.pointRef(editor, at);\n                var depth = at.path.length - height;\n                var [, highestPath] = highest;\n                var lowestPath = at.path.slice(0, depth);\n                var position = height === 0 ? at.offset : at.path[depth] + nudge;\n                for (var [node, _path2] of Editor.levels(editor, {\n                    at: lowestPath,\n                    reverse: true,\n                    voids\n                })){\n                    var split = false;\n                    if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n                        break;\n                    }\n                    var _point = beforeRef.current;\n                    var isEnd = Editor.isEnd(editor, _point, _path2);\n                    if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {\n                        split = true;\n                        var properties = Node.extractProps(node);\n                        editor.apply({\n                            type: \"split_node\",\n                            path: _path2,\n                            position,\n                            properties\n                        });\n                    }\n                    position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n                }\n                if (options.at == null) {\n                    var _point2 = afterRef.current || Editor.end(editor, []);\n                    Transforms.select(editor, _point2);\n                }\n            } finally{\n                var _afterRef;\n                beforeRef.unref();\n                (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Unset properties on the nodes at a location.\r\n   */ unsetNodes (editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!Array.isArray(props)) {\n            props = [\n                props\n            ];\n        }\n        var obj = {};\n        for (var key of props){\n            obj[key] = null;\n        }\n        Transforms.setNodes(editor, obj, options);\n    },\n    /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */ unwrapNodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { mode = \"lowest\", split = false, voids = false } = options;\n            var { at = editor.selection, match } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            if (Path.isPath(at)) {\n                at = Editor.range(editor, at);\n            }\n            var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n            var matches = Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            });\n            var pathRefs = Array.from(matches, (_ref5)=>{\n                var [, p] = _ref5;\n                return Editor.pathRef(editor, p);\n            } // unwrapNode will call liftNode which does not support splitting the node when nested.\n            ).reverse();\n            var _loop = function _loop(pathRef) {\n                var path = pathRef.unref();\n                var [node] = Editor.node(editor, path);\n                var range = Editor.range(editor, path);\n                if (split && rangeRef) {\n                    range = Range.intersection(rangeRef.current, range);\n                }\n                Transforms.liftNodes(editor, {\n                    at: range,\n                    match: (n)=>Element.isAncestor(node) && node.children.includes(n),\n                    voids\n                });\n            };\n            for (var pathRef of pathRefs){\n                _loop(pathRef);\n            }\n            if (rangeRef) {\n                rangeRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */ wrapNodes (editor, element) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { mode = \"lowest\", split = false, voids = false } = options;\n            var { match, at = editor.selection } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                if (Path.isPath(at)) {\n                    match = matchPath(editor, at);\n                } else if (editor.isInline(element)) {\n                    match = (n)=>Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n                } else {\n                    match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n                }\n            }\n            if (split && Range.isRange(at)) {\n                var [start, end] = Range.edges(at);\n                var rangeRef = Editor.rangeRef(editor, at, {\n                    affinity: \"inward\"\n                });\n                Transforms.splitNodes(editor, {\n                    at: end,\n                    match,\n                    voids\n                });\n                Transforms.splitNodes(editor, {\n                    at: start,\n                    match,\n                    voids\n                });\n                at = rangeRef.unref();\n                if (options.at == null) {\n                    Transforms.select(editor, at);\n                }\n            }\n            var roots = Array.from(Editor.nodes(editor, {\n                at,\n                match: editor.isInline(element) ? (n)=>Element.isElement(n) && Editor.isBlock(editor, n) : (n)=>Editor.isEditor(n),\n                mode: \"lowest\",\n                voids\n            }));\n            for (var [, rootPath] of roots){\n                var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n                if (!a) {\n                    continue;\n                }\n                var matches = Array.from(Editor.nodes(editor, {\n                    at: a,\n                    match,\n                    mode,\n                    voids\n                }));\n                if (matches.length > 0) {\n                    var _ret = function() {\n                        var [first] = matches;\n                        var last = matches[matches.length - 1];\n                        var [, firstPath] = first;\n                        var [, lastPath] = last;\n                        if (firstPath.length === 0 && lastPath.length === 0) {\n                            // if there's no matching parent - usually means the node is an editor - don't do anything\n                            return \"continue\";\n                        }\n                        var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n                        var range = Editor.range(editor, firstPath, lastPath);\n                        var commonNodeEntry = Editor.node(editor, commonPath);\n                        var [commonNode] = commonNodeEntry;\n                        var depth = commonPath.length + 1;\n                        var wrapperPath = Path.next(lastPath.slice(0, depth));\n                        var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {\n                            children: []\n                        });\n                        Transforms.insertNodes(editor, wrapper, {\n                            at: wrapperPath,\n                            voids\n                        });\n                        Transforms.moveNodes(editor, {\n                            at: range,\n                            match: (n)=>Element.isAncestor(commonNode) && commonNode.children.includes(n),\n                            to: wrapperPath.concat(0),\n                            voids\n                        });\n                    }();\n                    if (_ret === \"continue\") continue;\n                }\n            }\n        });\n    }\n};\nvar hasSingleChildNest = (editor, node)=>{\n    if (Element.isElement(node)) {\n        var element = node;\n        if (Editor.isVoid(editor, node)) {\n            return true;\n        } else if (element.children.length === 1) {\n            return hasSingleChildNest(editor, element.children[0]);\n        } else {\n            return false;\n        }\n    } else if (Editor.isEditor(node)) {\n        return false;\n    } else {\n        return true;\n    }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */ var deleteRange = (editor, range)=>{\n    if (Range.isCollapsed(range)) {\n        return range.anchor;\n    } else {\n        var [, end] = Range.edges(range);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n            at: range\n        });\n        return pointRef.unref();\n    }\n};\nvar matchPath = (editor, path)=>{\n    var [node] = Editor.node(editor, path);\n    return (n)=>n === node;\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar SelectionTransforms = {\n    /**\r\n   * Collapse the selection.\r\n   */ collapse (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { edge = \"anchor\" } = options;\n        var { selection } = editor;\n        if (!selection) {\n            return;\n        } else if (edge === \"anchor\") {\n            Transforms.select(editor, selection.anchor);\n        } else if (edge === \"focus\") {\n            Transforms.select(editor, selection.focus);\n        } else if (edge === \"start\") {\n            var [start] = Range.edges(selection);\n            Transforms.select(editor, start);\n        } else if (edge === \"end\") {\n            var [, end] = Range.edges(selection);\n            Transforms.select(editor, end);\n        }\n    },\n    /**\r\n   * Unset the selection.\r\n   */ deselect (editor) {\n        var { selection } = editor;\n        if (selection) {\n            editor.apply({\n                type: \"set_selection\",\n                properties: selection,\n                newProperties: null\n            });\n        }\n    },\n    /**\r\n   * Move the selection's point forward or backward.\r\n   */ move (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { selection } = editor;\n        var { distance = 1, unit = \"character\", reverse = false } = options;\n        var { edge = null } = options;\n        if (!selection) {\n            return;\n        }\n        if (edge === \"start\") {\n            edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n        }\n        if (edge === \"end\") {\n            edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n        }\n        var { anchor, focus } = selection;\n        var opts = {\n            distance,\n            unit\n        };\n        var props = {};\n        if (edge == null || edge === \"anchor\") {\n            var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n            if (point) {\n                props.anchor = point;\n            }\n        }\n        if (edge == null || edge === \"focus\") {\n            var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n            if (_point) {\n                props.focus = _point;\n            }\n        }\n        Transforms.setSelection(editor, props);\n    },\n    /**\r\n   * Set the selection to a new value.\r\n   */ select (editor, target) {\n        var { selection } = editor;\n        target = Editor.range(editor, target);\n        if (selection) {\n            Transforms.setSelection(editor, target);\n            return;\n        }\n        if (!Range.isRange(target)) {\n            throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n        }\n        editor.apply({\n            type: \"set_selection\",\n            properties: selection,\n            newProperties: target\n        });\n    },\n    /**\r\n   * Set new properties on one of the selection's points.\r\n   */ setPoint (editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { selection } = editor;\n        var { edge = \"both\" } = options;\n        if (!selection) {\n            return;\n        }\n        if (edge === \"start\") {\n            edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n        }\n        if (edge === \"end\") {\n            edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n        }\n        var { anchor, focus } = selection;\n        var point = edge === \"anchor\" ? anchor : focus;\n        Transforms.setSelection(editor, {\n            [edge === \"anchor\" ? \"anchor\" : \"focus\"]: _objectSpread$1(_objectSpread$1({}, point), props)\n        });\n    },\n    /**\r\n   * Set new properties on the selection.\r\n   */ setSelection (editor, props) {\n        var { selection } = editor;\n        var oldProps = {};\n        var newProps = {};\n        if (!selection) {\n            return;\n        }\n        for(var k in props){\n            if (k === \"anchor\" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === \"focus\" && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== \"anchor\" && k !== \"focus\" && props[k] !== selection[k]) {\n                oldProps[k] = selection[k];\n                newProps[k] = props[k];\n            }\n        }\n        if (Object.keys(oldProps).length > 0) {\n            editor.apply({\n                type: \"set_selection\",\n                properties: oldProps,\n                newProperties: newProps\n            });\n        }\n    }\n};\nvar TextTransforms = {\n    /**\r\n   * Delete content in the editor.\r\n   */ delete (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { reverse = false, unit = \"character\", distance = 1, voids = false } = options;\n            var { at = editor.selection, hanging = false } = options;\n            if (!at) {\n                return;\n            }\n            var isCollapsed = false;\n            if (Range.isRange(at) && Range.isCollapsed(at)) {\n                isCollapsed = true;\n                at = at.anchor;\n            }\n            if (Point.isPoint(at)) {\n                var furthestVoid = Editor.void(editor, {\n                    at,\n                    mode: \"highest\"\n                });\n                if (!voids && furthestVoid) {\n                    var [, voidPath] = furthestVoid;\n                    at = voidPath;\n                } else {\n                    var opts = {\n                        unit,\n                        distance\n                    };\n                    var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n                    at = {\n                        anchor: at,\n                        focus: target\n                    };\n                    hanging = true;\n                }\n            }\n            if (Path.isPath(at)) {\n                Transforms.removeNodes(editor, {\n                    at,\n                    voids\n                });\n                return;\n            }\n            if (Range.isCollapsed(at)) {\n                return;\n            }\n            if (!hanging) {\n                var [, _end] = Range.edges(at);\n                var endOfDoc = Editor.end(editor, []);\n                if (!Point.equals(_end, endOfDoc)) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids\n                    });\n                }\n            }\n            var [start, end] = Range.edges(at);\n            var startBlock = Editor.above(editor, {\n                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n                at: start,\n                voids\n            });\n            var endBlock = Editor.above(editor, {\n                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n                at: end,\n                voids\n            });\n            var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n            var isSingleText = Path.equals(start.path, end.path);\n            var startVoid = voids ? null : Editor.void(editor, {\n                at: start,\n                mode: \"highest\"\n            });\n            var endVoid = voids ? null : Editor.void(editor, {\n                at: end,\n                mode: \"highest\"\n            }); // If the start or end points are inside an inline void, nudge them out.\n            if (startVoid) {\n                var before = Editor.before(editor, start);\n                if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n                    start = before;\n                }\n            }\n            if (endVoid) {\n                var after = Editor.after(editor, end);\n                if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n                    end = after;\n                }\n            } // Get the highest nodes that are completely inside the range, as well as\n            // the start and end nodes.\n            var matches = [];\n            var lastPath;\n            for (var entry of Editor.nodes(editor, {\n                at,\n                voids\n            })){\n                var [node, path] = entry;\n                if (lastPath && Path.compare(path, lastPath) === 0) {\n                    continue;\n                }\n                if (!voids && Element.isElement(node) && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n                    matches.push(entry);\n                    lastPath = path;\n                }\n            }\n            var pathRefs = Array.from(matches, (_ref)=>{\n                var [, p] = _ref;\n                return Editor.pathRef(editor, p);\n            });\n            var startRef = Editor.pointRef(editor, start);\n            var endRef = Editor.pointRef(editor, end);\n            var removedText = \"\";\n            if (!isSingleText && !startVoid) {\n                var _point = startRef.current;\n                var [_node] = Editor.leaf(editor, _point);\n                var { path: _path } = _point;\n                var { offset } = start;\n                var text = _node.text.slice(offset);\n                if (text.length > 0) {\n                    editor.apply({\n                        type: \"remove_text\",\n                        path: _path,\n                        offset,\n                        text\n                    });\n                    removedText = text;\n                }\n            }\n            pathRefs.reverse().map((r)=>r.unref()).filter((r)=>r !== null).forEach((p)=>Transforms.removeNodes(editor, {\n                    at: p,\n                    voids\n                }));\n            if (!endVoid) {\n                var _point2 = endRef.current;\n                var [_node2] = Editor.leaf(editor, _point2);\n                var { path: _path2 } = _point2;\n                var _offset = isSingleText ? start.offset : 0;\n                var _text = _node2.text.slice(_offset, end.offset);\n                if (_text.length > 0) {\n                    editor.apply({\n                        type: \"remove_text\",\n                        path: _path2,\n                        offset: _offset,\n                        text: _text\n                    });\n                    removedText = _text;\n                }\n            }\n            if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n                Transforms.mergeNodes(editor, {\n                    at: endRef.current,\n                    hanging: true,\n                    voids\n                });\n            } // For Thai script, deleting N character(s) backward should delete\n            // N code point(s) instead of an entire grapheme cluster.\n            // Therefore, the remaining code points should be inserted back.\n            if (isCollapsed && reverse && unit === \"character\" && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n                Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n            }\n            var startUnref = startRef.unref();\n            var endUnref = endRef.unref();\n            var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n            if (options.at == null && point) {\n                Transforms.select(editor, point);\n            }\n        });\n    },\n    /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */ insertFragment (editor, fragment) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { hanging = false, voids = false } = options;\n            var { at = editor.selection } = options;\n            if (!fragment.length) {\n                return;\n            }\n            if (!at) {\n                return;\n            } else if (Range.isRange(at)) {\n                if (!hanging) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids\n                    });\n                }\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var [, end] = Range.edges(at);\n                    if (!voids && Editor.void(editor, {\n                        at: end\n                    })) {\n                        return;\n                    }\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms.delete(editor, {\n                        at\n                    });\n                    at = pointRef.unref();\n                }\n            } else if (Path.isPath(at)) {\n                at = Editor.start(editor, at);\n            }\n            if (!voids && Editor.void(editor, {\n                at\n            })) {\n                return;\n            } // If the insert point is at the edge of an inline node, move it outside\n            // instead since it will need to be split otherwise.\n            var inlineElementMatch = Editor.above(editor, {\n                at,\n                match: (n)=>Element.isElement(n) && Editor.isInline(editor, n),\n                mode: \"highest\",\n                voids\n            });\n            if (inlineElementMatch) {\n                var [, _inlinePath] = inlineElementMatch;\n                if (Editor.isEnd(editor, at, _inlinePath)) {\n                    var after = Editor.after(editor, _inlinePath);\n                    at = after;\n                } else if (Editor.isStart(editor, at, _inlinePath)) {\n                    var before = Editor.before(editor, _inlinePath);\n                    at = before;\n                }\n            }\n            var blockMatch = Editor.above(editor, {\n                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n                at,\n                voids\n            });\n            var [, blockPath] = blockMatch;\n            var isBlockStart = Editor.isStart(editor, at, blockPath);\n            var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n            var isBlockEmpty = isBlockStart && isBlockEnd;\n            var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n            var mergeEnd = !isBlockEnd;\n            var [, firstPath] = Node.first({\n                children: fragment\n            }, []);\n            var [, lastPath] = Node.last({\n                children: fragment\n            }, []);\n            var matches = [];\n            var matcher = (_ref2)=>{\n                var [n, p] = _ref2;\n                var isRoot = p.length === 0;\n                if (isRoot) {\n                    return false;\n                }\n                if (isBlockEmpty) {\n                    return true;\n                }\n                if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                    return false;\n                }\n                if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                    return false;\n                }\n                return true;\n            };\n            for (var entry of Node.nodes({\n                children: fragment\n            }, {\n                pass: matcher\n            })){\n                if (matcher(entry)) {\n                    matches.push(entry);\n                }\n            }\n            var starts = [];\n            var middles = [];\n            var ends = [];\n            var starting = true;\n            var hasBlocks = false;\n            for (var [node] of matches){\n                if (Element.isElement(node) && !editor.isInline(node)) {\n                    starting = false;\n                    hasBlocks = true;\n                    middles.push(node);\n                } else if (starting) {\n                    starts.push(node);\n                } else {\n                    ends.push(node);\n                }\n            }\n            var [inlineMatch] = Editor.nodes(editor, {\n                at,\n                match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n                mode: \"highest\",\n                voids\n            });\n            var [, inlinePath] = inlineMatch;\n            var isInlineStart = Editor.isStart(editor, at, inlinePath);\n            var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n            var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n            var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n            Transforms.splitNodes(editor, {\n                at,\n                match: (n)=>hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n                mode: hasBlocks ? \"lowest\" : \"highest\",\n                always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n                voids\n            });\n            var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n            Transforms.insertNodes(editor, starts, {\n                at: startRef.current,\n                match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n                mode: \"highest\",\n                voids\n            });\n            if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n                Transforms.delete(editor, {\n                    at: blockPath,\n                    voids\n                });\n            }\n            Transforms.insertNodes(editor, middles, {\n                at: middleRef.current,\n                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n                mode: \"lowest\",\n                voids\n            });\n            Transforms.insertNodes(editor, ends, {\n                at: endRef.current,\n                match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n                mode: \"highest\",\n                voids\n            });\n            if (!options.at) {\n                var path;\n                if (ends.length > 0 && endRef.current) {\n                    path = Path.previous(endRef.current);\n                } else if (middles.length > 0 && middleRef.current) {\n                    path = Path.previous(middleRef.current);\n                } else if (startRef.current) {\n                    path = Path.previous(startRef.current);\n                }\n                if (path) {\n                    var _end2 = Editor.end(editor, path);\n                    Transforms.select(editor, _end2);\n                }\n            }\n            startRef.unref();\n            middleRef.unref();\n            endRef.unref();\n        });\n    },\n    /**\r\n   * Insert a string of text in the Editor.\r\n   */ insertText (editor, text) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { voids = false } = options;\n            var { at = editor.selection } = options;\n            if (!at) {\n                return;\n            }\n            if (Path.isPath(at)) {\n                at = Editor.range(editor, at);\n            }\n            if (Range.isRange(at)) {\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var end = Range.end(at);\n                    if (!voids && Editor.void(editor, {\n                        at: end\n                    })) {\n                        return;\n                    }\n                    var start = Range.start(at);\n                    var startRef = Editor.pointRef(editor, start);\n                    var endRef = Editor.pointRef(editor, end);\n                    Transforms.delete(editor, {\n                        at,\n                        voids\n                    });\n                    var startPoint = startRef.unref();\n                    var endPoint = endRef.unref();\n                    at = startPoint || endPoint;\n                    Transforms.setSelection(editor, {\n                        anchor: at,\n                        focus: at\n                    });\n                }\n            }\n            if (!voids && Editor.void(editor, {\n                at\n            })) {\n                return;\n            }\n            var { path, offset } = at;\n            if (text.length > 0) editor.apply({\n                type: \"insert_text\",\n                path,\n                offset,\n                text\n            });\n        });\n    }\n};\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDbUI7QUFFbkUsU0FBU0ssZ0JBQWdCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztJQUN0QyxJQUFJRCxPQUFPRCxLQUFLO1FBQ2RHLE9BQU9DLGNBQWMsQ0FBQ0osS0FBS0MsS0FBSztZQUM5QkMsT0FBT0E7WUFDUEcsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7UUFDWjtJQUNGLE9BQU87UUFDTFAsR0FBRyxDQUFDQyxJQUFJLEdBQUdDO0lBQ2I7SUFFQSxPQUFPRjtBQUNUO0FBRUEsSUFBSVEsY0FBYyxJQUFJQztBQUN0QixJQUFJQyxrQkFBa0IsSUFBSUQ7QUFDMUIsSUFBSUUsV0FBVyxJQUFJRjtBQUNuQixJQUFJRyxjQUFjLElBQUlIO0FBQ3RCLElBQUlJLFlBQVksSUFBSUo7QUFDcEIsSUFBSUssYUFBYSxJQUFJTDtBQUNyQixJQUFJTSxhQUFhLElBQUlOO0FBRXJCLFNBQVNPLFVBQVVDLE1BQU0sRUFBRUMsY0FBYztJQUFJLElBQUlDLE9BQU9oQixPQUFPZ0IsSUFBSSxDQUFDRjtJQUFTLElBQUlkLE9BQU9pQixxQkFBcUIsRUFBRTtRQUFFLElBQUlDLFVBQVVsQixPQUFPaUIscUJBQXFCLENBQUNIO1FBQVMsSUFBSUMsZ0JBQWdCO1lBQUVHLFVBQVVBLFFBQVFDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHO2dCQUFJLE9BQU9wQixPQUFPcUIsd0JBQXdCLENBQUNQLFFBQVFNLEtBQUtsQixVQUFVO1lBQUU7UUFBSTtRQUFFYyxLQUFLTSxJQUFJLENBQUNDLEtBQUssQ0FBQ1AsTUFBTUU7SUFBVTtJQUFFLE9BQU9GO0FBQU07QUFFMVYsU0FBU1EsZ0JBQWdCQyxNQUFNO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztRQUFFLElBQUlHLFNBQVNG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QUFPLENBQUMsU0FBVWhDLEdBQUc7Z0JBQUlFLE9BQU9DLGNBQWMsQ0FBQ3dCLFFBQVEzQixLQUFLRSxPQUFPcUIsd0JBQXdCLENBQUNRLFFBQVEvQjtZQUFPO1FBQUk7SUFBRTtJQUFFLE9BQU8yQjtBQUFRO0FBQ3JoQixJQUFJK0MsYUFBYXVqQixjQUFjQSxjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBRzNHLG9CQUFvQkssaUJBQWlCd0Qsc0JBQXNCUztBQUVlLENBQ3ZKLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmVzLmpzPzdmNGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2lzLXBsYWluLW9iamVjdCc7XG5pbXBvcnQgeyBwcm9kdWNlLCBjcmVhdGVEcmFmdCwgZmluaXNoRHJhZnQsIGlzRHJhZnQgfSBmcm9tICdpbW1lcic7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG52YXIgRElSVFlfUEFUSFMgPSBuZXcgV2Vha01hcCgpO1xudmFyIERJUlRZX1BBVEhfS0VZUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRkxVU0hJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PUk1BTElaSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQQVRIX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBPSU5UX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIFJBTkdFX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDkob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDkodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ5KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkOShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgU2xhdGUgYEVkaXRvcmAgb2JqZWN0LlxyXG4gKi9cblxudmFyIGNyZWF0ZUVkaXRvciA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gICAgc2VsZWN0aW9uOiBudWxsLFxuICAgIG1hcmtzOiBudWxsLFxuICAgIGlzSW5saW5lOiAoKSA9PiBmYWxzZSxcbiAgICBpc1ZvaWQ6ICgpID0+IGZhbHNlLFxuICAgIG1hcmthYmxlVm9pZDogKCkgPT4gZmFsc2UsXG4gICAgb25DaGFuZ2U6ICgpID0+IHt9LFxuICAgIGFwcGx5OiBvcCA9PiB7XG4gICAgICBmb3IgKHZhciByZWYgb2YgRWRpdG9yLnBhdGhSZWZzKGVkaXRvcikpIHtcbiAgICAgICAgUGF0aFJlZi50cmFuc2Zvcm0ocmVmLCBvcCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9yZWYgb2YgRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpKSB7XG4gICAgICAgIFBvaW50UmVmLnRyYW5zZm9ybShfcmVmLCBvcCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9yZWYyIG9mIEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKSkge1xuICAgICAgICBSYW5nZVJlZi50cmFuc2Zvcm0oX3JlZjIsIG9wKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9sZERpcnR5UGF0aHMgPSBESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBbXTtcbiAgICAgIHZhciBvbGREaXJ0eVBhdGhLZXlzID0gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgICAgIHZhciBkaXJ0eVBhdGhzO1xuICAgICAgdmFyIGRpcnR5UGF0aEtleXM7XG5cbiAgICAgIHZhciBhZGQgPSBwYXRoID0+IHtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG5cbiAgICAgICAgICBpZiAoIWRpcnR5UGF0aEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGRpcnR5UGF0aEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBkaXJ0eVBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoUGF0aC5vcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wKSkge1xuICAgICAgICBkaXJ0eVBhdGhzID0gW107XG4gICAgICAgIGRpcnR5UGF0aEtleXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgZm9yICh2YXIgcGF0aCBvZiBvbGREaXJ0eVBhdGhzKSB7XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgYWRkKG5ld1BhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJ0eVBhdGhzID0gb2xkRGlydHlQYXRocztcbiAgICAgICAgZGlydHlQYXRoS2V5cyA9IG9sZERpcnR5UGF0aEtleXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdEaXJ0eVBhdGhzID0gZWRpdG9yLmdldERpcnR5UGF0aHMob3ApO1xuXG4gICAgICBmb3IgKHZhciBfcGF0aCBvZiBuZXdEaXJ0eVBhdGhzKSB7XG4gICAgICAgIGFkZChfcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIERJUlRZX1BBVEhTLnNldChlZGl0b3IsIGRpcnR5UGF0aHMpO1xuICAgICAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGRpcnR5UGF0aEtleXMpO1xuICAgICAgVHJhbnNmb3Jtcy50cmFuc2Zvcm0oZWRpdG9yLCBvcCk7XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yLCB7XG4gICAgICAgIG9wZXJhdGlvbjogb3BcbiAgICAgIH0pOyAvLyBDbGVhciBhbnkgZm9ybWF0cyBhcHBsaWVkIHRvIHRoZSBjdXJzb3IgaWYgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLlxuXG4gICAgICBpZiAob3AudHlwZSA9PT0gJ3NldF9zZWxlY3Rpb24nKSB7XG4gICAgICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIEZMVVNISU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICBlZGl0b3Iub25DaGFuZ2Uoe1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBvcFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVkaXRvci5vcGVyYXRpb25zID0gW107XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkTWFyazogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgbWFya2FibGVWb2lkXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtYXJrcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRleHRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgW3BhcmVudE5vZGUsIHBhcmVudFBhdGhdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIHJldHVybiAhZWRpdG9yLmlzVm9pZChwYXJlbnROb2RlKSB8fCBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICAgICAgdmFyIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIWV4cGFuZGVkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIFtzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbik7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIG1hdGNoKHNlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoKSkge1xuICAgICAgICAgICAgdmFyIFtwYXJlbnROb2RlXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBzZWxlY3RlZFBhdGgpO1xuICAgICAgICAgICAgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IHBhcmVudE5vZGUgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhwYW5kZWRTZWxlY3Rpb24gfHwgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBba2V5XTogdmFsdWVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSksIHt9LCB7XG4gICAgICAgICAgICBba2V5XTogdmFsdWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuXG4gICAgICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVCYWNrd2FyZDogdW5pdCA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICB1bml0LFxuICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVGb3J3YXJkOiB1bml0ID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIHVuaXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVGcmFnbWVudDogZGlyZWN0aW9uID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgcmV2ZXJzZTogZGlyZWN0aW9uID09PSAnYmFja3dhcmQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0RnJhZ21lbnQ6ICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gTm9kZS5mcmFnbWVudChlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGluc2VydEJyZWFrOiAoKSA9PiB7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpbnNlcnRTb2Z0QnJlYWs6ICgpID0+IHtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYWx3YXlzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGluc2VydEZyYWdtZW50OiBmcmFnbWVudCA9PiB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQpO1xuICAgIH0sXG4gICAgaW5zZXJ0Tm9kZTogbm9kZSA9PiB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSk7XG4gICAgfSxcbiAgICBpbnNlcnRUZXh0OiB0ZXh0ID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgbWFya3NcbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKG1hcmtzKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBfb2JqZWN0U3ByZWFkJDkoe1xuICAgICAgICAgICAgdGV4dFxuICAgICAgICAgIH0sIG1hcmtzKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCB0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBub3JtYWxpemVOb2RlOiBlbnRyeSA9PiB7XG4gICAgICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7IC8vIFRoZXJlIGFyZSBubyBjb3JlIG5vcm1hbGl6YXRpb25zIGZvciB0ZXh0IG5vZGVzLlxuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBFbnN1cmUgdGhhdCBibG9jayBhbmQgaW5saW5lIG5vZGVzIGhhdmUgYXQgbGVhc3Qgb25lIHRleHQgY2hpbGQuXG5cblxuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHtcbiAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGQsIHtcbiAgICAgICAgICBhdDogcGF0aC5jb25jYXQoMCksXG4gICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGhhdmUgYmxvY2sgb3IgaW5saW5lIGNoaWxkcmVuLlxuXG5cbiAgICAgIHZhciBzaG91bGRIYXZlSW5saW5lcyA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/IGZhbHNlIDogRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgKGVkaXRvci5pc0lubGluZShub2RlKSB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBUZXh0LmlzVGV4dChub2RlLmNoaWxkcmVuWzBdKSB8fCBlZGl0b3IuaXNJbmxpbmUobm9kZS5jaGlsZHJlblswXSkpOyAvLyBTaW5jZSB3ZSdsbCBiZSBhcHBseWluZyBvcGVyYXRpb25zIHdoaWxlIGl0ZXJhdGluZywga2VlcCB0cmFjayBvZiBhblxuICAgICAgLy8gaW5kZXggdGhhdCBhY2NvdW50cyBmb3IgYW55IGFkZGVkL3JlbW92ZWQgbm9kZXMuXG5cbiAgICAgIHZhciBuID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrLCBuKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KGN1cnJlbnROb2RlKSkgY29udGludWU7XG4gICAgICAgIHZhciBfY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIgcHJldiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuW24gLSAxXTtcbiAgICAgICAgdmFyIGlzTGFzdCA9IGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGlzSW5saW5lT3JUZXh0ID0gVGV4dC5pc1RleHQoX2NoaWxkKSB8fCBFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpICYmIGVkaXRvci5pc0lubGluZShfY2hpbGQpOyAvLyBPbmx5IGFsbG93IGJsb2NrIG5vZGVzIGluIHRoZSB0b3AtbGV2ZWwgY2hpbGRyZW4gYW5kIHBhcmVudCBibG9ja3NcbiAgICAgICAgLy8gdGhhdCBvbmx5IGNvbnRhaW4gYmxvY2sgbm9kZXMuIFNpbWlsYXJseSwgb25seSBhbGxvdyBpbmxpbmUgbm9kZXMgaW5cbiAgICAgICAgLy8gb3RoZXIgaW5saW5lIG5vZGVzLCBvciBwYXJlbnQgYmxvY2tzIHRoYXQgb25seSBjb250YWluIGlubGluZXMgYW5kXG4gICAgICAgIC8vIHRleHQuXG5cbiAgICAgICAgaWYgKGlzSW5saW5lT3JUZXh0ICE9PSBzaG91bGRIYXZlSW5saW5lcykge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgaW5saW5lIG5vZGVzIGFyZSBzdXJyb3VuZGVkIGJ5IHRleHQgbm9kZXMuXG4gICAgICAgICAgaWYgKGVkaXRvci5pc0lubGluZShfY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAocHJldiA9PSBudWxsIHx8ICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5ld0NoaWxkLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICB2YXIgX25ld0NoaWxkID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBfbmV3Q2hpbGQsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiArIDEpLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgdGhhdCBhcmUgZW1wdHkgb3IgbWF0Y2guXG4gICAgICAgICAgaWYgKHByZXYgIT0gbnVsbCAmJiBUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgaWYgKFRleHQuZXF1YWxzKF9jaGlsZCwgcHJldiwge1xuICAgICAgICAgICAgICBsb29zZTogdHJ1ZVxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2LnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gLSAxKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfY2hpbGQudGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZU1hcms6IGtleSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG1hdGNoID0gKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG1hcmtzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGV4dFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBbcGFyZW50Tm9kZSwgcGFyZW50UGF0aF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgcmV0dXJuICFlZGl0b3IuaXNWb2lkKHBhcmVudE5vZGUpIHx8IGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cGFuZGVkU2VsZWN0aW9uID0gUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pO1xuICAgICAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgW3NlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uKTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgW3BhcmVudE5vZGVdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCk7XG4gICAgICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBhbmRlZFNlbGVjdGlvbiB8fCBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwga2V5LCB7XG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDkoe30sIEVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9KTtcblxuICAgICAgICAgIGRlbGV0ZSBtYXJrc1trZXldO1xuICAgICAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuXG4gICAgICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBcImRpcnR5XCIgcGF0aHMgZ2VuZXJhdGVkIGZyb20gYW4gb3BlcmF0aW9uLlxyXG4gICAgICovXG4gICAgZ2V0RGlydHlQYXRoczogb3AgPT4ge1xuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgcGF0aFxuICAgICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgICAgcmV0dXJuIFBhdGgubGV2ZWxzKHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGgyKTtcbiAgICAgICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFRleHQuaXNUZXh0KG5vZGUpID8gW10gOiBBcnJheS5mcm9tKE5vZGUubm9kZXMobm9kZSksIF9yZWYzID0+IHtcbiAgICAgICAgICAgICAgdmFyIFssIHBdID0gX3JlZjM7XG4gICAgICAgICAgICAgIHJldHVybiBfcGF0aDIuY29uY2F0KHApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmxldmVscywgLi4uZGVzY2VuZGFudHNdO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgICBwYXRoOiBfcGF0aDNcbiAgICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICAgIHZhciBhbmNlc3RvcnMgPSBQYXRoLmFuY2VzdG9ycyhfcGF0aDMpO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzUGF0aCA9IFBhdGgucHJldmlvdXMoX3BhdGgzKTtcbiAgICAgICAgICAgIHJldHVybiBbLi4uYW5jZXN0b3JzLCBwcmV2aW91c1BhdGhdO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9wYXRoNCxcbiAgICAgICAgICAgICAgbmV3UGF0aFxuICAgICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX3BhdGg0LCBuZXdQYXRoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvbGRBbmNlc3RvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBuZXdBbmNlc3RvcnMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMoX3BhdGg0KSkge1xuICAgICAgICAgICAgICB2YXIgcCA9IFBhdGgudHJhbnNmb3JtKGFuY2VzdG9yLCBvcCk7XG4gICAgICAgICAgICAgIG9sZEFuY2VzdG9ycy5wdXNoKHApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBfYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMobmV3UGF0aCkpIHtcbiAgICAgICAgICAgICAgdmFyIF9wID0gUGF0aC50cmFuc2Zvcm0oX2FuY2VzdG9yLCBvcCk7XG5cbiAgICAgICAgICAgICAgbmV3QW5jZXN0b3JzLnB1c2goX3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3QW5jZXN0b3JzW25ld0FuY2VzdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IG5ld1BhdGhbbmV3UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciByZXN1bHRQYXRoID0gbmV3UGFyZW50LmNvbmNhdChuZXdJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLm9sZEFuY2VzdG9ycywgLi4ubmV3QW5jZXN0b3JzLCByZXN1bHRQYXRoXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9wYXRoNVxuICAgICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgICB2YXIgX2FuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoNSk7XG5cbiAgICAgICAgICAgIHJldHVybiBbLi4uX2FuY2VzdG9yc107XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9wYXRoNlxuICAgICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgICB2YXIgX2xldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoNik7XG5cbiAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IFBhdGgubmV4dChfcGF0aDYpO1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5fbGV2ZWxzLCBuZXh0UGF0aF07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3VsZE5vcm1hbGl6ZTogX3JlZjQgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBpbml0aWFsRGlydHlQYXRoc0xlbmd0aFxuICAgICAgfSA9IF9yZWY0O1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCAqIDQyOyAvLyBIQUNLOiBiZXR0ZXIgd2F5P1xuXG4gICAgICBpZiAoaXRlcmF0aW9uID4gbWF4SXRlcmF0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29tcGxldGVseSBub3JtYWxpemUgdGhlIGVkaXRvciBhZnRlciBcIi5jb25jYXQobWF4SXRlcmF0aW9ucywgXCIgaXRlcmF0aW9ucyEgVGhpcyBpcyB1c3VhbGx5IGR1ZSB0byBpbmNvcnJlY3Qgbm9ybWFsaXphdGlvbiBsb2dpYyB0aGF0IGxlYXZlcyBhIG5vZGUgaW4gYW4gaW52YWxpZCBzdGF0ZS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gQ2hhcmFjdGVyIChncmFwaGVtZSBjbHVzdGVyKSBib3VuZGFyaWVzIGFyZSBkZXRlcm1pbmVkIGFjY29yZGluZyB0b1xuLy8gdGhlIGRlZmF1bHQgZ3JhcGhlbWUgY2x1c3RlciBib3VuZGFyeSBzcGVjaWZpY2F0aW9uLCBleHRlbmRlZCBncmFwaGVtZSBjbHVzdGVycyB2YXJpYW50WzFdLlxuLy9cbi8vIFJlZmVyZW5jZXM6XG4vL1xuLy8gWzFdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIyOS8jRGVmYXVsdF9HcmFwaGVtZV9DbHVzdGVyX1RhYmxlXG4vLyBbMl0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0XG4vLyBbM10gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrVGVzdC5odG1sXG4vLyBbNF0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrVGVzdC50eHRcblxuLyoqXHJcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIGEgc3RyaW5nIG9mIHRleHQuXHJcbiAqL1xudmFyIGdldENoYXJhY3RlckRpc3RhbmNlID0gZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyRGlzdGFuY2Uoc3RyKSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBpc0xUUiA9ICFpc1JUTDtcbiAgdmFyIGNvZGVwb2ludHMgPSBpc1JUTCA/IGNvZGVwb2ludHNJdGVyYXRvclJUTChzdHIpIDogc3RyO1xuICB2YXIgbGVmdCA9IENvZGVwb2ludFR5cGUuTm9uZTtcbiAgdmFyIHJpZ2h0ID0gQ29kZXBvaW50VHlwZS5Ob25lO1xuICB2YXIgZGlzdGFuY2UgPSAwOyAvLyBFdmFsdWF0aW9uIG9mIHRoZXNlIGNvbmRpdGlvbnMgYXJlIGRlZmVycmVkLlxuXG4gIHZhciBnYjExID0gbnVsbDsgLy8gSXMgR0IxMSBhcHBsaWNhYmxlP1xuXG4gIHZhciBnYjEyT3IxMyA9IG51bGw7IC8vIElzIEdCMTIgb3IgR0IxMyBhcHBsaWNhYmxlP1xuXG4gIGZvciAodmFyIGNoYXIgb2YgY29kZXBvaW50cykge1xuICAgIHZhciBjb2RlID0gY2hhci5jb2RlUG9pbnRBdCgwKTtcbiAgICBpZiAoIWNvZGUpIGJyZWFrO1xuICAgIHZhciB0eXBlID0gZ2V0Q29kZXBvaW50VHlwZShjaGFyLCBjb2RlKTtcbiAgICBbbGVmdCwgcmlnaHRdID0gaXNMVFIgPyBbcmlnaHQsIHR5cGVdIDogW3R5cGUsIGxlZnRdO1xuXG4gICAgaWYgKGludGVyc2VjdHMobGVmdCwgQ29kZXBvaW50VHlwZS5aV0opICYmIGludGVyc2VjdHMocmlnaHQsIENvZGVwb2ludFR5cGUuRXh0UGljdCkpIHtcbiAgICAgIGlmIChpc0xUUikge1xuICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIGRpc3RhbmNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdiMTEpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpbnRlcnNlY3RzKGxlZnQsIENvZGVwb2ludFR5cGUuUkkpICYmIGludGVyc2VjdHMocmlnaHQsIENvZGVwb2ludFR5cGUuUkkpKSB7XG4gICAgICBpZiAoZ2IxMk9yMTMgIT09IG51bGwpIHtcbiAgICAgICAgZ2IxMk9yMTMgPSAhZ2IxMk9yMTM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgICBnYjEyT3IxMyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2IxMk9yMTMgPSBlbmRzV2l0aE9kZE51bWJlck9mUklzKHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFnYjEyT3IxMykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGxlZnQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiByaWdodCAhPT0gQ29kZXBvaW50VHlwZS5Ob25lICYmIGlzQm91bmRhcnlQYWlyKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGlzdGFuY2UgKz0gY2hhci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gZGlzdGFuY2UgfHwgMTtcbn07XG52YXIgU1BBQ0UgPSAvXFxzLztcbnZhciBQVU5DVFVBVElPTiA9IC9bXFx1MDAyMS1cXHUwMDIzXFx1MDAyNS1cXHUwMDJBXFx1MDAyQy1cXHUwMDJGXFx1MDAzQVxcdTAwM0JcXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RFxcdTAwNUZcXHUwMDdCXFx1MDA3RFxcdTAwQTFcXHUwMEE3XFx1MDBBQlxcdTAwQjZcXHUwMEI3XFx1MDBCQlxcdTAwQkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkUzQlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV0vO1xudmFyIENIQU1FTEVPTiA9IC9bJ1xcdTIwMThcXHUyMDE5XS87XG4vKipcclxuICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCB3b3JkIGluIGEgc3RyaW5nIG9mIHRleHQuXHJcbiAqL1xuXG52YXIgZ2V0V29yZERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0V29yZERpc3RhbmNlKHRleHQpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGRpc3QgPSAwO1xuICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xuXG4gIHdoaWxlICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBpc1JUTCk7XG4gICAgdmFyIFtjaGFyLCByZW1haW5pbmddID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHRleHQsIGNoYXJEaXN0LCBpc1JUTCk7XG5cbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKGNoYXIsIHJlbWFpbmluZywgaXNSVEwpKSB7XG4gICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgIGRpc3QgKz0gY2hhckRpc3Q7XG4gICAgfSBlbHNlIGlmICghc3RhcnRlZCkge1xuICAgICAgZGlzdCArPSBjaGFyRGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGV4dCA9IHJlbWFpbmluZztcbiAgfVxuXG4gIHJldHVybiBkaXN0O1xufTtcbi8qKlxyXG4gKiBTcGxpdCBhIHN0cmluZyBpbiB0d28gcGFydHMgYXQgYSBnaXZlbiBkaXN0YW5jZSBzdGFydGluZyBmcm9tIHRoZSBlbmQgd2hlblxyXG4gKiBgaXNSVExgIGlzIHNldCB0byBgdHJ1ZWAuXHJcbiAqL1xuXG52YXIgc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlID0gKHN0ciwgZGlzdCwgaXNSVEwpID0+IHtcbiAgaWYgKGlzUlRMKSB7XG4gICAgdmFyIGF0ID0gc3RyLmxlbmd0aCAtIGRpc3Q7XG4gICAgcmV0dXJuIFtzdHIuc2xpY2UoYXQsIHN0ci5sZW5ndGgpLCBzdHIuc2xpY2UoMCwgYXQpXTtcbiAgfVxuXG4gIHJldHVybiBbc3RyLnNsaWNlKDAsIGRpc3QpLCBzdHIuc2xpY2UoZGlzdCldO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGNoYXJhY3RlciBpcyBhIHdvcmQgY2hhcmFjdGVyLiBUaGUgYHJlbWFpbmluZ2AgYXJndW1lbnQgaXMgdXNlZFxyXG4gKiBiZWNhdXNlIHNvbWV0aW1lcyB5b3UgbXVzdCByZWFkIHN1YnNlcXVlbnQgY2hhcmFjdGVycyB0byB0cnVseSBkZXRlcm1pbmUgaXQuXHJcbiAqL1xuXG52YXIgaXNXb3JkQ2hhcmFjdGVyID0gZnVuY3Rpb24gaXNXb3JkQ2hhcmFjdGVyKGNoYXIsIHJlbWFpbmluZykge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIGlmIChTUEFDRS50ZXN0KGNoYXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIENoYW1lbGVvbnMgY291bnQgYXMgd29yZCBjaGFyYWN0ZXJzIGFzIGxvbmcgYXMgdGhleSdyZSBpbiBhIHdvcmQsIHNvXG4gIC8vIHJlY3Vyc2UgdG8gc2VlIGlmIHRoZSBuZXh0IG9uZSBpcyBhIHdvcmQgY2hhcmFjdGVyIG9yIG5vdC5cblxuXG4gIGlmIChDSEFNRUxFT04udGVzdChjaGFyKSkge1xuICAgIHZhciBjaGFyRGlzdCA9IGdldENoYXJhY3RlckRpc3RhbmNlKHJlbWFpbmluZywgaXNSVEwpO1xuICAgIHZhciBbbmV4dENoYXIsIG5leHRSZW1haW5pbmddID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHJlbWFpbmluZywgY2hhckRpc3QsIGlzUlRMKTtcblxuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIobmV4dENoYXIsIG5leHRSZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKFBVTkNUVUFUSU9OLnRlc3QoY2hhcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcclxuICogSXRlcmF0ZSBvbiBjb2RlcG9pbnRzIGZyb20gcmlnaHQgdG8gbGVmdC5cclxuICovXG5cblxudmFyIGNvZGVwb2ludHNJdGVyYXRvclJUTCA9IGZ1bmN0aW9uKiBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSB7XG4gIHZhciBlbmQgPSBzdHIubGVuZ3RoIC0gMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGFyMSA9IHN0ci5jaGFyQXQoZW5kIC0gaSk7XG5cbiAgICBpZiAoaXNMb3dTdXJyb2dhdGUoY2hhcjEuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHZhciBjaGFyMiA9IHN0ci5jaGFyQXQoZW5kIC0gaSAtIDEpO1xuXG4gICAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKGNoYXIyLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHlpZWxkIGNoYXIyICsgY2hhcjE7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeWllbGQgY2hhcjE7XG4gIH1cbn07XG4vKipcclxuICogSXMgYGNoYXJDb2RlYCBhIGhpZ2ggc3Vycm9nYXRlLlxyXG4gKlxyXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcclxuICovXG5cbnZhciBpc0hpZ2hTdXJyb2dhdGUgPSBjaGFyQ29kZSA9PiB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweGQ4MDAgJiYgY2hhckNvZGUgPD0gMHhkYmZmO1xufTtcbi8qKlxyXG4gKiBJcyBgY2hhckNvZGVgIGEgbG93IHN1cnJvZ2F0ZS5cclxuICpcclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXHJcbiAqL1xuXG5cbnZhciBpc0xvd1N1cnJvZ2F0ZSA9IGNoYXJDb2RlID0+IHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4ZGMwMCAmJiBjaGFyQ29kZSA8PSAweGRmZmY7XG59O1xuXG52YXIgQ29kZXBvaW50VHlwZTtcblxuKGZ1bmN0aW9uIChDb2RlcG9pbnRUeXBlKSB7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJFeHRlbmRcIl0gPSAxXSA9IFwiRXh0ZW5kXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlpXSlwiXSA9IDJdID0gXCJaV0pcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiUklcIl0gPSA0XSA9IFwiUklcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiUHJlcGVuZFwiXSA9IDhdID0gXCJQcmVwZW5kXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlNwYWNpbmdNYXJrXCJdID0gMTZdID0gXCJTcGFjaW5nTWFya1wiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMXCJdID0gMzJdID0gXCJMXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlZcIl0gPSA2NF0gPSBcIlZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiVFwiXSA9IDEyOF0gPSBcIlRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZcIl0gPSAyNTZdID0gXCJMVlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMVlRcIl0gPSA1MTJdID0gXCJMVlRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0UGljdFwiXSA9IDEwMjRdID0gXCJFeHRQaWN0XCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkFueVwiXSA9IDIwNDhdID0gXCJBbnlcIjtcbn0pKENvZGVwb2ludFR5cGUgfHwgKENvZGVwb2ludFR5cGUgPSB7fSkpO1xuXG52YXIgcmVFeHRlbmQgPSAvXig/OltcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RDMtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUJFXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTA5RkVcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEFGQS1cXHUwQUZGXFx1MEIwMVxcdTBCM0NcXHUwQjNFXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU1LVxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFXFx1MEJDMFxcdTBCQ0RcXHUwQkQ3XFx1MEMwMFxcdTBDMDRcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDMFxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjlcXHUxREZCLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REY0Ni1cXHVERjUwXXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQzktXFx1RERDQ1xcdUREQ0ZcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQlxcdURGM0NcXHVERjNFXFx1REY0MFxcdURGNTdcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDNUVcXHVEQ0IwXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkRcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERBRlxcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwNltcXHVEQzJGLVxcdURDMzdcXHVEQzM5XFx1REMzQVxcdUREMzBcXHVERDNCXFx1REQzQ1xcdUREM0VcXHVERDQzXFx1RERENC1cXHVEREQ3XFx1REREQVxcdUREREJcXHVEREUwXFx1REUwMS1cXHVERTBBXFx1REUzMy1cXHVERTM4XFx1REUzQi1cXHVERTNFXFx1REU0N1xcdURFNTEtXFx1REU1NlxcdURFNTktXFx1REU1QlxcdURFOEEtXFx1REU5NlxcdURFOThcXHVERTk5XXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XFx1REQzMS1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ1XFx1REQ0N1xcdUREOTBcXHVERDkxXFx1REQ5NVxcdUREOTdcXHVERUYzXFx1REVGNF18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY0RlxcdURGOEYtXFx1REY5MlxcdURGRTRdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdUREMzAtXFx1REQzNlxcdURFRUMtXFx1REVFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pJC87XG52YXIgcmVQcmVwZW5kID0gL14oPzpbXFx1MDYwMC1cXHUwNjA1XFx1MDZERFxcdTA3MEZcXHUwODkwXFx1MDg5MVxcdTA4RTJcXHUwRDRFXXxcXHVEODA0W1xcdURDQkRcXHVEQ0NEXFx1RERDMlxcdUREQzNdfFxcdUQ4MDZbXFx1REQzRlxcdURENDFcXHVERTNBXFx1REU4NC1cXHVERTg5XXxcXHVEODA3XFx1REQ0NikkLztcbnZhciByZVNwYWNpbmdNYXJrID0gL14oPzpbXFx1MDkwM1xcdTA5M0JcXHUwOTNFLVxcdTA5NDBcXHUwOTQ5LVxcdTA5NENcXHUwOTRFXFx1MDk0RlxcdTA5ODJcXHUwOTgzXFx1MDlCRlxcdTA5QzBcXHUwOUM3XFx1MDlDOFxcdTA5Q0JcXHUwOUNDXFx1MEEwM1xcdTBBM0UtXFx1MEE0MFxcdTBBODNcXHUwQUJFLVxcdTBBQzBcXHUwQUM5XFx1MEFDQlxcdTBBQ0NcXHUwQjAyXFx1MEIwM1xcdTBCNDBcXHUwQjQ3XFx1MEI0OFxcdTBCNEJcXHUwQjRDXFx1MEJCRlxcdTBCQzFcXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNDXFx1MEMwMS1cXHUwQzAzXFx1MEM0MS1cXHUwQzQ0XFx1MEM4MlxcdTBDODNcXHUwQ0JFXFx1MENDMFxcdTBDQzFcXHUwQ0MzXFx1MENDNFxcdTBDQzdcXHUwQ0M4XFx1MENDQVxcdTBDQ0JcXHUwRDAyXFx1MEQwM1xcdTBEM0ZcXHUwRDQwXFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRDXFx1MEQ4MlxcdTBEODNcXHUwREQwXFx1MEREMVxcdTBERDgtXFx1MERERVxcdTBERjJcXHUwREYzXFx1MEUzM1xcdTBFQjNcXHUwRjNFXFx1MEYzRlxcdTBGN0ZcXHUxMDMxXFx1MTAzQlxcdTEwM0NcXHUxMDU2XFx1MTA1N1xcdTEwODRcXHUxNzE1XFx1MTczNFxcdTE3QjZcXHUxN0JFLVxcdTE3QzVcXHUxN0M3XFx1MTdDOFxcdTE5MjMtXFx1MTkyNlxcdTE5MjktXFx1MTkyQlxcdTE5MzBcXHUxOTMxXFx1MTkzMy1cXHUxOTM4XFx1MUExOVxcdTFBMUFcXHUxQTU1XFx1MUE1N1xcdTFBNkQtXFx1MUE3MlxcdTFCMDRcXHUxQjNCXFx1MUIzRC1cXHUxQjQxXFx1MUI0M1xcdTFCNDRcXHUxQjgyXFx1MUJBMVxcdTFCQTZcXHUxQkE3XFx1MUJBQVxcdTFCRTdcXHUxQkVBLVxcdTFCRUNcXHUxQkVFXFx1MUJGMlxcdTFCRjNcXHUxQzI0LVxcdTFDMkJcXHUxQzM0XFx1MUMzNVxcdTFDRTFcXHUxQ0Y3XFx1QTgyM1xcdUE4MjRcXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzNcXHVBOTUyXFx1QTk1M1xcdUE5ODNcXHVBOUI0XFx1QTlCNVxcdUE5QkFcXHVBOUJCXFx1QTlCRS1cXHVBOUMwXFx1QUEyRlxcdUFBMzBcXHVBQTMzXFx1QUEzNFxcdUFBNERcXHVBQUVCXFx1QUFFRVxcdUFBRUZcXHVBQUY1XFx1QUJFM1xcdUFCRTRcXHVBQkU2XFx1QUJFN1xcdUFCRTlcXHVBQkVBXFx1QUJFQ118XFx1RDgwNFtcXHVEQzAwXFx1REMwMlxcdURDODJcXHVEQ0IwLVxcdURDQjJcXHVEQ0I3XFx1RENCOFxcdUREMkNcXHVERDQ1XFx1REQ0NlxcdUREODJcXHVEREIzLVxcdUREQjVcXHVEREJGXFx1RERDMFxcdUREQ0VcXHVERTJDLVxcdURFMkVcXHVERTMyXFx1REUzM1xcdURFMzVcXHVERUUwLVxcdURFRTJcXHVERjAyXFx1REYwM1xcdURGM0ZcXHVERjQxLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNjJcXHVERjYzXXxcXHVEODA1W1xcdURDMzUtXFx1REMzN1xcdURDNDBcXHVEQzQxXFx1REM0NVxcdURDQjFcXHVEQ0IyXFx1RENCOVxcdURDQkJcXHVEQ0JDXFx1RENCRVxcdURDQzFcXHVEREIwXFx1RERCMVxcdUREQjgtXFx1RERCQlxcdUREQkVcXHVERTMwLVxcdURFMzJcXHVERTNCXFx1REUzQ1xcdURFM0VcXHVERUFDXFx1REVBRVxcdURFQUZcXHVERUI2XFx1REYyNl18XFx1RDgwNltcXHVEQzJDLVxcdURDMkVcXHVEQzM4XFx1REQzMS1cXHVERDM1XFx1REQzN1xcdUREMzhcXHVERDNEXFx1REQ0MFxcdURENDJcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREZcXHVEREU0XFx1REUzOVxcdURFNTdcXHVERTU4XFx1REU5N118XFx1RDgwN1tcXHVEQzJGXFx1REMzRVxcdURDQTlcXHVEQ0IxXFx1RENCNFxcdUREOEEtXFx1REQ4RVxcdUREOTNcXHVERDk0XFx1REQ5NlxcdURFRjVcXHVERUY2XXxcXHVEODFCW1xcdURGNTEtXFx1REY4N1xcdURGRjBcXHVERkYxXXxcXHVEODM0W1xcdURENjZcXHVERDZEXSkkLztcbnZhciByZUwgPSAvXltcXHUxMTAwLVxcdTExNUZcXHVBOTYwLVxcdUE5N0NdJC87XG52YXIgcmVWID0gL15bXFx1MTE2MC1cXHUxMUE3XFx1RDdCMC1cXHVEN0M2XSQvO1xudmFyIHJlVCA9IC9eW1xcdTExQTgtXFx1MTFGRlxcdUQ3Q0ItXFx1RDdGQl0kLztcbnZhciByZUxWID0gL15bXFx1QUMwMFxcdUFDMUNcXHVBQzM4XFx1QUM1NFxcdUFDNzBcXHVBQzhDXFx1QUNBOFxcdUFDQzRcXHVBQ0UwXFx1QUNGQ1xcdUFEMThcXHVBRDM0XFx1QUQ1MFxcdUFENkNcXHVBRDg4XFx1QURBNFxcdUFEQzBcXHVBRERDXFx1QURGOFxcdUFFMTRcXHVBRTMwXFx1QUU0Q1xcdUFFNjhcXHVBRTg0XFx1QUVBMFxcdUFFQkNcXHVBRUQ4XFx1QUVGNFxcdUFGMTBcXHVBRjJDXFx1QUY0OFxcdUFGNjRcXHVBRjgwXFx1QUY5Q1xcdUFGQjhcXHVBRkQ0XFx1QUZGMFxcdUIwMENcXHVCMDI4XFx1QjA0NFxcdUIwNjBcXHVCMDdDXFx1QjA5OFxcdUIwQjRcXHVCMEQwXFx1QjBFQ1xcdUIxMDhcXHVCMTI0XFx1QjE0MFxcdUIxNUNcXHVCMTc4XFx1QjE5NFxcdUIxQjBcXHVCMUNDXFx1QjFFOFxcdUIyMDRcXHVCMjIwXFx1QjIzQ1xcdUIyNThcXHVCMjc0XFx1QjI5MFxcdUIyQUNcXHVCMkM4XFx1QjJFNFxcdUIzMDBcXHVCMzFDXFx1QjMzOFxcdUIzNTRcXHVCMzcwXFx1QjM4Q1xcdUIzQThcXHVCM0M0XFx1QjNFMFxcdUIzRkNcXHVCNDE4XFx1QjQzNFxcdUI0NTBcXHVCNDZDXFx1QjQ4OFxcdUI0QTRcXHVCNEMwXFx1QjREQ1xcdUI0RjhcXHVCNTE0XFx1QjUzMFxcdUI1NENcXHVCNTY4XFx1QjU4NFxcdUI1QTBcXHVCNUJDXFx1QjVEOFxcdUI1RjRcXHVCNjEwXFx1QjYyQ1xcdUI2NDhcXHVCNjY0XFx1QjY4MFxcdUI2OUNcXHVCNkI4XFx1QjZENFxcdUI2RjBcXHVCNzBDXFx1QjcyOFxcdUI3NDRcXHVCNzYwXFx1Qjc3Q1xcdUI3OThcXHVCN0I0XFx1QjdEMFxcdUI3RUNcXHVCODA4XFx1QjgyNFxcdUI4NDBcXHVCODVDXFx1Qjg3OFxcdUI4OTRcXHVCOEIwXFx1QjhDQ1xcdUI4RThcXHVCOTA0XFx1QjkyMFxcdUI5M0NcXHVCOTU4XFx1Qjk3NFxcdUI5OTBcXHVCOUFDXFx1QjlDOFxcdUI5RTRcXHVCQTAwXFx1QkExQ1xcdUJBMzhcXHVCQTU0XFx1QkE3MFxcdUJBOENcXHVCQUE4XFx1QkFDNFxcdUJBRTBcXHVCQUZDXFx1QkIxOFxcdUJCMzRcXHVCQjUwXFx1QkI2Q1xcdUJCODhcXHVCQkE0XFx1QkJDMFxcdUJCRENcXHVCQkY4XFx1QkMxNFxcdUJDMzBcXHVCQzRDXFx1QkM2OFxcdUJDODRcXHVCQ0EwXFx1QkNCQ1xcdUJDRDhcXHVCQ0Y0XFx1QkQxMFxcdUJEMkNcXHVCRDQ4XFx1QkQ2NFxcdUJEODBcXHVCRDlDXFx1QkRCOFxcdUJERDRcXHVCREYwXFx1QkUwQ1xcdUJFMjhcXHVCRTQ0XFx1QkU2MFxcdUJFN0NcXHVCRTk4XFx1QkVCNFxcdUJFRDBcXHVCRUVDXFx1QkYwOFxcdUJGMjRcXHVCRjQwXFx1QkY1Q1xcdUJGNzhcXHVCRjk0XFx1QkZCMFxcdUJGQ0NcXHVCRkU4XFx1QzAwNFxcdUMwMjBcXHVDMDNDXFx1QzA1OFxcdUMwNzRcXHVDMDkwXFx1QzBBQ1xcdUMwQzhcXHVDMEU0XFx1QzEwMFxcdUMxMUNcXHVDMTM4XFx1QzE1NFxcdUMxNzBcXHVDMThDXFx1QzFBOFxcdUMxQzRcXHVDMUUwXFx1QzFGQ1xcdUMyMThcXHVDMjM0XFx1QzI1MFxcdUMyNkNcXHVDMjg4XFx1QzJBNFxcdUMyQzBcXHVDMkRDXFx1QzJGOFxcdUMzMTRcXHVDMzMwXFx1QzM0Q1xcdUMzNjhcXHVDMzg0XFx1QzNBMFxcdUMzQkNcXHVDM0Q4XFx1QzNGNFxcdUM0MTBcXHVDNDJDXFx1QzQ0OFxcdUM0NjRcXHVDNDgwXFx1QzQ5Q1xcdUM0QjhcXHVDNEQ0XFx1QzRGMFxcdUM1MENcXHVDNTI4XFx1QzU0NFxcdUM1NjBcXHVDNTdDXFx1QzU5OFxcdUM1QjRcXHVDNUQwXFx1QzVFQ1xcdUM2MDhcXHVDNjI0XFx1QzY0MFxcdUM2NUNcXHVDNjc4XFx1QzY5NFxcdUM2QjBcXHVDNkNDXFx1QzZFOFxcdUM3MDRcXHVDNzIwXFx1QzczQ1xcdUM3NThcXHVDNzc0XFx1Qzc5MFxcdUM3QUNcXHVDN0M4XFx1QzdFNFxcdUM4MDBcXHVDODFDXFx1QzgzOFxcdUM4NTRcXHVDODcwXFx1Qzg4Q1xcdUM4QThcXHVDOEM0XFx1QzhFMFxcdUM4RkNcXHVDOTE4XFx1QzkzNFxcdUM5NTBcXHVDOTZDXFx1Qzk4OFxcdUM5QTRcXHVDOUMwXFx1QzlEQ1xcdUM5RjhcXHVDQTE0XFx1Q0EzMFxcdUNBNENcXHVDQTY4XFx1Q0E4NFxcdUNBQTBcXHVDQUJDXFx1Q0FEOFxcdUNBRjRcXHVDQjEwXFx1Q0IyQ1xcdUNCNDhcXHVDQjY0XFx1Q0I4MFxcdUNCOUNcXHVDQkI4XFx1Q0JENFxcdUNCRjBcXHVDQzBDXFx1Q0MyOFxcdUNDNDRcXHVDQzYwXFx1Q0M3Q1xcdUNDOThcXHVDQ0I0XFx1Q0NEMFxcdUNDRUNcXHVDRDA4XFx1Q0QyNFxcdUNENDBcXHVDRDVDXFx1Q0Q3OFxcdUNEOTRcXHVDREIwXFx1Q0RDQ1xcdUNERThcXHVDRTA0XFx1Q0UyMFxcdUNFM0NcXHVDRTU4XFx1Q0U3NFxcdUNFOTBcXHVDRUFDXFx1Q0VDOFxcdUNFRTRcXHVDRjAwXFx1Q0YxQ1xcdUNGMzhcXHVDRjU0XFx1Q0Y3MFxcdUNGOENcXHVDRkE4XFx1Q0ZDNFxcdUNGRTBcXHVDRkZDXFx1RDAxOFxcdUQwMzRcXHVEMDUwXFx1RDA2Q1xcdUQwODhcXHVEMEE0XFx1RDBDMFxcdUQwRENcXHVEMEY4XFx1RDExNFxcdUQxMzBcXHVEMTRDXFx1RDE2OFxcdUQxODRcXHVEMUEwXFx1RDFCQ1xcdUQxRDhcXHVEMUY0XFx1RDIxMFxcdUQyMkNcXHVEMjQ4XFx1RDI2NFxcdUQyODBcXHVEMjlDXFx1RDJCOFxcdUQyRDRcXHVEMkYwXFx1RDMwQ1xcdUQzMjhcXHVEMzQ0XFx1RDM2MFxcdUQzN0NcXHVEMzk4XFx1RDNCNFxcdUQzRDBcXHVEM0VDXFx1RDQwOFxcdUQ0MjRcXHVENDQwXFx1RDQ1Q1xcdUQ0NzhcXHVENDk0XFx1RDRCMFxcdUQ0Q0NcXHVENEU4XFx1RDUwNFxcdUQ1MjBcXHVENTNDXFx1RDU1OFxcdUQ1NzRcXHVENTkwXFx1RDVBQ1xcdUQ1QzhcXHVENUU0XFx1RDYwMFxcdUQ2MUNcXHVENjM4XFx1RDY1NFxcdUQ2NzBcXHVENjhDXFx1RDZBOFxcdUQ2QzRcXHVENkUwXFx1RDZGQ1xcdUQ3MThcXHVENzM0XFx1RDc1MFxcdUQ3NkNcXHVENzg4XSQvO1xudmFyIHJlTFZUID0gL15bXFx1QUMwMS1cXHVBQzFCXFx1QUMxRC1cXHVBQzM3XFx1QUMzOS1cXHVBQzUzXFx1QUM1NS1cXHVBQzZGXFx1QUM3MS1cXHVBQzhCXFx1QUM4RC1cXHVBQ0E3XFx1QUNBOS1cXHVBQ0MzXFx1QUNDNS1cXHVBQ0RGXFx1QUNFMS1cXHVBQ0ZCXFx1QUNGRC1cXHVBRDE3XFx1QUQxOS1cXHVBRDMzXFx1QUQzNS1cXHVBRDRGXFx1QUQ1MS1cXHVBRDZCXFx1QUQ2RC1cXHVBRDg3XFx1QUQ4OS1cXHVBREEzXFx1QURBNS1cXHVBREJGXFx1QURDMS1cXHVBRERCXFx1QURERC1cXHVBREY3XFx1QURGOS1cXHVBRTEzXFx1QUUxNS1cXHVBRTJGXFx1QUUzMS1cXHVBRTRCXFx1QUU0RC1cXHVBRTY3XFx1QUU2OS1cXHVBRTgzXFx1QUU4NS1cXHVBRTlGXFx1QUVBMS1cXHVBRUJCXFx1QUVCRC1cXHVBRUQ3XFx1QUVEOS1cXHVBRUYzXFx1QUVGNS1cXHVBRjBGXFx1QUYxMS1cXHVBRjJCXFx1QUYyRC1cXHVBRjQ3XFx1QUY0OS1cXHVBRjYzXFx1QUY2NS1cXHVBRjdGXFx1QUY4MS1cXHVBRjlCXFx1QUY5RC1cXHVBRkI3XFx1QUZCOS1cXHVBRkQzXFx1QUZENS1cXHVBRkVGXFx1QUZGMS1cXHVCMDBCXFx1QjAwRC1cXHVCMDI3XFx1QjAyOS1cXHVCMDQzXFx1QjA0NS1cXHVCMDVGXFx1QjA2MS1cXHVCMDdCXFx1QjA3RC1cXHVCMDk3XFx1QjA5OS1cXHVCMEIzXFx1QjBCNS1cXHVCMENGXFx1QjBEMS1cXHVCMEVCXFx1QjBFRC1cXHVCMTA3XFx1QjEwOS1cXHVCMTIzXFx1QjEyNS1cXHVCMTNGXFx1QjE0MS1cXHVCMTVCXFx1QjE1RC1cXHVCMTc3XFx1QjE3OS1cXHVCMTkzXFx1QjE5NS1cXHVCMUFGXFx1QjFCMS1cXHVCMUNCXFx1QjFDRC1cXHVCMUU3XFx1QjFFOS1cXHVCMjAzXFx1QjIwNS1cXHVCMjFGXFx1QjIyMS1cXHVCMjNCXFx1QjIzRC1cXHVCMjU3XFx1QjI1OS1cXHVCMjczXFx1QjI3NS1cXHVCMjhGXFx1QjI5MS1cXHVCMkFCXFx1QjJBRC1cXHVCMkM3XFx1QjJDOS1cXHVCMkUzXFx1QjJFNS1cXHVCMkZGXFx1QjMwMS1cXHVCMzFCXFx1QjMxRC1cXHVCMzM3XFx1QjMzOS1cXHVCMzUzXFx1QjM1NS1cXHVCMzZGXFx1QjM3MS1cXHVCMzhCXFx1QjM4RC1cXHVCM0E3XFx1QjNBOS1cXHVCM0MzXFx1QjNDNS1cXHVCM0RGXFx1QjNFMS1cXHVCM0ZCXFx1QjNGRC1cXHVCNDE3XFx1QjQxOS1cXHVCNDMzXFx1QjQzNS1cXHVCNDRGXFx1QjQ1MS1cXHVCNDZCXFx1QjQ2RC1cXHVCNDg3XFx1QjQ4OS1cXHVCNEEzXFx1QjRBNS1cXHVCNEJGXFx1QjRDMS1cXHVCNERCXFx1QjRERC1cXHVCNEY3XFx1QjRGOS1cXHVCNTEzXFx1QjUxNS1cXHVCNTJGXFx1QjUzMS1cXHVCNTRCXFx1QjU0RC1cXHVCNTY3XFx1QjU2OS1cXHVCNTgzXFx1QjU4NS1cXHVCNTlGXFx1QjVBMS1cXHVCNUJCXFx1QjVCRC1cXHVCNUQ3XFx1QjVEOS1cXHVCNUYzXFx1QjVGNS1cXHVCNjBGXFx1QjYxMS1cXHVCNjJCXFx1QjYyRC1cXHVCNjQ3XFx1QjY0OS1cXHVCNjYzXFx1QjY2NS1cXHVCNjdGXFx1QjY4MS1cXHVCNjlCXFx1QjY5RC1cXHVCNkI3XFx1QjZCOS1cXHVCNkQzXFx1QjZENS1cXHVCNkVGXFx1QjZGMS1cXHVCNzBCXFx1QjcwRC1cXHVCNzI3XFx1QjcyOS1cXHVCNzQzXFx1Qjc0NS1cXHVCNzVGXFx1Qjc2MS1cXHVCNzdCXFx1Qjc3RC1cXHVCNzk3XFx1Qjc5OS1cXHVCN0IzXFx1QjdCNS1cXHVCN0NGXFx1QjdEMS1cXHVCN0VCXFx1QjdFRC1cXHVCODA3XFx1QjgwOS1cXHVCODIzXFx1QjgyNS1cXHVCODNGXFx1Qjg0MS1cXHVCODVCXFx1Qjg1RC1cXHVCODc3XFx1Qjg3OS1cXHVCODkzXFx1Qjg5NS1cXHVCOEFGXFx1QjhCMS1cXHVCOENCXFx1QjhDRC1cXHVCOEU3XFx1QjhFOS1cXHVCOTAzXFx1QjkwNS1cXHVCOTFGXFx1QjkyMS1cXHVCOTNCXFx1QjkzRC1cXHVCOTU3XFx1Qjk1OS1cXHVCOTczXFx1Qjk3NS1cXHVCOThGXFx1Qjk5MS1cXHVCOUFCXFx1QjlBRC1cXHVCOUM3XFx1QjlDOS1cXHVCOUUzXFx1QjlFNS1cXHVCOUZGXFx1QkEwMS1cXHVCQTFCXFx1QkExRC1cXHVCQTM3XFx1QkEzOS1cXHVCQTUzXFx1QkE1NS1cXHVCQTZGXFx1QkE3MS1cXHVCQThCXFx1QkE4RC1cXHVCQUE3XFx1QkFBOS1cXHVCQUMzXFx1QkFDNS1cXHVCQURGXFx1QkFFMS1cXHVCQUZCXFx1QkFGRC1cXHVCQjE3XFx1QkIxOS1cXHVCQjMzXFx1QkIzNS1cXHVCQjRGXFx1QkI1MS1cXHVCQjZCXFx1QkI2RC1cXHVCQjg3XFx1QkI4OS1cXHVCQkEzXFx1QkJBNS1cXHVCQkJGXFx1QkJDMS1cXHVCQkRCXFx1QkJERC1cXHVCQkY3XFx1QkJGOS1cXHVCQzEzXFx1QkMxNS1cXHVCQzJGXFx1QkMzMS1cXHVCQzRCXFx1QkM0RC1cXHVCQzY3XFx1QkM2OS1cXHVCQzgzXFx1QkM4NS1cXHVCQzlGXFx1QkNBMS1cXHVCQ0JCXFx1QkNCRC1cXHVCQ0Q3XFx1QkNEOS1cXHVCQ0YzXFx1QkNGNS1cXHVCRDBGXFx1QkQxMS1cXHVCRDJCXFx1QkQyRC1cXHVCRDQ3XFx1QkQ0OS1cXHVCRDYzXFx1QkQ2NS1cXHVCRDdGXFx1QkQ4MS1cXHVCRDlCXFx1QkQ5RC1cXHVCREI3XFx1QkRCOS1cXHVCREQzXFx1QkRENS1cXHVCREVGXFx1QkRGMS1cXHVCRTBCXFx1QkUwRC1cXHVCRTI3XFx1QkUyOS1cXHVCRTQzXFx1QkU0NS1cXHVCRTVGXFx1QkU2MS1cXHVCRTdCXFx1QkU3RC1cXHVCRTk3XFx1QkU5OS1cXHVCRUIzXFx1QkVCNS1cXHVCRUNGXFx1QkVEMS1cXHVCRUVCXFx1QkVFRC1cXHVCRjA3XFx1QkYwOS1cXHVCRjIzXFx1QkYyNS1cXHVCRjNGXFx1QkY0MS1cXHVCRjVCXFx1QkY1RC1cXHVCRjc3XFx1QkY3OS1cXHVCRjkzXFx1QkY5NS1cXHVCRkFGXFx1QkZCMS1cXHVCRkNCXFx1QkZDRC1cXHVCRkU3XFx1QkZFOS1cXHVDMDAzXFx1QzAwNS1cXHVDMDFGXFx1QzAyMS1cXHVDMDNCXFx1QzAzRC1cXHVDMDU3XFx1QzA1OS1cXHVDMDczXFx1QzA3NS1cXHVDMDhGXFx1QzA5MS1cXHVDMEFCXFx1QzBBRC1cXHVDMEM3XFx1QzBDOS1cXHVDMEUzXFx1QzBFNS1cXHVDMEZGXFx1QzEwMS1cXHVDMTFCXFx1QzExRC1cXHVDMTM3XFx1QzEzOS1cXHVDMTUzXFx1QzE1NS1cXHVDMTZGXFx1QzE3MS1cXHVDMThCXFx1QzE4RC1cXHVDMUE3XFx1QzFBOS1cXHVDMUMzXFx1QzFDNS1cXHVDMURGXFx1QzFFMS1cXHVDMUZCXFx1QzFGRC1cXHVDMjE3XFx1QzIxOS1cXHVDMjMzXFx1QzIzNS1cXHVDMjRGXFx1QzI1MS1cXHVDMjZCXFx1QzI2RC1cXHVDMjg3XFx1QzI4OS1cXHVDMkEzXFx1QzJBNS1cXHVDMkJGXFx1QzJDMS1cXHVDMkRCXFx1QzJERC1cXHVDMkY3XFx1QzJGOS1cXHVDMzEzXFx1QzMxNS1cXHVDMzJGXFx1QzMzMS1cXHVDMzRCXFx1QzM0RC1cXHVDMzY3XFx1QzM2OS1cXHVDMzgzXFx1QzM4NS1cXHVDMzlGXFx1QzNBMS1cXHVDM0JCXFx1QzNCRC1cXHVDM0Q3XFx1QzNEOS1cXHVDM0YzXFx1QzNGNS1cXHVDNDBGXFx1QzQxMS1cXHVDNDJCXFx1QzQyRC1cXHVDNDQ3XFx1QzQ0OS1cXHVDNDYzXFx1QzQ2NS1cXHVDNDdGXFx1QzQ4MS1cXHVDNDlCXFx1QzQ5RC1cXHVDNEI3XFx1QzRCOS1cXHVDNEQzXFx1QzRENS1cXHVDNEVGXFx1QzRGMS1cXHVDNTBCXFx1QzUwRC1cXHVDNTI3XFx1QzUyOS1cXHVDNTQzXFx1QzU0NS1cXHVDNTVGXFx1QzU2MS1cXHVDNTdCXFx1QzU3RC1cXHVDNTk3XFx1QzU5OS1cXHVDNUIzXFx1QzVCNS1cXHVDNUNGXFx1QzVEMS1cXHVDNUVCXFx1QzVFRC1cXHVDNjA3XFx1QzYwOS1cXHVDNjIzXFx1QzYyNS1cXHVDNjNGXFx1QzY0MS1cXHVDNjVCXFx1QzY1RC1cXHVDNjc3XFx1QzY3OS1cXHVDNjkzXFx1QzY5NS1cXHVDNkFGXFx1QzZCMS1cXHVDNkNCXFx1QzZDRC1cXHVDNkU3XFx1QzZFOS1cXHVDNzAzXFx1QzcwNS1cXHVDNzFGXFx1QzcyMS1cXHVDNzNCXFx1QzczRC1cXHVDNzU3XFx1Qzc1OS1cXHVDNzczXFx1Qzc3NS1cXHVDNzhGXFx1Qzc5MS1cXHVDN0FCXFx1QzdBRC1cXHVDN0M3XFx1QzdDOS1cXHVDN0UzXFx1QzdFNS1cXHVDN0ZGXFx1QzgwMS1cXHVDODFCXFx1QzgxRC1cXHVDODM3XFx1QzgzOS1cXHVDODUzXFx1Qzg1NS1cXHVDODZGXFx1Qzg3MS1cXHVDODhCXFx1Qzg4RC1cXHVDOEE3XFx1QzhBOS1cXHVDOEMzXFx1QzhDNS1cXHVDOERGXFx1QzhFMS1cXHVDOEZCXFx1QzhGRC1cXHVDOTE3XFx1QzkxOS1cXHVDOTMzXFx1QzkzNS1cXHVDOTRGXFx1Qzk1MS1cXHVDOTZCXFx1Qzk2RC1cXHVDOTg3XFx1Qzk4OS1cXHVDOUEzXFx1QzlBNS1cXHVDOUJGXFx1QzlDMS1cXHVDOURCXFx1QzlERC1cXHVDOUY3XFx1QzlGOS1cXHVDQTEzXFx1Q0ExNS1cXHVDQTJGXFx1Q0EzMS1cXHVDQTRCXFx1Q0E0RC1cXHVDQTY3XFx1Q0E2OS1cXHVDQTgzXFx1Q0E4NS1cXHVDQTlGXFx1Q0FBMS1cXHVDQUJCXFx1Q0FCRC1cXHVDQUQ3XFx1Q0FEOS1cXHVDQUYzXFx1Q0FGNS1cXHVDQjBGXFx1Q0IxMS1cXHVDQjJCXFx1Q0IyRC1cXHVDQjQ3XFx1Q0I0OS1cXHVDQjYzXFx1Q0I2NS1cXHVDQjdGXFx1Q0I4MS1cXHVDQjlCXFx1Q0I5RC1cXHVDQkI3XFx1Q0JCOS1cXHVDQkQzXFx1Q0JENS1cXHVDQkVGXFx1Q0JGMS1cXHVDQzBCXFx1Q0MwRC1cXHVDQzI3XFx1Q0MyOS1cXHVDQzQzXFx1Q0M0NS1cXHVDQzVGXFx1Q0M2MS1cXHVDQzdCXFx1Q0M3RC1cXHVDQzk3XFx1Q0M5OS1cXHVDQ0IzXFx1Q0NCNS1cXHVDQ0NGXFx1Q0NEMS1cXHVDQ0VCXFx1Q0NFRC1cXHVDRDA3XFx1Q0QwOS1cXHVDRDIzXFx1Q0QyNS1cXHVDRDNGXFx1Q0Q0MS1cXHVDRDVCXFx1Q0Q1RC1cXHVDRDc3XFx1Q0Q3OS1cXHVDRDkzXFx1Q0Q5NS1cXHVDREFGXFx1Q0RCMS1cXHVDRENCXFx1Q0RDRC1cXHVDREU3XFx1Q0RFOS1cXHVDRTAzXFx1Q0UwNS1cXHVDRTFGXFx1Q0UyMS1cXHVDRTNCXFx1Q0UzRC1cXHVDRTU3XFx1Q0U1OS1cXHVDRTczXFx1Q0U3NS1cXHVDRThGXFx1Q0U5MS1cXHVDRUFCXFx1Q0VBRC1cXHVDRUM3XFx1Q0VDOS1cXHVDRUUzXFx1Q0VFNS1cXHVDRUZGXFx1Q0YwMS1cXHVDRjFCXFx1Q0YxRC1cXHVDRjM3XFx1Q0YzOS1cXHVDRjUzXFx1Q0Y1NS1cXHVDRjZGXFx1Q0Y3MS1cXHVDRjhCXFx1Q0Y4RC1cXHVDRkE3XFx1Q0ZBOS1cXHVDRkMzXFx1Q0ZDNS1cXHVDRkRGXFx1Q0ZFMS1cXHVDRkZCXFx1Q0ZGRC1cXHVEMDE3XFx1RDAxOS1cXHVEMDMzXFx1RDAzNS1cXHVEMDRGXFx1RDA1MS1cXHVEMDZCXFx1RDA2RC1cXHVEMDg3XFx1RDA4OS1cXHVEMEEzXFx1RDBBNS1cXHVEMEJGXFx1RDBDMS1cXHVEMERCXFx1RDBERC1cXHVEMEY3XFx1RDBGOS1cXHVEMTEzXFx1RDExNS1cXHVEMTJGXFx1RDEzMS1cXHVEMTRCXFx1RDE0RC1cXHVEMTY3XFx1RDE2OS1cXHVEMTgzXFx1RDE4NS1cXHVEMTlGXFx1RDFBMS1cXHVEMUJCXFx1RDFCRC1cXHVEMUQ3XFx1RDFEOS1cXHVEMUYzXFx1RDFGNS1cXHVEMjBGXFx1RDIxMS1cXHVEMjJCXFx1RDIyRC1cXHVEMjQ3XFx1RDI0OS1cXHVEMjYzXFx1RDI2NS1cXHVEMjdGXFx1RDI4MS1cXHVEMjlCXFx1RDI5RC1cXHVEMkI3XFx1RDJCOS1cXHVEMkQzXFx1RDJENS1cXHVEMkVGXFx1RDJGMS1cXHVEMzBCXFx1RDMwRC1cXHVEMzI3XFx1RDMyOS1cXHVEMzQzXFx1RDM0NS1cXHVEMzVGXFx1RDM2MS1cXHVEMzdCXFx1RDM3RC1cXHVEMzk3XFx1RDM5OS1cXHVEM0IzXFx1RDNCNS1cXHVEM0NGXFx1RDNEMS1cXHVEM0VCXFx1RDNFRC1cXHVENDA3XFx1RDQwOS1cXHVENDIzXFx1RDQyNS1cXHVENDNGXFx1RDQ0MS1cXHVENDVCXFx1RDQ1RC1cXHVENDc3XFx1RDQ3OS1cXHVENDkzXFx1RDQ5NS1cXHVENEFGXFx1RDRCMS1cXHVENENCXFx1RDRDRC1cXHVENEU3XFx1RDRFOS1cXHVENTAzXFx1RDUwNS1cXHVENTFGXFx1RDUyMS1cXHVENTNCXFx1RDUzRC1cXHVENTU3XFx1RDU1OS1cXHVENTczXFx1RDU3NS1cXHVENThGXFx1RDU5MS1cXHVENUFCXFx1RDVBRC1cXHVENUM3XFx1RDVDOS1cXHVENUUzXFx1RDVFNS1cXHVENUZGXFx1RDYwMS1cXHVENjFCXFx1RDYxRC1cXHVENjM3XFx1RDYzOS1cXHVENjUzXFx1RDY1NS1cXHVENjZGXFx1RDY3MS1cXHVENjhCXFx1RDY4RC1cXHVENkE3XFx1RDZBOS1cXHVENkMzXFx1RDZDNS1cXHVENkRGXFx1RDZFMS1cXHVENkZCXFx1RDZGRC1cXHVENzE3XFx1RDcxOS1cXHVENzMzXFx1RDczNS1cXHVENzRGXFx1RDc1MS1cXHVENzZCXFx1RDc2RC1cXHVENzg3XFx1RDc4OS1cXHVEN0EzXSQvO1xudmFyIHJlRXh0UGljdCA9IC9eKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSQvO1xuXG52YXIgZ2V0Q29kZXBvaW50VHlwZSA9IChjaGFyLCBjb2RlKSA9PiB7XG4gIHZhciB0eXBlID0gQ29kZXBvaW50VHlwZS5Bbnk7XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlRXh0ZW5kKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuRXh0ZW5kO1xuICB9XG5cbiAgaWYgKGNvZGUgPT09IDB4MjAwZCkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5aV0o7XG4gIH1cblxuICBpZiAoY29kZSA+PSAweDFmMWU2ICYmIGNvZGUgPD0gMHgxZjFmZikge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5SSTtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZVByZXBlbmQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5QcmVwZW5kO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlU3BhY2luZ01hcmspICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFyaztcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZUwpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlY7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVDtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZUxWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFY7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVMVlQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MVlQ7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVFeHRQaWN0KSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuRXh0UGljdDtcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufTtcblxuZnVuY3Rpb24gaW50ZXJzZWN0cyh4LCB5KSB7XG4gIHJldHVybiAoeCAmIHkpICE9PSAwO1xufVxuXG52YXIgTm9uQm91bmRhcnlQYWlycyA9IFsvLyBHQjZcbltDb2RlcG9pbnRUeXBlLkwsIENvZGVwb2ludFR5cGUuTCB8IENvZGVwb2ludFR5cGUuViB8IENvZGVwb2ludFR5cGUuTFYgfCBDb2RlcG9pbnRUeXBlLkxWVF0sIC8vIEdCN1xuW0NvZGVwb2ludFR5cGUuTFYgfCBDb2RlcG9pbnRUeXBlLlYsIENvZGVwb2ludFR5cGUuViB8IENvZGVwb2ludFR5cGUuVF0sIC8vIEdCOFxuW0NvZGVwb2ludFR5cGUuTFZUIHwgQ29kZXBvaW50VHlwZS5ULCBDb2RlcG9pbnRUeXBlLlRdLCAvLyBHQjlcbltDb2RlcG9pbnRUeXBlLkFueSwgQ29kZXBvaW50VHlwZS5FeHRlbmQgfCBDb2RlcG9pbnRUeXBlLlpXSl0sIC8vIEdCOWFcbltDb2RlcG9pbnRUeXBlLkFueSwgQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFya10sIC8vIEdCOWJcbltDb2RlcG9pbnRUeXBlLlByZXBlbmQsIENvZGVwb2ludFR5cGUuQW55XSwgLy8gR0IxMVxuW0NvZGVwb2ludFR5cGUuWldKLCBDb2RlcG9pbnRUeXBlLkV4dFBpY3RdLCAvLyBHQjEyIGFuZCBHQjEzXG5bQ29kZXBvaW50VHlwZS5SSSwgQ29kZXBvaW50VHlwZS5SSV1dO1xuXG5mdW5jdGlvbiBpc0JvdW5kYXJ5UGFpcihsZWZ0LCByaWdodCkge1xuICByZXR1cm4gTm9uQm91bmRhcnlQYWlycy5maW5kSW5kZXgociA9PiBpbnRlcnNlY3RzKGxlZnQsIHJbMF0pICYmIGludGVyc2VjdHMocmlnaHQsIHJbMV0pKSA9PT0gLTE7XG59XG5cbnZhciBlbmRpbmdFbW9qaVpXSiA9IC8oPzpbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzODhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDVcXHUyNjA3LVxcdTI2MTJcXHUyNjE0LVxcdTI2ODVcXHUyNjkwLVxcdTI3MDVcXHUyNzA4LVxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzLVxcdTI3NjdcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDAtXFx1RENGRlxcdUREMEQtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREFELVxcdURERTVcXHVERTAxLVxcdURFMEZcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFM0MtXFx1REUzRlxcdURFNDktXFx1REZGQV18XFx1RDgzRFtcXHVEQzAwLVxcdUREM0RcXHVERDQ2LVxcdURFNEZcXHVERTgwLVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVEQ0ZGXFx1REQwQy1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERUZGXXxcXHVEODNGW1xcdURDMDAtXFx1REZGRF0pKD86W1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwN0ZEXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhEMy1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QkVcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxXFx1MEIzQ1xcdTBCM0VcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTUtXFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkVcXHUwQkMwXFx1MEJDRFxcdTBCRDdcXHUwQzAwXFx1MEMwNFxcdTBDM0UtXFx1MEM0MFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxXFx1MENCQ1xcdTBDQkZcXHUwQ0MyXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDBcXHUwRDAxXFx1MEQzQlxcdTBEM0NcXHUwRDNFXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODFcXHUwRENBXFx1MERDRlxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRERGXFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGNzEtXFx1MEY3RVxcdTBGODAtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNBXFx1MTAzRFxcdTEwM0VcXHUxMDU4XFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOERcXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODg1XFx1MTg4NlxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUMwXFx1MUIwMC1cXHUxQjAzXFx1MUIzNC1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGOVxcdTFERkItXFx1MURGRlxcdTIwMENcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyNVxcdUE4MjZcXHVBODJDXFx1QThDNFxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOEZGXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUxXFx1QTk4MC1cXHVBOTgyXFx1QTlCM1xcdUE5QjYtXFx1QTlCOVxcdUE5QkNcXHVBOUJEXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkY5RVxcdUZGOUZdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDNbXFx1REQyNC1cXHVERDI3XFx1REVBQlxcdURFQUNcXHVERjQ2LVxcdURGNTBdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDOS1cXHVERENDXFx1RERDRlxcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFM0VcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNCXFx1REYzQ1xcdURGM0VcXHVERjQwXFx1REY1N1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1REM1RVxcdURDQjBcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRFxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREFGXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA2W1xcdURDMkYtXFx1REMzN1xcdURDMzlcXHVEQzNBXFx1REQzMFxcdUREM0JcXHVERDNDXFx1REQzRVxcdURENDNcXHVEREQ0LVxcdURERDdcXHVERERBXFx1REREQlxcdURERTBcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzhcXHVERTNCLVxcdURFM0VcXHVERTQ3XFx1REU1MS1cXHVERTU2XFx1REU1OS1cXHVERTVCXFx1REU4QS1cXHVERTk2XFx1REU5OFxcdURFOTldfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZcXHVERDMxLVxcdUREMzZcXHVERDNBXFx1REQzQ1xcdUREM0RcXHVERDNGLVxcdURENDVcXHVERDQ3XFx1REQ5MFxcdUREOTFcXHVERDk1XFx1REQ5N1xcdURFRjNcXHVERUY0XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjRGXFx1REY4Ri1cXHVERjkyXFx1REZFNF18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1XFx1REQ2Ny1cXHVERDY5XFx1REQ2RS1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXFx1REQzMC1cXHVERDM2XFx1REVFQy1cXHVERUVGXXxcXHVEODNBW1xcdURDRDAtXFx1RENENlxcdURENDQtXFx1REQ0QV18XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdURCNDBbXFx1REMyMC1cXHVEQzdGXFx1REQwMC1cXHVEREVGXSkqXFx1MjAwRCQvO1xuXG52YXIgZW5kc1dpdGhFbW9qaVpXSiA9IHN0ciA9PiB7XG4gIHJldHVybiBzdHIuc2VhcmNoKGVuZGluZ0Vtb2ppWldKKSAhPT0gLTE7XG59O1xuXG52YXIgZW5kaW5nUklzID0gLyg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREZGXSkrJC9nO1xuXG52YXIgZW5kc1dpdGhPZGROdW1iZXJPZlJJcyA9IHN0ciA9PiB7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChlbmRpbmdSSXMpO1xuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBIFJJIGlzIHJlcHJlc2VudGVkIGJ5IGEgc3Vycm9nYXRlIHBhaXIuXG4gICAgdmFyIG51bVJJcyA9IG1hdGNoWzBdLmxlbmd0aCAvIDI7XG4gICAgcmV0dXJuIG51bVJJcyAlIDIgPT09IDE7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBTaGFyZWQgdGhlIGZ1bmN0aW9uIHdpdGggaXNFbGVtZW50VHlwZSB1dGlsaXR5XHJcbiAqL1xuXG52YXIgaXNFbGVtZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiAhRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXG52YXIgRWxlbWVudCA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSAnQW5jZXN0b3InIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNBbmNlc3Rvcih2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYEVsZW1lbnRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNFbGVtZW50LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gYXJyYXkgb2YgYEVsZW1lbnRgIG9iamVjdHMuXHJcbiAgICovXG4gIGlzRWxlbWVudExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsID0+IEVsZW1lbnQuaXNFbGVtZW50KHZhbCkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgc2V0IG9mIHByb3BzIGlzIGEgcGFydGlhbCBvZiBFbGVtZW50LlxyXG4gICAqL1xuICBpc0VsZW1lbnRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYEVsZW1lbnRgIGludGVyZmFjZSBhbmQgaGFzIGVsZW1lbnRLZXkgd2l0aCBzZWxlY3RlZCB2YWx1ZS5cclxuICAgKiBEZWZhdWx0IGl0IGNoZWNrIHRvIGB0eXBlYCBrZXkgdmFsdWVcclxuICAgKi9cbiAgaXNFbGVtZW50VHlwZTogZnVuY3Rpb24gaXNFbGVtZW50VHlwZSh2YWx1ZSwgZWxlbWVudFZhbCkge1xuICAgIHZhciBlbGVtZW50S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndHlwZSc7XG4gICAgcmV0dXJuIGlzRWxlbWVudCh2YWx1ZSkgJiYgdmFsdWVbZWxlbWVudEtleV0gPT09IGVsZW1lbnRWYWw7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gZWxlbWVudCBtYXRjaGVzIHNldCBvZiBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogTm90ZTogdGhpcyBjaGVja3MgY3VzdG9tIHByb3BlcnRpZXMsIGFuZCBpdCBkb2VzIG5vdCBlbnN1cmUgdGhhdCBhbnlcclxuICAgKiBjaGlsZHJlbiBhcmUgZXF1aXZhbGVudC5cclxuICAgKi9cbiAgbWF0Y2hlcyhlbGVtZW50LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufTtcblxudmFyIF9leGNsdWRlZCQ0ID0gW1widGV4dFwiXSxcbiAgICBfZXhjbHVkZWQyJDMgPSBbXCJ0ZXh0XCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDgob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDgodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ4KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkOChPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBJU19FRElUT1JfQ0FDSEUgPSBuZXcgV2Vha01hcCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBFZGl0b3IgPSB7XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgYW5jZXN0b3IgYWJvdmUgYSBsb2NhdGlvbiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIGFib3ZlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcbiAgICB2YXIgcmV2ZXJzZSA9IG1vZGUgPT09ICdsb3dlc3QnO1xuXG4gICAgZm9yICh2YXIgW24sIHBdIG9mIEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIHZvaWRzLFxuICAgICAgbWF0Y2gsXG4gICAgICByZXZlcnNlXG4gICAgfSkpIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSkgY29udGludWU7XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGF0LmFuY2hvci5wYXRoKSAmJiBQYXRoLmlzQW5jZXN0b3IocCwgYXQuZm9jdXMucGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKHBhdGgsIHApKSB7XG4gICAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBBZGQgYSBjdXN0b20gcHJvcGVydHkgdG8gdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQsIHRoZSBtYXJrcyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxyXG4gICAqIGBlZGl0b3IubWFya3NgIHByb3BlcnR5IGluc3RlYWQsIGFuZCBhcHBsaWVkIHdoZW4gdGV4dCBpcyBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICBhZGRNYXJrKGVkaXRvciwga2V5LCB2YWx1ZSkge1xuICAgIGVkaXRvci5hZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYWZ0ZXIgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgYWZ0ZXIoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgYW5jaG9yID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KSkpIHtcbiAgICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIHRhcmdldCA9IHA7XG4gICAgICB9XG5cbiAgICAgIGQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYmVmb3JlIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGJlZm9yZShlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBhbmNob3IgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSkpKSB7XG4gICAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgfVxuXG4gICAgICBkKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGJhY2t3YXJkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVCYWNrd2FyZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGZvcndhcmQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlbGV0ZUZvcndhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICBlZGl0b3IuZGVsZXRlRm9yd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgdGhlIGNvbnRlbnQgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVGcmFnbWVudChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudChkaXJlY3Rpb24pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBbRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpLCBFZGl0b3IuZW5kKGVkaXRvciwgYXQpXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ2VuZCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGZpcnN0IG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICAgIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZnJhZ21lbnQgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZnJhZ21lbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB2YXIgZnJhZ21lbnQgPSBOb2RlLmZyYWdtZW50KGVkaXRvciwgcmFuZ2UpO1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgaGFzIGJsb2NrIGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNCbG9ja3MoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBoYXMgaW5saW5lIGFuZCB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5ldmVyeShuID0+IFRleHQuaXNUZXh0KG4pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBibG9jayBicmVhayBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBzb2Z0IGJyZWFrIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFNvZnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgbm9kZSBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnROb2RlKGVkaXRvciwgbm9kZSkge1xuICAgIGVkaXRvci5pbnNlcnROb2RlKG5vZGUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGJsb2NrIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiAhZWRpdG9yLmlzSW5saW5lKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGBFZGl0b3JgIG9iamVjdC5cclxuICAgKi9cbiAgaXNFZGl0b3IodmFsdWUpIHtcbiAgICB2YXIgY2FjaGVkSXNFZGl0b3IgPSBJU19FRElUT1JfQ0FDSEUuZ2V0KHZhbHVlKTtcblxuICAgIGlmIChjYWNoZWRJc0VkaXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkSXNFZGl0b3I7XG4gICAgfVxuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpc0VkaXRvciA9IHR5cGVvZiB2YWx1ZS5hZGRNYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5hcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlQmFja3dhcmQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUZvcndhcmQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUZyYWdtZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0U29mdEJyZWFrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0VGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNJbmxpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzVm9pZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUubm9ybWFsaXplTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUub25DaGFuZ2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnJlbW92ZU1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmdldERpcnR5UGF0aHMgPT09ICdmdW5jdGlvbicgJiYgKHZhbHVlLm1hcmtzID09PSBudWxsIHx8IGlzUGxhaW5PYmplY3QodmFsdWUubWFya3MpKSAmJiAodmFsdWUuc2VsZWN0aW9uID09PSBudWxsIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUuc2VsZWN0aW9uKSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiBPcGVyYXRpb24uaXNPcGVyYXRpb25MaXN0KHZhbHVlLm9wZXJhdGlvbnMpO1xuICAgIElTX0VESVRPUl9DQUNIRS5zZXQodmFsdWUsIGlzRWRpdG9yKTtcbiAgICByZXR1cm4gaXNFZGl0b3I7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyB0aGUgZW5kIHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgZW5kKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGFuIGVkZ2Ugb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgaXNFZGdlKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgcG9pbnQsIGF0KSB8fCBFZGl0b3IuaXNFbmQoZWRpdG9yLCBwb2ludCwgYXQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgZW1wdHksIGFjY291bnRpbmcgZm9yIHZvaWQgbm9kZXMuXHJcbiAgICovXG4gIGlzRW1wdHkoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgdmFyIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgdmFyIFtmaXJzdF0gPSBjaGlsZHJlbjtcbiAgICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBUZXh0LmlzVGV4dChmaXJzdCkgJiYgZmlyc3QudGV4dCA9PT0gJycgJiYgIWVkaXRvci5pc1ZvaWQoZWxlbWVudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpbmxpbmUgYEVsZW1lbnRgIG9iamVjdC5cclxuICAgKi9cbiAgaXNJbmxpbmUoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgY3VycmVudGx5IG5vcm1hbGl6aW5nIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxyXG4gICAqL1xuICBpc05vcm1hbGl6aW5nKGVkaXRvcikge1xuICAgIHZhciBpc05vcm1hbGl6aW5nID0gTk9STUFMSVpJTkcuZ2V0KGVkaXRvcik7XG4gICAgcmV0dXJuIGlzTm9ybWFsaXppbmcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpc05vcm1hbGl6aW5nO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgdGhlIHN0YXJ0IHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICAvLyBQRVJGOiBJZiB0aGUgb2Zmc2V0IGlzbid0IGAwYCB3ZSBrbm93IGl0J3Mgbm90IHRoZSBzdGFydC5cbiAgICBpZiAocG9pbnQub2Zmc2V0ICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIHN0YXJ0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgdm9pZCBgRWxlbWVudGAgb2JqZWN0LlxyXG4gICAqL1xuICBpc1ZvaWQoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNWb2lkKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxhc3Qgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsYXN0KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsZWFmIHRleHQgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsZWFmKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIHBhdGgpO1xuICAgIHJldHVybiBbbm9kZSwgcGF0aF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgbGV2ZWxzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gICpsZXZlbHMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcblxuICAgIGZvciAodmFyIFtuLCBwXSBvZiBOb2RlLmxldmVscyhlZGl0b3IsIHBhdGgpKSB7XG4gICAgICBpZiAoIW1hdGNoKG4sIHApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXZlbHMucHVzaChbbiwgcF0pO1xuXG4gICAgICBpZiAoIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGV2ZWxzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB5aWVsZCogbGV2ZWxzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWFya3MgdGhhdCB3b3VsZCBiZSBhZGRlZCB0byB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgbWFya3MoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIG1hcmtzLFxuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobWFya3MpIHtcbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgW21hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBbX25vZGVdID0gbWF0Y2g7XG5cbiAgICAgICAgdmFyIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlLCBfZXhjbHVkZWQkNCk7XG5cbiAgICAgICAgcmV0dXJuIF9yZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIHZhciB7XG4gICAgICBwYXRoXG4gICAgfSA9IGFuY2hvcjtcbiAgICB2YXIgW25vZGVdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKTtcblxuICAgIGlmIChhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgICAgfSk7XG4gICAgICB2YXIgbWFya2VkVm9pZCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pICYmIGVkaXRvci5tYXJrYWJsZVZvaWQobilcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW1hcmtlZFZvaWQpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByZXYgJiYgYmxvY2spIHtcbiAgICAgICAgICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2O1xuICAgICAgICAgIHZhciBbLCBibG9ja1BhdGhdID0gYmxvY2s7XG5cbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKGJsb2NrUGF0aCwgcHJldlBhdGgpKSB7XG4gICAgICAgICAgICBub2RlID0gcHJldk5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMiQzKTtcblxuICAgIHJldHVybiByZXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgYnJhbmNoIG9mIHRoZSBkb2N1bWVudCBhZnRlciBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBuZXh0KGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludEFmdGVyTG9jYXRpb24gPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwge1xuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICBpZiAoIXBvaW50QWZ0ZXJMb2NhdGlvbikgcmV0dXJuO1xuICAgIHZhciBbLCB0b10gPSBFZGl0b3IubGFzdChlZGl0b3IsIFtdKTtcbiAgICB2YXIgc3BhbiA9IFtwb2ludEFmdGVyTG9jYXRpb24ucGF0aCwgdG9dO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIG5leHQgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgW25leHRdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBub2RlKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBub2RlcyBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICAqbm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2FsbCcsXG4gICAgICB1bml2ZXJzYWwgPSBmYWxzZSxcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuXG4gICAgaWYgKFNwYW4uaXNTcGFuKGF0KSkge1xuICAgICAgZnJvbSA9IGF0WzBdO1xuICAgICAgdG8gPSBhdFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnZW5kJ1xuICAgICAgfSk7XG4gICAgICBmcm9tID0gcmV2ZXJzZSA/IGxhc3QgOiBmaXJzdDtcbiAgICAgIHRvID0gcmV2ZXJzZSA/IGZpcnN0IDogbGFzdDtcbiAgICB9XG5cbiAgICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgICB2YXIgW25dID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIHZvaWRzID8gZmFsc2UgOiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgaGl0O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIG5vZGVFbnRyaWVzKSB7XG4gICAgICB2YXIgaXNMb3dlciA9IGhpdCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgaGl0WzFdKSA9PT0gMDsgLy8gSW4gaGlnaGVzdCBtb2RlIGFueSBub2RlIGxvd2VyIHRoYW4gdGhlIGxhc3QgaGl0IGlzIG5vdCBhIG1hdGNoLlxuXG4gICAgICBpZiAobW9kZSA9PT0gJ2hpZ2hlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbWF0Y2gobm9kZSwgcGF0aCkpIHtcbiAgICAgICAgLy8gSWYgd2UndmUgYXJyaXZlZCBhdCBhIGxlYWYgdGV4dCBub2RlIHRoYXQgaXMgbm90IGxvd2VyIHRoYW4gdGhlIGxhc3RcbiAgICAgICAgLy8gaGl0LCB0aGVuIHdlJ3ZlIGZvdW5kIGEgYnJhbmNoIHRoYXQgZG9lc24ndCBpbmNsdWRlIGEgbWF0Y2gsIHdoaWNoXG4gICAgICAgIC8vIG1lYW5zIHRoZSBtYXRjaCBpcyBub3QgdW5pdmVyc2FsLlxuICAgICAgICBpZiAodW5pdmVyc2FsICYmICFpc0xvd2VyICYmIFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIElmIHRoZXJlJ3MgYSBtYXRjaCBhbmQgaXQncyBsb3dlciB0aGFuIHRoZSBsYXN0LCB1cGRhdGUgdGhlIGhpdC5cblxuXG4gICAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJbiBsb3dlc3QgbW9kZSB3ZSBlbWl0IHRoZSBsYXN0IGhpdCwgb25jZSBpdCdzIGd1YXJhbnRlZWQgbG93ZXN0LlxuXG5cbiAgICAgIHZhciBlbWl0ID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyBoaXQgOiBbbm9kZSwgcGF0aF07XG5cbiAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZW1pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgZW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgfSAvLyBTaW5jZSBsb3dlc3QgaXMgYWx3YXlzIGVtaXR0aW5nIG9uZSBiZWhpbmQsIGNhdGNoIHVwIGF0IHRoZSBlbmQuXG5cblxuICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBoaXQpIHtcbiAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGhpdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBoaXQ7XG4gICAgICB9XG4gICAgfSAvLyBVbml2ZXJzYWwgZGVmZXJzIHRvIGVuc3VyZSB0aGF0IHRoZSBtYXRjaCBvY2N1cnMgaW4gZXZlcnkgYnJhbmNoLCBzbyB3ZVxuICAgIC8vIHlpZWxkIGFsbCBvZiB0aGUgbWF0Y2hlcyBhZnRlciBpdGVyYXRpbmcuXG5cblxuICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgIHlpZWxkKiBtYXRjaGVzO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBOb3JtYWxpemUgYW55IGRpcnR5IG9iamVjdHMgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgbm9ybWFsaXplKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZm9yY2UgPSBmYWxzZSxcbiAgICAgIG9wZXJhdGlvblxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgdmFyIGdldERpcnR5UGF0aHMgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RGlydHlQYXRoS2V5cyA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgICB9O1xuXG4gICAgdmFyIHBvcERpcnR5UGF0aCA9IGVkaXRvciA9PiB7XG4gICAgICB2YXIgcGF0aCA9IGdldERpcnR5UGF0aHMoZWRpdG9yKS5wb3AoKTtcbiAgICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcbiAgICAgIGdldERpcnR5UGF0aEtleXMoZWRpdG9yKS5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cbiAgICBpZiAoIUVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIHZhciBhbGxQYXRocyA9IEFycmF5LmZyb20oTm9kZS5ub2RlcyhlZGl0b3IpLCBfcmVmMiA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFsbFBhdGhLZXlzID0gbmV3IFNldChhbGxQYXRocy5tYXAocCA9PiBwLmpvaW4oJywnKSkpO1xuICAgICAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgYWxsUGF0aHMpO1xuICAgICAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGFsbFBhdGhLZXlzKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAvKlxyXG4gICAgICAgIEZpeCBkaXJ0eSBlbGVtZW50cyB3aXRoIG5vIGNoaWxkcmVuLlxyXG4gICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKCkgZG9lcyBmaXggdGhpcywgYnV0IHNvbWUgbm9ybWFsaXphdGlvbiBmaXhlcyBhbHNvIHJlcXVpcmUgaXQgdG8gd29yay5cclxuICAgICAgICBSdW5uaW5nIGFuIGluaXRpYWwgcGFzcyBhdm9pZHMgdGhlIGNhdGNoLTIyIHJhY2UgY29uZGl0aW9uLlxyXG4gICAgICAqL1xuICAgICAgZm9yICh2YXIgZGlydHlQYXRoIG9mIGdldERpcnR5UGF0aHMoZWRpdG9yKSkge1xuICAgICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBkaXJ0eVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBkaXJ0eVBhdGgpO1xuICAgICAgICAgIHZhciBbbm9kZSwgX10gPSBlbnRyeTtcbiAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBUaGUgZGVmYXVsdCBub3JtYWxpemVyIGluc2VydHMgYW4gZW1wdHkgdGV4dCBub2RlIGluIHRoaXMgc2NlbmFyaW8sIGJ1dCBpdCBjYW4gYmUgY3VzdG9taXNlZC5cclxuICAgICAgICAgICAgU28gdGhlcmUgaXMgc29tZSByaXNrIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgQXMgbG9uZyBhcyB0aGUgbm9ybWFsaXplciBvbmx5IGluc2VydHMgY2hpbGQgbm9kZXMgZm9yIHRoaXMgY2FzZSBpdCBpcyBzYWZlIHRvIGRvIGluIGFueSBvcmRlcjtcclxuICAgICAgICAgICAgYnkgZGVmaW5pdGlvbiBhZGRpbmcgY2hpbGRyZW4gdG8gYW4gZW1wdHkgbm9kZSBjYW4ndCBjYXVzZSBvdGhlciBwYXRocyB0byBjaGFuZ2UuXHJcbiAgICAgICAgICAqL1xuXG4gICAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShlbnRyeSwge1xuICAgICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICAgIHZhciBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCA9IGRpcnR5UGF0aHMubGVuZ3RoO1xuICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG5cbiAgICAgIHdoaWxlIChkaXJ0eVBhdGhzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBpZiAoIWVkaXRvci5zaG91bGROb3JtYWxpemUoe1xuICAgICAgICAgIGRpcnR5UGF0aHMsXG4gICAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICAgIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoLFxuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZGlydHlQYXRoID0gcG9wRGlydHlQYXRoKGVkaXRvcik7IC8vIElmIHRoZSBub2RlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHRyZWUsIGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgbm9ybWFsaXplZC5cblxuXG4gICAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIF9kaXJ0eVBhdGgpKSB7XG4gICAgICAgICAgdmFyIF9lbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgX2RpcnR5UGF0aCk7XG5cbiAgICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShfZW50cnksIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlcmF0aW9uKys7XG4gICAgICAgIGRpcnR5UGF0aHMgPSBnZXREaXJ0eVBhdGhzKGVkaXRvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXJlbnQgbm9kZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBwYXJlbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXJlbnRQYXRoKTtcbiAgICByZXR1cm4gZW50cnk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXRoIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBhdGgoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZGVwdGgsXG4gICAgICBlZGdlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIGF0ID0gZmlyc3RQYXRoO1xuICAgICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpO1xuICAgICAgICBhdCA9IGxhc3RQYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgICAgYXQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIGF0ID0gUmFuZ2UuZW5kKGF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0ID0gUGF0aC5jb21tb24oYXQuYW5jaG9yLnBhdGgsIGF0LmZvY3VzLnBhdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgYXQgPSBhdC5wYXRoO1xuICAgIH1cblxuICAgIGlmIChkZXB0aCAhPSBudWxsKSB7XG4gICAgICBhdCA9IGF0LnNsaWNlKDAsIGRlcHRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG5cbiAgaGFzUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgICByZXR1cm4gTm9kZS5oYXMoZWRpdG9yLCBwYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUGF0aGAgb2JqZWN0LCB3aGljaCB3aWxsIHN0YXkgaW4gc3luYyBhcyBuZXdcclxuICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBhdGhSZWYoZWRpdG9yLCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBwYXRoLFxuICAgICAgYWZmaW5pdHksXG5cbiAgICAgIHVucmVmKCkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgfSA9IHJlZjtcbiAgICAgICAgdmFyIHBhdGhSZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgICAgIHBhdGhSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuXG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwYXRoIHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcGF0aFJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBQQVRIX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBQQVRIX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBvciBlbmQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcG9pbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZWRnZSA9ICdzdGFydCdcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBwYXRoO1xuXG4gICAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdChlZGl0b3IsIGF0KTtcbiAgICAgICAgcGF0aCA9IGxhc3RQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KGVkaXRvciwgYXQpO1xuICAgICAgICBwYXRoID0gZmlyc3RQYXRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgXCIuY29uY2F0KGVkZ2UsIFwiIHBvaW50IGluIHRoZSBub2RlIGF0IHBhdGggW1wiKS5jb25jYXQoYXQsIFwiXSBiZWNhdXNlIGl0IGhhcyBubyBcIikuY29uY2F0KGVkZ2UsIFwiIHRleHQgbm9kZS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQ6IGVkZ2UgPT09ICdlbmQnID8gbm9kZS50ZXh0Lmxlbmd0aCA6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgcmV0dXJuIGVkZ2UgPT09ICdzdGFydCcgPyBzdGFydCA6IGVuZDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSByZWYgZm9yIGEgYFBvaW50YCBvYmplY3QsIHdoaWNoIHdpbGwgc3RheSBpbiBzeW5jIGFzIG5ld1xyXG4gICAqIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcG9pbnRSZWYoZWRpdG9yLCBwb2ludCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogcG9pbnQsXG4gICAgICBhZmZpbml0eSxcblxuICAgICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgY3VycmVudFxuICAgICAgICB9ID0gcmVmO1xuICAgICAgICB2YXIgcG9pbnRSZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgICAgICBwb2ludFJlZnMuZGVsZXRlKHJlZik7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHZhciByZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwb2ludCByZWZzIG9mIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBvaW50UmVmcyhlZGl0b3IpIHtcbiAgICB2YXIgcmVmcyA9IFBPSU5UX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBQT0lOVF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbGwgdGhlIHBvc2l0aW9ucyBpbiBgYXRgIHJhbmdlIHdoZXJlIGEgYFBvaW50YCBjYW4gYmUgcGxhY2VkLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCwgbW92ZXMgZm9yd2FyZCBieSBpbmRpdmlkdWFsIG9mZnNldHMgYXQgYSB0aW1lLCBidXRcclxuICAgKiB0aGUgYHVuaXRgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byB0byBtb3ZlIGJ5IGNoYXJhY3Rlciwgd29yZCwgbGluZSwgb3IgYmxvY2suXHJcbiAgICpcclxuICAgKiBUaGUgYHJldmVyc2VgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgaXRlcmF0aW9uIGRpcmVjdGlvbi5cclxuICAgKlxyXG4gICAqIE5vdGU6IEJ5IGRlZmF1bHQgdm9pZCBub2RlcyBhcmUgdHJlYXRlZCBhcyBhIHNpbmdsZSBwb2ludCBhbmQgaXRlcmF0aW9uXHJcbiAgICogd2lsbCBub3QgaGFwcGVuIGluc2lkZSB0aGVpciBjb250ZW50IHVubGVzcyB5b3UgcGFzcyBpbiB0cnVlIGZvciB0aGVcclxuICAgKiBgdm9pZHNgIG9wdGlvbiwgdGhlbiBpdGVyYXRpb24gd2lsbCBvY2N1ci5cclxuICAgKi9cbiAgKnBvc2l0aW9ucyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIHVuaXQgPSAnb2Zmc2V0JyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBBbGdvcml0aG0gbm90ZXM6XHJcbiAgICAgKlxyXG4gICAgICogRWFjaCBzdGVwIGBkaXN0YW5jZWAgaXMgZHluYW1pYyBkZXBlbmRpbmcgb24gdGhlIHVuZGVybHlpbmcgdGV4dFxyXG4gICAgICogYW5kIHRoZSBgdW5pdGAgc3BlY2lmaWVkLiAgRWFjaCBzdGVwLCBlLmcuLCBhIGxpbmUgb3Igd29yZCwgbWF5XHJcbiAgICAgKiBzcGFuIG11bHRpcGxlIHRleHQgbm9kZXMsIHNvIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgdGV4dCBib3RoIG9uXHJcbiAgICAgKiB0d28gbGV2ZWxzIGluIHN0ZXAtc3luYzpcclxuICAgICAqXHJcbiAgICAgKiBgbGVhZlRleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIHRleHQgbGVhZiBsZXZlbCwgYW5kIGlzIGFkdmFuY2VkXHJcbiAgICAgKiB0aHJvdWdoIHVzaW5nIHRoZSBjb3VudGVycyBgbGVhZlRleHRPZmZzZXRgIGFuZCBgbGVhZlRleHRSZW1haW5pbmdgLlxyXG4gICAgICpcclxuICAgICAqIGBibG9ja1RleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIGJsb2NrIGxldmVsLCBhbmQgaXMgc2hvcnRlbmVkXHJcbiAgICAgKiBieSBgZGlzdGFuY2VgIGV2ZXJ5IHRpbWUgaXQgaXMgYWR2YW5jZWQuXHJcbiAgICAgKlxyXG4gICAgICogV2Ugb25seSBtYWludGFpbiBhIHdpbmRvdyBvZiBvbmUgYmxvY2tUZXh0IGFuZCBvbmUgbGVhZlRleHQgYmVjYXVzZVxyXG4gICAgICogYSBibG9jayBub2RlIGFsd2F5cyBhcHBlYXJzIGJlZm9yZSBhbGwgb2YgaXRzIGxlYWYgbm9kZXMuXHJcbiAgICAgKi9cblxuXG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIGZpcnN0ID0gcmV2ZXJzZSA/IGVuZCA6IHN0YXJ0O1xuICAgIHZhciBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgdmFyIGJsb2NrVGV4dCA9ICcnO1xuICAgIHZhciBkaXN0YW5jZSA9IDA7IC8vIERpc3RhbmNlIGZvciBsZWFmVGV4dCB0byBjYXRjaCB1cCB0byBibG9ja1RleHQuXG5cbiAgICB2YXIgbGVhZlRleHRSZW1haW5pbmcgPSAwO1xuICAgIHZhciBsZWFmVGV4dE9mZnNldCA9IDA7IC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgbm9kZXMgaW4gcmFuZ2UsIGdyYWJiaW5nIGVudGlyZSB0ZXh0dWFsIGNvbnRlbnRcbiAgICAvLyBvZiBibG9jayBub2RlcyBpbiBibG9ja1RleHQsIGFuZCB0ZXh0IG5vZGVzIGluIGxlYWZUZXh0LlxuICAgIC8vIEV4cGxvaXRzIHRoZSBmYWN0IHRoYXQgbm9kZXMgYXJlIHNlcXVlbmNlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgZmlyc3RcbiAgICAvLyBlbmNvdW50ZXIgdGhlIGJsb2NrIG5vZGUsIHRoZW4gYWxsIG9mIGl0cyB0ZXh0IG5vZGVzLCBzbyB3aGVuIGl0ZXJhdGluZ1xuICAgIC8vIHRocm91Z2ggdGhlIGJsb2NrVGV4dCBhbmQgbGVhZlRleHQgd2UganVzdCBuZWVkIHRvIHJlbWVtYmVyIGEgd2luZG93IG9mXG4gICAgLy8gb25lIGJsb2NrIG5vZGUgYW5kIGxlYWYgbm9kZSwgcmVzcGVjdGl2ZWx5LlxuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIC8qXHJcbiAgICAgICAqIEVMRU1FTlQgTk9ERSAtIFlpZWxkIHBvc2l0aW9uKHMpIGZvciB2b2lkcywgY29sbGVjdCBibG9ja1RleHQgZm9yIGJsb2Nrc1xyXG4gICAgICAgKi9cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICAvLyBWb2lkIG5vZGVzIGFyZSBhIHNwZWNpYWwgY2FzZSwgc28gYnkgZGVmYXVsdCB3ZSB3aWxsIGFsd2F5c1xuICAgICAgICAvLyB5aWVsZCB0aGVpciBmaXJzdCBwb2ludC4gSWYgdGhlIGB2b2lkc2Agb3B0aW9uIGlzIHNldCB0byB0cnVlLFxuICAgICAgICAvLyB0aGVuIHdlIHdpbGwgaXRlcmF0ZSBvdmVyIHRoZWlyIGNvbnRlbnQuXG4gICAgICAgIGlmICghdm9pZHMgJiYgZWRpdG9yLmlzVm9pZChub2RlKSkge1xuICAgICAgICAgIHlpZWxkIEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIElubGluZSBlbGVtZW50IG5vZGVzIGFyZSBpZ25vcmVkIGFzIHRoZXkgZG9uJ3QgdGhlbXNlbHZlc1xuICAgICAgICAvLyBjb250cmlidXRlIHRvIGBibG9ja1RleHRgIG9yIGBsZWFmVGV4dGAgLSB0aGVpciBwYXJlbnQgYW5kXG4gICAgICAgIC8vIGNoaWxkcmVuIGRvLlxuXG5cbiAgICAgICAgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkgY29udGludWU7IC8vIEJsb2NrIGVsZW1lbnQgbm9kZSAtIHNldCBgYmxvY2tUZXh0YCB0byBpdHMgdGV4dCBjb250ZW50LlxuXG4gICAgICAgIGlmIChFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgLy8gV2UgYWx3YXlzIGV4aGF1c3QgYmxvY2sgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLFxuICAgICAgICAgIC8vICAgICBgYmxvY2tUZXh0PScke2Jsb2NrVGV4dH0nIC0gYCtcbiAgICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBibG9jayBub2RlYCwgcGF0aClcbiAgICAgICAgICAvLyBFbnN1cmUgcmFuZ2UgY29uc2lkZXJlZCBpcyBjYXBwZWQgdG8gYHJhbmdlYCwgaW4gdGhlXG4gICAgICAgICAgLy8gc3RhcnQvZW5kIGVkZ2UgY2FzZXMgd2hlcmUgYmxvY2sgZXh0ZW5kcyBiZXlvbmQgcmFuZ2UuXG4gICAgICAgICAgLy8gRXF1aXZhbGVudCB0byB0aGlzLCBidXQgcHJlc3VtYWJseSBtb3JlIHBlcmZvcm1hbnQ6XG4gICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgLi4uRWRpdG9yLmVkZ2VzKGVkaXRvciwgcGF0aCkpXG4gICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBibG9ja1JhbmdlKSAvLyBpbnRlcnNlY3RcbiAgICAgICAgICAvLyAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBibG9ja1JhbmdlLCB7IHZvaWRzIH0pXG4gICAgICAgICAgdmFyIGUgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgZW5kLnBhdGgpID8gZW5kIDogRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIHZhciBzID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIHN0YXJ0LnBhdGgpID8gc3RhcnQgOiBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICBibG9ja1RleHQgPSBFZGl0b3Iuc3RyaW5nKGVkaXRvciwge1xuICAgICAgICAgICAgYW5jaG9yOiBzLFxuICAgICAgICAgICAgZm9jdXM6IGVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlzTmV3QmxvY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKlxyXG4gICAgICAgKiBURVhUIExFQUYgTk9ERSAtIEl0ZXJhdGUgdGhyb3VnaCB0ZXh0IGNvbnRlbnQsIHlpZWxkaW5nXHJcbiAgICAgICAqIHBvc2l0aW9ucyBldmVyeSBgZGlzdGFuY2VgIG9mZnNldCBhY2NvcmRpbmcgdG8gYHVuaXRgLlxyXG4gICAgICAgKi9cblxuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgdmFyIGlzRmlyc3QgPSBQYXRoLmVxdWFscyhwYXRoLCBmaXJzdC5wYXRoKTsgLy8gUHJvb2YgdGhhdCB3ZSBhbHdheXMgZXhoYXVzdCB0ZXh0IG5vZGVzIGJlZm9yZSBlbmNvdW50ZXJpbmcgYSBuZXcgb25lOlxuICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsXG4gICAgICAgIC8vICAgICBgbGVhZlRleHRSZW1haW5pbmc9JHtsZWFmVGV4dFJlbWFpbmluZ30gLSBgK1xuICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBsZWFmIHRleHQgbm9kZWAsIHBhdGgpXG4gICAgICAgIC8vIFJlc2V0IGBsZWFmVGV4dGAgY291bnRlcnMgZm9yIG5ldyB0ZXh0IG5vZGUuXG5cbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IHJldmVyc2UgPyBmaXJzdC5vZmZzZXQgOiBub2RlLnRleHQubGVuZ3RoIC0gZmlyc3Qub2Zmc2V0O1xuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gZmlyc3Qub2Zmc2V0OyAvLyBXb3JrcyBmb3IgcmV2ZXJzZSB0b28uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSBub2RlLnRleHQubGVuZ3RoO1xuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0UmVtYWluaW5nIDogMDtcbiAgICAgICAgfSAvLyBZaWVsZCBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2Ygbm9kZSAocG90ZW50aWFsbHkpLlxuXG5cbiAgICAgICAgaWYgKGlzRmlyc3QgfHwgaXNOZXdCbG9jayB8fCB1bml0ID09PSAnb2Zmc2V0Jykge1xuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgICAgIH0gLy8gWWllbGQgcG9zaXRpb25zIGV2ZXJ5IChkeW5hbWljYWxseSBjYWxjdWxhdGVkKSBgZGlzdGFuY2VgIG9mZnNldC5cblxuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgLy8gSWYgYGxlYWZUZXh0YCBoYXMgY2F1Z2h0IHVwIHdpdGggYGJsb2NrVGV4dGAgKGRpc3RhbmNlPTApLFxuICAgICAgICAgIC8vIGFuZCBpZiBibG9ja1RleHQgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYW5vdGhlciBibG9jayBub2RlLFxuICAgICAgICAgIC8vIG90aGVyd2lzZSBhZHZhbmNlIGJsb2NrVGV4dCBmb3J3YXJkIGJ5IHRoZSBuZXcgYGRpc3RhbmNlYC5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChibG9ja1RleHQgPT09ICcnKSBicmVhaztcbiAgICAgICAgICAgIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKGJsb2NrVGV4dCwgdW5pdCwgcmV2ZXJzZSk7IC8vIFNwbGl0IHRoZSBzdHJpbmcgYXQgdGhlIHByZXZpb3VzbHkgZm91bmQgZGlzdGFuY2UgYW5kIHVzZSB0aGVcbiAgICAgICAgICAgIC8vIHJlbWFpbmluZyBzdHJpbmcgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cblxuICAgICAgICAgICAgYmxvY2tUZXh0ID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKGJsb2NrVGV4dCwgZGlzdGFuY2UsIHJldmVyc2UpWzFdO1xuICAgICAgICAgIH0gLy8gQWR2YW5jZSBgbGVhZlRleHRgIGJ5IHRoZSBjdXJyZW50IGBkaXN0YW5jZWAuXG5cblxuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0T2Zmc2V0IC0gZGlzdGFuY2UgOiBsZWFmVGV4dE9mZnNldCArIGRpc3RhbmNlO1xuICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbGVhZlRleHRSZW1haW5pbmcgLSBkaXN0YW5jZTsgLy8gSWYgYGxlYWZUZXh0YCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhIG5ldyBsZWFmIG5vZGVcbiAgICAgICAgICAvLyBhbmQgc2V0IGRpc3RhbmNlIHRvIHRoZSBvdmVyZmxvdyBhbW91bnQsIHNvIHdlJ2xsIChtYXliZSlcbiAgICAgICAgICAvLyBjYXRjaCB1cCB0byBibG9ja1RleHQgaW4gdGhlIG5leHQgbGVhZiB0ZXh0IG5vZGUuXG5cbiAgICAgICAgICBpZiAobGVhZlRleHRSZW1haW5pbmcgPCAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IC1sZWFmVGV4dFJlbWFpbmluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gLy8gU3VjY2Vzc2Z1bGx5IHdhbGtlZCBgZGlzdGFuY2VgIG9mZnNldHMgdGhyb3VnaCBgbGVhZlRleHRgXG4gICAgICAgICAgLy8gdG8gY2F0Y2ggdXAgd2l0aCBgYmxvY2tUZXh0YCwgc28gd2UgY2FuIHJlc2V0IGBkaXN0YW5jZWBcbiAgICAgICAgICAvLyBhbmQgeWllbGQgdGhpcyBwb3NpdGlvbiBpbiB0aGlzIG5vZGUuXG5cblxuICAgICAgICAgIGRpc3RhbmNlID0gMDtcbiAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiBsZWFmVGV4dE9mZnNldFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFByb29mIHRoYXQgdXBvbiBjb21wbGV0aW9uLCB3ZSd2ZSBleGFodXN0ZWQgYm90aCBsZWFmIGFuZCBibG9jayB0ZXh0OlxuICAgIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCwgXCJsZWFmVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLCBcImJsb2NrVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gICAgLy8gSGVscGVyOlxuICAgIC8vIFJldHVybiB0aGUgZGlzdGFuY2UgaW4gb2Zmc2V0cyBmb3IgYSBzdGVwIG9mIHNpemUgYHVuaXRgIG9uIGdpdmVuIHN0cmluZy5cblxuXG4gICAgZnVuY3Rpb24gY2FsY0Rpc3RhbmNlKHRleHQsIHVuaXQsIHJldmVyc2UpIHtcbiAgICAgIGlmICh1bml0ID09PSAnY2hhcmFjdGVyJykge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICd3b3JkJykge1xuICAgICAgICByZXR1cm4gZ2V0V29yZERpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnbGluZScgfHwgdW5pdCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG1hdGNoaW5nIG5vZGUgaW4gdGhlIGJyYW5jaCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHByZXZpb3VzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludEJlZm9yZUxvY2F0aW9uID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGF0LCB7XG4gICAgICB2b2lkc1xuICAgIH0pO1xuXG4gICAgaWYgKCFwb2ludEJlZm9yZUxvY2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIFssIHRvXSA9IEVkaXRvci5maXJzdChlZGl0b3IsIFtdKTsgLy8gVGhlIHNlYXJjaCBsb2NhdGlvbiBpcyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgdG8gdGhlIHBhdGggb2ZcbiAgICAvLyB0aGUgcG9pbnQgYmVmb3JlIHRoZSBsb2NhdGlvbiBwYXNzZWQgaW5cblxuICAgIHZhciBzcGFuID0gW3BvaW50QmVmb3JlTG9jYXRpb24ucGF0aCwgdG9dO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuXG4gICAgICAgIG1hdGNoID0gbiA9PiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFtwcmV2aW91c10gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgYSByYW5nZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICByYW5nZShlZGl0b3IsIGF0LCB0bykge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiAhdG8pIHtcbiAgICAgIHJldHVybiBhdDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCB0byB8fCBhdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUmFuZ2VgIG9iamVjdCwgd2hpY2ggd2lsbCBzdGF5IGluIHN5bmMgYXMgbmV3XHJcbiAgICogb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICByYW5nZVJlZihlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiByYW5nZSxcbiAgICAgIGFmZmluaXR5LFxuXG4gICAgICB1bnJlZigpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBjdXJyZW50XG4gICAgICAgIH0gPSByZWY7XG4gICAgICAgIHZhciByYW5nZVJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgICAgIHJhbmdlUmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cblxuICAgIH07XG4gICAgdmFyIHJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgcmVmcy5hZGQocmVmKTtcbiAgICByZXR1cm4gcmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSB0cmFja2VkIHJhbmdlIHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcmFuZ2VSZWZzKGVkaXRvcikge1xuICAgIHZhciByZWZzID0gUkFOR0VfUkVGUy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcmVmcykge1xuICAgICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgIFJBTkdFX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgY3VzdG9tIHByb3BlcnR5IGZyb20gYWxsIG9mIHRoZSBsZWFmIHRleHQgbm9kZXMgaW4gdGhlIGN1cnJlbnRcclxuICAgKiBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQsIHRoZSByZW1vdmFsIHdpbGwgYmUgc3RvcmVkIG9uXHJcbiAgICogYGVkaXRvci5tYXJrc2AgYW5kIGFwcGxpZWQgdG8gdGhlIHRleHQgaW5zZXJ0ZWQgbmV4dC5cclxuICAgKi9cbiAgcmVtb3ZlTWFyayhlZGl0b3IsIGtleSkge1xuICAgIGVkaXRvci5yZW1vdmVNYXJrKGtleSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWFudWFsbHkgc2V0IGlmIHRoZSBlZGl0b3Igc2hvdWxkIGN1cnJlbnRseSBiZSBub3JtYWxpemluZy5cclxuICAgKlxyXG4gICAqIE5vdGU6IFVzaW5nIHRoaXMgaW5jb3JyZWN0bHkgY2FuIGxlYXZlIHRoZSBlZGl0b3IgaW4gYW4gaW52YWxpZCBzdGF0ZS5cclxuICAgKlxyXG4gICAqL1xuICBzZXROb3JtYWxpemluZyhlZGl0b3IsIGlzTm9ybWFsaXppbmcpIHtcbiAgICBOT1JNQUxJWklORy5zZXQoZWRpdG9yLCBpc05vcm1hbGl6aW5nKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHN0YXJ0KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHRleHQgc3RyaW5nIGNvbnRlbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKlxyXG4gICAqIE5vdGU6IGJ5IGRlZmF1bHQgdGhlIHRleHQgb2Ygdm9pZCBub2RlcyBpcyBjb25zaWRlcmVkIHRvIGJlIGFuIGVtcHR5XHJcbiAgICogc3RyaW5nLCByZWdhcmRsZXNzIG9mIGNvbnRlbnQsIHVubGVzcyB5b3UgcGFzcyBpbiB0cnVlIGZvciB0aGUgdm9pZHMgb3B0aW9uXHJcbiAgICovXG4gIHN0cmluZyhlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIHRleHQgPSAnJztcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICB2b2lkc1xuICAgIH0pKSB7XG4gICAgICB2YXIgdCA9IG5vZGUudGV4dDtcblxuICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICB0ID0gdC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgIHQgPSB0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHRleHQgKz0gdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIG5vbi1oYW5naW5nIG9uZS5cclxuICAgKi9cbiAgdW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7IC8vIFBFUkY6IGV4aXQgZWFybHkgaWYgd2UgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZSBpc24ndCBoYW5naW5nLlxuXG4gICAgaWYgKHN0YXJ0Lm9mZnNldCAhPT0gMCB8fCBlbmQub2Zmc2V0ICE9PSAwIHx8IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSB8fCBQYXRoLmhhc1ByZXZpb3VzKGVuZC5wYXRoKSkge1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cblxuICAgIHZhciBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIGF0OiBlbmQsXG4gICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgYmxvY2tQYXRoID0gZW5kQmxvY2sgPyBlbmRCbG9ja1sxXSA6IFtdO1xuICAgIHZhciBmaXJzdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHN0YXJ0KTtcbiAgICB2YXIgYmVmb3JlID0ge1xuICAgICAgYW5jaG9yOiBmaXJzdCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICAgIHZhciBza2lwID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYmVmb3JlLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRleHQgIT09ICcnIHx8IFBhdGguaXNCZWZvcmUocGF0aCwgYmxvY2tQYXRoKSkge1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IG5vZGUudGV4dC5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaCBhIHZvaWQgbm9kZSBpbiB0aGUgY3VycmVudCBicmFuY2ggb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgdm9pZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIEVkaXRvci5hYm92ZShlZGl0b3IsIF9vYmplY3RTcHJlYWQkOChfb2JqZWN0U3ByZWFkJDgoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pXG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENhbGwgYSBmdW5jdGlvbiwgZGVmZXJyaW5nIG5vcm1hbGl6YXRpb24gdW50aWwgYWZ0ZXIgaXQgY29tcGxldGVzLlxyXG4gICAqL1xuICB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIHZhciB2YWx1ZSA9IEVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcik7XG4gICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgZmFsc2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7XG4gIH1cblxufTtcblxudmFyIExvY2F0aW9uID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0xvY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlKSB8fCBQb2ludC5pc1BvaW50KHZhbHVlKSB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlKTtcbiAgfVxuXG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTcGFuID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBTcGFuYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzU3Bhbih2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdmFsdWUuZXZlcnkoUGF0aC5pc1BhdGgpO1xuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcImNoaWxkcmVuXCJdLFxuICAgIF9leGNsdWRlZDIkMiA9IFtcInRleHRcIl07XG52YXIgSVNfTk9ERV9MSVNUX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgTm9kZSA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aCwgYXNzZXJ0aW5nIHRoYXQgaXQncyBhbiBhbmNlc3RvciBub2RlLlxyXG4gICAqL1xuICBhbmNlc3Rvcihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgYW5jZXN0b3Igbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgdGV4dCBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgYW5jZXN0b3Igbm9kZXMgYWJvdmUgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCB0aGUgb3JkZXIgaXMgdG9wLWRvd24sIGZyb20gaGlnaGVzdCB0byBsb3dlc3QgYW5jZXN0b3IgaW5cclxuICAgKiB0aGUgdHJlZSwgYnV0IHlvdSBjYW4gcGFzcyB0aGUgYHJldmVyc2U6IHRydWVgIG9wdGlvbiB0byBnbyBib3R0b20tdXAuXHJcbiAgICovXG4gICphbmNlc3RvcnMocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGZvciAodmFyIHAgb2YgUGF0aC5hbmNlc3RvcnMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgIHZhciBuID0gTm9kZS5hbmNlc3Rvcihyb290LCBwKTtcbiAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgIHlpZWxkIGVudHJ5O1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNoaWxkIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIGluZGV4LlxyXG4gICAqL1xuICBjaGlsZChyb290LCBpbmRleCkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgY2hpbGQgb2YgYSB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHJvb3QuY2hpbGRyZW5baW5kZXhdO1xuXG4gICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBjaGlsZCBhdCBpbmRleCBgXCIuY29uY2F0KGluZGV4LCBcImAgaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIG92ZXIgdGhlIGNoaWxkcmVuIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gICpjaGlsZHJlbihyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBhbmNlc3RvcjtcbiAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICB3aGlsZSAocmV2ZXJzZSA/IGluZGV4ID49IDAgOiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gTm9kZS5jaGlsZChhbmNlc3RvciwgaW5kZXgpO1xuICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgIHlpZWxkIFtjaGlsZCwgY2hpbGRQYXRoXTtcbiAgICAgIGluZGV4ID0gcmV2ZXJzZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGFuIGVudHJ5IGZvciB0aGUgY29tbW9uIGFuY2VzZXRvciBub2RlIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHJvb3QsIHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgcCA9IFBhdGguY29tbW9uKHBhdGgsIGFub3RoZXIpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBhc3NlcnRpbmcgdGhhdCBpdCdzIGEgZGVzY2VuZGFudCBub2RlLlxyXG4gICAqL1xuICBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuXG4gICAgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgZGVzY2VuZGFudCBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gdGhlIHJvb3QgZWRpdG9yIG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBkZXNjZW5kYW50IG5vZGUgZW50cmllcyBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gICpkZXNjZW5kYW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNvZXJjZSBoZXJlIGJlY2F1c2UgY2hlY2tpbmcgdGhlIHBhdGgncyBsZW5ndGggZG9lc1xuICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgbm9kZWAgaXMgbm90IGEgYEVkaXRvcmAsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdy5cbiAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBlbGVtZW50IG5vZGVzIGluc2lkZSBhIHJvb3Qgbm9kZS4gRWFjaCBpdGVyYXRpb25cclxuICAgKiB3aWxsIHJldHVybiBhbiBgRWxlbWVudEVudHJ5YCB0dXBsZSBjb25zaXN0aW5nIG9mIGBbRWxlbWVudCwgUGF0aF1gLiBJZiB0aGVcclxuICAgKiByb290IG5vZGUgaXMgYW4gZWxlbWVudCBpdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBpdGVyYXRpb24gYXMgd2VsbC5cclxuICAgKi9cbiAgKmVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRXh0cmFjdCBwcm9wcyBmcm9tIGEgTm9kZS5cclxuICAgKi9cbiAgZXh0cmFjdFByb3BzKG5vZGUpIHtcbiAgICBpZiAoRWxlbWVudC5pc0FuY2VzdG9yKG5vZGUpKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQkMyk7XG5cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDIpO1xuXG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBmaXJzdCBub2RlIGVudHJ5IGluIGEgcm9vdCBub2RlIGZyb20gYSBwYXRoLlxyXG4gICAqL1xuICBmaXJzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcblxuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5jaGlsZHJlblswXTtcbiAgICAgICAgcC5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzbGljZWQgZnJhZ21lbnQgcmVwcmVzZW50ZWQgYnkgYSByYW5nZSBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gIGZyYWdtZW50KHJvb3QsIHJhbmdlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgZnJhZ21lbnQgc3RhcnRpbmcgZnJvbSBhIHJvb3QgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1Jvb3QgPSBwcm9kdWNlKHtcbiAgICAgIGNoaWxkcmVuOiByb290LmNoaWxkcmVuXG4gICAgfSwgciA9PiB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgICAgdmFyIG5vZGVFbnRyaWVzID0gTm9kZS5ub2RlcyhyLCB7XG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgICAgIHZhciBbLCBwYXRoXSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBbLCBwYXRoXSBvZiBub2RlRW50cmllcykge1xuICAgICAgICBpZiAoIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChyLCBwYXRoKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIGxlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgbGVhZi50ZXh0ID0gbGVhZi50ZXh0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgICAgdmFyIF9sZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuXG4gICAgICAgICAgX2xlYWYudGV4dCA9IF9sZWFmLnRleHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKHIpKSB7XG4gICAgICAgIHIuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Um9vdC5jaGlsZHJlbjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSByZWZlcnJlZCB0byBieSBhIHNwZWNpZmljIHBhdGguIElmIHRoZSBwYXRoIGlzIGFuXHJcbiAgICogZW1wdHkgYXJyYXksIGl0IHJlZmVycyB0byB0aGUgcm9vdCBub2RlIGl0c2VsZi5cclxuICAgKi9cbiAgZ2V0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGVzY2VuZGFudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgZGVzY2VuZGFudCBub2RlIGV4aXN0cyBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gIGhhcyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYE5vZGVgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBgTm9kZWAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNOb2RlTGlzdCh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVkUmVzdWx0ID0gSVNfTk9ERV9MSVNUX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGlzTm9kZUxpc3QgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gTm9kZS5pc05vZGUodmFsKSk7XG4gICAgSVNfTk9ERV9MSVNUX0NBQ0hFLnNldCh2YWx1ZSwgaXNOb2RlTGlzdCk7XG4gICAgcmV0dXJuIGlzTm9kZUxpc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsYXN0IG5vZGUgZW50cnkgaW4gYSByb290IG5vZGUgZnJvbSBhIHBhdGguXHJcbiAgICovXG4gIGxhc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG5cbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pIHx8IG4uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSBuLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIG4gPSBuLmNoaWxkcmVuW2ldO1xuICAgICAgICBwLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBlbnN1cmluZyBpdCdzIGEgbGVhZiB0ZXh0IG5vZGUuXHJcbiAgICovXG4gIGxlYWYocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBsZWFmIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIG5vbi1sZWFmIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIHRoZSBpbiBhIGJyYW5jaCBvZiB0aGUgdHJlZSwgZnJvbSBhIHNwZWNpZmljIHBhdGguXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0IHRoZSBvcmRlciBpcyB0b3AtZG93biwgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBub2RlIGluIHRoZSB0cmVlLFxyXG4gICAqIGJ1dCB5b3UgY2FuIHBhc3MgdGhlIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gdG8gZ28gYm90dG9tLXVwLlxyXG4gICAqL1xuICAqbGV2ZWxzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBmb3IgKHZhciBwIG9mIFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgeWllbGQgW24sIHBdO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgbWF0Y2hlcyBhIHNldCBvZiBwcm9wcy5cclxuICAgKi9cbiAgbWF0Y2hlcyhub2RlLCBwcm9wcykge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudFByb3BzKHByb3BzKSAmJiBFbGVtZW50Lm1hdGNoZXMobm9kZSwgcHJvcHMpIHx8IFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0UHJvcHMocHJvcHMpICYmIFRleHQubWF0Y2hlcyhub2RlLCBwcm9wcyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgbm9kZSBlbnRyaWVzIG9mIGEgcm9vdCBub2RlLiBFYWNoIGVudHJ5IGlzXHJcbiAgICogcmV0dXJuZWQgYXMgYSBgW05vZGUsIFBhdGhdYCB0dXBsZSwgd2l0aCB0aGUgcGF0aCByZWZlcnJpbmcgdG8gdGhlIG5vZGUnc1xyXG4gICAqIHBvc2l0aW9uIGluc2lkZSB0aGUgcm9vdCBub2RlLlxyXG4gICAqL1xuICAqbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcGFzcyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBmcm9tID0gW10sXG4gICAgICB0b1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIG4gPSByb290O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikpIHtcbiAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGdvIGRvd253YXJkIGFuZCB3ZSBoYXZlbid0IGRlc2NlbmRlZCB5ZXQsIGRvLlxuXG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSByZXZlcnNlID8gbi5jaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGZyb20pKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5jb25jYXQobmV4dEluZGV4KTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYXQgdGhlIHJvb3QgYW5kIHdlIGNhbid0IGdvIGRvd24sIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBmb3J3YXJkLi4uXG5cblxuICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHApO1xuXG4gICAgICAgIGlmIChOb2RlLmhhcyhyb290LCBuZXdQYXRoKSkge1xuICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBiYWNrd2FyZC4uLlxuXG5cbiAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICB2YXIgX25ld1BhdGggPSBQYXRoLnByZXZpb3VzKHApO1xuXG4gICAgICAgIHAgPSBfbmV3UGF0aDtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlJ3JlIGdvaW5nIHVwd2FyZC4uLlxuXG5cbiAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqL1xuICBwYXJlbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIHAgPSBOb2RlLmdldChyb290LCBwYXJlbnRQYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29uY2F0ZW5hdGVkIHRleHQgc3RyaW5nIG9mIGEgbm9kZSdzIGNvbnRlbnQuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBpbmNsdWRlIHNwYWNlcyBvciBsaW5lIGJyZWFrcyBiZXR3ZWVuIGJsb2NrIG5vZGVzLlxyXG4gICAqIEl0IGlzIG5vdCBhIHVzZXItZmFjaW5nIHN0cmluZywgYnV0IGEgc3RyaW5nIGZvciBwZXJmb3JtaW5nIG9mZnNldC1yZWxhdGVkXHJcbiAgICogY29tcHV0YXRpb25zIGZvciBhIG5vZGUuXHJcbiAgICovXG4gIHN0cmluZyhub2RlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoTm9kZS5zdHJpbmcpLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIGxlYWYgdGV4dCBub2RlcyBpbiBhIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgKnRleHRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ3KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ3KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDcoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBPcGVyYXRpb24gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgTm9kZU9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc05vZGVPcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfbm9kZScpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gYE9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc09wZXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgUGF0aC5pc1BhdGgodmFsdWUubmV3UGF0aCk7XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUubmV3UHJvcGVydGllcykgfHwgdmFsdWUubmV3UHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLnByb3BlcnRpZXMpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYE9wZXJhdGlvbmAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBTZWxlY3Rpb25PcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNTZWxlY3Rpb25PcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfc2VsZWN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBUZXh0T3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzVGV4dE9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ190ZXh0Jyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW52ZXJ0IGFuIG9wZXJhdGlvbiwgcmV0dXJuaW5nIGEgbmV3IG9wZXJhdGlvbiB0aGF0IHdpbGwgZXhhY3RseSB1bmRvIHRoZVxyXG4gICAqIG9yaWdpbmFsIHdoZW4gYXBwbGllZC5cclxuICAgKi9cbiAgaW52ZXJzZShvcCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgucHJldmlvdXMob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIG5ld1BhdGgsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfSA9IG9wOyAvLyBQRVJGOiBpbiB0aGlzIGNhc2UgdGhlIG1vdmUgb3BlcmF0aW9uIGlzIGEgbm8tb3AgYW55d2F5cy5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgaGFwcGVucyBjb21wbGV0ZWx5IHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgdGhlIHBhdGggYW5kXG4gICAgICAgICAgLy8gbmV3UGF0aCBhcmUgc3RhYmxlIHdpdGggcmVzcGVjdCB0byBlYWNoIG90aGVyLlxuXG5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgZG9lcyBub3QgaGFwcGVuIHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgaXQgaXMgcG9zc2libGVcbiAgICAgICAgICAvLyBmb3IgdGhlIG1vdmUgdG8gaW1wYWN0IHRoZSB0cnVlIHBhdGggdG8gdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHJlbW92ZWQgZnJvbSBhbmQgd2hlcmUgaXQgd2FzIGluc2VydGVkLiBXZSBoYXZlIHRvIGFkanVzdCBmb3IgdGhpc1xuICAgICAgICAgIC8vIGFuZCBmaW5kIHRoZSBvcmlnaW5hbCBwYXRoLiBXZSBjYW4gYWNjb21wbGlzaCB0aGlzIChvbmx5IGluIG5vbi1zaWJsaW5nKVxuICAgICAgICAgIC8vIG1vdmVzIGJ5IGxvb2tpbmcgYXQgdGhlIGltcGFjdCBvZiB0aGUgbW92ZSBvcGVyYXRpb24gb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBhZnRlciB0aGUgb3JpZ2luYWwgbW92ZSBwYXRoLlxuXG5cbiAgICAgICAgICB2YXIgaW52ZXJzZVBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgdmFyIGludmVyc2VOZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0oUGF0aC5uZXh0KHBhdGgpLCBvcCk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aDogaW52ZXJzZU5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IF9wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX3Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLm5leHQob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUGF0aCA9IHtcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBhbmNlc3RvciBwYXRocyBmb3IgYSBnaXZlbiBwYXRoLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QgYW5jZXN0b3IuIEhvd2V2ZXIsIGlmIHRoZVxyXG4gICAqIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgYW5jZXN0b3JzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBwYXRocyA9IFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRocztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoICYmIGkgPCBhbm90aGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcblxuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tb247XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBhdGggdG8gYW5vdGhlciwgcmV0dXJuaW5nIGFuIGludGVnZXIgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYXRoXHJcbiAgICogd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKlxyXG4gICAqIE5vdGU6IFR3byBwYXRocyBvZiB1bmVxdWFsIGxlbmd0aCBjYW4gc3RpbGwgcmVjZWl2ZSBhIGAwYCByZXN1bHQgaWYgb25lIGlzXHJcbiAgICogZGlyZWN0bHkgYWJvdmUgb3IgYmVsb3cgdGhlIG90aGVyLiBJZiB5b3Ugd2FudCBleGFjdCBtYXRjaGluZywgdXNlXHJcbiAgICogW1tQYXRoLmVxdWFsc11dIGluc3RlYWQuXHJcbiAgICovXG4gIGNvbXBhcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihwYXRoLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBlbmRzIGFmdGVyIG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPiBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBhdCBvbmUgb2YgdGhlIGluZGV4ZXMgaW4gYW5vdGhlci5cclxuICAgKi9cbiAgZW5kc0F0KHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBiZWZvcmUgb25lIG9mIHRoZSBpbmRleGVzIGluIGFub3RoZXIuXHJcbiAgICovXG4gIGVuZHNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPCBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHMocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggJiYgcGF0aC5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYW5vdGhlcltpXSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHBhdGggb2YgcHJldmlvdXMgc2libGluZyBub2RlIGV4aXN0c1xyXG4gICAqL1xuICBoYXNQcmV2aW91cyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA+IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFmdGVyIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQW5jZXN0b3IocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYSBjaGlsZCBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0NoaWxkKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICsgMSAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGVxdWFsIHRvIG9yIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNEZXNjZW5kYW50KHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIHRoZSBwYXJlbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNQYXJlbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCArIDEgPT09IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpcyBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQYXRoYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIHNpYmxpbmcgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNTaWJsaW5nKHBhdGgsIGFub3RoZXIpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGFsID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHZhciBibCA9IGFub3RoZXJbYW5vdGhlci5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gYWwgIT09IGJsICYmIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBwYXRocyBhdCBldmVyeSBsZXZlbCBkb3duIHRvIGEgcGF0aC4gTm90ZTogdGhpcyBpcyB0aGUgc2FtZVxyXG4gICAqIGFzIGBQYXRoLmFuY2VzdG9yc2AsIGJ1dCBpbmNsdWRpbmcgdGhlIHBhdGggaXRzZWxmLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QuIEhvd2V2ZXIsIGlmIHRoZSBgcmV2ZXJzZTpcclxuICAgKiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBsaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2gocGF0aC5zbGljZSgwLCBpKSk7XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxpc3QucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgcGF0aCwgZ2V0IHRoZSBwYXRoIHRvIHRoZSBuZXh0IHNpYmxpbmcgbm9kZS5cclxuICAgKi9cbiAgbmV4dChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIG5leHQgaW5kZXguXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgKyAxKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvcGVyYXRpb24gY2FuIGFmZmVjdCBwYXRocyBvciBub3QuIFVzZWQgYXMgYW5cclxuICAgKiBvcHRpbWl6YXRpb24gd2hlbiB1cGRhdGluZyBkaXJ0eSBwYXRocyBkdXJpbmcgbm9ybWFsaXphdGlvblxyXG4gICAqXHJcbiAgICogTk9URTogVGhpcyAqbXVzdCogYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIGltcGxlbWVudGF0aW9uIG9mICd0cmFuc2Zvcm0nXHJcbiAgICogYmVsb3dcclxuICAgKi9cbiAgb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcGVyYXRpb24pIHtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBwYXRoLCByZXR1cm4gYSBuZXcgcGF0aCByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCBub2RlIGFib3ZlIGl0LlxyXG4gICAqL1xuICBwYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IHBhdGggb2YgdGhlIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXS5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIGdldCB0aGUgcGF0aCB0byB0aGUgcHJldmlvdXMgc2libGluZyBub2RlLlxyXG4gICAqL1xuICBwcmV2aW91cyhwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBwcmV2aW91cyBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIGZpcnN0IGNoaWxkIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBuZWdhdGl2ZSBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCAtIDEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHBhdGggcmVsYXRpdmUgdG8gYW4gYW5jZXN0b3IuXHJcbiAgICovXG4gIHJlbGF0aXZlKHBhdGgsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFQYXRoLmlzQW5jZXN0b3IoYW5jZXN0b3IsIHBhdGgpICYmICFQYXRoLmVxdWFscyhwYXRoLCBhbmNlc3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHJlbGF0aXZlIHBhdGggb2YgW1wiLmNvbmNhdChwYXRoLCBcIl0gaW5zaWRlIGFuY2VzdG9yIFtcIikuY29uY2F0KGFuY2VzdG9yLCBcIl0sIGJlY2F1c2UgaXQgaXMgbm90IGFib3ZlIG9yIGVxdWFsIHRvIHRoZSBwYXRoLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoYW5jZXN0b3IubGVuZ3RoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwYXRoIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHBhdGgsIG9wZXJhdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsOyAvLyBQRVJGOiB1c2UgZGVzdHJ1Y3RpbmcgaW5zdGVhZCBvZiBpbW1lclxuXG4gICAgdmFyIHAgPSBbLi4ucGF0aF07XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7IC8vIFBFUkY6IEV4aXQgZWFybHkgaWYgdGhlIG9wZXJhdGlvbiBpcyBndWFyYW50ZWVkIG5vdCB0byBoYXZlIGFuIGVmZmVjdC5cblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IG9wXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcCwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKG9wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AsIHApKSB7XG4gICAgICAgICAgICBwW29wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcFxuICAgICAgICAgIH0gPSBvcGVyYXRpb247XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfb3AyLFxuICAgICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDIsIHApIHx8IFBhdGguZW5kc0JlZm9yZShfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aF0gKz0gcG9zaXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wMyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBfcG9zaXRpb25cbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBpZiAoYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICBwW3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdiYWNrd2FyZCcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3AzLCBwKSAmJiBwYXRoW19vcDMubGVuZ3RoXSA+PSBfcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aF0gLT0gX3Bvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wNCxcbiAgICAgICAgICAgIG5ld1BhdGg6IG9ucFxuICAgICAgICAgIH0gPSBvcGVyYXRpb247IC8vIElmIHRoZSBvbGQgYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZSwgaXQncyBhIG5vLW9wLlxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDQsIG9ucCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wNCwgcCkgfHwgUGF0aC5lcXVhbHMoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb25wLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgb25wKSAmJiBfb3A0Lmxlbmd0aCA8IG9ucC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29weVtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb3B5LmNvbmNhdChwLnNsaWNlKF9vcDQubGVuZ3RoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzU2libGluZyhfb3A0LCBvbnApICYmIChQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9ucCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfVxuXG59O1xuXG52YXIgUGF0aFJlZiA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBwYXRoIHJlZidzIGN1cnJlbnQgdmFsdWUgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gUGF0aC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDYoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ2KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgUG9pbnQgPSB7XG4gIC8qKlxyXG4gICAqIENvbXBhcmUgYSBwb2ludCB0byBhbm90aGVyLCByZXR1cm5pbmcgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlXHJcbiAgICogcG9pbnQgd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKi9cbiAgY29tcGFyZShwb2ludCwgYW5vdGhlcikge1xuICAgIHZhciByZXN1bHQgPSBQYXRoLmNvbXBhcmUocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcblxuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBhbm90aGVyLm9mZnNldCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA+IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBhZnRlciBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FmdGVyKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzKHBvaW50LCBhbm90aGVyKSB7XG4gICAgLy8gUEVSRjogZW5zdXJlIHRoZSBvZmZzZXRzIGFyZSBlcXVhbCBmaXJzdCBzaW5jZSB0aGV5IGFyZSBjaGVhcGVyIHRvIGNoZWNrLlxuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IGFub3RoZXIub2Zmc2V0ICYmIFBhdGguZXF1YWxzKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgUG9pbnRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNQb2ludCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwb2ludCBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShwb2ludCwgb3ApIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIHByb2R1Y2UocG9pbnQsIHAgPT4ge1xuICAgICAgaWYgKHAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IHA7XG5cbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgKG9wLm9mZnNldCA8IG9mZnNldCB8fCBvcC5vZmZzZXQgPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgb3Aub2Zmc2V0IDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICBwLm9mZnNldCAtPSBNYXRoLm1pbihvZmZzZXQgLSBvcC5vZmZzZXQsIG9wLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcC5wb3NpdGlvbiA8IG9mZnNldCB8fCBvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgICBwLm9mZnNldCAtPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59O1xuXG52YXIgUG9pbnRSZWYgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcG9pbnQgcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50ID0gUG9pbnQudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcG9pbnQ7XG5cbiAgICBpZiAocG9pbnQgPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDUob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDUodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ1KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFJhbmdlID0ge1xuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIG9mIGEgcmFuZ2UsIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFwcGVhclxyXG4gICAqIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgZWRnZXMocmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkgPT09IHJldmVyc2UgPyBbYW5jaG9yLCBmb2N1c10gOiBbZm9jdXMsIGFuY2hvcl07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBlbmQgcG9pbnQgb2YgYSByYW5nZS5cclxuICAgKi9cbiAgZW5kKHJhbmdlKSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgcmV0dXJuIGVuZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhyYW5nZS5hbmNob3IsIGFub3RoZXIuYW5jaG9yKSAmJiBQb2ludC5lcXVhbHMocmFuZ2UuZm9jdXMsIGFub3RoZXIuZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaW5jbHVkZXMgYSBwYXRoLCBhIHBvaW50IG9yIHBhcnQgb2YgYW5vdGhlciByYW5nZS5cclxuICAgKi9cbiAgaW5jbHVkZXMocmFuZ2UsIHRhcmdldCkge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICAgIGlmIChSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmFuY2hvcikgfHwgUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5mb2N1cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBbcnMsIHJlXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICAgIHZhciBbdHMsIHRlXSA9IFJhbmdlLmVkZ2VzKHRhcmdldCk7XG4gICAgICByZXR1cm4gUG9pbnQuaXNCZWZvcmUocnMsIHRzKSAmJiBQb2ludC5pc0FmdGVyKHJlLCB0ZSk7XG4gICAgfVxuXG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgaXNBZnRlclN0YXJ0ID0gZmFsc2U7XG4gICAgdmFyIGlzQmVmb3JlRW5kID0gZmFsc2U7XG5cbiAgICBpZiAoUG9pbnQuaXNQb2ludCh0YXJnZXQpKSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgc3RhcnQpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBlbmQpIDw9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIHN0YXJ0LnBhdGgpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIGVuZC5wYXRoKSA8PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gb2YgYSByYW5nZSB3aXRoIGFub3RoZXIuXHJcbiAgICovXG4gIGludGVyc2VjdGlvbihyYW5nZSwgYW5vdGhlcikge1xuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQkMik7XG5cbiAgICB2YXIgW3MxLCBlMV0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIFtzMiwgZTJdID0gUmFuZ2UuZWRnZXMoYW5vdGhlcik7XG4gICAgdmFyIHN0YXJ0ID0gUG9pbnQuaXNCZWZvcmUoczEsIHMyKSA/IHMyIDogczE7XG4gICAgdmFyIGVuZCA9IFBvaW50LmlzQmVmb3JlKGUxLCBlMikgPyBlMSA6IGUyO1xuXG4gICAgaWYgKFBvaW50LmlzQmVmb3JlKGVuZCwgc3RhcnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNSh7XG4gICAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICAgIGZvY3VzOiBlbmRcbiAgICAgIH0sIHJlc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGJhY2t3YXJkLCBtZWFuaW5nIHRoYXQgaXRzIGFuY2hvciBwb2ludCBhcHBlYXJzIGluIHRoZVxyXG4gICAqIGRvY3VtZW50IF9hZnRlcl8gaXRzIGZvY3VzIHBvaW50LlxyXG4gICAqL1xuICBpc0JhY2t3YXJkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5pc0FmdGVyKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgY29sbGFwc2VkLCBtZWFuaW5nIHRoYXQgYm90aCBpdHMgYW5jaG9yIGFuZCBmb2N1c1xyXG4gICAqIHBvaW50cyByZWZlciB0byB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIGlzQ29sbGFwc2VkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBleHBhbmRlZC5cclxuICAgKlxyXG4gICAqIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIFtbUmFuZ2UuaXNDb2xsYXBzZWRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRXhwYW5kZWQocmFuZ2UpIHtcbiAgICByZXR1cm4gIVJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGZvcndhcmQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBbW1JhbmdlLmlzQmFja3dhcmRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRm9yd2FyZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBbW1JhbmdlXV0gaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1JhbmdlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuYW5jaG9yKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBwb2ludCBlbnRyaWVzIGluIGEgcmFuZ2UuXHJcbiAgICovXG4gICpwb2ludHMocmFuZ2UpIHtcbiAgICB5aWVsZCBbcmFuZ2UuYW5jaG9yLCAnYW5jaG9yJ107XG4gICAgeWllbGQgW3JhbmdlLmZvY3VzLCAnZm9jdXMnXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgcmFuZ2UuXHJcbiAgICovXG4gIHN0YXJ0KHJhbmdlKSB7XG4gICAgdmFyIFtzdGFydF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHJhbmdlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHJhbmdlLCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gcHJvZHVjZShyYW5nZSwgciA9PiB7XG4gICAgICBpZiAociA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgYWZmaW5pdHkgPSAnaW53YXJkJ1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIgYWZmaW5pdHlBbmNob3I7XG4gICAgICB2YXIgYWZmaW5pdHlGb2N1cztcblxuICAgICAgaWYgKGFmZmluaXR5ID09PSAnaW53YXJkJykge1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLCBtYWtlIHN1cmUgdG8gdXNlIHRoZSBzYW1lIGFmZmluaXR5IHRvXG4gICAgICAgIC8vIGF2b2lkIHRoZSB0d28gcG9pbnRzIHBhc3NpbmcgZWFjaCBvdGhlciBhbmQgZXhwYW5kaW5nIGluIHRoZSBvcHBvc2l0ZVxuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgdmFyIGlzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQocik7XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyKSkge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2JhY2t3YXJkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnZm9yd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdvdXR3YXJkJykge1xuICAgICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHIpKSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnZm9yd2FyZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdiYWNrd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gYWZmaW5pdHk7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSBhZmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuY2hvciA9IFBvaW50LnRyYW5zZm9ybShyLmFuY2hvciwgb3AsIHtcbiAgICAgICAgYWZmaW5pdHk6IGFmZmluaXR5QW5jaG9yXG4gICAgICB9KTtcbiAgICAgIHZhciBmb2N1cyA9IFBvaW50LnRyYW5zZm9ybShyLmZvY3VzLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlGb2N1c1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghYW5jaG9yIHx8ICFmb2N1cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgci5hbmNob3IgPSBhbmNob3I7XG4gICAgICByLmZvY3VzID0gZm9jdXM7XG4gICAgfSk7XG4gIH1cblxufTtcblxudmFyIFJhbmdlUmVmID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIHJhbmdlIHJlZidzIGN1cnJlbnQgdmFsdWUgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gUmFuZ2UudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcGF0aDtcblxuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxuXG59O1xuXG52YXIgX3NjcnViYmVyID0gdW5kZWZpbmVkO1xuLyoqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIGltcGxlbWVudHMgYSBzdHJpbmdpZnkoKSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBieSBTbGF0ZVxyXG4gKiBpbnRlcm5hbGx5IHdoZW4gZ2VuZXJhdGluZyBleGNlcHRpb25zIGNvbnRhaW5pbmcgZW5kIHVzZXIgZGF0YS4gRGV2ZWxvcGVyc1xyXG4gKiB1c2luZyBTbGF0ZSBtYXkgY2FsbCBTY3J1YmJlci5zZXRTY3J1YmJlcigpIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGlzXHJcbiAqIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgdG8gcHJldmVudCB0aGUgY2xlYXJ0ZXh0IGxvZ2dpbmcgb2YgJ3RleHQnIGZpZWxkcyB3aXRoaW4gTm9kZXM6XHJcbiAqXHJcbiAqICAgIGltcG9ydCB7IFNjcnViYmVyIH0gZnJvbSAnc2xhdGUnO1xyXG4gKiAgICBTY3J1YmJlci5zZXRTY3J1YmJlcigoa2V5LCB2YWwpID0+IHtcclxuICogICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHJldHVybiAnLi4uc2NydWJiZWQuLi4nXHJcbiAqICAgICAgcmV0dXJuIHZhbFxyXG4gKiAgICB9KTtcclxuICpcclxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTY3J1YmJlciA9IHtcbiAgc2V0U2NydWJiZXIoc2NydWJiZXIpIHtcbiAgICBfc2NydWJiZXIgPSBzY3J1YmJlcjtcbiAgfSxcblxuICBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIF9zY3J1YmJlcik7XG4gIH1cblxufTtcblxuLypcclxuICBDdXN0b20gZGVlcCBlcXVhbCBjb21wYXJpc29uIGZvciBTbGF0ZSBub2Rlcy5cclxuXG4gIFdlIGRvbid0IG5lZWQgZ2VuZXJhbCBwdXJwb3NlIGRlZXAgZXF1YWxpdHk7XHJcbiAgU2xhdGUgb25seSBzdXBwb3J0cyBwbGFpbiB2YWx1ZXMsIEFycmF5cywgYW5kIG5lc3RlZCBvYmplY3RzLlxyXG4gIENvbXBsZXggdmFsdWVzIG5lc3RlZCBpbnNpZGUgQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG5cbiAgU2xhdGUgb2JqZWN0cyBhcmUgZGVzaWduZWQgdG8gYmUgc2VyaWFsaXNlZCwgc29cclxuICBtaXNzaW5nIGtleXMgYXJlIGRlbGliZXJhdGVseSBub3JtYWxpc2VkIHRvIHVuZGVmaW5lZC5cclxuICovXG5cbnZhciBpc0RlZXBFcXVhbCA9IChub2RlLCBhbm90aGVyKSA9PiB7XG4gIGZvciAodmFyIGtleSBpbiBub2RlKSB7XG4gICAgdmFyIGEgPSBub2RlW2tleV07XG4gICAgdmFyIGIgPSBhbm90aGVyW2tleV07XG5cbiAgICBpZiAoaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsKGEsIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhICE9PSBiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qXHJcbiAgICBEZWVwIG9iamVjdCBlcXVhbGl0eSBpcyBvbmx5IG5lY2Vzc2FyeSBpbiBvbmUgZGlyZWN0aW9uOyBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cclxuICAgIHdlIGFyZSBvbmx5IGxvb2tpbmcgZm9yIGtleXMgdGhhdCBhcmUgbWlzc2luZy5cclxuICAgIEFzIGFib3ZlLCB1bmRlZmluZWQga2V5cyBhcmUgbm9ybWFsaXNlZCB0byBtaXNzaW5nLlxyXG4gICovXG5cblxuICBmb3IgKHZhciBfa2V5IGluIGFub3RoZXIpIHtcbiAgICBpZiAobm9kZVtfa2V5XSA9PT0gdW5kZWZpbmVkICYmIGFub3RoZXJbX2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIF9leGNsdWRlZCQxID0gW1widGV4dFwiXSxcbiAgICBfZXhjbHVkZWQyJDEgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQ0KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNChPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDQoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBUZXh0ID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiB0d28gdGV4dCBub2RlcyBhcmUgZXF1YWwuXHJcbiAgICpcclxuICAgKiBXaGVuIGxvb3NlIGlzIHNldCwgdGhlIHRleHQgaXMgbm90IGNvbXBhcmVkLiBUaGlzIGlzXHJcbiAgICogdXNlZCB0byBjaGVjayB3aGV0aGVyIHNpYmxpbmcgdGV4dCBub2RlcyBjYW4gYmUgbWVyZ2VkLlxyXG4gICAqL1xuICBlcXVhbHModGV4dCwgYW5vdGhlcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbG9vc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgZnVuY3Rpb24gb21pdFRleHQob2JqKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIF9leGNsdWRlZCQxKTtcblxuICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRGVlcEVxdWFsKGxvb3NlID8gb21pdFRleHQodGV4dCkgOiB0ZXh0LCBsb29zZSA/IG9taXRUZXh0KGFub3RoZXIpIDogYW5vdGhlcik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgVGV4dGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1RleHQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIGBUZXh0YCBvYmplY3RzLlxyXG4gICAqL1xuICBpc1RleHRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBUZXh0LmlzVGV4dCh2YWwpKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBzb21lIHByb3BzIGFyZSBhIHBhcnRpYWwgb2YgVGV4dC5cclxuICAgKi9cbiAgaXNUZXh0UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dCAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIHRleHQgbWF0Y2hlcyBzZXQgb2YgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIE5vdGU6IHRoaXMgaXMgZm9yIG1hdGNoaW5nIGN1c3RvbSBwcm9wZXJ0aWVzLCBhbmQgaXQgZG9lcyBub3QgZW5zdXJlIHRoYXRcclxuICAgKiB0aGUgYHRleHRgIHByb3BlcnR5IGFyZSB0d28gbm9kZXMgZXF1YWwuXHJcbiAgICovXG4gIG1hdGNoZXModGV4dCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0ZXh0Lmhhc093blByb3BlcnR5KGtleSkgfHwgdGV4dFtrZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxlYXZlcyBmb3IgYSB0ZXh0IG5vZGUgZ2l2ZW4gZGVjb3JhdGlvbnMuXHJcbiAgICovXG4gIGRlY29yYXRpb25zKG5vZGUsIGRlY29yYXRpb25zKSB7XG4gICAgdmFyIGxlYXZlcyA9IFtfb2JqZWN0U3ByZWFkJDQoe30sIG5vZGUpXTtcblxuICAgIGZvciAodmFyIGRlYyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZGVjLCBfZXhjbHVkZWQyJDEpO1xuXG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoZGVjKTtcbiAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICB2YXIgbGVhZkVuZCA9IDA7XG4gICAgICB2YXIgZGVjb3JhdGlvblN0YXJ0ID0gc3RhcnQub2Zmc2V0O1xuICAgICAgdmFyIGRlY29yYXRpb25FbmQgPSBlbmQub2Zmc2V0O1xuXG4gICAgICBmb3IgKHZhciBsZWFmIG9mIGxlYXZlcykge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGxlbmd0aFxuICAgICAgICB9ID0gbGVhZi50ZXh0O1xuICAgICAgICB2YXIgbGVhZlN0YXJ0ID0gbGVhZkVuZDtcbiAgICAgICAgbGVhZkVuZCArPSBsZW5ndGg7IC8vIElmIHRoZSByYW5nZSBlbmNvbXBhc3NlcyB0aGUgZW50aXJlIGxlYWYsIGFkZCB0aGUgcmFuZ2UuXG5cbiAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCA8PSBsZWFmU3RhcnQgJiYgbGVhZkVuZCA8PSBkZWNvcmF0aW9uRW5kKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihsZWFmLCByZXN0KTtcbiAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSWYgdGhlIHJhbmdlIGV4cGFuZGVkIGFuZCBtYXRjaCB0aGUgbGVhZiwgb3Igc3RhcnRzIGFmdGVyLCBvciBlbmRzIGJlZm9yZSBpdCwgY29udGludWUuXG5cblxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ICE9PSBkZWNvcmF0aW9uRW5kICYmIChkZWNvcmF0aW9uU3RhcnQgPT09IGxlYWZFbmQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0KSB8fCBkZWNvcmF0aW9uU3RhcnQgPiBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPCBsZWFmU3RhcnQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0ICYmIGxlYWZTdGFydCAhPT0gMCkge1xuICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBzcGxpdCB0aGUgbGVhZiwgYXQgdGhlIHN0YXJ0LCBlbmQsIG9yIGJvdGgsXG4gICAgICAgIC8vIGFuZCBhZGQgdGhlIHJhbmdlIHRvIHRoZSBtaWRkbGUgaW50ZXJzZWN0aW5nIHNlY3Rpb24uIERvIHRoZSBlbmRcbiAgICAgICAgLy8gc3BsaXQgZmlyc3Qgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIG9mZnNldCB0aGF0IHdheS5cblxuXG4gICAgICAgIHZhciBtaWRkbGUgPSBsZWFmO1xuICAgICAgICB2YXIgYmVmb3JlID0gdm9pZCAwO1xuICAgICAgICB2YXIgYWZ0ZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGRlY29yYXRpb25FbmQgPCBsZWFmRW5kKSB7XG4gICAgICAgICAgdmFyIG9mZiA9IGRlY29yYXRpb25FbmQgLSBsZWFmU3RhcnQ7XG4gICAgICAgICAgYWZ0ZXIgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2Uob2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZSgwLCBvZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ID4gbGVhZlN0YXJ0KSB7XG4gICAgICAgICAgdmFyIF9vZmYgPSBkZWNvcmF0aW9uU3RhcnQgLSBsZWFmU3RhcnQ7XG5cbiAgICAgICAgICBiZWZvcmUgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWlkZGxlLCByZXN0KTtcblxuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGJlZm9yZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0LnB1c2gobWlkZGxlKTtcblxuICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICBuZXh0LnB1c2goYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxlYXZlcyA9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIGFwcGx5VG9EcmFmdCA9IChlZGl0b3IsIHNlbGVjdGlvbiwgb3ApID0+IHtcbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgbm9kZVxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGluZGV4ID4gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBcXFwiaW5zZXJ0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiB0aGUgbm9kZS5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgbm9kZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtwb2ludCwga2V5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW2tleV0gPSBQb2ludC50cmFuc2Zvcm0ocG9pbnQsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIF9ub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgX3BhdGgpO1xuXG4gICAgICAgIHZhciBiZWZvcmUgPSBfbm9kZS50ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgICAgICAgdmFyIGFmdGVyID0gX25vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuXG4gICAgICAgIF9ub2RlLnRleHQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQsIF9rZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIHZhciBfbm9kZTIgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMik7XG5cbiAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDIpO1xuICAgICAgICB2YXIgcHJldiA9IE5vZGUuZ2V0KGVkaXRvciwgcHJldlBhdGgpO1xuXG4gICAgICAgIHZhciBfcGFyZW50ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDIpO1xuXG4gICAgICAgIHZhciBfaW5kZXggPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTIpICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgcHJldi50ZXh0ICs9IF9ub2RlMi50ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCFUZXh0LmlzVGV4dChfbm9kZTIpICYmICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHByZXYuY2hpbGRyZW4ucHVzaCguLi5fbm9kZTIuY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJtZXJnZV9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoMiwgXCJdIHRvIG5vZGVzIG9mIGRpZmZlcmVudCBpbnRlcmZhY2VzOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbm9kZTIpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BhcmVudC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4LCAxKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDIsIF9rZXkyXSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkyXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQyLCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoMyxcbiAgICAgICAgICBuZXdQYXRoXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbW92ZSBhIHBhdGggW1wiLmNvbmNhdChfcGF0aDMsIFwiXSB0byBuZXcgcGF0aCBbXCIpLmNvbmNhdChuZXdQYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgaW5zaWRlIGl0c2VsZi5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9ub2RlMyA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICB2YXIgX3BhcmVudDIgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMyk7XG5cbiAgICAgICAgdmFyIF9pbmRleDIgPSBfcGF0aDNbX3BhdGgzLmxlbmd0aCAtIDFdOyAvLyBUaGlzIGlzIHRyaWNreSwgYnV0IHNpbmNlIHRoZSBgcGF0aGAgYW5kIGBuZXdQYXRoYCBib3RoIHJlZmVyIHRvXG4gICAgICAgIC8vIHRoZSBzYW1lIHNuYXBzaG90IGluIHRpbWUsIHRoZXJlJ3MgYSBtaXNtYXRjaC4gQWZ0ZXIgZWl0aGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiwgdGhlIHNlY29uZCBzdGVwJ3MgcGF0aCBjYW4gYmUgb3V0XG4gICAgICAgIC8vIG9mIGRhdGUuIFNvIGluc3RlYWQgb2YgdXNpbmcgdGhlIGBvcC5uZXdQYXRoYCBkaXJlY3RseSwgd2VcbiAgICAgICAgLy8gdHJhbnNmb3JtIGBvcC5wYXRoYCB0byBhc2NlcnRhaW4gd2hhdCB0aGUgYG5ld1BhdGhgIHdvdWxkIGJlIGFmdGVyXG4gICAgICAgIC8vIHRoZSBvcGVyYXRpb24gd2FzIGFwcGxpZWQuXG5cbiAgICAgICAgX3BhcmVudDIuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDIsIDEpO1xuXG4gICAgICAgIHZhciB0cnVlUGF0aCA9IFBhdGgudHJhbnNmb3JtKF9wYXRoMywgb3ApO1xuICAgICAgICB2YXIgbmV3UGFyZW50ID0gTm9kZS5nZXQoZWRpdG9yLCBQYXRoLnBhcmVudCh0cnVlUGF0aCkpO1xuICAgICAgICB2YXIgbmV3SW5kZXggPSB0cnVlUGF0aFt0cnVlUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgbmV3UGFyZW50LmNoaWxkcmVuLnNwbGljZShuZXdJbmRleCwgMCwgX25vZGUzKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDMsIF9rZXkzXSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkzXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQzLCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg0XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIF9pbmRleDMgPSBfcGF0aDRbX3BhdGg0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHZhciBfcGFyZW50MyA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGg0KTtcblxuICAgICAgICBfcGFyZW50My5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MywgMSk7IC8vIFRyYW5zZm9ybSBhbGwgb2YgdGhlIHBvaW50cyBpbiB0aGUgdmFsdWUsIGJ1dCBpZiB0aGUgcG9pbnQgd2FzIGluIHRoZVxuICAgICAgICAvLyBub2RlIHRoYXQgd2FzIHJlbW92ZWQgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJhbmdlIG9yIHJlbW92ZSBpdC5cblxuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50NCwgX2tleTRdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDQsIG9wKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAhPSBudWxsICYmIHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NF0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX3ByZXYgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgW24sIHBdIG9mIE5vZGUudGV4dHMoZWRpdG9yKSkge1xuICAgICAgICAgICAgICAgIGlmIChQYXRoLmNvbXBhcmUocCwgX3BhdGg0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIF9wcmV2ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXh0ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHByZWZlck5leHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAoX3ByZXYgJiYgbmV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXh0WzFdLCBfcGF0aDQpKSB7XG4gICAgICAgICAgICAgICAgICBwcmVmZXJOZXh0ID0gIVBhdGguaGFzUHJldmlvdXMobmV4dFsxXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSBQYXRoLmNvbW1vbihfcHJldlsxXSwgX3BhdGg0KS5sZW5ndGggPCBQYXRoLmNvbW1vbihuZXh0WzFdLCBfcGF0aDQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoX3ByZXYgJiYgIXByZWZlck5leHQpIHtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBfcHJldlsxXTtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0Lm9mZnNldCA9IF9wcmV2WzBdLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBuZXh0WzFdO1xuICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg1LFxuICAgICAgICAgIG9mZnNldDogX29mZnNldCxcbiAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIGlmIChfdGV4dC5sZW5ndGggPT09IDApIGJyZWFrO1xuXG4gICAgICAgIHZhciBfbm9kZTQgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aDUpO1xuXG4gICAgICAgIHZhciBfYmVmb3JlID0gX25vZGU0LnRleHQuc2xpY2UoMCwgX29mZnNldCk7XG5cbiAgICAgICAgdmFyIF9hZnRlciA9IF9ub2RlNC50ZXh0LnNsaWNlKF9vZmZzZXQgKyBfdGV4dC5sZW5ndGgpO1xuXG4gICAgICAgIF9ub2RlNC50ZXh0ID0gX2JlZm9yZSArIF9hZnRlcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDUsIF9rZXk1XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk1XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ1LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg2LFxuICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgaWYgKF9wYXRoNi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHByb3BlcnRpZXMgb24gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGU1ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDYpO1xuXG4gICAgICAgIGZvciAodmFyIF9rZXk2IGluIG5ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoX2tleTYgPT09ICdjaGlsZHJlbicgfHwgX2tleTYgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB0aGUgXFxcIlwiLmNvbmNhdChfa2V5NiwgXCJcXFwiIHByb3BlcnR5IG9mIG5vZGVzIVwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbHVlID0gbmV3UHJvcGVydGllc1tfa2V5Nl07XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIF9ub2RlNVtfa2V5Nl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9ub2RlNVtfa2V5Nl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gcHJvcGVydGllcyB0aGF0IHdlcmUgcHJldmlvdXNseSBkZWZpbmVkLCBidXQgYXJlIG5vdyBtaXNzaW5nLCBtdXN0IGJlIGRlbGV0ZWRcblxuXG4gICAgICAgIGZvciAodmFyIF9rZXk3IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoX2tleTcpKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk3XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgIHNlbGVjdGlvbiA9IF9uZXdQcm9wZXJ0aWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKF9uZXdQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gaW5jb21wbGV0ZSBcXFwic2V0X3NlbGVjdGlvblxcXCIgb3BlcmF0aW9uIHByb3BlcnRpZXMgXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbmV3UHJvcGVydGllcyksIFwiIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudCBzZWxlY3Rpb24uXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0aW9uID0gX29iamVjdFNwcmVhZCQzKHt9LCBfbmV3UHJvcGVydGllcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2tleTggaW4gX25ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciBfdmFsdWUgPSBfbmV3UHJvcGVydGllc1tfa2V5OF07XG5cbiAgICAgICAgICAgIGlmIChfdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoX2tleTggPT09ICdhbmNob3InIHx8IF9rZXk4ID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgXFxcIlwiLmNvbmNhdChfa2V5OCwgXCJcXFwiIHNlbGVjdGlvbiBwcm9wZXJ0eVwiKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWxldGUgc2VsZWN0aW9uW19rZXk4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5OF0gPSBfdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDcsXG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgcHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChfcGF0aDcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcInNwbGl0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGg3LCBcIl0gYmVjYXVzZSB0aGUgcm9vdCBub2RlIGNhbm5vdCBiZSBzcGxpdC5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9ub2RlNiA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGg3KTtcblxuICAgICAgICB2YXIgX3BhcmVudDQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNyk7XG5cbiAgICAgICAgdmFyIF9pbmRleDQgPSBfcGF0aDdbX3BhdGg3Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbmV3Tm9kZTtcblxuICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGU2KSkge1xuICAgICAgICAgIHZhciBfYmVmb3JlMiA9IF9ub2RlNi50ZXh0LnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICAgIHZhciBfYWZ0ZXIyID0gX25vZGU2LnRleHQuc2xpY2UocG9zaXRpb24pO1xuXG4gICAgICAgICAgX25vZGU2LnRleHQgPSBfYmVmb3JlMjtcbiAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgX3Byb3BlcnRpZXMpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogX2FmdGVyMlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfYmVmb3JlMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZSgwLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICB2YXIgX2FmdGVyMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICBfbm9kZTYuY2hpbGRyZW4gPSBfYmVmb3JlMztcbiAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgX3Byb3BlcnRpZXMpLCB7fSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IF9hZnRlcjNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wYXJlbnQ0LmNoaWxkcmVuLnNwbGljZShfaW5kZXg0ICsgMSwgMCwgbmV3Tm9kZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ2LCBfa2V5OV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5OV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Niwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXG52YXIgR2VuZXJhbFRyYW5zZm9ybXMgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgZWRpdG9yIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKGVkaXRvciwgb3ApIHtcbiAgICBlZGl0b3IuY2hpbGRyZW4gPSBjcmVhdGVEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uICYmIGNyZWF0ZURyYWZ0KGVkaXRvci5zZWxlY3Rpb24pO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGVjdGlvbiA9IGFwcGx5VG9EcmFmdChlZGl0b3IsIHNlbGVjdGlvbiwgb3ApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlZGl0b3IuY2hpbGRyZW4gPSBmaW5pc2hEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBpc0RyYWZ0KHNlbGVjdGlvbikgPyBmaW5pc2hEcmFmdChzZWxlY3Rpb24pIDogc2VsZWN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJjaGlsZHJlblwiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBOb2RlVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogSW5zZXJ0IG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIEVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2Rlcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBzZWxlY3RcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoTm9kZS5pc05vZGUobm9kZXMpKSB7XG4gICAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBbbm9kZV0gPSBub2RlczsgLy8gQnkgZGVmYXVsdCwgdXNlIHRoZSBzZWxlY3Rpb24gYXMgdGhlIHRhcmdldCBsb2NhdGlvbi4gQnV0IGlmIHRoZXJlIGlzXG4gICAgICAvLyBubyBzZWxlY3Rpb24sIGluc2VydCBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCBzaW5jZSB0aGF0IGlzIHN1Y2ggYVxuICAgICAgLy8gY29tbW9uIHVzZSBjYXNlIHdoZW4gaW5zZXJ0aW5nIGZyb20gYSBub24tc2VsZWN0ZWQgc3RhdGUuXG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXQgPSBbMF07XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ID09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbiA9PiBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgW2VudHJ5XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQucGF0aCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBbLCBfbWF0Y2hQYXRoXSA9IGVudHJ5O1xuICAgICAgICAgIHZhciBwYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICB2YXIgaXNBdEVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBpc0F0RW5kID8gUGF0aC5uZXh0KHBhdGgpIDogcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChhdCk7XG4gICAgICB2YXIgaW5kZXggPSBhdFthdC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhcmVudFBhdGhcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX25vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgdmFyIF9wYXRoID0gcGFyZW50UGF0aC5jb25jYXQoaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBub2RlOiBfbm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgICAgfVxuXG4gICAgICBhdCA9IFBhdGgucHJldmlvdXMoYXQpO1xuXG4gICAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBMaWZ0IG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gdXB3YXJkcyBpbiB0aGUgZG9jdW1lbnQgdHJlZSwgc3BsaXR0aW5nXHJcbiAgICogdGhlaXIgcGFyZW50IGluIHR3byBpZiBuZWNlc3NhcnkuXHJcbiAgICovXG4gIGxpZnROb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbGlmdCBub2RlIGF0IGEgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGhhcyBhIGRlcHRoIG9mIGxlc3MgdGhhbiBgMmAuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnROb2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpKTtcbiAgICAgICAgdmFyIFtwYXJlbnQsIHBhcmVudFBhdGhdID0gcGFyZW50Tm9kZUVudHJ5O1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbGVuZ3RoXG4gICAgICAgIH0gPSBwYXJlbnQuY2hpbGRyZW47XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciB0b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiB0b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IHBhcmVudFBhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIF90b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcGxpdFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgICAgICAgICB2YXIgX3RvUGF0aDIgPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogc3BsaXRQYXRoLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgyLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1lcmdlIGEgbm9kZSBhdCBhIGxvY2F0aW9uIHdpdGggdGhlIHByZXZpb3VzIG5vZGUgb2YgdGhlIHNhbWUgZGVwdGgsXHJcbiAgICogcmVtb3ZpbmcgYW55IGVtcHR5IGNvbnRhaW5pbmcgbm9kZXMgYWZ0ZXIgdGhlIG1lcmdlIGlmIG5lY2Vzc2FyeS5cclxuICAgKi9cbiAgbWVyZ2VOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbY3VycmVudF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdm9pZHMsXG4gICAgICAgIG1vZGVcbiAgICAgIH0pO1xuICAgICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdm9pZHMsXG4gICAgICAgIG1vZGVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWN1cnJlbnQgfHwgIXByZXYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgW25vZGUsIHBhdGhdID0gY3VycmVudDtcbiAgICAgIHZhciBbcHJldk5vZGUsIHByZXZQYXRoXSA9IHByZXY7XG5cbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCB8fCBwcmV2UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwcmV2UGF0aCk7XG4gICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguY29tbW9uKHBhdGgsIHByZXZQYXRoKTtcbiAgICAgIHZhciBpc1ByZXZpb3VzU2libGluZyA9IFBhdGguaXNTaWJsaW5nKHBhdGgsIHByZXZQYXRoKTtcbiAgICAgIHZhciBsZXZlbHMgPSBBcnJheS5mcm9tKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoXG4gICAgICB9KSwgX3JlZjIgPT4ge1xuICAgICAgICB2YXIgW25dID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSkuc2xpY2UoY29tbW9uUGF0aC5sZW5ndGgpLnNsaWNlKDAsIC0xKTsgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtZXJnZSB3aWxsIGxlYXZlIGFuIGFuY2VzdG9yIG9mIHRoZSBwYXRoIGVtcHR5IGFzIGFcbiAgICAgIC8vIHJlc3VsdCwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHJlbW92ZSBpdCBhZnRlciBtZXJnaW5nLlxuXG4gICAgICB2YXIgZW1wdHlBbmNlc3RvciA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgbWF0Y2g6IG4gPT4gbGV2ZWxzLmluY2x1ZGVzKG4pICYmIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIG4pXG4gICAgICB9KTtcbiAgICAgIHZhciBlbXB0eVJlZiA9IGVtcHR5QW5jZXN0b3IgJiYgRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBlbXB0eUFuY2VzdG9yWzFdKTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzO1xuICAgICAgdmFyIHBvc2l0aW9uOyAvLyBFbnN1cmUgdGhhdCB0aGUgbm9kZXMgYXJlIGVxdWl2YWxlbnQsIGFuZCBmaWd1cmUgb3V0IHdoYXQgdGhlIHBvc2l0aW9uXG4gICAgICAvLyBhbmQgZXh0cmEgcHJvcGVydGllcyBvZiB0aGUgbWVyZ2Ugd2lsbCBiZS5cblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0KHByZXZOb2RlKSkge1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQpO1xuXG4gICAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUudGV4dC5sZW5ndGg7XG4gICAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkpIHtcbiAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHRoZSBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gd2l0aCB0aGUgcHJldmlvdXMgc2libGluZyBiZWNhdXNlIGl0IGlzIG5vdCB0aGUgc2FtZSBraW5kOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldk5vZGUpKSk7XG4gICAgICB9IC8vIElmIHRoZSBub2RlIGlzbid0IGFscmVhZHkgdGhlIG5leHQgc2libGluZyBvZiB0aGUgcHJldmlvdXMgbm9kZSwgbW92ZVxuICAgICAgLy8gaXQgc28gdGhhdCBpdCBpcyBiZWZvcmUgbWVyZ2luZy5cblxuXG4gICAgICBpZiAoIWlzUHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiBuZXdQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBJZiB0aGVyZSB3YXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgYW5jZXN0b3Igb2YgdGhlIG5vZGUgdGhhdCB3YXMgbWVyZ2VkLFxuICAgICAgLy8gd2UgcmVtb3ZlIGl0IGZyb20gdGhlIHRyZWUuXG5cblxuICAgICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVtcHR5UmVmLmN1cnJlbnQsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIHRoZSB0YXJnZXQgbm9kZSB0aGF0IHdlJ3JlIG1lcmdpbmcgd2l0aCBpcyBlbXB0eSwgcmVtb3ZlIGl0IGluc3RlYWRcbiAgICAgIC8vIG9mIG1lcmdpbmcgdGhlIHR3by4gVGhpcyBpcyBhIGNvbW1vbiByaWNoIHRleHQgZWRpdG9yIGJlaGF2aW9yIHRvXG4gICAgICAvLyBwcmV2ZW50IGxvc2luZyBmb3JtYXR0aW5nIHdoZW4gZGVsZXRpbmcgZW50aXJlIG5vZGVzIHdoZW4geW91IGhhdmUgYVxuICAgICAgLy8gaGFuZ2luZyBzZWxlY3Rpb24uXG4gICAgICAvLyBpZiBwcmV2Tm9kZSBpcyBmaXJzdCBjaGlsZCBpbiBwYXJlbnQsZG9uJ3QgcmVtb3ZlIGl0LlxuXG5cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkgJiYgRWRpdG9yLmlzRW1wdHkoZWRpdG9yLCBwcmV2Tm9kZSkgfHwgVGV4dC5pc1RleHQocHJldk5vZGUpICYmIHByZXZOb2RlLnRleHQgPT09ICcnICYmIHByZXZQYXRoW3ByZXZQYXRoLmxlbmd0aCAtIDFdICE9PSAwKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHByZXZQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgICAgZW1wdHlSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNb3ZlIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uIHRvIGEgbmV3IGxvY2F0aW9uLlxyXG4gICAqL1xuICBtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHRvLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCB0byk7XG4gICAgICB2YXIgdGFyZ2V0cyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKHRhcmdldHMsIF9yZWYzID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjM7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgIHZhciBuZXdQYXRoID0gdG9SZWYuY3VycmVudDtcblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ21vdmVfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgbmV3UGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvUmVmLmN1cnJlbnQgJiYgUGF0aC5pc1NpYmxpbmcobmV3UGF0aCwgcGF0aCkgJiYgUGF0aC5pc0FmdGVyKG5ld1BhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgc2libGluZyBtb3ZlIHRvIGEgbGF0ZXIgaW5kZXgsIHRoZSBwYXRoIGF0IHRoZSBkZXN0aW5hdGlvbiBpcyBzaGlmdGVkXG4gICAgICAgICAgLy8gdG8gYmVmb3JlIHRoZSBpbnNlcnRpb24gcG9pbnQgaW5zdGVhZCBvZiBhZnRlci4gVG8gZW5zdXJlIG91ciBncm91cCBvZiBub2RlcyBhcmUgaW5zZXJ0ZWRcbiAgICAgICAgICAvLyBpbiB0aGUgY29ycmVjdCBvcmRlciB3ZSBpbmNyZW1lbnQgdG9SZWYgdG8gYWNjb3VudCBmb3IgdGhhdFxuICAgICAgICAgIHRvUmVmLmN1cnJlbnQgPSBQYXRoLm5leHQodG9SZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9SZWYudW5yZWYoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICByZW1vdmVOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2hcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXB0aHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShkZXB0aHMsIF9yZWY0ID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjQ7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGNvbXBhcmUsXG4gICAgICAgIG1lcmdlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSAmJiBFZGl0b3IubGVhZihlZGl0b3IsIGF0LmFuY2hvcilbMF0udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCBpbiBhIG5vbi1lbXB0eSBub2RlIGFuZCAnc3BsaXQnIGlzIHRydWUsIHRoZXJlJ3Mgbm90aGluZyB0b1xuICAgICAgICAgIC8vIHNldCB0aGF0IHdvbid0IGdldCBub3JtYWxpemVkIGF3YXlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHNwbGl0TW9kZSA9IG1vZGUgPT09ICdsb3dlc3QnID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCc7XG4gICAgICAgIHZhciBlbmRBdEVuZE9mTm9kZSA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGVuZCwgZW5kLnBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhZW5kQXRFbmRPZk5vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdGFydEF0U3RhcnRPZk5vZGUgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHN0YXJ0LCBzdGFydC5wYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhc3RhcnRBdFN0YXJ0T2ZOb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY29tcGFyZSkge1xuICAgICAgICBjb21wYXJlID0gKHByb3AsIG5vZGVQcm9wKSA9PiBwcm9wICE9PSBub2RlUHJvcDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTsgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNDaGFuZ2VzID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgICAgIGlmIChrID09PSAnY2hpbGRyZW4nIHx8IGsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbXBhcmUocHJvcHNba10sIG5vZGVba10pKSB7XG4gICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTsgLy8gT21pdCBuZXcgcHJvcGVydGllcyBmcm9tIHRoZSBvbGQgcHJvcGVydGllcyBsaXN0XG5cbiAgICAgICAgICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KGspKSBwcm9wZXJ0aWVzW2tdID0gbm9kZVtrXTsgLy8gT21pdCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbmV3IHByb3BlcnRpZXMgbGlzdFxuXG4gICAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBtZXJnZShub2RlW2tdLCBwcm9wc1trXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IHByb3BzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNwbGl0IHRoZSBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxyXG4gICAqL1xuICBzcGxpdE5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGFsd2F5cyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IGRlbGV0ZVJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfSAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgcGF0aCwgdGhlIGRlZmF1bHQgaGVpZ2h0LXNraXBwaW5nIGFuZCBwb3NpdGlvblxuICAgICAgLy8gY291bnRlcnMgbmVlZCB0byBhY2NvdW50IGZvciB1cyBwb3RlbnRpYWxseSBzcGxpdHRpbmcgYXQgYSBub24tbGVhZi5cblxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBwYXRoID0gYXQ7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgbWF0Y2ggPSBuID0+IG4gPT09IHBhcmVudDtcblxuICAgICAgICBoZWlnaHQgPSBwb2ludC5wYXRoLmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgYXQgPSBwb2ludDtcbiAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiZWZvcmVSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgICAgfSk7XG4gICAgICB2YXIgYWZ0ZXJSZWY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBbaGlnaGVzdF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWhpZ2hlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbnVkZ2UgPSAwO1xuXG4gICAgICAgIGlmICghdm9pZHMgJiYgdm9pZE1hdGNoKSB7XG4gICAgICAgICAgdmFyIFt2b2lkTm9kZSwgdm9pZFBhdGhdID0gdm9pZE1hdGNoO1xuXG4gICAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHZvaWROb2RlKSAmJiBlZGl0b3IuaXNJbmxpbmUodm9pZE5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCB2b2lkUGF0aCk7XG5cbiAgICAgICAgICAgIGlmICghYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIGFmdGVyUGF0aCA9IFBhdGgubmV4dCh2b2lkUGF0aCk7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB0ZXh0LCB7XG4gICAgICAgICAgICAgICAgYXQ6IGFmdGVyUGF0aCxcbiAgICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2libGluZ0hlaWdodCA9IGF0LnBhdGgubGVuZ3RoIC0gdm9pZFBhdGgubGVuZ3RoO1xuICAgICAgICAgIGhlaWdodCA9IHNpYmxpbmdIZWlnaHQgKyAxO1xuICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgICAgdmFyIGRlcHRoID0gYXQucGF0aC5sZW5ndGggLSBoZWlnaHQ7XG4gICAgICAgIHZhciBbLCBoaWdoZXN0UGF0aF0gPSBoaWdoZXN0O1xuICAgICAgICB2YXIgbG93ZXN0UGF0aCA9IGF0LnBhdGguc2xpY2UoMCwgZGVwdGgpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBoZWlnaHQgPT09IDAgPyBhdC5vZmZzZXQgOiBhdC5wYXRoW2RlcHRoXSArIG51ZGdlO1xuXG4gICAgICAgIGZvciAodmFyIFtub2RlLCBfcGF0aDJdIG9mIEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKF9wYXRoMi5sZW5ndGggPCBoaWdoZXN0UGF0aC5sZW5ndGggfHwgX3BhdGgyLmxlbmd0aCA9PT0gMCB8fCAhdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3BvaW50ID0gYmVmb3JlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpO1xuXG4gICAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpKSB7XG4gICAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IE5vZGUuZXh0cmFjdFByb3BzKG5vZGUpO1xuICAgICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgICBwYXRoOiBfcGF0aDIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3NpdGlvbiA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV0gKyAoc3BsaXQgfHwgaXNFbmQgPyAxIDogMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9wb2ludDIgPSBhZnRlclJlZi5jdXJyZW50IHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9wb2ludDIpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB2YXIgX2FmdGVyUmVmO1xuXG4gICAgICAgIGJlZm9yZVJlZi51bnJlZigpO1xuICAgICAgICAoX2FmdGVyUmVmID0gYWZ0ZXJSZWYpID09PSBudWxsIHx8IF9hZnRlclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FmdGVyUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgcHJvcGVydGllcyBvbiB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgcHJvcHMgPSBbcHJvcHNdO1xuICAgIH1cblxuICAgIHZhciBvYmogPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBvZiBwcm9wcykge1xuICAgICAgb2JqW2tleV0gPSBudWxsO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBvYmosIG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVud3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBmcm9tIGEgcGFyZW50IG5vZGUsIHNwbGl0dGluZyB0aGUgcGFyZW50IGlmXHJcbiAgICogbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGNvbnRlbnQgaW4gdGhlIHJhbmdlIGlzIHVud3JhcHBlZC5cclxuICAgKi9cbiAgdW53cmFwTm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlUmVmID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCkgOiBudWxsO1xuICAgICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBfcmVmNSA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY1O1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0gLy8gdW53cmFwTm9kZSB3aWxsIGNhbGwgbGlmdE5vZGUgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBzcGxpdHRpbmcgdGhlIG5vZGUgd2hlbiBuZXN0ZWQuXG4gICAgICAvLyBJZiB3ZSBkbyBub3QgcmV2ZXJzZSB0aGUgb3JkZXIgYW5kIGNhbGwgaXQgZnJvbSB0b3AgdG8gdGhlIGJvdHRvbSwgaXQgd2lsbCByZW1vdmUgYWxsIGJsb2Nrc1xuICAgICAgLy8gdGhhdCB3cmFwIHRhcmdldCBub2RlLiBTbyB3ZSByZXZlcnNlIHRoZSBvcmRlci5cbiAgICAgICkucmV2ZXJzZSgpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwYXRoUmVmKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHNwbGl0ICYmIHJhbmdlUmVmKSB7XG4gICAgICAgICAgcmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2VSZWYuY3VycmVudCwgcmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5saWZ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSAmJiBub2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgICBfbG9vcChwYXRoUmVmKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhbmdlUmVmKSB7XG4gICAgICAgIHJhbmdlUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogV3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBpbiBhIG5ldyBjb250YWluZXIgbm9kZSwgc3BsaXR0aW5nIHRoZSBlZGdlc1xyXG4gICAqIG9mIHRoZSByYW5nZSBmaXJzdCB0byBlbnN1cmUgdGhhdCBvbmx5IHRoZSBjb250ZW50IGluIHRoZSByYW5nZSBpcyB3cmFwcGVkLlxyXG4gICAqL1xuICB3cmFwTm9kZXMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoZWRpdG9yLCBhdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pIHx8IFRleHQuaXNUZXh0KG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJvb3RzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaDogZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpID8gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogbiA9PiBFZGl0b3IuaXNFZGl0b3IobiksXG4gICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpO1xuXG4gICAgICBmb3IgKHZhciBbLCByb290UGF0aF0gb2Ygcm9vdHMpIHtcbiAgICAgICAgdmFyIGEgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IFJhbmdlLmludGVyc2VjdGlvbihhdCwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcm9vdFBhdGgpKSA6IGF0O1xuXG4gICAgICAgIGlmICghYSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYSxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgW2ZpcnN0XSA9IG1hdGNoZXM7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gZmlyc3Q7XG4gICAgICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gbGFzdDtcblxuICAgICAgICAgICAgaWYgKGZpcnN0UGF0aC5sZW5ndGggPT09IDAgJiYgbGFzdFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgcGFyZW50IC0gdXN1YWxseSBtZWFucyB0aGUgbm9kZSBpcyBhbiBlZGl0b3IgLSBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguZXF1YWxzKGZpcnN0UGF0aCwgbGFzdFBhdGgpID8gUGF0aC5wYXJlbnQoZmlyc3RQYXRoKSA6IFBhdGguY29tbW9uKGZpcnN0UGF0aCwgbGFzdFBhdGgpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgICB2YXIgY29tbW9uTm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBjb21tb25QYXRoKTtcbiAgICAgICAgICAgIHZhciBbY29tbW9uTm9kZV0gPSBjb21tb25Ob2RlRW50cnk7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSBjb21tb25QYXRoLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB2YXIgd3JhcHBlclBhdGggPSBQYXRoLm5leHQobGFzdFBhdGguc2xpY2UoMCwgZGVwdGgpKTtcblxuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBlbGVtZW50KSwge30sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHdyYXBwZXIsIHtcbiAgICAgICAgICAgICAgYXQ6IHdyYXBwZXJQYXRoLFxuICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzQW5jZXN0b3IoY29tbW9uTm9kZSkgJiYgY29tbW9uTm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKSxcbiAgICAgICAgICAgICAgdG86IHdyYXBwZXJQYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufTtcblxudmFyIGhhc1NpbmdsZUNoaWxkTmVzdCA9IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuXG4gICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbi8qKlxyXG4gKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIHBvaW50IGJ5IGRlbGV0aW5nIGl0J3MgY29udGVudC5cclxuICovXG5cblxudmFyIGRlbGV0ZVJhbmdlID0gKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiByYW5nZS5hbmNob3I7XG4gIH0gZWxzZSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFJlZi51bnJlZigpO1xuICB9XG59O1xuXG52YXIgbWF0Y2hQYXRoID0gKGVkaXRvciwgcGF0aCkgPT4ge1xuICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgcmV0dXJuIG4gPT4gbiA9PT0gbm9kZTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgU2VsZWN0aW9uVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogQ29sbGFwc2UgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgY29sbGFwc2UoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBlZGdlID0gJ2FuY2hvcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIHZhciBbc3RhcnRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc3RhcnQpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgZW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgZGVzZWxlY3QoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIHNlbGVjdGlvbidzIHBvaW50IGZvcndhcmQgb3IgYmFja3dhcmQuXHJcbiAgICovXG4gIG1vdmUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciB7XG4gICAgICBkaXN0YW5jZSA9IDEsXG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgZWRnZSA9IG51bGxcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBkaXN0YW5jZSxcbiAgICAgIHVuaXRcbiAgICB9O1xuICAgIHZhciBwcm9wcyA9IHt9O1xuXG4gICAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhbmNob3IsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYW5jaG9yLCBvcHRzKTtcblxuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIHByb3BzLmFuY2hvciA9IHBvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlZGdlID09IG51bGwgfHwgZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgdmFyIF9wb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgZm9jdXMsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgZm9jdXMsIG9wdHMpO1xuXG4gICAgICBpZiAoX3BvaW50KSB7XG4gICAgICAgIHByb3BzLmZvY3VzID0gX3BvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc2VsZWN0aW9uIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xuICBzZWxlY3QoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB0YXJnZXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGBudWxsYCB5b3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IGFuIGBhbmNob3JgIGFuZCBgZm9jdXNgLCBidXQgeW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeSh0YXJnZXQpKSk7XG4gICAgfVxuXG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgIG5ld1Byb3BlcnRpZXM6IHRhcmdldFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiBvbmUgb2YgdGhlIHNlbGVjdGlvbidzIHBvaW50cy5cclxuICAgKi9cbiAgc2V0UG9pbnQoZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIge1xuICAgICAgZWRnZSA9ICdib3RoJ1xuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICB2YXIgcG9pbnQgPSBlZGdlID09PSAnYW5jaG9yJyA/IGFuY2hvciA6IGZvY3VzO1xuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgW2VkZ2UgPT09ICdhbmNob3InID8gJ2FuY2hvcicgOiAnZm9jdXMnXTogX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgcG9pbnQpLCBwcm9wcylcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgb2xkUHJvcHMgPSB7fTtcbiAgICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgaWYgKGsgPT09ICdhbmNob3InICYmIHByb3BzLmFuY2hvciAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuYW5jaG9yLCBzZWxlY3Rpb24uYW5jaG9yKSB8fCBrID09PSAnZm9jdXMnICYmIHByb3BzLmZvY3VzICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5mb2N1cywgc2VsZWN0aW9uLmZvY3VzKSB8fCBrICE9PSAnYW5jaG9yJyAmJiBrICE9PSAnZm9jdXMnICYmIHByb3BzW2tdICE9PSBzZWxlY3Rpb25ba10pIHtcbiAgICAgICAgb2xkUHJvcHNba10gPSBzZWxlY3Rpb25ba107XG4gICAgICAgIG5ld1Byb3BzW2tdID0gcHJvcHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKG9sZFByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IG9sZFByb3BzLFxuICAgICAgICBuZXdQcm9wZXJ0aWVzOiBuZXdQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBUZXh0VHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogRGVsZXRlIGNvbnRlbnQgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgZGVsZXRlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICAgIGRpc3RhbmNlID0gMSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb2xsYXBzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmIFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgdmFyIGZ1cnRoZXN0Vm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0LFxuICAgICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXZvaWRzICYmIGZ1cnRoZXN0Vm9pZCkge1xuICAgICAgICAgIHZhciBbLCB2b2lkUGF0aF0gPSBmdXJ0aGVzdFZvaWQ7XG4gICAgICAgICAgYXQgPSB2b2lkUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICAgIGF0ID0ge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiB0YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhhbmdpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgIHZhciBbLCBfZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIGVuZE9mRG9jID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcblxuICAgICAgICBpZiAoIVBvaW50LmVxdWFscyhfZW5kLCBlbmRPZkRvYykpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBpc0Fjcm9zc0Jsb2NrcyA9IHN0YXJ0QmxvY2sgJiYgZW5kQmxvY2sgJiYgIVBhdGguZXF1YWxzKHN0YXJ0QmxvY2tbMV0sIGVuZEJsb2NrWzFdKTtcbiAgICAgIHZhciBpc1NpbmdsZVRleHQgPSBQYXRoLmVxdWFscyhzdGFydC5wYXRoLCBlbmQucGF0aCk7XG4gICAgICB2YXIgc3RhcnRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbmRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7IC8vIElmIHRoZSBzdGFydCBvciBlbmQgcG9pbnRzIGFyZSBpbnNpZGUgYW4gaW5saW5lIHZvaWQsIG51ZGdlIHRoZW0gb3V0LlxuXG4gICAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChiZWZvcmUgJiYgc3RhcnRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3Ioc3RhcnRCbG9ja1sxXSwgYmVmb3JlLnBhdGgpKSB7XG4gICAgICAgICAgc3RhcnQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgZW5kKTtcblxuICAgICAgICBpZiAoYWZ0ZXIgJiYgZW5kQmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKGVuZEJsb2NrWzFdLCBhZnRlci5wYXRoKSkge1xuICAgICAgICAgIGVuZCA9IGFmdGVyO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdldCB0aGUgaGlnaGVzdCBub2RlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmFuZ2UsIGFzIHdlbGwgYXNcbiAgICAgIC8vIHRoZSBzdGFydCBhbmQgZW5kIG5vZGVzLlxuXG5cbiAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICB2YXIgbGFzdFBhdGg7XG5cbiAgICAgIGZvciAodmFyIGVudHJ5IG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7XG5cbiAgICAgICAgaWYgKGxhc3RQYXRoICYmIFBhdGguY29tcGFyZShwYXRoLCBsYXN0UGF0aCkgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8ICFQYXRoLmlzQ29tbW9uKHBhdGgsIHN0YXJ0LnBhdGgpICYmICFQYXRoLmlzQ29tbW9uKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgbGFzdFBhdGggPSBwYXRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgX3JlZiA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgIHZhciByZW1vdmVkVGV4dCA9ICcnO1xuXG4gICAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgW19ub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50KTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aFxuICAgICAgICB9ID0gX3BvaW50O1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG9mZnNldFxuICAgICAgICB9ID0gc3RhcnQ7XG5cbiAgICAgICAgdmFyIHRleHQgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVtb3ZlZFRleHQgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhdGhSZWZzLnJldmVyc2UoKS5tYXAociA9PiByLnVucmVmKCkpLmZpbHRlcihyID0+IHIgIT09IG51bGwpLmZvckVhY2gocCA9PiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKCFlbmRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQyID0gZW5kUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBbX25vZGUyXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50Mik7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgIH0gPSBfcG9pbnQyO1xuXG4gICAgICAgIHZhciBfb2Zmc2V0ID0gaXNTaW5nbGVUZXh0ID8gc3RhcnQub2Zmc2V0IDogMDtcblxuICAgICAgICB2YXIgX3RleHQgPSBfbm9kZTIudGV4dC5zbGljZShfb2Zmc2V0LCBlbmQub2Zmc2V0KTtcblxuICAgICAgICBpZiAoX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgyLFxuICAgICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgICAgdGV4dDogX3RleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZW1vdmVkVGV4dCA9IF90ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNTaW5nbGVUZXh0ICYmIGlzQWNyb3NzQmxvY2tzICYmIGVuZFJlZi5jdXJyZW50ICYmIHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgICAgICBoYW5naW5nOiB0cnVlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBGb3IgVGhhaSBzY3JpcHQsIGRlbGV0aW5nIE4gY2hhcmFjdGVyKHMpIGJhY2t3YXJkIHNob3VsZCBkZWxldGVcbiAgICAgIC8vIE4gY29kZSBwb2ludChzKSBpbnN0ZWFkIG9mIGFuIGVudGlyZSBncmFwaGVtZSBjbHVzdGVyLlxuICAgICAgLy8gVGhlcmVmb3JlLCB0aGUgcmVtYWluaW5nIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbnNlcnRlZCBiYWNrLlxuXG5cbiAgICAgIGlmIChpc0NvbGxhcHNlZCAmJiByZXZlcnNlICYmIHVuaXQgPT09ICdjaGFyYWN0ZXInICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCA+IDEgJiYgcmVtb3ZlZFRleHQubWF0Y2goL1tcXHUwRTAwLVxcdTBFN0ZdKy8pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIHJlbW92ZWRUZXh0LnNsaWNlKDAsIHJlbW92ZWRUZXh0Lmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydFVucmVmID0gc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgIHZhciBlbmRVbnJlZiA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IHN0YXJ0VW5yZWYgfHwgZW5kVW5yZWYgOiBlbmRVbnJlZiB8fCBzdGFydFVucmVmO1xuXG4gICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsICYmIHBvaW50KSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIGZyYWdtZW50IGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghZnJhZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXRcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gSWYgdGhlIGluc2VydCBwb2ludCBpcyBhdCB0aGUgZWRnZSBvZiBhbiBpbmxpbmUgbm9kZSwgbW92ZSBpdCBvdXRzaWRlXG4gICAgICAvLyBpbnN0ZWFkIHNpbmNlIGl0IHdpbGwgbmVlZCB0byBiZSBzcGxpdCBvdGhlcndpc2UuXG5cblxuICAgICAgdmFyIGlubGluZUVsZW1lbnRNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlubGluZUVsZW1lbnRNYXRjaCkge1xuICAgICAgICB2YXIgWywgX2lubGluZVBhdGhdID0gaW5saW5lRWxlbWVudE1hdGNoO1xuXG4gICAgICAgIGlmIChFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgX2lubGluZVBhdGgpO1xuICAgICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgICAgYXQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrTWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIGF0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgWywgYmxvY2tQYXRoXSA9IGJsb2NrTWF0Y2g7XG4gICAgICB2YXIgaXNCbG9ja1N0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICAgIHZhciBpc0Jsb2NrRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgICB2YXIgaXNCbG9ja0VtcHR5ID0gaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgICB2YXIgbWVyZ2VTdGFydCA9ICFpc0Jsb2NrU3RhcnQgfHwgaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgICB2YXIgbWVyZ2VFbmQgPSAhaXNCbG9ja0VuZDtcbiAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pO1xuICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pO1xuICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgICAgdmFyIG1hdGNoZXIgPSBfcmVmMiA9PiB7XG4gICAgICAgIHZhciBbbiwgcF0gPSBfcmVmMjtcbiAgICAgICAgdmFyIGlzUm9vdCA9IHAubGVuZ3RoID09PSAwO1xuXG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbG9ja0VtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VTdGFydCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgZmlyc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lcmdlRW5kICYmIFBhdGguaXNBbmNlc3RvcihwLCBsYXN0UGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgZW50cnkgb2YgTm9kZS5ub2Rlcyh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwge1xuICAgICAgICBwYXNzOiBtYXRjaGVyXG4gICAgICB9KSkge1xuICAgICAgICBpZiAobWF0Y2hlcihlbnRyeSkpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydHMgPSBbXTtcbiAgICAgIHZhciBtaWRkbGVzID0gW107XG4gICAgICB2YXIgZW5kcyA9IFtdO1xuICAgICAgdmFyIHN0YXJ0aW5nID0gdHJ1ZTtcbiAgICAgIHZhciBoYXNCbG9ja3MgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgW25vZGVdIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgICAgICBzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgIGhhc0Jsb2NrcyA9IHRydWU7XG4gICAgICAgICAgbWlkZGxlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgICAgc3RhcnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbaW5saW5lTWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIFssIGlubGluZVBhdGhdID0gaW5saW5lTWF0Y2g7XG4gICAgICB2YXIgaXNJbmxpbmVTdGFydCA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgICAgdmFyIGlzSW5saW5lRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgICAgdmFyIG1pZGRsZVJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNCbG9ja0VuZCAmJiAhZW5kcy5sZW5ndGggPyBQYXRoLm5leHQoYmxvY2tQYXRoKSA6IGJsb2NrUGF0aCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBpc0lubGluZUVuZCA/IFBhdGgubmV4dChpbmxpbmVQYXRoKSA6IGlubGluZVBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gaGFzQmxvY2tzID8gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSA6IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiBoYXNCbG9ja3MgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JyxcbiAgICAgICAgYWx3YXlzOiBoYXNCbG9ja3MgJiYgKCFpc0Jsb2NrU3RhcnQgfHwgc3RhcnRzLmxlbmd0aCA+IDApICYmICghaXNCbG9ja0VuZCB8fCBlbmRzLmxlbmd0aCA+IDApLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsICFpc0lubGluZVN0YXJ0IHx8IGlzSW5saW5lU3RhcnQgJiYgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBzdGFydHMsIHtcbiAgICAgICAgYXQ6IHN0YXJ0UmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzQmxvY2tFbXB0eSAmJiAhc3RhcnRzLmxlbmd0aCAmJiBtaWRkbGVzLmxlbmd0aCAmJiAhZW5kcy5sZW5ndGgpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG1pZGRsZXMsIHtcbiAgICAgICAgYXQ6IG1pZGRsZVJlZi5jdXJyZW50LFxuICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGVuZHMsIHtcbiAgICAgICAgYXQ6IGVuZFJlZi5jdXJyZW50LFxuICAgICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5hdCkge1xuICAgICAgICB2YXIgcGF0aDtcblxuICAgICAgICBpZiAoZW5kcy5sZW5ndGggPiAwICYmIGVuZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoZW5kUmVmLmN1cnJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1pZGRsZXMubGVuZ3RoID4gMCAmJiBtaWRkbGVSZWYuY3VycmVudCkge1xuICAgICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKG1pZGRsZVJlZi5jdXJyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoc3RhcnRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBfZW5kMiA9IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX2VuZDIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICBtaWRkbGVSZWYudW5yZWYoKTtcbiAgICAgIGVuZFJlZi51bnJlZigpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIHN0cmluZyBvZiB0ZXh0IGluIHRoZSBFZGl0b3IuXHJcbiAgICovXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbmQgPSBSYW5nZS5lbmQoYXQpO1xuXG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzdGFydFJlZi51bnJlZigpO1xuICAgICAgICAgIHZhciBlbmRQb2ludCA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgICAgIGF0ID0gc3RhcnRQb2ludCB8fCBlbmRQb2ludDtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgICBmb2N1czogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBhdDtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdpbnNlcnRfdGV4dCcsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgdGV4dFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIFRyYW5zZm9ybXMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBHZW5lcmFsVHJhbnNmb3JtcyksIE5vZGVUcmFuc2Zvcm1zKSwgU2VsZWN0aW9uVHJhbnNmb3JtcyksIFRleHRUcmFuc2Zvcm1zKTtcblxuZXhwb3J0IHsgRWRpdG9yLCBFbGVtZW50LCBMb2NhdGlvbiwgTm9kZSwgT3BlcmF0aW9uLCBQYXRoLCBQYXRoUmVmLCBQb2ludCwgUG9pbnRSZWYsIFJhbmdlLCBSYW5nZVJlZiwgU2NydWJiZXIsIFNwYW4sIFRleHQsIFRyYW5zZm9ybXMsIGNyZWF0ZUVkaXRvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOlsiaXNQbGFpbk9iamVjdCIsInByb2R1Y2UiLCJjcmVhdGVEcmFmdCIsImZpbmlzaERyYWZ0IiwiaXNEcmFmdCIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJESVJUWV9QQVRIUyIsIldlYWtNYXAiLCJESVJUWV9QQVRIX0tFWVMiLCJGTFVTSElORyIsIk5PUk1BTElaSU5HIiwiUEFUSF9SRUZTIiwiUE9JTlRfUkVGUyIsIlJBTkdFX1JFRlMiLCJvd25LZXlzJDkiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCQ5IiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVkaXRvciIsImVkaXRvciIsImNoaWxkcmVuIiwib3BlcmF0aW9ucyIsInNlbGVjdGlvbiIsIm1hcmtzIiwiaXNJbmxpbmUiLCJpc1ZvaWQiLCJtYXJrYWJsZVZvaWQiLCJvbkNoYW5nZSIsIm9wIiwicmVmIiwiRWRpdG9yIiwicGF0aFJlZnMiLCJQYXRoUmVmIiwidHJhbnNmb3JtIiwiX3JlZiIsInBvaW50UmVmcyIsIlBvaW50UmVmIiwiX3JlZjIiLCJyYW5nZVJlZnMiLCJSYW5nZVJlZiIsIm9sZERpcnR5UGF0aHMiLCJnZXQiLCJvbGREaXJ0eVBhdGhLZXlzIiwiU2V0IiwiZGlydHlQYXRocyIsImRpcnR5UGF0aEtleXMiLCJhZGQiLCJwYXRoIiwiam9pbiIsImhhcyIsIlBhdGgiLCJvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoIiwibmV3UGF0aCIsIm5ld0RpcnR5UGF0aHMiLCJnZXREaXJ0eVBhdGhzIiwiX3BhdGgiLCJzZXQiLCJUcmFuc2Zvcm1zIiwibm9ybWFsaXplIiwib3BlcmF0aW9uIiwidHlwZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImFkZE1hcmsiLCJtYXRjaCIsIm5vZGUiLCJUZXh0IiwiaXNUZXh0IiwicGFyZW50Tm9kZSIsInBhcmVudFBhdGgiLCJwYXJlbnQiLCJleHBhbmRlZFNlbGVjdGlvbiIsIlJhbmdlIiwiaXNFeHBhbmRlZCIsIm1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQiLCJzZWxlY3RlZE5vZGUiLCJzZWxlY3RlZFBhdGgiLCJzZXROb2RlcyIsInNwbGl0Iiwidm9pZHMiLCJkZWxldGVCYWNrd2FyZCIsInVuaXQiLCJpc0NvbGxhcHNlZCIsImRlbGV0ZSIsInJldmVyc2UiLCJkZWxldGVGb3J3YXJkIiwiZGVsZXRlRnJhZ21lbnQiLCJkaXJlY3Rpb24iLCJnZXRGcmFnbWVudCIsIk5vZGUiLCJmcmFnbWVudCIsImluc2VydEJyZWFrIiwic3BsaXROb2RlcyIsImFsd2F5cyIsImluc2VydFNvZnRCcmVhayIsImluc2VydEZyYWdtZW50IiwiaW5zZXJ0Tm9kZSIsImluc2VydE5vZGVzIiwiaW5zZXJ0VGV4dCIsInRleHQiLCJub3JtYWxpemVOb2RlIiwiZW50cnkiLCJFbGVtZW50IiwiaXNFbGVtZW50IiwiY2hpbGQiLCJhdCIsImNvbmNhdCIsInNob3VsZEhhdmVJbmxpbmVzIiwiaXNFZGl0b3IiLCJuIiwiY3VycmVudE5vZGUiLCJfY2hpbGQiLCJwcmV2IiwiaXNMYXN0IiwiaXNJbmxpbmVPclRleHQiLCJyZW1vdmVOb2RlcyIsIm5ld0NoaWxkIiwiX25ld0NoaWxkIiwiZXF1YWxzIiwibG9vc2UiLCJtZXJnZU5vZGVzIiwicmVtb3ZlTWFyayIsInVuc2V0Tm9kZXMiLCJsZXZlbHMiLCJfcGF0aDIiLCJkZXNjZW5kYW50cyIsIkFycmF5IiwiZnJvbSIsIm5vZGVzIiwiX3JlZjMiLCJwIiwiX3BhdGgzIiwiYW5jZXN0b3JzIiwicHJldmlvdXNQYXRoIiwicHJldmlvdXMiLCJfcGF0aDQiLCJvbGRBbmNlc3RvcnMiLCJuZXdBbmNlc3RvcnMiLCJhbmNlc3RvciIsIl9hbmNlc3RvciIsIl9wIiwibmV3UGFyZW50IiwibmV3SW5kZXgiLCJyZXN1bHRQYXRoIiwiX3BhdGg1IiwiX2FuY2VzdG9ycyIsIl9wYXRoNiIsIl9sZXZlbHMiLCJuZXh0UGF0aCIsIm5leHQiLCJzaG91bGROb3JtYWxpemUiLCJfcmVmNCIsIml0ZXJhdGlvbiIsImluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoIiwibWF4SXRlcmF0aW9ucyIsIkVycm9yIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJpbmRleE9mIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlU3ltYm9sS2V5cyIsInByb3RvdHlwZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY2FsbCIsImdldENoYXJhY3RlckRpc3RhbmNlIiwic3RyIiwiaXNSVEwiLCJ1bmRlZmluZWQiLCJpc0xUUiIsImNvZGVwb2ludHMiLCJjb2RlcG9pbnRzSXRlcmF0b3JSVEwiLCJsZWZ0IiwiQ29kZXBvaW50VHlwZSIsIk5vbmUiLCJyaWdodCIsImRpc3RhbmNlIiwiZ2IxMSIsImdiMTJPcjEzIiwiY2hhciIsImNvZGUiLCJjb2RlUG9pbnRBdCIsImdldENvZGVwb2ludFR5cGUiLCJpbnRlcnNlY3RzIiwiWldKIiwiRXh0UGljdCIsImVuZHNXaXRoRW1vamlaV0oiLCJzdWJzdHJpbmciLCJSSSIsImVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMiLCJpc0JvdW5kYXJ5UGFpciIsIlNQQUNFIiwiUFVOQ1RVQVRJT04iLCJDSEFNRUxFT04iLCJnZXRXb3JkRGlzdGFuY2UiLCJkaXN0Iiwic3RhcnRlZCIsImNoYXJEaXN0IiwicmVtYWluaW5nIiwic3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlIiwiaXNXb3JkQ2hhcmFjdGVyIiwic2xpY2UiLCJ0ZXN0IiwibmV4dENoYXIiLCJuZXh0UmVtYWluaW5nIiwiZW5kIiwiY2hhcjEiLCJjaGFyQXQiLCJpc0xvd1N1cnJvZ2F0ZSIsImNoYXJDb2RlQXQiLCJjaGFyMiIsImlzSGlnaFN1cnJvZ2F0ZSIsImNoYXJDb2RlIiwicmVFeHRlbmQiLCJyZVByZXBlbmQiLCJyZVNwYWNpbmdNYXJrIiwicmVMIiwicmVWIiwicmVUIiwicmVMViIsInJlTFZUIiwicmVFeHRQaWN0IiwiQW55Iiwic2VhcmNoIiwiRXh0ZW5kIiwiUHJlcGVuZCIsIlNwYWNpbmdNYXJrIiwiTCIsIlYiLCJUIiwiTFYiLCJMVlQiLCJ4IiwieSIsIk5vbkJvdW5kYXJ5UGFpcnMiLCJmaW5kSW5kZXgiLCJyIiwiZW5kaW5nRW1vamlaV0oiLCJlbmRpbmdSSXMiLCJudW1SSXMiLCJpc05vZGVMaXN0IiwiaXNBbmNlc3RvciIsImlzRWxlbWVudExpc3QiLCJpc0FycmF5IiwiZXZlcnkiLCJ2YWwiLCJpc0VsZW1lbnRQcm9wcyIsInByb3BzIiwiaXNFbGVtZW50VHlwZSIsImVsZW1lbnRWYWwiLCJlbGVtZW50S2V5IiwibWF0Y2hlcyIsImVsZW1lbnQiLCJfZXhjbHVkZWQkNCIsIl9leGNsdWRlZDIkMyIsIm93bktleXMkOCIsIl9vYmplY3RTcHJlYWQkOCIsIklTX0VESVRPUl9DQUNIRSIsImFib3ZlIiwib3B0aW9ucyIsIm1vZGUiLCJpc1JhbmdlIiwiYW5jaG9yIiwiZm9jdXMiLCJhZnRlciIsInBvaW50IiwiZWRnZSIsInJhbmdlIiwiZCIsInBvc2l0aW9ucyIsImJlZm9yZSIsInN0YXJ0IiwiZWRnZXMiLCJmaXJzdCIsImhhc0Jsb2NrcyIsInNvbWUiLCJpc0Jsb2NrIiwiaGFzSW5saW5lcyIsImhhc1RleHRzIiwiY2FjaGVkSXNFZGl0b3IiLCJPcGVyYXRpb24iLCJpc09wZXJhdGlvbkxpc3QiLCJpc0VuZCIsIlBvaW50IiwiaXNFZGdlIiwiaXNTdGFydCIsImlzRW1wdHkiLCJpc05vcm1hbGl6aW5nIiwib2Zmc2V0IiwibGFzdCIsImxlYWYiLCJfbm9kZSIsIl9yZXN0IiwibWFya2VkVm9pZCIsImJsb2NrIiwicHJldk5vZGUiLCJwcmV2UGF0aCIsImJsb2NrUGF0aCIsInJlc3QiLCJwb2ludEFmdGVyTG9jYXRpb24iLCJ0byIsInNwYW4iLCJpc1BhdGgiLCJpbmNsdWRlcyIsInVuaXZlcnNhbCIsIlNwYW4iLCJpc1NwYW4iLCJub2RlRW50cmllcyIsInBhc3MiLCJoaXQiLCJpc0xvd2VyIiwiY29tcGFyZSIsImVtaXQiLCJmb3JjZSIsImdldERpcnR5UGF0aEtleXMiLCJwb3BEaXJ0eVBhdGgiLCJwb3AiLCJhbGxQYXRocyIsImFsbFBhdGhLZXlzIiwibWFwIiwid2l0aG91dE5vcm1hbGl6aW5nIiwiZGlydHlQYXRoIiwiXyIsIl9kaXJ0eVBhdGgiLCJfZW50cnkiLCJkZXB0aCIsImZpcnN0UGF0aCIsImxhc3RQYXRoIiwiY29tbW9uIiwiaXNQb2ludCIsImhhc1BhdGgiLCJwYXRoUmVmIiwiYWZmaW5pdHkiLCJjdXJyZW50IiwidW5yZWYiLCJyZWZzIiwicG9pbnRSZWYiLCJpc05ld0Jsb2NrIiwiYmxvY2tUZXh0IiwibGVhZlRleHRSZW1haW5pbmciLCJsZWFmVGV4dE9mZnNldCIsImUiLCJzIiwic3RyaW5nIiwiaXNGaXJzdCIsImNhbGNEaXN0YW5jZSIsInBvaW50QmVmb3JlTG9jYXRpb24iLCJyYW5nZVJlZiIsInNldE5vcm1hbGl6aW5nIiwidCIsInVuaGFuZ1JhbmdlIiwiaGFzUHJldmlvdXMiLCJlbmRCbG9jayIsInNraXAiLCJpc0JlZm9yZSIsInZvaWQiLCJmbiIsIkxvY2F0aW9uIiwiaXNMb2NhdGlvbiIsIl9leGNsdWRlZCQzIiwiX2V4Y2x1ZGVkMiQyIiwiSVNfTk9ERV9MSVNUX0NBQ0hFIiwicm9vdCIsIlNjcnViYmVyIiwic3RyaW5naWZ5IiwiaW5kZXgiLCJjIiwiY2hpbGRQYXRoIiwiYW5vdGhlciIsImRlc2NlbmRhbnQiLCJlbGVtZW50cyIsImV4dHJhY3RQcm9wcyIsInByb3BlcnRpZXMiLCJuZXdSb290Iiwic3BsaWNlIiwiX2xlYWYiLCJpc05vZGUiLCJjYWNoZWRSZXN1bHQiLCJpc1RleHRQcm9wcyIsInZpc2l0ZWQiLCJpc0FmdGVyIiwibmV4dEluZGV4IiwiX25ld1BhdGgiLCJ0ZXh0cyIsIm93bktleXMkNyIsIl9vYmplY3RTcHJlYWQkNyIsImlzTm9kZU9wZXJhdGlvbiIsImlzT3BlcmF0aW9uIiwiZW5kc1dpdGgiLCJwb3NpdGlvbiIsIm5ld1Byb3BlcnRpZXMiLCJpc1NlbGVjdGlvbk9wZXJhdGlvbiIsImlzVGV4dE9wZXJhdGlvbiIsImludmVyc2UiLCJpc1NpYmxpbmciLCJpbnZlcnNlUGF0aCIsImludmVyc2VOZXdQYXRoIiwiX3Byb3BlcnRpZXMiLCJfbmV3UHJvcGVydGllcyIsInBhdGhzIiwiYXYiLCJidiIsIm1pbiIsIk1hdGgiLCJlbmRzQWZ0ZXIiLCJhcyIsImJzIiwiZW5kc0F0IiwiZW5kc0JlZm9yZSIsImlzQ2hpbGQiLCJpc0NvbW1vbiIsImlzRGVzY2VuZGFudCIsImlzUGFyZW50IiwiYWwiLCJibCIsImxpc3QiLCJyZWxhdGl2ZSIsIl9vcCIsIl9vcDIiLCJfb3AzIiwiX3Bvc2l0aW9uIiwiX29wNCIsIm9ucCIsImNvcHkiLCJvd25LZXlzJDYiLCJfb2JqZWN0U3ByZWFkJDYiLCJyZXN1bHQiLCJfZXhjbHVkZWQkMiIsIm93bktleXMkNSIsIl9vYmplY3RTcHJlYWQkNSIsImlzQmFja3dhcmQiLCJycyIsInJlIiwidHMiLCJ0ZSIsImlzQWZ0ZXJTdGFydCIsImlzQmVmb3JlRW5kIiwiaW50ZXJzZWN0aW9uIiwiczEiLCJlMSIsInMyIiwiZTIiLCJpc0ZvcndhcmQiLCJwb2ludHMiLCJhZmZpbml0eUFuY2hvciIsImFmZmluaXR5Rm9jdXMiLCJfc2NydWJiZXIiLCJzZXRTY3J1YmJlciIsInNjcnViYmVyIiwiSlNPTiIsImlzRGVlcEVxdWFsIiwiYSIsImIiLCJfa2V5IiwiX2V4Y2x1ZGVkJDEiLCJfZXhjbHVkZWQyJDEiLCJvd25LZXlzJDQiLCJfb2JqZWN0U3ByZWFkJDQiLCJvbWl0VGV4dCIsImlzVGV4dExpc3QiLCJoYXNPd25Qcm9wZXJ0eSIsImRlY29yYXRpb25zIiwibGVhdmVzIiwiZGVjIiwibGVhZkVuZCIsImRlY29yYXRpb25TdGFydCIsImRlY29yYXRpb25FbmQiLCJsZWFmU3RhcnQiLCJhc3NpZ24iLCJtaWRkbGUiLCJvZmYiLCJfb2ZmIiwib3duS2V5cyQzIiwiX29iamVjdFNwcmVhZCQzIiwiYXBwbHlUb0RyYWZ0IiwiX3BvaW50IiwiX25vZGUyIiwiX3BhcmVudCIsIl9pbmRleCIsIl9wb2ludDIiLCJfa2V5MiIsIl9ub2RlMyIsIl9wYXJlbnQyIiwiX2luZGV4MiIsInRydWVQYXRoIiwiX3BvaW50MyIsIl9rZXkzIiwiX2luZGV4MyIsIl9wYXJlbnQzIiwiX3BvaW50NCIsIl9rZXk0IiwiX3ByZXYiLCJwcmVmZXJOZXh0IiwiX29mZnNldCIsIl90ZXh0IiwiX25vZGU0IiwiX2JlZm9yZSIsIl9hZnRlciIsIl9wb2ludDUiLCJfa2V5NSIsIl9ub2RlNSIsIl9rZXk2IiwiX2tleTciLCJfa2V5OCIsIl92YWx1ZSIsIl9wYXRoNyIsIl9ub2RlNiIsIl9wYXJlbnQ0IiwiX2luZGV4NCIsIm5ld05vZGUiLCJfYmVmb3JlMiIsIl9hZnRlcjIiLCJfYmVmb3JlMyIsIl9hZnRlcjMiLCJfcG9pbnQ2IiwiX2tleTkiLCJHZW5lcmFsVHJhbnNmb3JtcyIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJvd25LZXlzJDIiLCJfb2JqZWN0U3ByZWFkJDIiLCJOb2RlVHJhbnNmb3JtcyIsImhhbmdpbmciLCJzZWxlY3QiLCJfbWF0Y2hQYXRoIiwiaXNBdEVuZCIsImxpZnROb2RlcyIsIm1hdGNoUGF0aCIsInBhcmVudE5vZGVFbnRyeSIsInRvUGF0aCIsIm1vdmVOb2RlcyIsIl90b1BhdGgiLCJzcGxpdFBhdGgiLCJfdG9QYXRoMiIsImNvbW1vblBhdGgiLCJpc1ByZXZpb3VzU2libGluZyIsImVtcHR5QW5jZXN0b3IiLCJoYXNTaW5nbGVDaGlsZE5lc3QiLCJlbXB0eVJlZiIsInRvUmVmIiwidGFyZ2V0cyIsImRlcHRocyIsIm1lcmdlIiwic3BsaXRNb2RlIiwiZW5kQXRFbmRPZk5vZGUiLCJzdGFydEF0U3RhcnRPZk5vZGUiLCJwcm9wIiwibm9kZVByb3AiLCJoYXNDaGFuZ2VzIiwiayIsImhlaWdodCIsImRlbGV0ZVJhbmdlIiwiYmVmb3JlUmVmIiwiYWZ0ZXJSZWYiLCJoaWdoZXN0Iiwidm9pZE1hdGNoIiwibnVkZ2UiLCJ2b2lkTm9kZSIsInZvaWRQYXRoIiwiYWZ0ZXJQYXRoIiwic2libGluZ0hlaWdodCIsImhpZ2hlc3RQYXRoIiwibG93ZXN0UGF0aCIsIl9hZnRlclJlZiIsInVud3JhcE5vZGVzIiwiX3JlZjUiLCJfbG9vcCIsIndyYXBOb2RlcyIsInJvb3RzIiwicm9vdFBhdGgiLCJfcmV0IiwiY29tbW9uTm9kZUVudHJ5IiwiY29tbW9uTm9kZSIsIndyYXBwZXJQYXRoIiwid3JhcHBlciIsIm93bktleXMkMSIsIl9vYmplY3RTcHJlYWQkMSIsIlNlbGVjdGlvblRyYW5zZm9ybXMiLCJjb2xsYXBzZSIsImRlc2VsZWN0IiwibW92ZSIsIm9wdHMiLCJzZXRTZWxlY3Rpb24iLCJzZXRQb2ludCIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJUZXh0VHJhbnNmb3JtcyIsImZ1cnRoZXN0Vm9pZCIsIl9lbmQiLCJlbmRPZkRvYyIsInN0YXJ0QmxvY2siLCJpc0Fjcm9zc0Jsb2NrcyIsImlzU2luZ2xlVGV4dCIsInN0YXJ0Vm9pZCIsImVuZFZvaWQiLCJzdGFydFJlZiIsImVuZFJlZiIsInJlbW92ZWRUZXh0Iiwic3RhcnRVbnJlZiIsImVuZFVucmVmIiwiaW5saW5lRWxlbWVudE1hdGNoIiwiX2lubGluZVBhdGgiLCJibG9ja01hdGNoIiwiaXNCbG9ja1N0YXJ0IiwiaXNCbG9ja0VuZCIsImlzQmxvY2tFbXB0eSIsIm1lcmdlU3RhcnQiLCJtZXJnZUVuZCIsIm1hdGNoZXIiLCJpc1Jvb3QiLCJzdGFydHMiLCJtaWRkbGVzIiwiZW5kcyIsInN0YXJ0aW5nIiwiaW5saW5lTWF0Y2giLCJpbmxpbmVQYXRoIiwiaXNJbmxpbmVTdGFydCIsImlzSW5saW5lRW5kIiwibWlkZGxlUmVmIiwiX2VuZDIiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJvd25LZXlzIiwiX29iamVjdFNwcmVhZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate/dist/index.es.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/slate/dist/index.es.js":
/*!*********************************************!*\
  !*** ./node_modules/slate/dist/index.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Operation: () => (/* binding */ Operation),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathRef: () => (/* binding */ PathRef),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PointRef: () => (/* binding */ PointRef),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeRef: () => (/* binding */ RangeRef),\n/* harmony export */   Scrubber: () => (/* binding */ Scrubber),\n/* harmony export */   Span: () => (/* binding */ Span),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transforms: () => (/* binding */ Transforms),\n/* harmony export */   createEditor: () => (/* binding */ createEditor)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"(rsc)/./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immer */ \"(rsc)/./node_modules/immer/dist/immer.esm.mjs\");\n\n\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\nfunction ownKeys$9(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$9(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$9(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$9(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * Create a new Slate `Editor` object.\r\n */ var createEditor = ()=>{\n    var editor = {\n        children: [],\n        operations: [],\n        selection: null,\n        marks: null,\n        isInline: ()=>false,\n        isVoid: ()=>false,\n        markableVoid: ()=>false,\n        onChange: ()=>{},\n        apply: (op)=>{\n            for (var ref of Editor.pathRefs(editor)){\n                PathRef.transform(ref, op);\n            }\n            for (var _ref of Editor.pointRefs(editor)){\n                PointRef.transform(_ref, op);\n            }\n            for (var _ref2 of Editor.rangeRefs(editor)){\n                RangeRef.transform(_ref2, op);\n            }\n            var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n            var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n            var dirtyPaths;\n            var dirtyPathKeys;\n            var add = (path)=>{\n                if (path) {\n                    var key = path.join(\",\");\n                    if (!dirtyPathKeys.has(key)) {\n                        dirtyPathKeys.add(key);\n                        dirtyPaths.push(path);\n                    }\n                }\n            };\n            if (Path.operationCanTransformPath(op)) {\n                dirtyPaths = [];\n                dirtyPathKeys = new Set();\n                for (var path of oldDirtyPaths){\n                    var newPath = Path.transform(path, op);\n                    add(newPath);\n                }\n            } else {\n                dirtyPaths = oldDirtyPaths;\n                dirtyPathKeys = oldDirtyPathKeys;\n            }\n            var newDirtyPaths = editor.getDirtyPaths(op);\n            for (var _path of newDirtyPaths){\n                add(_path);\n            }\n            DIRTY_PATHS.set(editor, dirtyPaths);\n            DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n            Transforms.transform(editor, op);\n            editor.operations.push(op);\n            Editor.normalize(editor, {\n                operation: op\n            }); // Clear any formats applied to the cursor if the selection changes.\n            if (op.type === \"set_selection\") {\n                editor.marks = null;\n            }\n            if (!FLUSHING.get(editor)) {\n                FLUSHING.set(editor, true);\n                Promise.resolve().then(()=>{\n                    FLUSHING.set(editor, false);\n                    editor.onChange({\n                        operation: op\n                    });\n                    editor.operations = [];\n                });\n            }\n        },\n        addMark: (key, value)=>{\n            var { selection, markableVoid } = editor;\n            if (selection) {\n                var match = (node, path)=>{\n                    if (!Text.isText(node)) {\n                        return false; // marks can only be applied to text\n                    }\n                    var [parentNode, parentPath] = Editor.parent(editor, path);\n                    return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n                };\n                var expandedSelection = Range.isExpanded(selection);\n                var markAcceptingVoidSelected = false;\n                if (!expandedSelection) {\n                    var [selectedNode, selectedPath] = Editor.node(editor, selection);\n                    if (selectedNode && match(selectedNode, selectedPath)) {\n                        var [parentNode] = Editor.parent(editor, selectedPath);\n                        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n                    }\n                }\n                if (expandedSelection || markAcceptingVoidSelected) {\n                    Transforms.setNodes(editor, {\n                        [key]: value\n                    }, {\n                        match,\n                        split: true,\n                        voids: true\n                    });\n                } else {\n                    var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, {\n                        [key]: value\n                    });\n                    editor.marks = marks;\n                    if (!FLUSHING.get(editor)) {\n                        editor.onChange();\n                    }\n                }\n            }\n        },\n        deleteBackward: (unit)=>{\n            var { selection } = editor;\n            if (selection && Range.isCollapsed(selection)) {\n                Transforms.delete(editor, {\n                    unit,\n                    reverse: true\n                });\n            }\n        },\n        deleteForward: (unit)=>{\n            var { selection } = editor;\n            if (selection && Range.isCollapsed(selection)) {\n                Transforms.delete(editor, {\n                    unit\n                });\n            }\n        },\n        deleteFragment: (direction)=>{\n            var { selection } = editor;\n            if (selection && Range.isExpanded(selection)) {\n                Transforms.delete(editor, {\n                    reverse: direction === \"backward\"\n                });\n            }\n        },\n        getFragment: ()=>{\n            var { selection } = editor;\n            if (selection) {\n                return Node.fragment(editor, selection);\n            }\n            return [];\n        },\n        insertBreak: ()=>{\n            Transforms.splitNodes(editor, {\n                always: true\n            });\n        },\n        insertSoftBreak: ()=>{\n            Transforms.splitNodes(editor, {\n                always: true\n            });\n        },\n        insertFragment: (fragment)=>{\n            Transforms.insertFragment(editor, fragment);\n        },\n        insertNode: (node)=>{\n            Transforms.insertNodes(editor, node);\n        },\n        insertText: (text)=>{\n            var { selection, marks } = editor;\n            if (selection) {\n                if (marks) {\n                    var node = _objectSpread$9({\n                        text\n                    }, marks);\n                    Transforms.insertNodes(editor, node);\n                } else {\n                    Transforms.insertText(editor, text);\n                }\n                editor.marks = null;\n            }\n        },\n        normalizeNode: (entry)=>{\n            var [node, path] = entry; // There are no core normalizations for text nodes.\n            if (Text.isText(node)) {\n                return;\n            } // Ensure that block and inline nodes have at least one text child.\n            if (Element.isElement(node) && node.children.length === 0) {\n                var child = {\n                    text: \"\"\n                };\n                Transforms.insertNodes(editor, child, {\n                    at: path.concat(0),\n                    voids: true\n                });\n                return;\n            } // Determine whether the node should have block or inline children.\n            var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n            // index that accounts for any added/removed nodes.\n            var n = 0;\n            for(var i = 0; i < node.children.length; i++, n++){\n                var currentNode = Node.get(editor, path);\n                if (Text.isText(currentNode)) continue;\n                var _child = node.children[i];\n                var prev = currentNode.children[n - 1];\n                var isLast = i === node.children.length - 1;\n                var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n                // that only contain block nodes. Similarly, only allow inline nodes in\n                // other inline nodes, or parent blocks that only contain inlines and\n                // text.\n                if (isInlineOrText !== shouldHaveInlines) {\n                    Transforms.removeNodes(editor, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n--;\n                } else if (Element.isElement(_child)) {\n                    // Ensure that inline nodes are surrounded by text nodes.\n                    if (editor.isInline(_child)) {\n                        if (prev == null || !Text.isText(prev)) {\n                            var newChild = {\n                                text: \"\"\n                            };\n                            Transforms.insertNodes(editor, newChild, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n++;\n                        } else if (isLast) {\n                            var _newChild = {\n                                text: \"\"\n                            };\n                            Transforms.insertNodes(editor, _newChild, {\n                                at: path.concat(n + 1),\n                                voids: true\n                            });\n                            n++;\n                        }\n                    }\n                } else {\n                    // Merge adjacent text nodes that are empty or match.\n                    if (prev != null && Text.isText(prev)) {\n                        if (Text.equals(_child, prev, {\n                            loose: true\n                        })) {\n                            Transforms.mergeNodes(editor, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n--;\n                        } else if (prev.text === \"\") {\n                            Transforms.removeNodes(editor, {\n                                at: path.concat(n - 1),\n                                voids: true\n                            });\n                            n--;\n                        } else if (_child.text === \"\") {\n                            Transforms.removeNodes(editor, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n--;\n                        }\n                    }\n                }\n            }\n        },\n        removeMark: (key)=>{\n            var { selection } = editor;\n            if (selection) {\n                var match = (node, path)=>{\n                    if (!Text.isText(node)) {\n                        return false; // marks can only be applied to text\n                    }\n                    var [parentNode, parentPath] = Editor.parent(editor, path);\n                    return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n                };\n                var expandedSelection = Range.isExpanded(selection);\n                var markAcceptingVoidSelected = false;\n                if (!expandedSelection) {\n                    var [selectedNode, selectedPath] = Editor.node(editor, selection);\n                    if (selectedNode && match(selectedNode, selectedPath)) {\n                        var [parentNode] = Editor.parent(editor, selectedPath);\n                        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n                    }\n                }\n                if (expandedSelection || markAcceptingVoidSelected) {\n                    Transforms.unsetNodes(editor, key, {\n                        match,\n                        split: true,\n                        voids: true\n                    });\n                } else {\n                    var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n                    delete marks[key];\n                    editor.marks = marks;\n                    if (!FLUSHING.get(editor)) {\n                        editor.onChange();\n                    }\n                }\n            }\n        },\n        /**\r\n     * Get the \"dirty\" paths generated from an operation.\r\n     */ getDirtyPaths: (op)=>{\n            switch(op.type){\n                case \"insert_text\":\n                case \"remove_text\":\n                case \"set_node\":\n                    {\n                        var { path } = op;\n                        return Path.levels(path);\n                    }\n                case \"insert_node\":\n                    {\n                        var { node, path: _path2 } = op;\n                        var levels = Path.levels(_path2);\n                        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), (_ref3)=>{\n                            var [, p] = _ref3;\n                            return _path2.concat(p);\n                        });\n                        return [\n                            ...levels,\n                            ...descendants\n                        ];\n                    }\n                case \"merge_node\":\n                    {\n                        var { path: _path3 } = op;\n                        var ancestors = Path.ancestors(_path3);\n                        var previousPath = Path.previous(_path3);\n                        return [\n                            ...ancestors,\n                            previousPath\n                        ];\n                    }\n                case \"move_node\":\n                    {\n                        var { path: _path4, newPath } = op;\n                        if (Path.equals(_path4, newPath)) {\n                            return [];\n                        }\n                        var oldAncestors = [];\n                        var newAncestors = [];\n                        for (var ancestor of Path.ancestors(_path4)){\n                            var p = Path.transform(ancestor, op);\n                            oldAncestors.push(p);\n                        }\n                        for (var _ancestor of Path.ancestors(newPath)){\n                            var _p = Path.transform(_ancestor, op);\n                            newAncestors.push(_p);\n                        }\n                        var newParent = newAncestors[newAncestors.length - 1];\n                        var newIndex = newPath[newPath.length - 1];\n                        var resultPath = newParent.concat(newIndex);\n                        return [\n                            ...oldAncestors,\n                            ...newAncestors,\n                            resultPath\n                        ];\n                    }\n                case \"remove_node\":\n                    {\n                        var { path: _path5 } = op;\n                        var _ancestors = Path.ancestors(_path5);\n                        return [\n                            ..._ancestors\n                        ];\n                    }\n                case \"split_node\":\n                    {\n                        var { path: _path6 } = op;\n                        var _levels = Path.levels(_path6);\n                        var nextPath = Path.next(_path6);\n                        return [\n                            ..._levels,\n                            nextPath\n                        ];\n                    }\n                default:\n                    {\n                        return [];\n                    }\n            }\n        },\n        shouldNormalize: (_ref4)=>{\n            var { iteration, initialDirtyPathsLength } = _ref4;\n            var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n            if (iteration > maxIterations) {\n                throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n            }\n            return true;\n        }\n    };\n    return editor;\n};\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */ var getCharacterDistance = function getCharacterDistance(str) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var isLTR = !isRTL;\n    var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n    var left = CodepointType.None;\n    var right = CodepointType.None;\n    var distance = 0; // Evaluation of these conditions are deferred.\n    var gb11 = null; // Is GB11 applicable?\n    var gb12Or13 = null; // Is GB12 or GB13 applicable?\n    for (var char of codepoints){\n        var code = char.codePointAt(0);\n        if (!code) break;\n        var type = getCodepointType(char, code);\n        [left, right] = isLTR ? [\n            right,\n            type\n        ] : [\n            type,\n            left\n        ];\n        if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n            if (isLTR) {\n                gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n            } else {\n                gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n            }\n            if (!gb11) break;\n        }\n        if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n            if (gb12Or13 !== null) {\n                gb12Or13 = !gb12Or13;\n            } else {\n                if (isLTR) {\n                    gb12Or13 = true;\n                } else {\n                    gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n                }\n            }\n            if (!gb12Or13) break;\n        }\n        if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n            break;\n        }\n        distance += char.length;\n    }\n    return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */ var getWordDistance = function getWordDistance(text) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var dist = 0;\n    var started = false;\n    while(text.length > 0){\n        var charDist = getCharacterDistance(text, isRTL);\n        var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n        if (isWordCharacter(char, remaining, isRTL)) {\n            started = true;\n            dist += charDist;\n        } else if (!started) {\n            dist += charDist;\n        } else {\n            break;\n        }\n        text = remaining;\n    }\n    return dist;\n};\n/**\r\n * Split a string in two parts at a given distance starting from the end when\r\n * `isRTL` is set to `true`.\r\n */ var splitByCharacterDistance = (str, dist, isRTL)=>{\n    if (isRTL) {\n        var at = str.length - dist;\n        return [\n            str.slice(at, str.length),\n            str.slice(0, at)\n        ];\n    }\n    return [\n        str.slice(0, dist),\n        str.slice(dist)\n    ];\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */ var isWordCharacter = function isWordCharacter(char, remaining) {\n    var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (SPACE.test(char)) {\n        return false;\n    } // Chameleons count as word characters as long as they're in a word, so\n    // recurse to see if the next one is a word character or not.\n    if (CHAMELEON.test(char)) {\n        var charDist = getCharacterDistance(remaining, isRTL);\n        var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n        if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n            return true;\n        }\n    }\n    if (PUNCTUATION.test(char)) {\n        return false;\n    }\n    return true;\n};\n/**\r\n * Iterate on codepoints from right to left.\r\n */ var codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n    var end = str.length - 1;\n    for(var i = 0; i < str.length; i++){\n        var char1 = str.charAt(end - i);\n        if (isLowSurrogate(char1.charCodeAt(0))) {\n            var char2 = str.charAt(end - i - 1);\n            if (isHighSurrogate(char2.charCodeAt(0))) {\n                yield char2 + char1;\n                i++;\n                continue;\n            }\n        }\n        yield char1;\n    }\n};\n/**\r\n * Is `charCode` a high surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */ var isHighSurrogate = (charCode)=>{\n    return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\r\n * Is `charCode` a low surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */ var isLowSurrogate = (charCode)=>{\n    return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function(CodepointType) {\n    CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n    CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n    CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n    CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n    CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n    CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n    CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n    CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n    CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n    CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n    CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n    CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n    CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = (char, code)=>{\n    var type = CodepointType.Any;\n    if (char.search(reExtend) !== -1) {\n        type |= CodepointType.Extend;\n    }\n    if (code === 0x200d) {\n        type |= CodepointType.ZWJ;\n    }\n    if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n        type |= CodepointType.RI;\n    }\n    if (char.search(rePrepend) !== -1) {\n        type |= CodepointType.Prepend;\n    }\n    if (char.search(reSpacingMark) !== -1) {\n        type |= CodepointType.SpacingMark;\n    }\n    if (char.search(reL) !== -1) {\n        type |= CodepointType.L;\n    }\n    if (char.search(reV) !== -1) {\n        type |= CodepointType.V;\n    }\n    if (char.search(reT) !== -1) {\n        type |= CodepointType.T;\n    }\n    if (char.search(reLV) !== -1) {\n        type |= CodepointType.LV;\n    }\n    if (char.search(reLVT) !== -1) {\n        type |= CodepointType.LVT;\n    }\n    if (char.search(reExtPict) !== -1) {\n        type |= CodepointType.ExtPict;\n    }\n    return type;\n};\nfunction intersects(x, y) {\n    return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n    [\n        CodepointType.L,\n        CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT\n    ],\n    [\n        CodepointType.LV | CodepointType.V,\n        CodepointType.V | CodepointType.T\n    ],\n    [\n        CodepointType.LVT | CodepointType.T,\n        CodepointType.T\n    ],\n    [\n        CodepointType.Any,\n        CodepointType.Extend | CodepointType.ZWJ\n    ],\n    [\n        CodepointType.Any,\n        CodepointType.SpacingMark\n    ],\n    [\n        CodepointType.Prepend,\n        CodepointType.Any\n    ],\n    [\n        CodepointType.ZWJ,\n        CodepointType.ExtPict\n    ],\n    [\n        CodepointType.RI,\n        CodepointType.RI\n    ]\n];\nfunction isBoundaryPair(left, right) {\n    return NonBoundaryPairs.findIndex((r)=>intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = (str)=>{\n    return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = (str)=>{\n    var match = str.match(endingRIs);\n    if (match === null) {\n        return false;\n    } else {\n        // A RI is represented by a surrogate pair.\n        var numRIs = match[0].length / 2;\n        return numRIs % 2 === 1;\n    }\n};\n/**\r\n * Shared the function with isElementType utility\r\n */ var isElement = (value)=>{\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n}; // eslint-disable-next-line no-redeclare\nvar Element = {\n    /**\r\n   * Check if a value implements the 'Ancestor' interface.\r\n   */ isAncestor (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children);\n    },\n    /**\r\n   * Check if a value implements the `Element` interface.\r\n   */ isElement,\n    /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */ isElementList (value) {\n        return Array.isArray(value) && value.every((val)=>Element.isElement(val));\n    },\n    /**\r\n   * Check if a set of props is a partial of Element.\r\n   */ isElementProps (props) {\n        return props.children !== undefined;\n    },\n    /**\r\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\r\n   * Default it check to `type` key value\r\n   */ isElementType: function isElementType(value, elementVal) {\n        var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"type\";\n        return isElement(value) && value[elementKey] === elementVal;\n    },\n    /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */ matches (element, props) {\n        for(var key in props){\n            if (key === \"children\") {\n                continue;\n            }\n            if (element[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\nvar _excluded$4 = [\n    \"text\"\n], _excluded2$3 = [\n    \"text\"\n];\nfunction ownKeys$8(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$8(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$8(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$8(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar IS_EDITOR_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\nvar Editor = {\n    /**\r\n   * Get the ancestor above a location in the document.\r\n   */ above (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { voids = false, mode = \"lowest\", at = editor.selection, match } = options;\n        if (!at) {\n            return;\n        }\n        var path = Editor.path(editor, at);\n        var reverse = mode === \"lowest\";\n        for (var [n, p] of Editor.levels(editor, {\n            at: path,\n            voids,\n            match,\n            reverse\n        })){\n            if (Text.isText(n)) continue;\n            if (Range.isRange(at)) {\n                if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n                    return [\n                        n,\n                        p\n                    ];\n                }\n            } else {\n                if (!Path.equals(path, p)) {\n                    return [\n                        n,\n                        p\n                    ];\n                }\n            }\n        }\n    },\n    /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */ addMark (editor, key, value) {\n        editor.addMark(key, value);\n    },\n    /**\r\n   * Get the point after a location.\r\n   */ after (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var anchor = Editor.point(editor, at, {\n            edge: \"end\"\n        });\n        var focus = Editor.end(editor, []);\n        var range = {\n            anchor,\n            focus\n        };\n        var { distance = 1 } = options;\n        var d = 0;\n        var target;\n        for (var p of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            at: range\n        }))){\n            if (d > distance) {\n                break;\n            }\n            if (d !== 0) {\n                target = p;\n            }\n            d++;\n        }\n        return target;\n    },\n    /**\r\n   * Get the point before a location.\r\n   */ before (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var anchor = Editor.start(editor, []);\n        var focus = Editor.point(editor, at, {\n            edge: \"start\"\n        });\n        var range = {\n            anchor,\n            focus\n        };\n        var { distance = 1 } = options;\n        var d = 0;\n        var target;\n        for (var p of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            at: range,\n            reverse: true\n        }))){\n            if (d > distance) {\n                break;\n            }\n            if (d !== 0) {\n                target = p;\n            }\n            d++;\n        }\n        return target;\n    },\n    /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */ deleteBackward (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { unit = \"character\" } = options;\n        editor.deleteBackward(unit);\n    },\n    /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */ deleteForward (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { unit = \"character\" } = options;\n        editor.deleteForward(unit);\n    },\n    /**\r\n   * Delete the content in the current selection.\r\n   */ deleteFragment (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { direction = \"forward\" } = options;\n        editor.deleteFragment(direction);\n    },\n    /**\r\n   * Get the start and end points of a location.\r\n   */ edges (editor, at) {\n        return [\n            Editor.start(editor, at),\n            Editor.end(editor, at)\n        ];\n    },\n    /**\r\n   * Get the end point of a location.\r\n   */ end (editor, at) {\n        return Editor.point(editor, at, {\n            edge: \"end\"\n        });\n    },\n    /**\r\n   * Get the first node at a location.\r\n   */ first (editor, at) {\n        var path = Editor.path(editor, at, {\n            edge: \"start\"\n        });\n        return Editor.node(editor, path);\n    },\n    /**\r\n   * Get the fragment at a location.\r\n   */ fragment (editor, at) {\n        var range = Editor.range(editor, at);\n        var fragment = Node.fragment(editor, range);\n        return fragment;\n    },\n    /**\r\n   * Check if a node has block children.\r\n   */ hasBlocks (editor, element) {\n        return element.children.some((n)=>Element.isElement(n) && Editor.isBlock(editor, n));\n    },\n    /**\r\n   * Check if a node has inline and text children.\r\n   */ hasInlines (editor, element) {\n        return element.children.some((n)=>Text.isText(n) || Editor.isInline(editor, n));\n    },\n    /**\r\n   * Check if a node has text children.\r\n   */ hasTexts (editor, element) {\n        return element.children.every((n)=>Text.isText(n));\n    },\n    /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertBreak (editor) {\n        editor.insertBreak();\n    },\n    /**\r\n   * Insert a soft break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertSoftBreak (editor) {\n        editor.insertSoftBreak();\n    },\n    /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertFragment (editor, fragment) {\n        editor.insertFragment(fragment);\n    },\n    /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertNode (editor, node) {\n        editor.insertNode(node);\n    },\n    /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertText (editor, text) {\n        editor.insertText(text);\n    },\n    /**\r\n   * Check if a value is a block `Element` object.\r\n   */ isBlock (editor, value) {\n        return !editor.isInline(value);\n    },\n    /**\r\n   * Check if a value is an `Editor` object.\r\n   */ isEditor (value) {\n        var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n        if (cachedIsEditor !== undefined) {\n            return cachedIsEditor;\n        }\n        if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n            return false;\n        }\n        var isEditor = typeof value.addMark === \"function\" && typeof value.apply === \"function\" && typeof value.deleteBackward === \"function\" && typeof value.deleteForward === \"function\" && typeof value.deleteFragment === \"function\" && typeof value.insertBreak === \"function\" && typeof value.insertSoftBreak === \"function\" && typeof value.insertFragment === \"function\" && typeof value.insertNode === \"function\" && typeof value.insertText === \"function\" && typeof value.isInline === \"function\" && typeof value.isVoid === \"function\" && typeof value.normalizeNode === \"function\" && typeof value.onChange === \"function\" && typeof value.removeMark === \"function\" && typeof value.getDirtyPaths === \"function\" && (value.marks === null || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n        IS_EDITOR_CACHE.set(value, isEditor);\n        return isEditor;\n    },\n    /**\r\n   * Check if a point is the end point of a location.\r\n   */ isEnd (editor, point, at) {\n        var end = Editor.end(editor, at);\n        return Point.equals(point, end);\n    },\n    /**\r\n   * Check if a point is an edge of a location.\r\n   */ isEdge (editor, point, at) {\n        return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n    },\n    /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */ isEmpty (editor, element) {\n        var { children } = element;\n        var [first] = children;\n        return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === \"\" && !editor.isVoid(element);\n    },\n    /**\r\n   * Check if a value is an inline `Element` object.\r\n   */ isInline (editor, value) {\n        return editor.isInline(value);\n    },\n    /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */ isNormalizing (editor) {\n        var isNormalizing = NORMALIZING.get(editor);\n        return isNormalizing === undefined ? true : isNormalizing;\n    },\n    /**\r\n   * Check if a point is the start point of a location.\r\n   */ isStart (editor, point, at) {\n        // PERF: If the offset isn't `0` we know it's not the start.\n        if (point.offset !== 0) {\n            return false;\n        }\n        var start = Editor.start(editor, at);\n        return Point.equals(point, start);\n    },\n    /**\r\n   * Check if a value is a void `Element` object.\r\n   */ isVoid (editor, value) {\n        return editor.isVoid(value);\n    },\n    /**\r\n   * Get the last node at a location.\r\n   */ last (editor, at) {\n        var path = Editor.path(editor, at, {\n            edge: \"end\"\n        });\n        return Editor.node(editor, path);\n    },\n    /**\r\n   * Get the leaf text node at a location.\r\n   */ leaf (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var node = Node.leaf(editor, path);\n        return [\n            node,\n            path\n        ];\n    },\n    /**\r\n   * Iterate through all of the levels at a location.\r\n   */ *levels (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { at = editor.selection, reverse = false, voids = false } = options;\n        var { match } = options;\n        if (match == null) {\n            match = ()=>true;\n        }\n        if (!at) {\n            return;\n        }\n        var levels = [];\n        var path = Editor.path(editor, at);\n        for (var [n, p] of Node.levels(editor, path)){\n            if (!match(n, p)) {\n                continue;\n            }\n            levels.push([\n                n,\n                p\n            ]);\n            if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n                break;\n            }\n        }\n        if (reverse) {\n            levels.reverse();\n        }\n        yield* levels;\n    },\n    /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */ marks (editor) {\n        var { marks, selection } = editor;\n        if (!selection) {\n            return null;\n        }\n        if (marks) {\n            return marks;\n        }\n        if (Range.isExpanded(selection)) {\n            var [match] = Editor.nodes(editor, {\n                match: Text.isText\n            });\n            if (match) {\n                var [_node] = match;\n                var _rest = _objectWithoutProperties(_node, _excluded$4);\n                return _rest;\n            } else {\n                return {};\n            }\n        }\n        var { anchor } = selection;\n        var { path } = anchor;\n        var [node] = Editor.leaf(editor, path);\n        if (anchor.offset === 0) {\n            var prev = Editor.previous(editor, {\n                at: path,\n                match: Text.isText\n            });\n            var markedVoid = Editor.above(editor, {\n                match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n)\n            });\n            if (!markedVoid) {\n                var block = Editor.above(editor, {\n                    match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n)\n                });\n                if (prev && block) {\n                    var [prevNode, prevPath] = prev;\n                    var [, blockPath] = block;\n                    if (Path.isAncestor(blockPath, prevPath)) {\n                        node = prevNode;\n                    }\n                }\n            }\n        }\n        var rest = _objectWithoutProperties(node, _excluded2$3);\n        return rest;\n    },\n    /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */ next (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { mode = \"lowest\", voids = false } = options;\n        var { match, at = editor.selection } = options;\n        if (!at) {\n            return;\n        }\n        var pointAfterLocation = Editor.after(editor, at, {\n            voids\n        });\n        if (!pointAfterLocation) return;\n        var [, to] = Editor.last(editor, []);\n        var span = [\n            pointAfterLocation.path,\n            to\n        ];\n        if (Path.isPath(at) && at.length === 0) {\n            throw new Error(\"Cannot get the next node from the root node!\");\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                var [parent] = Editor.parent(editor, at);\n                match = (n)=>parent.children.includes(n);\n            } else {\n                match = ()=>true;\n            }\n        }\n        var [next] = Editor.nodes(editor, {\n            at: span,\n            match,\n            mode,\n            voids\n        });\n        return next;\n    },\n    /**\r\n   * Get the node at a location.\r\n   */ node (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var node = Node.get(editor, path);\n        return [\n            node,\n            path\n        ];\n    },\n    /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */ *nodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { at = editor.selection, mode = \"all\", universal = false, reverse = false, voids = false } = options;\n        var { match } = options;\n        if (!match) {\n            match = ()=>true;\n        }\n        if (!at) {\n            return;\n        }\n        var from;\n        var to;\n        if (Span.isSpan(at)) {\n            from = at[0];\n            to = at[1];\n        } else {\n            var first = Editor.path(editor, at, {\n                edge: \"start\"\n            });\n            var last = Editor.path(editor, at, {\n                edge: \"end\"\n            });\n            from = reverse ? last : first;\n            to = reverse ? first : last;\n        }\n        var nodeEntries = Node.nodes(editor, {\n            reverse,\n            from,\n            to,\n            pass: (_ref)=>{\n                var [n] = _ref;\n                return voids ? false : Element.isElement(n) && Editor.isVoid(editor, n);\n            }\n        });\n        var matches = [];\n        var hit;\n        for (var [node, path] of nodeEntries){\n            var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n            if (mode === \"highest\" && isLower) {\n                continue;\n            }\n            if (!match(node, path)) {\n                // If we've arrived at a leaf text node that is not lower than the last\n                // hit, then we've found a branch that doesn't include a match, which\n                // means the match is not universal.\n                if (universal && !isLower && Text.isText(node)) {\n                    return;\n                } else {\n                    continue;\n                }\n            } // If there's a match and it's lower than the last, update the hit.\n            if (mode === \"lowest\" && isLower) {\n                hit = [\n                    node,\n                    path\n                ];\n                continue;\n            } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n            var emit = mode === \"lowest\" ? hit : [\n                node,\n                path\n            ];\n            if (emit) {\n                if (universal) {\n                    matches.push(emit);\n                } else {\n                    yield emit;\n                }\n            }\n            hit = [\n                node,\n                path\n            ];\n        } // Since lowest is always emitting one behind, catch up at the end.\n        if (mode === \"lowest\" && hit) {\n            if (universal) {\n                matches.push(hit);\n            } else {\n                yield hit;\n            }\n        } // Universal defers to ensure that the match occurs in every branch, so we\n        // yield all of the matches after iterating.\n        if (universal) {\n            yield* matches;\n        }\n    },\n    /**\r\n   * Normalize any dirty objects in the editor.\r\n   */ normalize (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { force = false, operation } = options;\n        var getDirtyPaths = (editor)=>{\n            return DIRTY_PATHS.get(editor) || [];\n        };\n        var getDirtyPathKeys = (editor)=>{\n            return DIRTY_PATH_KEYS.get(editor) || new Set();\n        };\n        var popDirtyPath = (editor)=>{\n            var path = getDirtyPaths(editor).pop();\n            var key = path.join(\",\");\n            getDirtyPathKeys(editor).delete(key);\n            return path;\n        };\n        if (!Editor.isNormalizing(editor)) {\n            return;\n        }\n        if (force) {\n            var allPaths = Array.from(Node.nodes(editor), (_ref2)=>{\n                var [, p] = _ref2;\n                return p;\n            });\n            var allPathKeys = new Set(allPaths.map((p)=>p.join(\",\")));\n            DIRTY_PATHS.set(editor, allPaths);\n            DIRTY_PATH_KEYS.set(editor, allPathKeys);\n        }\n        if (getDirtyPaths(editor).length === 0) {\n            return;\n        }\n        Editor.withoutNormalizing(editor, ()=>{\n            /*\r\n        Fix dirty elements with no children.\r\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n        Running an initial pass avoids the catch-22 race condition.\r\n      */ for (var dirtyPath of getDirtyPaths(editor)){\n                if (Node.has(editor, dirtyPath)) {\n                    var entry = Editor.node(editor, dirtyPath);\n                    var [node, _] = entry;\n                    /*\r\n            The default normalizer inserts an empty text node in this scenario, but it can be customised.\r\n            So there is some risk here.\r\n                       As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\r\n            by definition adding children to an empty node can't cause other paths to change.\r\n          */ if (Element.isElement(node) && node.children.length === 0) {\n                        editor.normalizeNode(entry, {\n                            operation\n                        });\n                    }\n                }\n            }\n            var dirtyPaths = getDirtyPaths(editor);\n            var initialDirtyPathsLength = dirtyPaths.length;\n            var iteration = 0;\n            while(dirtyPaths.length !== 0){\n                if (!editor.shouldNormalize({\n                    dirtyPaths,\n                    iteration,\n                    initialDirtyPathsLength,\n                    operation\n                })) {\n                    return;\n                }\n                var _dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.\n                if (Node.has(editor, _dirtyPath)) {\n                    var _entry = Editor.node(editor, _dirtyPath);\n                    editor.normalizeNode(_entry, {\n                        operation\n                    });\n                }\n                iteration++;\n                dirtyPaths = getDirtyPaths(editor);\n            }\n        });\n    },\n    /**\r\n   * Get the parent node of a location.\r\n   */ parent (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var parentPath = Path.parent(path);\n        var entry = Editor.node(editor, parentPath);\n        return entry;\n    },\n    /**\r\n   * Get the path of a location.\r\n   */ path (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { depth, edge } = options;\n        if (Path.isPath(at)) {\n            if (edge === \"start\") {\n                var [, firstPath] = Node.first(editor, at);\n                at = firstPath;\n            } else if (edge === \"end\") {\n                var [, lastPath] = Node.last(editor, at);\n                at = lastPath;\n            }\n        }\n        if (Range.isRange(at)) {\n            if (edge === \"start\") {\n                at = Range.start(at);\n            } else if (edge === \"end\") {\n                at = Range.end(at);\n            } else {\n                at = Path.common(at.anchor.path, at.focus.path);\n            }\n        }\n        if (Point.isPoint(at)) {\n            at = at.path;\n        }\n        if (depth != null) {\n            at = at.slice(0, depth);\n        }\n        return at;\n    },\n    hasPath (editor, path) {\n        return Node.has(editor, path);\n    },\n    /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ pathRef (editor, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { affinity = \"forward\" } = options;\n        var ref = {\n            current: path,\n            affinity,\n            unref () {\n                var { current } = ref;\n                var pathRefs = Editor.pathRefs(editor);\n                pathRefs.delete(ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.pathRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */ pathRefs (editor) {\n        var refs = PATH_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            PATH_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Get the start or end point of a location.\r\n   */ point (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { edge = \"start\" } = options;\n        if (Path.isPath(at)) {\n            var path;\n            if (edge === \"end\") {\n                var [, lastPath] = Node.last(editor, at);\n                path = lastPath;\n            } else {\n                var [, firstPath] = Node.first(editor, at);\n                path = firstPath;\n            }\n            var node = Node.get(editor, path);\n            if (!Text.isText(node)) {\n                throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n            }\n            return {\n                path,\n                offset: edge === \"end\" ? node.text.length : 0\n            };\n        }\n        if (Range.isRange(at)) {\n            var [start, end] = Range.edges(at);\n            return edge === \"start\" ? start : end;\n        }\n        return at;\n    },\n    /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ pointRef (editor, point) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { affinity = \"forward\" } = options;\n        var ref = {\n            current: point,\n            affinity,\n            unref () {\n                var { current } = ref;\n                var pointRefs = Editor.pointRefs(editor);\n                pointRefs.delete(ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.pointRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */ pointRefs (editor) {\n        var refs = POINT_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            POINT_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Return all the positions in `at` range where a `Point` can be placed.\r\n   *\r\n   * By default, moves forward by individual offsets at a time, but\r\n   * the `unit` option can be used to to move by character, word, line, or block.\r\n   *\r\n   * The `reverse` option can be used to change iteration direction.\r\n   *\r\n   * Note: By default void nodes are treated as a single point and iteration\r\n   * will not happen inside their content unless you pass in true for the\r\n   * `voids` option, then iteration will occur.\r\n   */ *positions (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { at = editor.selection, unit = \"offset\", reverse = false, voids = false } = options;\n        if (!at) {\n            return;\n        }\n        /**\r\n     * Algorithm notes:\r\n     *\r\n     * Each step `distance` is dynamic depending on the underlying text\r\n     * and the `unit` specified.  Each step, e.g., a line or word, may\r\n     * span multiple text nodes, so we iterate through the text both on\r\n     * two levels in step-sync:\r\n     *\r\n     * `leafText` stores the text on a text leaf level, and is advanced\r\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n     *\r\n     * `blockText` stores the text on a block level, and is shortened\r\n     * by `distance` every time it is advanced.\r\n     *\r\n     * We only maintain a window of one blockText and one leafText because\r\n     * a block node always appears before all of its leaf nodes.\r\n     */ var range = Editor.range(editor, at);\n        var [start, end] = Range.edges(range);\n        var first = reverse ? end : start;\n        var isNewBlock = false;\n        var blockText = \"\";\n        var distance = 0; // Distance for leafText to catch up to blockText.\n        var leafTextRemaining = 0;\n        var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n        // of block nodes in blockText, and text nodes in leafText.\n        // Exploits the fact that nodes are sequenced in such a way that we first\n        // encounter the block node, then all of its text nodes, so when iterating\n        // through the blockText and leafText we just need to remember a window of\n        // one block node and leaf node, respectively.\n        for (var [node, path] of Editor.nodes(editor, {\n            at,\n            reverse,\n            voids\n        })){\n            /*\r\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\r\n       */ if (Element.isElement(node)) {\n                // Void nodes are a special case, so by default we will always\n                // yield their first point. If the `voids` option is set to true,\n                // then we will iterate over their content.\n                if (!voids && editor.isVoid(node)) {\n                    yield Editor.start(editor, path);\n                    continue;\n                } // Inline element nodes are ignored as they don't themselves\n                // contribute to `blockText` or `leafText` - their parent and\n                // children do.\n                if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.\n                if (Editor.hasInlines(editor, node)) {\n                    // We always exhaust block nodes before encountering a new one:\n                    //   console.assert(blockText === '',\n                    //     `blockText='${blockText}' - `+\n                    //     `not exhausted before new block node`, path)\n                    // Ensure range considered is capped to `range`, in the\n                    // start/end edge cases where block extends beyond range.\n                    // Equivalent to this, but presumably more performant:\n                    //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n                    //   blockRange = Range.intersection(range, blockRange) // intersect\n                    //   blockText = Editor.string(editor, blockRange, { voids })\n                    var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n                    var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n                    blockText = Editor.string(editor, {\n                        anchor: s,\n                        focus: e\n                    }, {\n                        voids\n                    });\n                    isNewBlock = true;\n                }\n            }\n            /*\r\n       * TEXT LEAF NODE - Iterate through text content, yielding\r\n       * positions every `distance` offset according to `unit`.\r\n       */ if (Text.isText(node)) {\n                var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n                //   console.assert(leafTextRemaining <= 0,\n                //     `leafTextRemaining=${leafTextRemaining} - `+\n                //     `not exhausted before new leaf text node`, path)\n                // Reset `leafText` counters for new text node.\n                if (isFirst) {\n                    leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n                    leafTextOffset = first.offset; // Works for reverse too.\n                } else {\n                    leafTextRemaining = node.text.length;\n                    leafTextOffset = reverse ? leafTextRemaining : 0;\n                } // Yield position at the start of node (potentially).\n                if (isFirst || isNewBlock || unit === \"offset\") {\n                    yield {\n                        path,\n                        offset: leafTextOffset\n                    };\n                    isNewBlock = false;\n                } // Yield positions every (dynamically calculated) `distance` offset.\n                while(true){\n                    // If `leafText` has caught up with `blockText` (distance=0),\n                    // and if blockText is exhausted, break to get another block node,\n                    // otherwise advance blockText forward by the new `distance`.\n                    if (distance === 0) {\n                        if (blockText === \"\") break;\n                        distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the\n                        // remaining string for the next iteration.\n                        blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n                    } // Advance `leafText` by the current `distance`.\n                    leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n                    leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n                    // and set distance to the overflow amount, so we'll (maybe)\n                    // catch up to blockText in the next leaf text node.\n                    if (leafTextRemaining < 0) {\n                        distance = -leafTextRemaining;\n                        break;\n                    } // Successfully walked `distance` offsets through `leafText`\n                    // to catch up with `blockText`, so we can reset `distance`\n                    // and yield this position in this node.\n                    distance = 0;\n                    yield {\n                        path,\n                        offset: leafTextOffset\n                    };\n                }\n            }\n        } // Proof that upon completion, we've exahusted both leaf and block text:\n        //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n        //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n        // Helper:\n        // Return the distance in offsets for a step of size `unit` on given string.\n        function calcDistance(text, unit, reverse) {\n            if (unit === \"character\") {\n                return getCharacterDistance(text, reverse);\n            } else if (unit === \"word\") {\n                return getWordDistance(text, reverse);\n            } else if (unit === \"line\" || unit === \"block\") {\n                return text.length;\n            }\n            return 1;\n        }\n    },\n    /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */ previous (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { mode = \"lowest\", voids = false } = options;\n        var { match, at = editor.selection } = options;\n        if (!at) {\n            return;\n        }\n        var pointBeforeLocation = Editor.before(editor, at, {\n            voids\n        });\n        if (!pointBeforeLocation) {\n            return;\n        }\n        var [, to] = Editor.first(editor, []); // The search location is from the start of the document to the path of\n        // the point before the location passed in\n        var span = [\n            pointBeforeLocation.path,\n            to\n        ];\n        if (Path.isPath(at) && at.length === 0) {\n            throw new Error(\"Cannot get the previous node from the root node!\");\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                var [parent] = Editor.parent(editor, at);\n                match = (n)=>parent.children.includes(n);\n            } else {\n                match = ()=>true;\n            }\n        }\n        var [previous] = Editor.nodes(editor, {\n            reverse: true,\n            at: span,\n            match,\n            mode,\n            voids\n        });\n        return previous;\n    },\n    /**\r\n   * Get a range of a location.\r\n   */ range (editor, at, to) {\n        if (Range.isRange(at) && !to) {\n            return at;\n        }\n        var start = Editor.start(editor, at);\n        var end = Editor.end(editor, to || at);\n        return {\n            anchor: start,\n            focus: end\n        };\n    },\n    /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ rangeRef (editor, range) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { affinity = \"forward\" } = options;\n        var ref = {\n            current: range,\n            affinity,\n            unref () {\n                var { current } = ref;\n                var rangeRefs = Editor.rangeRefs(editor);\n                rangeRefs.delete(ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.rangeRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */ rangeRefs (editor) {\n        var refs = RANGE_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            RANGE_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */ removeMark (editor, key) {\n        editor.removeMark(key);\n    },\n    /**\r\n   * Manually set if the editor should currently be normalizing.\r\n   *\r\n   * Note: Using this incorrectly can leave the editor in an invalid state.\r\n   *\r\n   */ setNormalizing (editor, isNormalizing) {\n        NORMALIZING.set(editor, isNormalizing);\n    },\n    /**\r\n   * Get the start point of a location.\r\n   */ start (editor, at) {\n        return Editor.point(editor, at, {\n            edge: \"start\"\n        });\n    },\n    /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: by default the text of void nodes is considered to be an empty\r\n   * string, regardless of content, unless you pass in true for the voids option\r\n   */ string (editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { voids = false } = options;\n        var range = Editor.range(editor, at);\n        var [start, end] = Range.edges(range);\n        var text = \"\";\n        for (var [node, path] of Editor.nodes(editor, {\n            at: range,\n            match: Text.isText,\n            voids\n        })){\n            var t = node.text;\n            if (Path.equals(path, end.path)) {\n                t = t.slice(0, end.offset);\n            }\n            if (Path.equals(path, start.path)) {\n                t = t.slice(start.offset);\n            }\n            text += t;\n        }\n        return text;\n    },\n    /**\r\n   * Convert a range into a non-hanging one.\r\n   */ unhangRange (editor, range) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { voids = false } = options;\n        var [start, end] = Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.\n        if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n            return range;\n        }\n        var endBlock = Editor.above(editor, {\n            at: end,\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            voids\n        });\n        var blockPath = endBlock ? endBlock[1] : [];\n        var first = Editor.start(editor, start);\n        var before = {\n            anchor: first,\n            focus: end\n        };\n        var skip = true;\n        for (var [node, path] of Editor.nodes(editor, {\n            at: before,\n            match: Text.isText,\n            reverse: true,\n            voids\n        })){\n            if (skip) {\n                skip = false;\n                continue;\n            }\n            if (node.text !== \"\" || Path.isBefore(path, blockPath)) {\n                end = {\n                    path,\n                    offset: node.text.length\n                };\n                break;\n            }\n        }\n        return {\n            anchor: start,\n            focus: end\n        };\n    },\n    /**\r\n   * Match a void node in the current branch of the editor.\r\n   */ void (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n)\n        }));\n    },\n    /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */ withoutNormalizing (editor, fn) {\n        var value = Editor.isNormalizing(editor);\n        Editor.setNormalizing(editor, false);\n        try {\n            fn();\n        } finally{\n            Editor.setNormalizing(editor, value);\n        }\n        Editor.normalize(editor);\n    }\n};\nvar Location = {\n    /**\r\n   * Check if a value implements the `Location` interface.\r\n   */ isLocation (value) {\n        return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n    }\n}; // eslint-disable-next-line no-redeclare\nvar Span = {\n    /**\r\n   * Check if a value implements the `Span` interface.\r\n   */ isSpan (value) {\n        return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n    }\n};\nvar _excluded$3 = [\n    \"children\"\n], _excluded2$2 = [\n    \"text\"\n];\nvar IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\nvar Node = {\n    /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */ ancestor (root, path) {\n        var node = Node.get(root, path);\n        if (Text.isText(node)) {\n            throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go bottom-up.\r\n   */ *ancestors (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        for (var p of Path.ancestors(path, options)){\n            var n = Node.ancestor(root, p);\n            var entry = [\n                n,\n                p\n            ];\n            yield entry;\n        }\n    },\n    /**\r\n   * Get the child of a node at a specific index.\r\n   */ child (root, index) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n        }\n        var c = root.children[index];\n        if (c == null) {\n            throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n        }\n        return c;\n    },\n    /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */ *children (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { reverse = false } = options;\n        var ancestor = Node.ancestor(root, path);\n        var { children } = ancestor;\n        var index = reverse ? children.length - 1 : 0;\n        while(reverse ? index >= 0 : index < children.length){\n            var child = Node.child(ancestor, index);\n            var childPath = path.concat(index);\n            yield [\n                child,\n                childPath\n            ];\n            index = reverse ? index - 1 : index + 1;\n        }\n    },\n    /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */ common (root, path, another) {\n        var p = Path.common(path, another);\n        var n = Node.get(root, p);\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */ descendant (root, path) {\n        var node = Node.get(root, path);\n        if (Editor.isEditor(node)) {\n            throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */ *descendants (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        for (var [node, path] of Node.nodes(root, options)){\n            if (path.length !== 0) {\n                // NOTE: we have to coerce here because checking the path's length does\n                // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n                yield [\n                    node,\n                    path\n                ];\n            }\n        }\n    },\n    /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */ *elements (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        for (var [node, path] of Node.nodes(root, options)){\n            if (Element.isElement(node)) {\n                yield [\n                    node,\n                    path\n                ];\n            }\n        }\n    },\n    /**\r\n   * Extract props from a Node.\r\n   */ extractProps (node) {\n        if (Element.isAncestor(node)) {\n            var properties = _objectWithoutProperties(node, _excluded$3);\n            return properties;\n        } else {\n            var properties = _objectWithoutProperties(node, _excluded2$2);\n            return properties;\n        }\n    },\n    /**\r\n   * Get the first node entry in a root node from a path.\r\n   */ first (root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                n = n.children[0];\n                p.push(0);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */ fragment (root, range) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n        }\n        var newRoot = (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)({\n            children: root.children\n        }, (r)=>{\n            var [start, end] = Range.edges(range);\n            var nodeEntries = Node.nodes(r, {\n                reverse: true,\n                pass: (_ref)=>{\n                    var [, path] = _ref;\n                    return !Range.includes(range, path);\n                }\n            });\n            for (var [, path] of nodeEntries){\n                if (!Range.includes(range, path)) {\n                    var parent = Node.parent(r, path);\n                    var index = path[path.length - 1];\n                    parent.children.splice(index, 1);\n                }\n                if (Path.equals(path, end.path)) {\n                    var leaf = Node.leaf(r, path);\n                    leaf.text = leaf.text.slice(0, end.offset);\n                }\n                if (Path.equals(path, start.path)) {\n                    var _leaf = Node.leaf(r, path);\n                    _leaf.text = _leaf.text.slice(start.offset);\n                }\n            }\n            if (Editor.isEditor(r)) {\n                r.selection = null;\n            }\n        });\n        return newRoot.children;\n    },\n    /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */ get (root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n            }\n            node = node.children[p];\n        }\n        return node;\n    },\n    /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */ has (root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                return false;\n            }\n            node = node.children[p];\n        }\n        return true;\n    },\n    /**\r\n   * Check if a value implements the `Node` interface.\r\n   */ isNode (value) {\n        return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n    },\n    /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */ isNodeList (value) {\n        if (!Array.isArray(value)) {\n            return false;\n        }\n        var cachedResult = IS_NODE_LIST_CACHE.get(value);\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n        var isNodeList = value.every((val)=>Node.isNode(val));\n        IS_NODE_LIST_CACHE.set(value, isNodeList);\n        return isNodeList;\n    },\n    /**\r\n   * Get the last node entry in a root node from a path.\r\n   */ last (root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                var i = n.children.length - 1;\n                n = n.children[i];\n                p.push(i);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */ leaf (root, path) {\n        var node = Node.get(root, path);\n        if (!Text.isText(node)) {\n            throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */ *levels (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        for (var p of Path.levels(path, options)){\n            var n = Node.get(root, p);\n            yield [\n                n,\n                p\n            ];\n        }\n    },\n    /**\r\n   * Check if a node matches a set of props.\r\n   */ matches (node, props) {\n        return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n    },\n    /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */ *nodes (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { pass, reverse = false } = options;\n        var { from = [], to } = options;\n        var visited = new Set();\n        var p = [];\n        var n = root;\n        while(true){\n            if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n                break;\n            }\n            if (!visited.has(n)) {\n                yield [\n                    n,\n                    p\n                ];\n            } // If we're allowed to go downward and we haven't descended yet, do.\n            if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([\n                n,\n                p\n            ]) === false)) {\n                visited.add(n);\n                var nextIndex = reverse ? n.children.length - 1 : 0;\n                if (Path.isAncestor(p, from)) {\n                    nextIndex = from[p.length];\n                }\n                p = p.concat(nextIndex);\n                n = Node.get(root, p);\n                continue;\n            } // If we're at the root and we can't go down, we're done.\n            if (p.length === 0) {\n                break;\n            } // If we're going forward...\n            if (!reverse) {\n                var newPath = Path.next(p);\n                if (Node.has(root, newPath)) {\n                    p = newPath;\n                    n = Node.get(root, p);\n                    continue;\n                }\n            } // If we're going backward...\n            if (reverse && p[p.length - 1] !== 0) {\n                var _newPath = Path.previous(p);\n                p = _newPath;\n                n = Node.get(root, p);\n                continue;\n            } // Otherwise we're going upward...\n            p = Path.parent(p);\n            n = Node.get(root, p);\n            visited.add(n);\n        }\n    },\n    /**\r\n   * Get the parent of a node at a specific path.\r\n   */ parent (root, path) {\n        var parentPath = Path.parent(path);\n        var p = Node.get(root, parentPath);\n        if (Text.isText(p)) {\n            throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n        }\n        return p;\n    },\n    /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */ string (node) {\n        if (Text.isText(node)) {\n            return node.text;\n        } else {\n            return node.children.map(Node.string).join(\"\");\n        }\n    },\n    /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */ *texts (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        for (var [node, path] of Node.nodes(root, options)){\n            if (Text.isText(node)) {\n                yield [\n                    node,\n                    path\n                ];\n            }\n        }\n    }\n};\nfunction ownKeys$7(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$7(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$7(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$7(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Operation = {\n    /**\r\n   * Check if a value is a `NodeOperation` object.\r\n   */ isNodeOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_node\");\n    },\n    /**\r\n   * Check if a value is an `Operation` object.\r\n   */ isOperation (value) {\n        if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n            return false;\n        }\n        switch(value.type){\n            case \"insert_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"insert_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"merge_node\":\n                return typeof value.position === \"number\" && Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n            case \"move_node\":\n                return Path.isPath(value.path) && Path.isPath(value.newPath);\n            case \"remove_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"remove_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"set_node\":\n                return Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n            case \"set_selection\":\n                return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n            case \"split_node\":\n                return Path.isPath(value.path) && typeof value.position === \"number\" && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n            default:\n                return false;\n        }\n    },\n    /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */ isOperationList (value) {\n        return Array.isArray(value) && value.every((val)=>Operation.isOperation(val));\n    },\n    /**\r\n   * Check if a value is a `SelectionOperation` object.\r\n   */ isSelectionOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_selection\");\n    },\n    /**\r\n   * Check if a value is a `TextOperation` object.\r\n   */ isTextOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_text\");\n    },\n    /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */ inverse (op) {\n        switch(op.type){\n            case \"insert_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"remove_node\"\n                    });\n                }\n            case \"insert_text\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"remove_text\"\n                    });\n                }\n            case \"merge_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"split_node\",\n                        path: Path.previous(op.path)\n                    });\n                }\n            case \"move_node\":\n                {\n                    var { newPath, path } = op; // PERF: in this case the move operation is a no-op anyways.\n                    if (Path.equals(newPath, path)) {\n                        return op;\n                    } // If the move happens completely within a single parent the path and\n                    // newPath are stable with respect to each other.\n                    if (Path.isSibling(path, newPath)) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            path: newPath,\n                            newPath: path\n                        });\n                    } // If the move does not happen within a single parent it is possible\n                    // for the move to impact the true path to the location where the node\n                    // was removed from and where it was inserted. We have to adjust for this\n                    // and find the original path. We can accomplish this (only in non-sibling)\n                    // moves by looking at the impact of the move operation on the node\n                    // after the original move path.\n                    var inversePath = Path.transform(path, op);\n                    var inverseNewPath = Path.transform(Path.next(path), op);\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        path: inversePath,\n                        newPath: inverseNewPath\n                    });\n                }\n            case \"remove_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"insert_node\"\n                    });\n                }\n            case \"remove_text\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"insert_text\"\n                    });\n                }\n            case \"set_node\":\n                {\n                    var { properties, newProperties } = op;\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        properties: newProperties,\n                        newProperties: properties\n                    });\n                }\n            case \"set_selection\":\n                {\n                    var { properties: _properties, newProperties: _newProperties } = op;\n                    if (_properties == null) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: null\n                        });\n                    } else if (_newProperties == null) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: null,\n                            newProperties: _properties\n                        });\n                    } else {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: _properties\n                        });\n                    }\n                }\n            case \"split_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"merge_node\",\n                        path: Path.next(op.path)\n                    });\n                }\n        }\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar Path = {\n    /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */ ancestors (path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var paths = Path.levels(path, options);\n        if (reverse) {\n            paths = paths.slice(1);\n        } else {\n            paths = paths.slice(0, -1);\n        }\n        return paths;\n    },\n    /**\r\n   * Get the common ancestor path of two paths.\r\n   */ common (path, another) {\n        var common = [];\n        for(var i = 0; i < path.length && i < another.length; i++){\n            var av = path[i];\n            var bv = another[i];\n            if (av !== bv) {\n                break;\n            }\n            common.push(av);\n        }\n        return common;\n    },\n    /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */ compare (path, another) {\n        var min = Math.min(path.length, another.length);\n        for(var i = 0; i < min; i++){\n            if (path[i] < another[i]) return -1;\n            if (path[i] > another[i]) return 1;\n        }\n        return 0;\n    },\n    /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */ endsAfter (path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av > bv;\n    },\n    /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */ endsAt (path, another) {\n        var i = path.length;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        return Path.equals(as, bs);\n    },\n    /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */ endsBefore (path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av < bv;\n    },\n    /**\r\n   * Check if a path is exactly equal to another.\r\n   */ equals (path, another) {\n        return path.length === another.length && path.every((n, i)=>n === another[i]);\n    },\n    /**\r\n   * Check if the path of previous sibling node exists\r\n   */ hasPrevious (path) {\n        return path[path.length - 1] > 0;\n    },\n    /**\r\n   * Check if a path is after another.\r\n   */ isAfter (path, another) {\n        return Path.compare(path, another) === 1;\n    },\n    /**\r\n   * Check if a path is an ancestor of another.\r\n   */ isAncestor (path, another) {\n        return path.length < another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is before another.\r\n   */ isBefore (path, another) {\n        return Path.compare(path, another) === -1;\n    },\n    /**\r\n   * Check if a path is a child of another.\r\n   */ isChild (path, another) {\n        return path.length === another.length + 1 && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */ isCommon (path, another) {\n        return path.length <= another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is a descendant of another.\r\n   */ isDescendant (path, another) {\n        return path.length > another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is the parent of another.\r\n   */ isParent (path, another) {\n        return path.length + 1 === another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check is a value implements the `Path` interface.\r\n   */ isPath (value) {\n        return Array.isArray(value) && (value.length === 0 || typeof value[0] === \"number\");\n    },\n    /**\r\n   * Check if a path is a sibling of another.\r\n   */ isSibling (path, another) {\n        if (path.length !== another.length) {\n            return false;\n        }\n        var as = path.slice(0, -1);\n        var bs = another.slice(0, -1);\n        var al = path[path.length - 1];\n        var bl = another[another.length - 1];\n        return al !== bl && Path.equals(as, bs);\n    },\n    /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */ levels (path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var list = [];\n        for(var i = 0; i <= path.length; i++){\n            list.push(path.slice(0, i));\n        }\n        if (reverse) {\n            list.reverse();\n        }\n        return list;\n    },\n    /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */ next (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n        }\n        var last = path[path.length - 1];\n        return path.slice(0, -1).concat(last + 1);\n    },\n    /**\r\n   * Returns whether this operation can affect paths or not. Used as an\r\n   * optimization when updating dirty paths during normalization\r\n   *\r\n   * NOTE: This *must* be kept in sync with the implementation of 'transform'\r\n   * below\r\n   */ operationCanTransformPath (operation) {\n        switch(operation.type){\n            case \"insert_node\":\n            case \"remove_node\":\n            case \"merge_node\":\n            case \"split_node\":\n            case \"move_node\":\n                return true;\n            default:\n                return false;\n        }\n    },\n    /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */ parent (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n        }\n        return path.slice(0, -1);\n    },\n    /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */ previous (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n        }\n        var last = path[path.length - 1];\n        if (last <= 0) {\n            throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n        }\n        return path.slice(0, -1).concat(last - 1);\n    },\n    /**\r\n   * Get a path relative to an ancestor.\r\n   */ relative (path, ancestor) {\n        if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n            throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n        }\n        return path.slice(ancestor.length);\n    },\n    /**\r\n   * Transform a path by an operation.\r\n   */ transform (path, operation) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!path) return null; // PERF: use destructing instead of immer\n        var p = [\n            ...path\n        ];\n        var { affinity = \"forward\" } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.\n        if (path.length === 0) {\n            return p;\n        }\n        switch(operation.type){\n            case \"insert_node\":\n                {\n                    var { path: op } = operation;\n                    if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n                        p[op.length - 1] += 1;\n                    }\n                    break;\n                }\n            case \"remove_node\":\n                {\n                    var { path: _op } = operation;\n                    if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n                        return null;\n                    } else if (Path.endsBefore(_op, p)) {\n                        p[_op.length - 1] -= 1;\n                    }\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var { path: _op2, position } = operation;\n                    if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                    } else if (Path.isAncestor(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                        p[_op2.length] += position;\n                    }\n                    break;\n                }\n            case \"split_node\":\n                {\n                    var { path: _op3, position: _position } = operation;\n                    if (Path.equals(_op3, p)) {\n                        if (affinity === \"forward\") {\n                            p[p.length - 1] += 1;\n                        } else if (affinity === \"backward\") ;\n                        else {\n                            return null;\n                        }\n                    } else if (Path.endsBefore(_op3, p)) {\n                        p[_op3.length - 1] += 1;\n                    } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n                        p[_op3.length - 1] += 1;\n                        p[_op3.length] -= _position;\n                    }\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var { path: _op4, newPath: onp } = operation; // If the old and new path are the same, it's a no-op.\n                    if (Path.equals(_op4, onp)) {\n                        return p;\n                    }\n                    if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n                        var copy = onp.slice();\n                        if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                            copy[_op4.length - 1] -= 1;\n                        }\n                        return copy.concat(p.slice(_op4.length));\n                    } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        } else {\n                            p[_op4.length - 1] += 1;\n                        }\n                    } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        }\n                        p[onp.length - 1] += 1;\n                    } else if (Path.endsBefore(_op4, p)) {\n                        if (Path.equals(onp, p)) {\n                            p[onp.length - 1] += 1;\n                        }\n                        p[_op4.length - 1] -= 1;\n                    }\n                    break;\n                }\n        }\n        return p;\n    }\n};\nvar PathRef = {\n    /**\r\n   * Transform the path ref's current value by an operation.\r\n   */ transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var path = Path.transform(current, op, {\n            affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nfunction ownKeys$6(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$6(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$6(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$6(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Point = {\n    /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */ compare (point, another) {\n        var result = Path.compare(point.path, another.path);\n        if (result === 0) {\n            if (point.offset < another.offset) return -1;\n            if (point.offset > another.offset) return 1;\n            return 0;\n        }\n        return result;\n    },\n    /**\r\n   * Check if a point is after another.\r\n   */ isAfter (point, another) {\n        return Point.compare(point, another) === 1;\n    },\n    /**\r\n   * Check if a point is before another.\r\n   */ isBefore (point, another) {\n        return Point.compare(point, another) === -1;\n    },\n    /**\r\n   * Check if a point is exactly equal to another.\r\n   */ equals (point, another) {\n        // PERF: ensure the offsets are equal first since they are cheaper to check.\n        return point.offset === another.offset && Path.equals(point.path, another.path);\n    },\n    /**\r\n   * Check if a value implements the `Point` interface.\r\n   */ isPoint (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.offset === \"number\" && Path.isPath(value.path);\n    },\n    /**\r\n   * Transform a point by an operation.\r\n   */ transform (point, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(point, (p)=>{\n            if (p === null) {\n                return null;\n            }\n            var { affinity = \"forward\" } = options;\n            var { path, offset } = p;\n            switch(op.type){\n                case \"insert_node\":\n                case \"move_node\":\n                    {\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"insert_text\":\n                    {\n                        if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === \"forward\")) {\n                            p.offset += op.text.length;\n                        }\n                        break;\n                    }\n                case \"merge_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            p.offset += op.position;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"remove_text\":\n                    {\n                        if (Path.equals(op.path, path) && op.offset <= offset) {\n                            p.offset -= Math.min(offset - op.offset, op.text.length);\n                        }\n                        break;\n                    }\n                case \"remove_node\":\n                    {\n                        if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n                            return null;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"split_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            if (op.position === offset && affinity == null) {\n                                return null;\n                            } else if (op.position < offset || op.position === offset && affinity === \"forward\") {\n                                p.offset -= op.position;\n                                p.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {\n                                    affinity: \"forward\"\n                                }));\n                            }\n                        } else {\n                            p.path = Path.transform(path, op, options);\n                        }\n                        break;\n                    }\n            }\n        });\n    }\n};\nvar PointRef = {\n    /**\r\n   * Transform the point ref's current value by an operation.\r\n   */ transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var point = Point.transform(current, op, {\n            affinity\n        });\n        ref.current = point;\n        if (point == null) {\n            ref.unref();\n        }\n    }\n};\nvar _excluded$2 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction ownKeys$5(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$5(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$5(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$5(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Range = {\n    /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */ edges (range) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var { anchor, focus } = range;\n        return Range.isBackward(range) === reverse ? [\n            anchor,\n            focus\n        ] : [\n            focus,\n            anchor\n        ];\n    },\n    /**\r\n   * Get the end point of a range.\r\n   */ end (range) {\n        var [, end] = Range.edges(range);\n        return end;\n    },\n    /**\r\n   * Check if a range is exactly equal to another.\r\n   */ equals (range, another) {\n        return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n    },\n    /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */ includes (range, target) {\n        if (Range.isRange(target)) {\n            if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n                return true;\n            }\n            var [rs, re] = Range.edges(range);\n            var [ts, te] = Range.edges(target);\n            return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n        }\n        var [start, end] = Range.edges(range);\n        var isAfterStart = false;\n        var isBeforeEnd = false;\n        if (Point.isPoint(target)) {\n            isAfterStart = Point.compare(target, start) >= 0;\n            isBeforeEnd = Point.compare(target, end) <= 0;\n        } else {\n            isAfterStart = Path.compare(target, start.path) >= 0;\n            isBeforeEnd = Path.compare(target, end.path) <= 0;\n        }\n        return isAfterStart && isBeforeEnd;\n    },\n    /**\r\n   * Get the intersection of a range with another.\r\n   */ intersection (range, another) {\n        var rest = _objectWithoutProperties(range, _excluded$2);\n        var [s1, e1] = Range.edges(range);\n        var [s2, e2] = Range.edges(another);\n        var start = Point.isBefore(s1, s2) ? s2 : s1;\n        var end = Point.isBefore(e1, e2) ? e1 : e2;\n        if (Point.isBefore(end, start)) {\n            return null;\n        } else {\n            return _objectSpread$5({\n                anchor: start,\n                focus: end\n            }, rest);\n        }\n    },\n    /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */ isBackward (range) {\n        var { anchor, focus } = range;\n        return Point.isAfter(anchor, focus);\n    },\n    /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */ isCollapsed (range) {\n        var { anchor, focus } = range;\n        return Point.equals(anchor, focus);\n    },\n    /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */ isExpanded (range) {\n        return !Range.isCollapsed(range);\n    },\n    /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */ isForward (range) {\n        return !Range.isBackward(range);\n    },\n    /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */ isRange (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n    },\n    /**\r\n   * Iterate through all of the point entries in a range.\r\n   */ *points (range) {\n        yield [\n            range.anchor,\n            \"anchor\"\n        ];\n        yield [\n            range.focus,\n            \"focus\"\n        ];\n    },\n    /**\r\n   * Get the start point of a range.\r\n   */ start (range) {\n        var [start] = Range.edges(range);\n        return start;\n    },\n    /**\r\n   * Transform a range by an operation.\r\n   */ transform (range, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(range, (r)=>{\n            if (r === null) {\n                return null;\n            }\n            var { affinity = \"inward\" } = options;\n            var affinityAnchor;\n            var affinityFocus;\n            if (affinity === \"inward\") {\n                // If the range is collapsed, make sure to use the same affinity to\n                // avoid the two points passing each other and expanding in the opposite\n                // direction\n                var isCollapsed = Range.isCollapsed(r);\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"backward\";\n                } else {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"forward\";\n                }\n            } else if (affinity === \"outward\") {\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = \"forward\";\n                } else {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = \"backward\";\n                }\n            } else {\n                affinityAnchor = affinity;\n                affinityFocus = affinity;\n            }\n            var anchor = Point.transform(r.anchor, op, {\n                affinity: affinityAnchor\n            });\n            var focus = Point.transform(r.focus, op, {\n                affinity: affinityFocus\n            });\n            if (!anchor || !focus) {\n                return null;\n            }\n            r.anchor = anchor;\n            r.focus = focus;\n        });\n    }\n};\nvar RangeRef = {\n    /**\r\n   * Transform the range ref's current value by an operation.\r\n   */ transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var path = Range.transform(current, op, {\n            affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nvar _scrubber = undefined;\n/**\r\n * This interface implements a stringify() function, which is used by Slate\r\n * internally when generating exceptions containing end user data. Developers\r\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\r\n * stringify() function.\r\n *\r\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\r\n *\r\n *    import { Scrubber } from 'slate';\r\n *    Scrubber.setScrubber((key, val) => {\r\n *      if (key === 'text') return '...scrubbed...'\r\n *      return val\r\n *    });\r\n *\r\n */ // eslint-disable-next-line no-redeclare\nvar Scrubber = {\n    setScrubber (scrubber) {\n        _scrubber = scrubber;\n    },\n    stringify (value) {\n        return JSON.stringify(value, _scrubber);\n    }\n};\n/*\r\n  Custom deep equal comparison for Slate nodes.\r\n\n  We don't need general purpose deep equality;\r\n  Slate only supports plain values, Arrays, and nested objects.\r\n  Complex values nested inside Arrays are not supported.\r\n\n  Slate objects are designed to be serialised, so\r\n  missing keys are deliberately normalised to undefined.\r\n */ var isDeepEqual = (node, another)=>{\n    for(var key in node){\n        var a = node[key];\n        var b = another[key];\n        if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(a) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(b)) {\n            if (!isDeepEqual(a, b)) return false;\n        } else if (Array.isArray(a) && Array.isArray(b)) {\n            if (a.length !== b.length) return false;\n            for(var i = 0; i < a.length; i++){\n                if (a[i] !== b[i]) return false;\n            }\n        } else if (a !== b) {\n            return false;\n        }\n    }\n    /*\r\n    Deep object equality is only necessary in one direction; in the reverse direction\r\n    we are only looking for keys that are missing.\r\n    As above, undefined keys are normalised to missing.\r\n  */ for(var _key in another){\n        if (node[_key] === undefined && another[_key] !== undefined) {\n            return false;\n        }\n    }\n    return true;\n};\nvar _excluded$1 = [\n    \"text\"\n], _excluded2$1 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction ownKeys$4(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$4(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$4(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$4(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Text = {\n    /**\r\n   * Check if two text nodes are equal.\r\n   *\r\n   * When loose is set, the text is not compared. This is\r\n   * used to check whether sibling text nodes can be merged.\r\n   */ equals (text, another) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { loose = false } = options;\n        function omitText(obj) {\n            var rest = _objectWithoutProperties(obj, _excluded$1);\n            return rest;\n        }\n        return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n    },\n    /**\r\n   * Check if a value implements the `Text` interface.\r\n   */ isText (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.text === \"string\";\n    },\n    /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */ isTextList (value) {\n        return Array.isArray(value) && value.every((val)=>Text.isText(val));\n    },\n    /**\r\n   * Check if some props are a partial of Text.\r\n   */ isTextProps (props) {\n        return props.text !== undefined;\n    },\n    /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */ matches (text, props) {\n        for(var key in props){\n            if (key === \"text\") {\n                continue;\n            }\n            if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    /**\r\n   * Get the leaves for a text node given decorations.\r\n   */ decorations (node, decorations) {\n        var leaves = [\n            _objectSpread$4({}, node)\n        ];\n        for (var dec of decorations){\n            var rest = _objectWithoutProperties(dec, _excluded2$1);\n            var [start, end] = Range.edges(dec);\n            var next = [];\n            var leafEnd = 0;\n            var decorationStart = start.offset;\n            var decorationEnd = end.offset;\n            for (var leaf of leaves){\n                var { length } = leaf.text;\n                var leafStart = leafEnd;\n                leafEnd += length; // If the range encompasses the entire leaf, add the range.\n                if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n                    Object.assign(leaf, rest);\n                    next.push(leaf);\n                    continue;\n                } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n                if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n                    next.push(leaf);\n                    continue;\n                } // Otherwise we need to split the leaf, at the start, end, or both,\n                // and add the range to the middle intersecting section. Do the end\n                // split first since we don't need to update the offset that way.\n                var middle = leaf;\n                var before = void 0;\n                var after = void 0;\n                if (decorationEnd < leafEnd) {\n                    var off = decorationEnd - leafStart;\n                    after = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                        text: middle.text.slice(off)\n                    });\n                    middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                        text: middle.text.slice(0, off)\n                    });\n                }\n                if (decorationStart > leafStart) {\n                    var _off = decorationStart - leafStart;\n                    before = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                        text: middle.text.slice(0, _off)\n                    });\n                    middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                        text: middle.text.slice(_off)\n                    });\n                }\n                Object.assign(middle, rest);\n                if (before) {\n                    next.push(before);\n                }\n                next.push(middle);\n                if (after) {\n                    next.push(after);\n                }\n            }\n            leaves = next;\n        }\n        return leaves;\n    }\n};\nfunction ownKeys$3(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$3(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$3(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar applyToDraft = (editor, selection, op)=>{\n    switch(op.type){\n        case \"insert_node\":\n            {\n                var { path, node } = op;\n                var parent = Node.parent(editor, path);\n                var index = path[path.length - 1];\n                if (index > parent.children.length) {\n                    throw new Error('Cannot apply an \"insert_node\" operation at path ['.concat(path, \"] because the destination is past the end of the node.\"));\n                }\n                parent.children.splice(index, 0, node);\n                if (selection) {\n                    for (var [point, key] of Range.points(selection)){\n                        selection[key] = Point.transform(point, op);\n                    }\n                }\n                break;\n            }\n        case \"insert_text\":\n            {\n                var { path: _path, offset, text } = op;\n                if (text.length === 0) break;\n                var _node = Node.leaf(editor, _path);\n                var before = _node.text.slice(0, offset);\n                var after = _node.text.slice(offset);\n                _node.text = before + text + after;\n                if (selection) {\n                    for (var [_point, _key] of Range.points(selection)){\n                        selection[_key] = Point.transform(_point, op);\n                    }\n                }\n                break;\n            }\n        case \"merge_node\":\n            {\n                var { path: _path2 } = op;\n                var _node2 = Node.get(editor, _path2);\n                var prevPath = Path.previous(_path2);\n                var prev = Node.get(editor, prevPath);\n                var _parent = Node.parent(editor, _path2);\n                var _index = _path2[_path2.length - 1];\n                if (Text.isText(_node2) && Text.isText(prev)) {\n                    prev.text += _node2.text;\n                } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n                    prev.children.push(..._node2.children);\n                } else {\n                    throw new Error('Cannot apply a \"merge_node\" operation at path ['.concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n                }\n                _parent.children.splice(_index, 1);\n                if (selection) {\n                    for (var [_point2, _key2] of Range.points(selection)){\n                        selection[_key2] = Point.transform(_point2, op);\n                    }\n                }\n                break;\n            }\n        case \"move_node\":\n            {\n                var { path: _path3, newPath } = op;\n                if (Path.isAncestor(_path3, newPath)) {\n                    throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n                }\n                var _node3 = Node.get(editor, _path3);\n                var _parent2 = Node.parent(editor, _path3);\n                var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n                // the same snapshot in time, there's a mismatch. After either\n                // removing the original position, the second step's path can be out\n                // of date. So instead of using the `op.newPath` directly, we\n                // transform `op.path` to ascertain what the `newPath` would be after\n                // the operation was applied.\n                _parent2.children.splice(_index2, 1);\n                var truePath = Path.transform(_path3, op);\n                var newParent = Node.get(editor, Path.parent(truePath));\n                var newIndex = truePath[truePath.length - 1];\n                newParent.children.splice(newIndex, 0, _node3);\n                if (selection) {\n                    for (var [_point3, _key3] of Range.points(selection)){\n                        selection[_key3] = Point.transform(_point3, op);\n                    }\n                }\n                break;\n            }\n        case \"remove_node\":\n            {\n                var { path: _path4 } = op;\n                var _index3 = _path4[_path4.length - 1];\n                var _parent3 = Node.parent(editor, _path4);\n                _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n                // node that was removed we need to update the range or remove it.\n                if (selection) {\n                    for (var [_point4, _key4] of Range.points(selection)){\n                        var result = Point.transform(_point4, op);\n                        if (selection != null && result != null) {\n                            selection[_key4] = result;\n                        } else {\n                            var _prev = void 0;\n                            var next = void 0;\n                            for (var [n, p] of Node.texts(editor)){\n                                if (Path.compare(p, _path4) === -1) {\n                                    _prev = [\n                                        n,\n                                        p\n                                    ];\n                                } else {\n                                    next = [\n                                        n,\n                                        p\n                                    ];\n                                    break;\n                                }\n                            }\n                            var preferNext = false;\n                            if (_prev && next) {\n                                if (Path.equals(next[1], _path4)) {\n                                    preferNext = !Path.hasPrevious(next[1]);\n                                } else {\n                                    preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                                }\n                            }\n                            if (_prev && !preferNext) {\n                                _point4.path = _prev[1];\n                                _point4.offset = _prev[0].text.length;\n                            } else if (next) {\n                                _point4.path = next[1];\n                                _point4.offset = 0;\n                            } else {\n                                selection = null;\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        case \"remove_text\":\n            {\n                var { path: _path5, offset: _offset, text: _text } = op;\n                if (_text.length === 0) break;\n                var _node4 = Node.leaf(editor, _path5);\n                var _before = _node4.text.slice(0, _offset);\n                var _after = _node4.text.slice(_offset + _text.length);\n                _node4.text = _before + _after;\n                if (selection) {\n                    for (var [_point5, _key5] of Range.points(selection)){\n                        selection[_key5] = Point.transform(_point5, op);\n                    }\n                }\n                break;\n            }\n        case \"set_node\":\n            {\n                var { path: _path6, properties, newProperties } = op;\n                if (_path6.length === 0) {\n                    throw new Error(\"Cannot set properties on the root node!\");\n                }\n                var _node5 = Node.get(editor, _path6);\n                for(var _key6 in newProperties){\n                    if (_key6 === \"children\" || _key6 === \"text\") {\n                        throw new Error('Cannot set the \"'.concat(_key6, '\" property of nodes!'));\n                    }\n                    var value = newProperties[_key6];\n                    if (value == null) {\n                        delete _node5[_key6];\n                    } else {\n                        _node5[_key6] = value;\n                    }\n                } // properties that were previously defined, but are now missing, must be deleted\n                for(var _key7 in properties){\n                    if (!newProperties.hasOwnProperty(_key7)) {\n                        delete _node5[_key7];\n                    }\n                }\n                break;\n            }\n        case \"set_selection\":\n            {\n                var { newProperties: _newProperties } = op;\n                if (_newProperties == null) {\n                    selection = _newProperties;\n                } else {\n                    if (selection == null) {\n                        if (!Range.isRange(_newProperties)) {\n                            throw new Error('Cannot apply an incomplete \"set_selection\" operation properties '.concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n                        }\n                        selection = _objectSpread$3({}, _newProperties);\n                    }\n                    for(var _key8 in _newProperties){\n                        var _value = _newProperties[_key8];\n                        if (_value == null) {\n                            if (_key8 === \"anchor\" || _key8 === \"focus\") {\n                                throw new Error('Cannot remove the \"'.concat(_key8, '\" selection property'));\n                            }\n                            delete selection[_key8];\n                        } else {\n                            selection[_key8] = _value;\n                        }\n                    }\n                }\n                break;\n            }\n        case \"split_node\":\n            {\n                var { path: _path7, position, properties: _properties } = op;\n                if (_path7.length === 0) {\n                    throw new Error('Cannot apply a \"split_node\" operation at path ['.concat(_path7, \"] because the root node cannot be split.\"));\n                }\n                var _node6 = Node.get(editor, _path7);\n                var _parent4 = Node.parent(editor, _path7);\n                var _index4 = _path7[_path7.length - 1];\n                var newNode;\n                if (Text.isText(_node6)) {\n                    var _before2 = _node6.text.slice(0, position);\n                    var _after2 = _node6.text.slice(position);\n                    _node6.text = _before2;\n                    newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n                        text: _after2\n                    });\n                } else {\n                    var _before3 = _node6.children.slice(0, position);\n                    var _after3 = _node6.children.slice(position);\n                    _node6.children = _before3;\n                    newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n                        children: _after3\n                    });\n                }\n                _parent4.children.splice(_index4 + 1, 0, newNode);\n                if (selection) {\n                    for (var [_point6, _key9] of Range.points(selection)){\n                        selection[_key9] = Point.transform(_point6, op);\n                    }\n                }\n                break;\n            }\n    }\n    return selection;\n}; // eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n    /**\r\n   * Transform the editor by an operation.\r\n   */ transform (editor, op) {\n        editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.children);\n        var selection = editor.selection && (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.selection);\n        try {\n            selection = applyToDraft(editor, selection, op);\n        } finally{\n            editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(editor.children);\n            if (selection) {\n                editor.selection = (0,immer__WEBPACK_IMPORTED_MODULE_1__.isDraft)(selection) ? (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(selection) : selection;\n            } else {\n                editor.selection = null;\n            }\n        }\n    }\n};\nvar _excluded = [\n    \"text\"\n], _excluded2 = [\n    \"children\"\n];\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar NodeTransforms = {\n    /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */ insertNodes (editor, nodes) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { hanging = false, voids = false, mode = \"lowest\" } = options;\n            var { at, match, select } = options;\n            if (Node.isNode(nodes)) {\n                nodes = [\n                    nodes\n                ];\n            }\n            if (nodes.length === 0) {\n                return;\n            }\n            var [node] = nodes; // By default, use the selection as the target location. But if there is\n            // no selection, insert at the end of the document since that is such a\n            // common use case when inserting from a non-selected state.\n            if (!at) {\n                if (editor.selection) {\n                    at = editor.selection;\n                } else if (editor.children.length > 0) {\n                    at = Editor.end(editor, []);\n                } else {\n                    at = [\n                        0\n                    ];\n                }\n                select = true;\n            }\n            if (select == null) {\n                select = false;\n            }\n            if (Range.isRange(at)) {\n                if (!hanging) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids\n                    });\n                }\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var [, end] = Range.edges(at);\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms.delete(editor, {\n                        at\n                    });\n                    at = pointRef.unref();\n                }\n            }\n            if (Point.isPoint(at)) {\n                if (match == null) {\n                    if (Text.isText(node)) {\n                        match = (n)=>Text.isText(n);\n                    } else if (editor.isInline(node)) {\n                        match = (n)=>Text.isText(n) || Editor.isInline(editor, n);\n                    } else {\n                        match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n                    }\n                }\n                var [entry] = Editor.nodes(editor, {\n                    at: at.path,\n                    match,\n                    mode,\n                    voids\n                });\n                if (entry) {\n                    var [, _matchPath] = entry;\n                    var pathRef = Editor.pathRef(editor, _matchPath);\n                    var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n                    Transforms.splitNodes(editor, {\n                        at,\n                        match,\n                        mode,\n                        voids\n                    });\n                    var path = pathRef.unref();\n                    at = isAtEnd ? Path.next(path) : path;\n                } else {\n                    return;\n                }\n            }\n            var parentPath = Path.parent(at);\n            var index = at[at.length - 1];\n            if (!voids && Editor.void(editor, {\n                at: parentPath\n            })) {\n                return;\n            }\n            for (var _node of nodes){\n                var _path = parentPath.concat(index);\n                index++;\n                editor.apply({\n                    type: \"insert_node\",\n                    path: _path,\n                    node: _node\n                });\n                at = Path.next(at);\n            }\n            at = Path.previous(at);\n            if (select) {\n                var point = Editor.end(editor, at);\n                if (point) {\n                    Transforms.select(editor, point);\n                }\n            }\n        });\n    },\n    /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */ liftNodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { at = editor.selection, mode = \"lowest\", voids = false } = options;\n            var { match } = options;\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            if (!at) {\n                return;\n            }\n            var matches = Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            });\n            var pathRefs = Array.from(matches, (_ref)=>{\n                var [, p] = _ref;\n                return Editor.pathRef(editor, p);\n            });\n            for (var pathRef of pathRefs){\n                var path = pathRef.unref();\n                if (path.length < 2) {\n                    throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n                }\n                var parentNodeEntry = Editor.node(editor, Path.parent(path));\n                var [parent, parentPath] = parentNodeEntry;\n                var index = path[path.length - 1];\n                var { length } = parent.children;\n                if (length === 1) {\n                    var toPath = Path.next(parentPath);\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: toPath,\n                        voids\n                    });\n                    Transforms.removeNodes(editor, {\n                        at: parentPath,\n                        voids\n                    });\n                } else if (index === 0) {\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: parentPath,\n                        voids\n                    });\n                } else if (index === length - 1) {\n                    var _toPath = Path.next(parentPath);\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: _toPath,\n                        voids\n                    });\n                } else {\n                    var splitPath = Path.next(path);\n                    var _toPath2 = Path.next(parentPath);\n                    Transforms.splitNodes(editor, {\n                        at: splitPath,\n                        voids\n                    });\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: _toPath2,\n                        voids\n                    });\n                }\n            }\n        });\n    },\n    /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */ mergeNodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { match, at = editor.selection } = options;\n            var { hanging = false, voids = false, mode = \"lowest\" } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                if (Path.isPath(at)) {\n                    var [parent] = Editor.parent(editor, at);\n                    match = (n)=>parent.children.includes(n);\n                } else {\n                    match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n                }\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            if (Range.isRange(at)) {\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var [, end] = Range.edges(at);\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms.delete(editor, {\n                        at\n                    });\n                    at = pointRef.unref();\n                    if (options.at == null) {\n                        Transforms.select(editor, at);\n                    }\n                }\n            }\n            var [current] = Editor.nodes(editor, {\n                at,\n                match,\n                voids,\n                mode\n            });\n            var prev = Editor.previous(editor, {\n                at,\n                match,\n                voids,\n                mode\n            });\n            if (!current || !prev) {\n                return;\n            }\n            var [node, path] = current;\n            var [prevNode, prevPath] = prev;\n            if (path.length === 0 || prevPath.length === 0) {\n                return;\n            }\n            var newPath = Path.next(prevPath);\n            var commonPath = Path.common(path, prevPath);\n            var isPreviousSibling = Path.isSibling(path, prevPath);\n            var levels = Array.from(Editor.levels(editor, {\n                at: path\n            }), (_ref2)=>{\n                var [n] = _ref2;\n                return n;\n            }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n            // result, in which case we'll want to remove it after merging.\n            var emptyAncestor = Editor.above(editor, {\n                at: path,\n                mode: \"highest\",\n                match: (n)=>levels.includes(n) && hasSingleChildNest(editor, n)\n            });\n            var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n            var properties;\n            var position; // Ensure that the nodes are equivalent, and figure out what the position\n            // and extra properties of the merge will be.\n            if (Text.isText(node) && Text.isText(prevNode)) {\n                var rest = _objectWithoutProperties(node, _excluded);\n                position = prevNode.text.length;\n                properties = rest;\n            } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n                var rest = _objectWithoutProperties(node, _excluded2);\n                position = prevNode.children.length;\n                properties = rest;\n            } else {\n                throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n            } // If the node isn't already the next sibling of the previous node, move\n            // it so that it is before merging.\n            if (!isPreviousSibling) {\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: newPath,\n                    voids\n                });\n            } // If there was going to be an empty ancestor of the node that was merged,\n            // we remove it from the tree.\n            if (emptyRef) {\n                Transforms.removeNodes(editor, {\n                    at: emptyRef.current,\n                    voids\n                });\n            } // If the target node that we're merging with is empty, remove it instead\n            // of merging the two. This is a common rich text editor behavior to\n            // prevent losing formatting when deleting entire nodes when you have a\n            // hanging selection.\n            // if prevNode is first child in parent,don't remove it.\n            if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === \"\" && prevPath[prevPath.length - 1] !== 0) {\n                Transforms.removeNodes(editor, {\n                    at: prevPath,\n                    voids\n                });\n            } else {\n                editor.apply({\n                    type: \"merge_node\",\n                    path: newPath,\n                    position,\n                    properties\n                });\n            }\n            if (emptyRef) {\n                emptyRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Move the nodes at a location to a new location.\r\n   */ moveNodes (editor, options) {\n        Editor.withoutNormalizing(editor, ()=>{\n            var { to, at = editor.selection, mode = \"lowest\", voids = false } = options;\n            var { match } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            var toRef = Editor.pathRef(editor, to);\n            var targets = Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            });\n            var pathRefs = Array.from(targets, (_ref3)=>{\n                var [, p] = _ref3;\n                return Editor.pathRef(editor, p);\n            });\n            for (var pathRef of pathRefs){\n                var path = pathRef.unref();\n                var newPath = toRef.current;\n                if (path.length !== 0) {\n                    editor.apply({\n                        type: \"move_node\",\n                        path,\n                        newPath\n                    });\n                }\n                if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n                    // When performing a sibling move to a later index, the path at the destination is shifted\n                    // to before the insertion point instead of after. To ensure our group of nodes are inserted\n                    // in the correct order we increment toRef to account for that\n                    toRef.current = Path.next(toRef.current);\n                }\n            }\n            toRef.unref();\n        });\n    },\n    /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */ removeNodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { hanging = false, voids = false, mode = \"lowest\" } = options;\n            var { at = editor.selection, match } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            var depths = Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            });\n            var pathRefs = Array.from(depths, (_ref4)=>{\n                var [, p] = _ref4;\n                return Editor.pathRef(editor, p);\n            });\n            for (var pathRef of pathRefs){\n                var path = pathRef.unref();\n                if (path) {\n                    var [node] = Editor.node(editor, path);\n                    editor.apply({\n                        type: \"remove_node\",\n                        path,\n                        node\n                    });\n                }\n            }\n        });\n    },\n    /**\r\n   * Set new properties on the nodes at a location.\r\n   */ setNodes (editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { match, at = editor.selection, compare, merge } = options;\n            var { hanging = false, mode = \"lowest\", split = false, voids = false } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            if (split && Range.isRange(at)) {\n                if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n                    // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n                    // set that won't get normalized away\n                    return;\n                }\n                var rangeRef = Editor.rangeRef(editor, at, {\n                    affinity: \"inward\"\n                });\n                var [start, end] = Range.edges(at);\n                var splitMode = mode === \"lowest\" ? \"lowest\" : \"highest\";\n                var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n                Transforms.splitNodes(editor, {\n                    at: end,\n                    match,\n                    mode: splitMode,\n                    voids,\n                    always: !endAtEndOfNode\n                });\n                var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n                Transforms.splitNodes(editor, {\n                    at: start,\n                    match,\n                    mode: splitMode,\n                    voids,\n                    always: !startAtStartOfNode\n                });\n                at = rangeRef.unref();\n                if (options.at == null) {\n                    Transforms.select(editor, at);\n                }\n            }\n            if (!compare) {\n                compare = (prop, nodeProp)=>prop !== nodeProp;\n            }\n            for (var [node, path] of Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            })){\n                var properties = {};\n                var newProperties = {}; // You can't set properties on the editor node.\n                if (path.length === 0) {\n                    continue;\n                }\n                var hasChanges = false;\n                for(var k in props){\n                    if (k === \"children\" || k === \"text\") {\n                        continue;\n                    }\n                    if (compare(props[k], node[k])) {\n                        hasChanges = true; // Omit new properties from the old properties list\n                        if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list\n                        if (merge) {\n                            if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n                        } else {\n                            if (props[k] != null) newProperties[k] = props[k];\n                        }\n                    }\n                }\n                if (hasChanges) {\n                    editor.apply({\n                        type: \"set_node\",\n                        path,\n                        properties,\n                        newProperties\n                    });\n                }\n            }\n        });\n    },\n    /**\r\n   * Split the nodes at a specific location.\r\n   */ splitNodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { mode = \"lowest\", voids = false } = options;\n            var { match, at = editor.selection, height = 0, always = false } = options;\n            if (match == null) {\n                match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            if (Range.isRange(at)) {\n                at = deleteRange(editor, at);\n            } // If the target is a path, the default height-skipping and position\n            // counters need to account for us potentially splitting at a non-leaf.\n            if (Path.isPath(at)) {\n                var path = at;\n                var point = Editor.point(editor, path);\n                var [parent] = Editor.parent(editor, path);\n                match = (n)=>n === parent;\n                height = point.path.length - path.length + 1;\n                at = point;\n                always = true;\n            }\n            if (!at) {\n                return;\n            }\n            var beforeRef = Editor.pointRef(editor, at, {\n                affinity: \"backward\"\n            });\n            var afterRef;\n            try {\n                var [highest] = Editor.nodes(editor, {\n                    at,\n                    match,\n                    mode,\n                    voids\n                });\n                if (!highest) {\n                    return;\n                }\n                var voidMatch = Editor.void(editor, {\n                    at,\n                    mode: \"highest\"\n                });\n                var nudge = 0;\n                if (!voids && voidMatch) {\n                    var [voidNode, voidPath] = voidMatch;\n                    if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n                        var after = Editor.after(editor, voidPath);\n                        if (!after) {\n                            var text = {\n                                text: \"\"\n                            };\n                            var afterPath = Path.next(voidPath);\n                            Transforms.insertNodes(editor, text, {\n                                at: afterPath,\n                                voids\n                            });\n                            after = Editor.point(editor, afterPath);\n                        }\n                        at = after;\n                        always = true;\n                    }\n                    var siblingHeight = at.path.length - voidPath.length;\n                    height = siblingHeight + 1;\n                    always = true;\n                }\n                afterRef = Editor.pointRef(editor, at);\n                var depth = at.path.length - height;\n                var [, highestPath] = highest;\n                var lowestPath = at.path.slice(0, depth);\n                var position = height === 0 ? at.offset : at.path[depth] + nudge;\n                for (var [node, _path2] of Editor.levels(editor, {\n                    at: lowestPath,\n                    reverse: true,\n                    voids\n                })){\n                    var split = false;\n                    if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n                        break;\n                    }\n                    var _point = beforeRef.current;\n                    var isEnd = Editor.isEnd(editor, _point, _path2);\n                    if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {\n                        split = true;\n                        var properties = Node.extractProps(node);\n                        editor.apply({\n                            type: \"split_node\",\n                            path: _path2,\n                            position,\n                            properties\n                        });\n                    }\n                    position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n                }\n                if (options.at == null) {\n                    var _point2 = afterRef.current || Editor.end(editor, []);\n                    Transforms.select(editor, _point2);\n                }\n            } finally{\n                var _afterRef;\n                beforeRef.unref();\n                (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Unset properties on the nodes at a location.\r\n   */ unsetNodes (editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!Array.isArray(props)) {\n            props = [\n                props\n            ];\n        }\n        var obj = {};\n        for (var key of props){\n            obj[key] = null;\n        }\n        Transforms.setNodes(editor, obj, options);\n    },\n    /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */ unwrapNodes (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { mode = \"lowest\", split = false, voids = false } = options;\n            var { at = editor.selection, match } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n            if (Path.isPath(at)) {\n                at = Editor.range(editor, at);\n            }\n            var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n            var matches = Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            });\n            var pathRefs = Array.from(matches, (_ref5)=>{\n                var [, p] = _ref5;\n                return Editor.pathRef(editor, p);\n            } // unwrapNode will call liftNode which does not support splitting the node when nested.\n            ).reverse();\n            var _loop = function _loop(pathRef) {\n                var path = pathRef.unref();\n                var [node] = Editor.node(editor, path);\n                var range = Editor.range(editor, path);\n                if (split && rangeRef) {\n                    range = Range.intersection(rangeRef.current, range);\n                }\n                Transforms.liftNodes(editor, {\n                    at: range,\n                    match: (n)=>Element.isAncestor(node) && node.children.includes(n),\n                    voids\n                });\n            };\n            for (var pathRef of pathRefs){\n                _loop(pathRef);\n            }\n            if (rangeRef) {\n                rangeRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */ wrapNodes (editor, element) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { mode = \"lowest\", split = false, voids = false } = options;\n            var { match, at = editor.selection } = options;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                if (Path.isPath(at)) {\n                    match = matchPath(editor, at);\n                } else if (editor.isInline(element)) {\n                    match = (n)=>Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n                } else {\n                    match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n                }\n            }\n            if (split && Range.isRange(at)) {\n                var [start, end] = Range.edges(at);\n                var rangeRef = Editor.rangeRef(editor, at, {\n                    affinity: \"inward\"\n                });\n                Transforms.splitNodes(editor, {\n                    at: end,\n                    match,\n                    voids\n                });\n                Transforms.splitNodes(editor, {\n                    at: start,\n                    match,\n                    voids\n                });\n                at = rangeRef.unref();\n                if (options.at == null) {\n                    Transforms.select(editor, at);\n                }\n            }\n            var roots = Array.from(Editor.nodes(editor, {\n                at,\n                match: editor.isInline(element) ? (n)=>Element.isElement(n) && Editor.isBlock(editor, n) : (n)=>Editor.isEditor(n),\n                mode: \"lowest\",\n                voids\n            }));\n            for (var [, rootPath] of roots){\n                var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n                if (!a) {\n                    continue;\n                }\n                var matches = Array.from(Editor.nodes(editor, {\n                    at: a,\n                    match,\n                    mode,\n                    voids\n                }));\n                if (matches.length > 0) {\n                    var _ret = function() {\n                        var [first] = matches;\n                        var last = matches[matches.length - 1];\n                        var [, firstPath] = first;\n                        var [, lastPath] = last;\n                        if (firstPath.length === 0 && lastPath.length === 0) {\n                            // if there's no matching parent - usually means the node is an editor - don't do anything\n                            return \"continue\";\n                        }\n                        var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n                        var range = Editor.range(editor, firstPath, lastPath);\n                        var commonNodeEntry = Editor.node(editor, commonPath);\n                        var [commonNode] = commonNodeEntry;\n                        var depth = commonPath.length + 1;\n                        var wrapperPath = Path.next(lastPath.slice(0, depth));\n                        var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {\n                            children: []\n                        });\n                        Transforms.insertNodes(editor, wrapper, {\n                            at: wrapperPath,\n                            voids\n                        });\n                        Transforms.moveNodes(editor, {\n                            at: range,\n                            match: (n)=>Element.isAncestor(commonNode) && commonNode.children.includes(n),\n                            to: wrapperPath.concat(0),\n                            voids\n                        });\n                    }();\n                    if (_ret === \"continue\") continue;\n                }\n            }\n        });\n    }\n};\nvar hasSingleChildNest = (editor, node)=>{\n    if (Element.isElement(node)) {\n        var element = node;\n        if (Editor.isVoid(editor, node)) {\n            return true;\n        } else if (element.children.length === 1) {\n            return hasSingleChildNest(editor, element.children[0]);\n        } else {\n            return false;\n        }\n    } else if (Editor.isEditor(node)) {\n        return false;\n    } else {\n        return true;\n    }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */ var deleteRange = (editor, range)=>{\n    if (Range.isCollapsed(range)) {\n        return range.anchor;\n    } else {\n        var [, end] = Range.edges(range);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n            at: range\n        });\n        return pointRef.unref();\n    }\n};\nvar matchPath = (editor, path)=>{\n    var [node] = Editor.node(editor, path);\n    return (n)=>n === node;\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar SelectionTransforms = {\n    /**\r\n   * Collapse the selection.\r\n   */ collapse (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { edge = \"anchor\" } = options;\n        var { selection } = editor;\n        if (!selection) {\n            return;\n        } else if (edge === \"anchor\") {\n            Transforms.select(editor, selection.anchor);\n        } else if (edge === \"focus\") {\n            Transforms.select(editor, selection.focus);\n        } else if (edge === \"start\") {\n            var [start] = Range.edges(selection);\n            Transforms.select(editor, start);\n        } else if (edge === \"end\") {\n            var [, end] = Range.edges(selection);\n            Transforms.select(editor, end);\n        }\n    },\n    /**\r\n   * Unset the selection.\r\n   */ deselect (editor) {\n        var { selection } = editor;\n        if (selection) {\n            editor.apply({\n                type: \"set_selection\",\n                properties: selection,\n                newProperties: null\n            });\n        }\n    },\n    /**\r\n   * Move the selection's point forward or backward.\r\n   */ move (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { selection } = editor;\n        var { distance = 1, unit = \"character\", reverse = false } = options;\n        var { edge = null } = options;\n        if (!selection) {\n            return;\n        }\n        if (edge === \"start\") {\n            edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n        }\n        if (edge === \"end\") {\n            edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n        }\n        var { anchor, focus } = selection;\n        var opts = {\n            distance,\n            unit\n        };\n        var props = {};\n        if (edge == null || edge === \"anchor\") {\n            var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n            if (point) {\n                props.anchor = point;\n            }\n        }\n        if (edge == null || edge === \"focus\") {\n            var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n            if (_point) {\n                props.focus = _point;\n            }\n        }\n        Transforms.setSelection(editor, props);\n    },\n    /**\r\n   * Set the selection to a new value.\r\n   */ select (editor, target) {\n        var { selection } = editor;\n        target = Editor.range(editor, target);\n        if (selection) {\n            Transforms.setSelection(editor, target);\n            return;\n        }\n        if (!Range.isRange(target)) {\n            throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n        }\n        editor.apply({\n            type: \"set_selection\",\n            properties: selection,\n            newProperties: target\n        });\n    },\n    /**\r\n   * Set new properties on one of the selection's points.\r\n   */ setPoint (editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { selection } = editor;\n        var { edge = \"both\" } = options;\n        if (!selection) {\n            return;\n        }\n        if (edge === \"start\") {\n            edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n        }\n        if (edge === \"end\") {\n            edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n        }\n        var { anchor, focus } = selection;\n        var point = edge === \"anchor\" ? anchor : focus;\n        Transforms.setSelection(editor, {\n            [edge === \"anchor\" ? \"anchor\" : \"focus\"]: _objectSpread$1(_objectSpread$1({}, point), props)\n        });\n    },\n    /**\r\n   * Set new properties on the selection.\r\n   */ setSelection (editor, props) {\n        var { selection } = editor;\n        var oldProps = {};\n        var newProps = {};\n        if (!selection) {\n            return;\n        }\n        for(var k in props){\n            if (k === \"anchor\" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === \"focus\" && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== \"anchor\" && k !== \"focus\" && props[k] !== selection[k]) {\n                oldProps[k] = selection[k];\n                newProps[k] = props[k];\n            }\n        }\n        if (Object.keys(oldProps).length > 0) {\n            editor.apply({\n                type: \"set_selection\",\n                properties: oldProps,\n                newProperties: newProps\n            });\n        }\n    }\n};\nvar TextTransforms = {\n    /**\r\n   * Delete content in the editor.\r\n   */ delete (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { reverse = false, unit = \"character\", distance = 1, voids = false } = options;\n            var { at = editor.selection, hanging = false } = options;\n            if (!at) {\n                return;\n            }\n            var isCollapsed = false;\n            if (Range.isRange(at) && Range.isCollapsed(at)) {\n                isCollapsed = true;\n                at = at.anchor;\n            }\n            if (Point.isPoint(at)) {\n                var furthestVoid = Editor.void(editor, {\n                    at,\n                    mode: \"highest\"\n                });\n                if (!voids && furthestVoid) {\n                    var [, voidPath] = furthestVoid;\n                    at = voidPath;\n                } else {\n                    var opts = {\n                        unit,\n                        distance\n                    };\n                    var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n                    at = {\n                        anchor: at,\n                        focus: target\n                    };\n                    hanging = true;\n                }\n            }\n            if (Path.isPath(at)) {\n                Transforms.removeNodes(editor, {\n                    at,\n                    voids\n                });\n                return;\n            }\n            if (Range.isCollapsed(at)) {\n                return;\n            }\n            if (!hanging) {\n                var [, _end] = Range.edges(at);\n                var endOfDoc = Editor.end(editor, []);\n                if (!Point.equals(_end, endOfDoc)) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids\n                    });\n                }\n            }\n            var [start, end] = Range.edges(at);\n            var startBlock = Editor.above(editor, {\n                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n                at: start,\n                voids\n            });\n            var endBlock = Editor.above(editor, {\n                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n                at: end,\n                voids\n            });\n            var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n            var isSingleText = Path.equals(start.path, end.path);\n            var startVoid = voids ? null : Editor.void(editor, {\n                at: start,\n                mode: \"highest\"\n            });\n            var endVoid = voids ? null : Editor.void(editor, {\n                at: end,\n                mode: \"highest\"\n            }); // If the start or end points are inside an inline void, nudge them out.\n            if (startVoid) {\n                var before = Editor.before(editor, start);\n                if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n                    start = before;\n                }\n            }\n            if (endVoid) {\n                var after = Editor.after(editor, end);\n                if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n                    end = after;\n                }\n            } // Get the highest nodes that are completely inside the range, as well as\n            // the start and end nodes.\n            var matches = [];\n            var lastPath;\n            for (var entry of Editor.nodes(editor, {\n                at,\n                voids\n            })){\n                var [node, path] = entry;\n                if (lastPath && Path.compare(path, lastPath) === 0) {\n                    continue;\n                }\n                if (!voids && Element.isElement(node) && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n                    matches.push(entry);\n                    lastPath = path;\n                }\n            }\n            var pathRefs = Array.from(matches, (_ref)=>{\n                var [, p] = _ref;\n                return Editor.pathRef(editor, p);\n            });\n            var startRef = Editor.pointRef(editor, start);\n            var endRef = Editor.pointRef(editor, end);\n            var removedText = \"\";\n            if (!isSingleText && !startVoid) {\n                var _point = startRef.current;\n                var [_node] = Editor.leaf(editor, _point);\n                var { path: _path } = _point;\n                var { offset } = start;\n                var text = _node.text.slice(offset);\n                if (text.length > 0) {\n                    editor.apply({\n                        type: \"remove_text\",\n                        path: _path,\n                        offset,\n                        text\n                    });\n                    removedText = text;\n                }\n            }\n            pathRefs.reverse().map((r)=>r.unref()).filter((r)=>r !== null).forEach((p)=>Transforms.removeNodes(editor, {\n                    at: p,\n                    voids\n                }));\n            if (!endVoid) {\n                var _point2 = endRef.current;\n                var [_node2] = Editor.leaf(editor, _point2);\n                var { path: _path2 } = _point2;\n                var _offset = isSingleText ? start.offset : 0;\n                var _text = _node2.text.slice(_offset, end.offset);\n                if (_text.length > 0) {\n                    editor.apply({\n                        type: \"remove_text\",\n                        path: _path2,\n                        offset: _offset,\n                        text: _text\n                    });\n                    removedText = _text;\n                }\n            }\n            if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n                Transforms.mergeNodes(editor, {\n                    at: endRef.current,\n                    hanging: true,\n                    voids\n                });\n            } // For Thai script, deleting N character(s) backward should delete\n            // N code point(s) instead of an entire grapheme cluster.\n            // Therefore, the remaining code points should be inserted back.\n            if (isCollapsed && reverse && unit === \"character\" && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n                Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n            }\n            var startUnref = startRef.unref();\n            var endUnref = endRef.unref();\n            var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n            if (options.at == null && point) {\n                Transforms.select(editor, point);\n            }\n        });\n    },\n    /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */ insertFragment (editor, fragment) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { hanging = false, voids = false } = options;\n            var { at = editor.selection } = options;\n            if (!fragment.length) {\n                return;\n            }\n            if (!at) {\n                return;\n            } else if (Range.isRange(at)) {\n                if (!hanging) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids\n                    });\n                }\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var [, end] = Range.edges(at);\n                    if (!voids && Editor.void(editor, {\n                        at: end\n                    })) {\n                        return;\n                    }\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms.delete(editor, {\n                        at\n                    });\n                    at = pointRef.unref();\n                }\n            } else if (Path.isPath(at)) {\n                at = Editor.start(editor, at);\n            }\n            if (!voids && Editor.void(editor, {\n                at\n            })) {\n                return;\n            } // If the insert point is at the edge of an inline node, move it outside\n            // instead since it will need to be split otherwise.\n            var inlineElementMatch = Editor.above(editor, {\n                at,\n                match: (n)=>Element.isElement(n) && Editor.isInline(editor, n),\n                mode: \"highest\",\n                voids\n            });\n            if (inlineElementMatch) {\n                var [, _inlinePath] = inlineElementMatch;\n                if (Editor.isEnd(editor, at, _inlinePath)) {\n                    var after = Editor.after(editor, _inlinePath);\n                    at = after;\n                } else if (Editor.isStart(editor, at, _inlinePath)) {\n                    var before = Editor.before(editor, _inlinePath);\n                    at = before;\n                }\n            }\n            var blockMatch = Editor.above(editor, {\n                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n                at,\n                voids\n            });\n            var [, blockPath] = blockMatch;\n            var isBlockStart = Editor.isStart(editor, at, blockPath);\n            var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n            var isBlockEmpty = isBlockStart && isBlockEnd;\n            var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n            var mergeEnd = !isBlockEnd;\n            var [, firstPath] = Node.first({\n                children: fragment\n            }, []);\n            var [, lastPath] = Node.last({\n                children: fragment\n            }, []);\n            var matches = [];\n            var matcher = (_ref2)=>{\n                var [n, p] = _ref2;\n                var isRoot = p.length === 0;\n                if (isRoot) {\n                    return false;\n                }\n                if (isBlockEmpty) {\n                    return true;\n                }\n                if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                    return false;\n                }\n                if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                    return false;\n                }\n                return true;\n            };\n            for (var entry of Node.nodes({\n                children: fragment\n            }, {\n                pass: matcher\n            })){\n                if (matcher(entry)) {\n                    matches.push(entry);\n                }\n            }\n            var starts = [];\n            var middles = [];\n            var ends = [];\n            var starting = true;\n            var hasBlocks = false;\n            for (var [node] of matches){\n                if (Element.isElement(node) && !editor.isInline(node)) {\n                    starting = false;\n                    hasBlocks = true;\n                    middles.push(node);\n                } else if (starting) {\n                    starts.push(node);\n                } else {\n                    ends.push(node);\n                }\n            }\n            var [inlineMatch] = Editor.nodes(editor, {\n                at,\n                match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n                mode: \"highest\",\n                voids\n            });\n            var [, inlinePath] = inlineMatch;\n            var isInlineStart = Editor.isStart(editor, at, inlinePath);\n            var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n            var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n            var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n            Transforms.splitNodes(editor, {\n                at,\n                match: (n)=>hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n                mode: hasBlocks ? \"lowest\" : \"highest\",\n                always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n                voids\n            });\n            var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n            Transforms.insertNodes(editor, starts, {\n                at: startRef.current,\n                match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n                mode: \"highest\",\n                voids\n            });\n            if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n                Transforms.delete(editor, {\n                    at: blockPath,\n                    voids\n                });\n            }\n            Transforms.insertNodes(editor, middles, {\n                at: middleRef.current,\n                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n                mode: \"lowest\",\n                voids\n            });\n            Transforms.insertNodes(editor, ends, {\n                at: endRef.current,\n                match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n                mode: \"highest\",\n                voids\n            });\n            if (!options.at) {\n                var path;\n                if (ends.length > 0 && endRef.current) {\n                    path = Path.previous(endRef.current);\n                } else if (middles.length > 0 && middleRef.current) {\n                    path = Path.previous(middleRef.current);\n                } else if (startRef.current) {\n                    path = Path.previous(startRef.current);\n                }\n                if (path) {\n                    var _end2 = Editor.end(editor, path);\n                    Transforms.select(editor, _end2);\n                }\n            }\n            startRef.unref();\n            middleRef.unref();\n            endRef.unref();\n        });\n    },\n    /**\r\n   * Insert a string of text in the Editor.\r\n   */ insertText (editor, text) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { voids = false } = options;\n            var { at = editor.selection } = options;\n            if (!at) {\n                return;\n            }\n            if (Path.isPath(at)) {\n                at = Editor.range(editor, at);\n            }\n            if (Range.isRange(at)) {\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var end = Range.end(at);\n                    if (!voids && Editor.void(editor, {\n                        at: end\n                    })) {\n                        return;\n                    }\n                    var start = Range.start(at);\n                    var startRef = Editor.pointRef(editor, start);\n                    var endRef = Editor.pointRef(editor, end);\n                    Transforms.delete(editor, {\n                        at,\n                        voids\n                    });\n                    var startPoint = startRef.unref();\n                    var endPoint = endRef.unref();\n                    at = startPoint || endPoint;\n                    Transforms.setSelection(editor, {\n                        anchor: at,\n                        focus: at\n                    });\n                }\n            }\n            if (!voids && Editor.void(editor, {\n                at\n            })) {\n                return;\n            }\n            var { path, offset } = at;\n            if (text.length > 0) editor.apply({\n                type: \"insert_text\",\n                path,\n                offset,\n                text\n            });\n        });\n    }\n};\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDbUI7QUFFbkUsU0FBU0ssZ0JBQWdCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztJQUN0QyxJQUFJRCxPQUFPRCxLQUFLO1FBQ2RHLE9BQU9DLGNBQWMsQ0FBQ0osS0FBS0MsS0FBSztZQUM5QkMsT0FBT0E7WUFDUEcsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7UUFDWjtJQUNGLE9BQU87UUFDTFAsR0FBRyxDQUFDQyxJQUFJLEdBQUdDO0lBQ2I7SUFFQSxPQUFPRjtBQUNUO0FBRUEsSUFBSVEsY0FBYyxJQUFJQztBQUN0QixJQUFJQyxrQkFBa0IsSUFBSUQ7QUFDMUIsSUFBSUUsV0FBVyxJQUFJRjtBQUNuQixJQUFJRyxjQUFjLElBQUlIO0FBQ3RCLElBQUlJLFlBQVksSUFBSUo7QUFDcEIsSUFBSUssYUFBYSxJQUFJTDtBQUNyQixJQUFJTSxhQUFhLElBQUlOO0FBRXJCLFNBQVNPLFVBQVVDLE1BQU0sRUFBRUMsY0FBYztJQUFJLElBQUlDLE9BQU9oQixPQUFPZ0IsSUFBSSxDQUFDRjtJQUFTLElBQUlkLE9BQU9pQixxQkFBcUIsRUFBRTtRQUFFLElBQUlDLFVBQVVsQixPQUFPaUIscUJBQXFCLENBQUNIO1FBQVMsSUFBSUMsZ0JBQWdCO1lBQUVHLFVBQVVBLFFBQVFDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHO2dCQUFJLE9BQU9wQixPQUFPcUIsd0JBQXdCLENBQUNQLFFBQVFNLEtBQUtsQixVQUFVO1lBQUU7UUFBSTtRQUFFYyxLQUFLTSxJQUFJLENBQUNDLEtBQUssQ0FBQ1AsTUFBTUU7SUFBVTtJQUFFLE9BQU9GO0FBQU07QUFFMVYsU0FBU1EsZ0JBQWdCQyxNQUFNO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztRQUFFLElBQUlHLFNBQVNG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QUFPLENBQUMsU0FBVWhDLEdBQUc7Z0JBQUlFLE9BQU9DLGNBQWMsQ0FBQ3dCLFFBQVEzQixLQUFLRSxPQUFPcUIsd0JBQXdCLENBQUNRLFFBQVEvQjtZQUFPO1FBQUk7SUFBRTtJQUFFLE9BQU8yQjtBQUFRO0FBQ3JoQixJQUFJK0MsYUFBYXVqQixjQUFjQSxjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBRzNHLG9CQUFvQkssaUJBQWlCd0Qsc0JBQXNCUztBQUVlLENBQ3ZKLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmVzLmpzPzdmNGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2lzLXBsYWluLW9iamVjdCc7XG5pbXBvcnQgeyBwcm9kdWNlLCBjcmVhdGVEcmFmdCwgZmluaXNoRHJhZnQsIGlzRHJhZnQgfSBmcm9tICdpbW1lcic7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG52YXIgRElSVFlfUEFUSFMgPSBuZXcgV2Vha01hcCgpO1xudmFyIERJUlRZX1BBVEhfS0VZUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRkxVU0hJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PUk1BTElaSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQQVRIX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBPSU5UX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIFJBTkdFX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDkob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDkodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ5KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkOShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgU2xhdGUgYEVkaXRvcmAgb2JqZWN0LlxyXG4gKi9cblxudmFyIGNyZWF0ZUVkaXRvciA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gICAgc2VsZWN0aW9uOiBudWxsLFxuICAgIG1hcmtzOiBudWxsLFxuICAgIGlzSW5saW5lOiAoKSA9PiBmYWxzZSxcbiAgICBpc1ZvaWQ6ICgpID0+IGZhbHNlLFxuICAgIG1hcmthYmxlVm9pZDogKCkgPT4gZmFsc2UsXG4gICAgb25DaGFuZ2U6ICgpID0+IHt9LFxuICAgIGFwcGx5OiBvcCA9PiB7XG4gICAgICBmb3IgKHZhciByZWYgb2YgRWRpdG9yLnBhdGhSZWZzKGVkaXRvcikpIHtcbiAgICAgICAgUGF0aFJlZi50cmFuc2Zvcm0ocmVmLCBvcCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9yZWYgb2YgRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpKSB7XG4gICAgICAgIFBvaW50UmVmLnRyYW5zZm9ybShfcmVmLCBvcCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9yZWYyIG9mIEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKSkge1xuICAgICAgICBSYW5nZVJlZi50cmFuc2Zvcm0oX3JlZjIsIG9wKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9sZERpcnR5UGF0aHMgPSBESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBbXTtcbiAgICAgIHZhciBvbGREaXJ0eVBhdGhLZXlzID0gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgICAgIHZhciBkaXJ0eVBhdGhzO1xuICAgICAgdmFyIGRpcnR5UGF0aEtleXM7XG5cbiAgICAgIHZhciBhZGQgPSBwYXRoID0+IHtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG5cbiAgICAgICAgICBpZiAoIWRpcnR5UGF0aEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGRpcnR5UGF0aEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBkaXJ0eVBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoUGF0aC5vcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wKSkge1xuICAgICAgICBkaXJ0eVBhdGhzID0gW107XG4gICAgICAgIGRpcnR5UGF0aEtleXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgZm9yICh2YXIgcGF0aCBvZiBvbGREaXJ0eVBhdGhzKSB7XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgYWRkKG5ld1BhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJ0eVBhdGhzID0gb2xkRGlydHlQYXRocztcbiAgICAgICAgZGlydHlQYXRoS2V5cyA9IG9sZERpcnR5UGF0aEtleXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdEaXJ0eVBhdGhzID0gZWRpdG9yLmdldERpcnR5UGF0aHMob3ApO1xuXG4gICAgICBmb3IgKHZhciBfcGF0aCBvZiBuZXdEaXJ0eVBhdGhzKSB7XG4gICAgICAgIGFkZChfcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIERJUlRZX1BBVEhTLnNldChlZGl0b3IsIGRpcnR5UGF0aHMpO1xuICAgICAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGRpcnR5UGF0aEtleXMpO1xuICAgICAgVHJhbnNmb3Jtcy50cmFuc2Zvcm0oZWRpdG9yLCBvcCk7XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yLCB7XG4gICAgICAgIG9wZXJhdGlvbjogb3BcbiAgICAgIH0pOyAvLyBDbGVhciBhbnkgZm9ybWF0cyBhcHBsaWVkIHRvIHRoZSBjdXJzb3IgaWYgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLlxuXG4gICAgICBpZiAob3AudHlwZSA9PT0gJ3NldF9zZWxlY3Rpb24nKSB7XG4gICAgICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIEZMVVNISU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICBlZGl0b3Iub25DaGFuZ2Uoe1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBvcFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVkaXRvci5vcGVyYXRpb25zID0gW107XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkTWFyazogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgbWFya2FibGVWb2lkXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtYXJrcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRleHRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgW3BhcmVudE5vZGUsIHBhcmVudFBhdGhdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIHJldHVybiAhZWRpdG9yLmlzVm9pZChwYXJlbnROb2RlKSB8fCBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICAgICAgdmFyIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIWV4cGFuZGVkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIFtzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbik7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIG1hdGNoKHNlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoKSkge1xuICAgICAgICAgICAgdmFyIFtwYXJlbnROb2RlXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBzZWxlY3RlZFBhdGgpO1xuICAgICAgICAgICAgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IHBhcmVudE5vZGUgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhwYW5kZWRTZWxlY3Rpb24gfHwgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBba2V5XTogdmFsdWVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSksIHt9LCB7XG4gICAgICAgICAgICBba2V5XTogdmFsdWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuXG4gICAgICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVCYWNrd2FyZDogdW5pdCA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICB1bml0LFxuICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVGb3J3YXJkOiB1bml0ID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIHVuaXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVGcmFnbWVudDogZGlyZWN0aW9uID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgcmV2ZXJzZTogZGlyZWN0aW9uID09PSAnYmFja3dhcmQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0RnJhZ21lbnQ6ICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gTm9kZS5mcmFnbWVudChlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGluc2VydEJyZWFrOiAoKSA9PiB7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpbnNlcnRTb2Z0QnJlYWs6ICgpID0+IHtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYWx3YXlzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGluc2VydEZyYWdtZW50OiBmcmFnbWVudCA9PiB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQpO1xuICAgIH0sXG4gICAgaW5zZXJ0Tm9kZTogbm9kZSA9PiB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSk7XG4gICAgfSxcbiAgICBpbnNlcnRUZXh0OiB0ZXh0ID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgbWFya3NcbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKG1hcmtzKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBfb2JqZWN0U3ByZWFkJDkoe1xuICAgICAgICAgICAgdGV4dFxuICAgICAgICAgIH0sIG1hcmtzKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCB0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBub3JtYWxpemVOb2RlOiBlbnRyeSA9PiB7XG4gICAgICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7IC8vIFRoZXJlIGFyZSBubyBjb3JlIG5vcm1hbGl6YXRpb25zIGZvciB0ZXh0IG5vZGVzLlxuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBFbnN1cmUgdGhhdCBibG9jayBhbmQgaW5saW5lIG5vZGVzIGhhdmUgYXQgbGVhc3Qgb25lIHRleHQgY2hpbGQuXG5cblxuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHtcbiAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGQsIHtcbiAgICAgICAgICBhdDogcGF0aC5jb25jYXQoMCksXG4gICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGhhdmUgYmxvY2sgb3IgaW5saW5lIGNoaWxkcmVuLlxuXG5cbiAgICAgIHZhciBzaG91bGRIYXZlSW5saW5lcyA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/IGZhbHNlIDogRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgKGVkaXRvci5pc0lubGluZShub2RlKSB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBUZXh0LmlzVGV4dChub2RlLmNoaWxkcmVuWzBdKSB8fCBlZGl0b3IuaXNJbmxpbmUobm9kZS5jaGlsZHJlblswXSkpOyAvLyBTaW5jZSB3ZSdsbCBiZSBhcHBseWluZyBvcGVyYXRpb25zIHdoaWxlIGl0ZXJhdGluZywga2VlcCB0cmFjayBvZiBhblxuICAgICAgLy8gaW5kZXggdGhhdCBhY2NvdW50cyBmb3IgYW55IGFkZGVkL3JlbW92ZWQgbm9kZXMuXG5cbiAgICAgIHZhciBuID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrLCBuKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KGN1cnJlbnROb2RlKSkgY29udGludWU7XG4gICAgICAgIHZhciBfY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIgcHJldiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuW24gLSAxXTtcbiAgICAgICAgdmFyIGlzTGFzdCA9IGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGlzSW5saW5lT3JUZXh0ID0gVGV4dC5pc1RleHQoX2NoaWxkKSB8fCBFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpICYmIGVkaXRvci5pc0lubGluZShfY2hpbGQpOyAvLyBPbmx5IGFsbG93IGJsb2NrIG5vZGVzIGluIHRoZSB0b3AtbGV2ZWwgY2hpbGRyZW4gYW5kIHBhcmVudCBibG9ja3NcbiAgICAgICAgLy8gdGhhdCBvbmx5IGNvbnRhaW4gYmxvY2sgbm9kZXMuIFNpbWlsYXJseSwgb25seSBhbGxvdyBpbmxpbmUgbm9kZXMgaW5cbiAgICAgICAgLy8gb3RoZXIgaW5saW5lIG5vZGVzLCBvciBwYXJlbnQgYmxvY2tzIHRoYXQgb25seSBjb250YWluIGlubGluZXMgYW5kXG4gICAgICAgIC8vIHRleHQuXG5cbiAgICAgICAgaWYgKGlzSW5saW5lT3JUZXh0ICE9PSBzaG91bGRIYXZlSW5saW5lcykge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgaW5saW5lIG5vZGVzIGFyZSBzdXJyb3VuZGVkIGJ5IHRleHQgbm9kZXMuXG4gICAgICAgICAgaWYgKGVkaXRvci5pc0lubGluZShfY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAocHJldiA9PSBudWxsIHx8ICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5ld0NoaWxkLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICB2YXIgX25ld0NoaWxkID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBfbmV3Q2hpbGQsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiArIDEpLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgdGhhdCBhcmUgZW1wdHkgb3IgbWF0Y2guXG4gICAgICAgICAgaWYgKHByZXYgIT0gbnVsbCAmJiBUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgaWYgKFRleHQuZXF1YWxzKF9jaGlsZCwgcHJldiwge1xuICAgICAgICAgICAgICBsb29zZTogdHJ1ZVxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2LnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gLSAxKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfY2hpbGQudGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZU1hcms6IGtleSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG1hdGNoID0gKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG1hcmtzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGV4dFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBbcGFyZW50Tm9kZSwgcGFyZW50UGF0aF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgcmV0dXJuICFlZGl0b3IuaXNWb2lkKHBhcmVudE5vZGUpIHx8IGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cGFuZGVkU2VsZWN0aW9uID0gUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pO1xuICAgICAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgW3NlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uKTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgW3BhcmVudE5vZGVdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCk7XG4gICAgICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBhbmRlZFNlbGVjdGlvbiB8fCBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwga2V5LCB7XG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDkoe30sIEVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9KTtcblxuICAgICAgICAgIGRlbGV0ZSBtYXJrc1trZXldO1xuICAgICAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuXG4gICAgICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBcImRpcnR5XCIgcGF0aHMgZ2VuZXJhdGVkIGZyb20gYW4gb3BlcmF0aW9uLlxyXG4gICAgICovXG4gICAgZ2V0RGlydHlQYXRoczogb3AgPT4ge1xuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgcGF0aFxuICAgICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgICAgcmV0dXJuIFBhdGgubGV2ZWxzKHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGgyKTtcbiAgICAgICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFRleHQuaXNUZXh0KG5vZGUpID8gW10gOiBBcnJheS5mcm9tKE5vZGUubm9kZXMobm9kZSksIF9yZWYzID0+IHtcbiAgICAgICAgICAgICAgdmFyIFssIHBdID0gX3JlZjM7XG4gICAgICAgICAgICAgIHJldHVybiBfcGF0aDIuY29uY2F0KHApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmxldmVscywgLi4uZGVzY2VuZGFudHNdO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgICBwYXRoOiBfcGF0aDNcbiAgICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICAgIHZhciBhbmNlc3RvcnMgPSBQYXRoLmFuY2VzdG9ycyhfcGF0aDMpO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzUGF0aCA9IFBhdGgucHJldmlvdXMoX3BhdGgzKTtcbiAgICAgICAgICAgIHJldHVybiBbLi4uYW5jZXN0b3JzLCBwcmV2aW91c1BhdGhdO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9wYXRoNCxcbiAgICAgICAgICAgICAgbmV3UGF0aFxuICAgICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX3BhdGg0LCBuZXdQYXRoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvbGRBbmNlc3RvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBuZXdBbmNlc3RvcnMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMoX3BhdGg0KSkge1xuICAgICAgICAgICAgICB2YXIgcCA9IFBhdGgudHJhbnNmb3JtKGFuY2VzdG9yLCBvcCk7XG4gICAgICAgICAgICAgIG9sZEFuY2VzdG9ycy5wdXNoKHApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBfYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMobmV3UGF0aCkpIHtcbiAgICAgICAgICAgICAgdmFyIF9wID0gUGF0aC50cmFuc2Zvcm0oX2FuY2VzdG9yLCBvcCk7XG5cbiAgICAgICAgICAgICAgbmV3QW5jZXN0b3JzLnB1c2goX3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3QW5jZXN0b3JzW25ld0FuY2VzdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IG5ld1BhdGhbbmV3UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciByZXN1bHRQYXRoID0gbmV3UGFyZW50LmNvbmNhdChuZXdJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLm9sZEFuY2VzdG9ycywgLi4ubmV3QW5jZXN0b3JzLCByZXN1bHRQYXRoXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9wYXRoNVxuICAgICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgICB2YXIgX2FuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoNSk7XG5cbiAgICAgICAgICAgIHJldHVybiBbLi4uX2FuY2VzdG9yc107XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9wYXRoNlxuICAgICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgICB2YXIgX2xldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoNik7XG5cbiAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IFBhdGgubmV4dChfcGF0aDYpO1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5fbGV2ZWxzLCBuZXh0UGF0aF07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3VsZE5vcm1hbGl6ZTogX3JlZjQgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBpbml0aWFsRGlydHlQYXRoc0xlbmd0aFxuICAgICAgfSA9IF9yZWY0O1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCAqIDQyOyAvLyBIQUNLOiBiZXR0ZXIgd2F5P1xuXG4gICAgICBpZiAoaXRlcmF0aW9uID4gbWF4SXRlcmF0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29tcGxldGVseSBub3JtYWxpemUgdGhlIGVkaXRvciBhZnRlciBcIi5jb25jYXQobWF4SXRlcmF0aW9ucywgXCIgaXRlcmF0aW9ucyEgVGhpcyBpcyB1c3VhbGx5IGR1ZSB0byBpbmNvcnJlY3Qgbm9ybWFsaXphdGlvbiBsb2dpYyB0aGF0IGxlYXZlcyBhIG5vZGUgaW4gYW4gaW52YWxpZCBzdGF0ZS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gQ2hhcmFjdGVyIChncmFwaGVtZSBjbHVzdGVyKSBib3VuZGFyaWVzIGFyZSBkZXRlcm1pbmVkIGFjY29yZGluZyB0b1xuLy8gdGhlIGRlZmF1bHQgZ3JhcGhlbWUgY2x1c3RlciBib3VuZGFyeSBzcGVjaWZpY2F0aW9uLCBleHRlbmRlZCBncmFwaGVtZSBjbHVzdGVycyB2YXJpYW50WzFdLlxuLy9cbi8vIFJlZmVyZW5jZXM6XG4vL1xuLy8gWzFdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIyOS8jRGVmYXVsdF9HcmFwaGVtZV9DbHVzdGVyX1RhYmxlXG4vLyBbMl0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0XG4vLyBbM10gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrVGVzdC5odG1sXG4vLyBbNF0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrVGVzdC50eHRcblxuLyoqXHJcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIGEgc3RyaW5nIG9mIHRleHQuXHJcbiAqL1xudmFyIGdldENoYXJhY3RlckRpc3RhbmNlID0gZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyRGlzdGFuY2Uoc3RyKSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBpc0xUUiA9ICFpc1JUTDtcbiAgdmFyIGNvZGVwb2ludHMgPSBpc1JUTCA/IGNvZGVwb2ludHNJdGVyYXRvclJUTChzdHIpIDogc3RyO1xuICB2YXIgbGVmdCA9IENvZGVwb2ludFR5cGUuTm9uZTtcbiAgdmFyIHJpZ2h0ID0gQ29kZXBvaW50VHlwZS5Ob25lO1xuICB2YXIgZGlzdGFuY2UgPSAwOyAvLyBFdmFsdWF0aW9uIG9mIHRoZXNlIGNvbmRpdGlvbnMgYXJlIGRlZmVycmVkLlxuXG4gIHZhciBnYjExID0gbnVsbDsgLy8gSXMgR0IxMSBhcHBsaWNhYmxlP1xuXG4gIHZhciBnYjEyT3IxMyA9IG51bGw7IC8vIElzIEdCMTIgb3IgR0IxMyBhcHBsaWNhYmxlP1xuXG4gIGZvciAodmFyIGNoYXIgb2YgY29kZXBvaW50cykge1xuICAgIHZhciBjb2RlID0gY2hhci5jb2RlUG9pbnRBdCgwKTtcbiAgICBpZiAoIWNvZGUpIGJyZWFrO1xuICAgIHZhciB0eXBlID0gZ2V0Q29kZXBvaW50VHlwZShjaGFyLCBjb2RlKTtcbiAgICBbbGVmdCwgcmlnaHRdID0gaXNMVFIgPyBbcmlnaHQsIHR5cGVdIDogW3R5cGUsIGxlZnRdO1xuXG4gICAgaWYgKGludGVyc2VjdHMobGVmdCwgQ29kZXBvaW50VHlwZS5aV0opICYmIGludGVyc2VjdHMocmlnaHQsIENvZGVwb2ludFR5cGUuRXh0UGljdCkpIHtcbiAgICAgIGlmIChpc0xUUikge1xuICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIGRpc3RhbmNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdiMTEpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpbnRlcnNlY3RzKGxlZnQsIENvZGVwb2ludFR5cGUuUkkpICYmIGludGVyc2VjdHMocmlnaHQsIENvZGVwb2ludFR5cGUuUkkpKSB7XG4gICAgICBpZiAoZ2IxMk9yMTMgIT09IG51bGwpIHtcbiAgICAgICAgZ2IxMk9yMTMgPSAhZ2IxMk9yMTM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgICBnYjEyT3IxMyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2IxMk9yMTMgPSBlbmRzV2l0aE9kZE51bWJlck9mUklzKHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFnYjEyT3IxMykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGxlZnQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiByaWdodCAhPT0gQ29kZXBvaW50VHlwZS5Ob25lICYmIGlzQm91bmRhcnlQYWlyKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGlzdGFuY2UgKz0gY2hhci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gZGlzdGFuY2UgfHwgMTtcbn07XG52YXIgU1BBQ0UgPSAvXFxzLztcbnZhciBQVU5DVFVBVElPTiA9IC9bXFx1MDAyMS1cXHUwMDIzXFx1MDAyNS1cXHUwMDJBXFx1MDAyQy1cXHUwMDJGXFx1MDAzQVxcdTAwM0JcXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RFxcdTAwNUZcXHUwMDdCXFx1MDA3RFxcdTAwQTFcXHUwMEE3XFx1MDBBQlxcdTAwQjZcXHUwMEI3XFx1MDBCQlxcdTAwQkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkUzQlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV0vO1xudmFyIENIQU1FTEVPTiA9IC9bJ1xcdTIwMThcXHUyMDE5XS87XG4vKipcclxuICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCB3b3JkIGluIGEgc3RyaW5nIG9mIHRleHQuXHJcbiAqL1xuXG52YXIgZ2V0V29yZERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0V29yZERpc3RhbmNlKHRleHQpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGRpc3QgPSAwO1xuICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xuXG4gIHdoaWxlICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBpc1JUTCk7XG4gICAgdmFyIFtjaGFyLCByZW1haW5pbmddID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHRleHQsIGNoYXJEaXN0LCBpc1JUTCk7XG5cbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKGNoYXIsIHJlbWFpbmluZywgaXNSVEwpKSB7XG4gICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgIGRpc3QgKz0gY2hhckRpc3Q7XG4gICAgfSBlbHNlIGlmICghc3RhcnRlZCkge1xuICAgICAgZGlzdCArPSBjaGFyRGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGV4dCA9IHJlbWFpbmluZztcbiAgfVxuXG4gIHJldHVybiBkaXN0O1xufTtcbi8qKlxyXG4gKiBTcGxpdCBhIHN0cmluZyBpbiB0d28gcGFydHMgYXQgYSBnaXZlbiBkaXN0YW5jZSBzdGFydGluZyBmcm9tIHRoZSBlbmQgd2hlblxyXG4gKiBgaXNSVExgIGlzIHNldCB0byBgdHJ1ZWAuXHJcbiAqL1xuXG52YXIgc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlID0gKHN0ciwgZGlzdCwgaXNSVEwpID0+IHtcbiAgaWYgKGlzUlRMKSB7XG4gICAgdmFyIGF0ID0gc3RyLmxlbmd0aCAtIGRpc3Q7XG4gICAgcmV0dXJuIFtzdHIuc2xpY2UoYXQsIHN0ci5sZW5ndGgpLCBzdHIuc2xpY2UoMCwgYXQpXTtcbiAgfVxuXG4gIHJldHVybiBbc3RyLnNsaWNlKDAsIGRpc3QpLCBzdHIuc2xpY2UoZGlzdCldO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGNoYXJhY3RlciBpcyBhIHdvcmQgY2hhcmFjdGVyLiBUaGUgYHJlbWFpbmluZ2AgYXJndW1lbnQgaXMgdXNlZFxyXG4gKiBiZWNhdXNlIHNvbWV0aW1lcyB5b3UgbXVzdCByZWFkIHN1YnNlcXVlbnQgY2hhcmFjdGVycyB0byB0cnVseSBkZXRlcm1pbmUgaXQuXHJcbiAqL1xuXG52YXIgaXNXb3JkQ2hhcmFjdGVyID0gZnVuY3Rpb24gaXNXb3JkQ2hhcmFjdGVyKGNoYXIsIHJlbWFpbmluZykge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIGlmIChTUEFDRS50ZXN0KGNoYXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIENoYW1lbGVvbnMgY291bnQgYXMgd29yZCBjaGFyYWN0ZXJzIGFzIGxvbmcgYXMgdGhleSdyZSBpbiBhIHdvcmQsIHNvXG4gIC8vIHJlY3Vyc2UgdG8gc2VlIGlmIHRoZSBuZXh0IG9uZSBpcyBhIHdvcmQgY2hhcmFjdGVyIG9yIG5vdC5cblxuXG4gIGlmIChDSEFNRUxFT04udGVzdChjaGFyKSkge1xuICAgIHZhciBjaGFyRGlzdCA9IGdldENoYXJhY3RlckRpc3RhbmNlKHJlbWFpbmluZywgaXNSVEwpO1xuICAgIHZhciBbbmV4dENoYXIsIG5leHRSZW1haW5pbmddID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHJlbWFpbmluZywgY2hhckRpc3QsIGlzUlRMKTtcblxuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIobmV4dENoYXIsIG5leHRSZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKFBVTkNUVUFUSU9OLnRlc3QoY2hhcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcclxuICogSXRlcmF0ZSBvbiBjb2RlcG9pbnRzIGZyb20gcmlnaHQgdG8gbGVmdC5cclxuICovXG5cblxudmFyIGNvZGVwb2ludHNJdGVyYXRvclJUTCA9IGZ1bmN0aW9uKiBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSB7XG4gIHZhciBlbmQgPSBzdHIubGVuZ3RoIC0gMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGFyMSA9IHN0ci5jaGFyQXQoZW5kIC0gaSk7XG5cbiAgICBpZiAoaXNMb3dTdXJyb2dhdGUoY2hhcjEuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHZhciBjaGFyMiA9IHN0ci5jaGFyQXQoZW5kIC0gaSAtIDEpO1xuXG4gICAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKGNoYXIyLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHlpZWxkIGNoYXIyICsgY2hhcjE7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeWllbGQgY2hhcjE7XG4gIH1cbn07XG4vKipcclxuICogSXMgYGNoYXJDb2RlYCBhIGhpZ2ggc3Vycm9nYXRlLlxyXG4gKlxyXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcclxuICovXG5cbnZhciBpc0hpZ2hTdXJyb2dhdGUgPSBjaGFyQ29kZSA9PiB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweGQ4MDAgJiYgY2hhckNvZGUgPD0gMHhkYmZmO1xufTtcbi8qKlxyXG4gKiBJcyBgY2hhckNvZGVgIGEgbG93IHN1cnJvZ2F0ZS5cclxuICpcclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXHJcbiAqL1xuXG5cbnZhciBpc0xvd1N1cnJvZ2F0ZSA9IGNoYXJDb2RlID0+IHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4ZGMwMCAmJiBjaGFyQ29kZSA8PSAweGRmZmY7XG59O1xuXG52YXIgQ29kZXBvaW50VHlwZTtcblxuKGZ1bmN0aW9uIChDb2RlcG9pbnRUeXBlKSB7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJFeHRlbmRcIl0gPSAxXSA9IFwiRXh0ZW5kXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlpXSlwiXSA9IDJdID0gXCJaV0pcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiUklcIl0gPSA0XSA9IFwiUklcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiUHJlcGVuZFwiXSA9IDhdID0gXCJQcmVwZW5kXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlNwYWNpbmdNYXJrXCJdID0gMTZdID0gXCJTcGFjaW5nTWFya1wiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMXCJdID0gMzJdID0gXCJMXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlZcIl0gPSA2NF0gPSBcIlZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiVFwiXSA9IDEyOF0gPSBcIlRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZcIl0gPSAyNTZdID0gXCJMVlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMVlRcIl0gPSA1MTJdID0gXCJMVlRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0UGljdFwiXSA9IDEwMjRdID0gXCJFeHRQaWN0XCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkFueVwiXSA9IDIwNDhdID0gXCJBbnlcIjtcbn0pKENvZGVwb2ludFR5cGUgfHwgKENvZGVwb2ludFR5cGUgPSB7fSkpO1xuXG52YXIgcmVFeHRlbmQgPSAvXig/OltcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RDMtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUJFXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTA5RkVcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEFGQS1cXHUwQUZGXFx1MEIwMVxcdTBCM0NcXHUwQjNFXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU1LVxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFXFx1MEJDMFxcdTBCQ0RcXHUwQkQ3XFx1MEMwMFxcdTBDMDRcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDMFxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjlcXHUxREZCLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REY0Ni1cXHVERjUwXXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQzktXFx1RERDQ1xcdUREQ0ZcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQlxcdURGM0NcXHVERjNFXFx1REY0MFxcdURGNTdcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDNUVcXHVEQ0IwXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkRcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERBRlxcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwNltcXHVEQzJGLVxcdURDMzdcXHVEQzM5XFx1REMzQVxcdUREMzBcXHVERDNCXFx1REQzQ1xcdUREM0VcXHVERDQzXFx1RERENC1cXHVEREQ3XFx1REREQVxcdUREREJcXHVEREUwXFx1REUwMS1cXHVERTBBXFx1REUzMy1cXHVERTM4XFx1REUzQi1cXHVERTNFXFx1REU0N1xcdURFNTEtXFx1REU1NlxcdURFNTktXFx1REU1QlxcdURFOEEtXFx1REU5NlxcdURFOThcXHVERTk5XXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XFx1REQzMS1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ1XFx1REQ0N1xcdUREOTBcXHVERDkxXFx1REQ5NVxcdUREOTdcXHVERUYzXFx1REVGNF18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY0RlxcdURGOEYtXFx1REY5MlxcdURGRTRdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdUREMzAtXFx1REQzNlxcdURFRUMtXFx1REVFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pJC87XG52YXIgcmVQcmVwZW5kID0gL14oPzpbXFx1MDYwMC1cXHUwNjA1XFx1MDZERFxcdTA3MEZcXHUwODkwXFx1MDg5MVxcdTA4RTJcXHUwRDRFXXxcXHVEODA0W1xcdURDQkRcXHVEQ0NEXFx1RERDMlxcdUREQzNdfFxcdUQ4MDZbXFx1REQzRlxcdURENDFcXHVERTNBXFx1REU4NC1cXHVERTg5XXxcXHVEODA3XFx1REQ0NikkLztcbnZhciByZVNwYWNpbmdNYXJrID0gL14oPzpbXFx1MDkwM1xcdTA5M0JcXHUwOTNFLVxcdTA5NDBcXHUwOTQ5LVxcdTA5NENcXHUwOTRFXFx1MDk0RlxcdTA5ODJcXHUwOTgzXFx1MDlCRlxcdTA5QzBcXHUwOUM3XFx1MDlDOFxcdTA5Q0JcXHUwOUNDXFx1MEEwM1xcdTBBM0UtXFx1MEE0MFxcdTBBODNcXHUwQUJFLVxcdTBBQzBcXHUwQUM5XFx1MEFDQlxcdTBBQ0NcXHUwQjAyXFx1MEIwM1xcdTBCNDBcXHUwQjQ3XFx1MEI0OFxcdTBCNEJcXHUwQjRDXFx1MEJCRlxcdTBCQzFcXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNDXFx1MEMwMS1cXHUwQzAzXFx1MEM0MS1cXHUwQzQ0XFx1MEM4MlxcdTBDODNcXHUwQ0JFXFx1MENDMFxcdTBDQzFcXHUwQ0MzXFx1MENDNFxcdTBDQzdcXHUwQ0M4XFx1MENDQVxcdTBDQ0JcXHUwRDAyXFx1MEQwM1xcdTBEM0ZcXHUwRDQwXFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRDXFx1MEQ4MlxcdTBEODNcXHUwREQwXFx1MEREMVxcdTBERDgtXFx1MERERVxcdTBERjJcXHUwREYzXFx1MEUzM1xcdTBFQjNcXHUwRjNFXFx1MEYzRlxcdTBGN0ZcXHUxMDMxXFx1MTAzQlxcdTEwM0NcXHUxMDU2XFx1MTA1N1xcdTEwODRcXHUxNzE1XFx1MTczNFxcdTE3QjZcXHUxN0JFLVxcdTE3QzVcXHUxN0M3XFx1MTdDOFxcdTE5MjMtXFx1MTkyNlxcdTE5MjktXFx1MTkyQlxcdTE5MzBcXHUxOTMxXFx1MTkzMy1cXHUxOTM4XFx1MUExOVxcdTFBMUFcXHUxQTU1XFx1MUE1N1xcdTFBNkQtXFx1MUE3MlxcdTFCMDRcXHUxQjNCXFx1MUIzRC1cXHUxQjQxXFx1MUI0M1xcdTFCNDRcXHUxQjgyXFx1MUJBMVxcdTFCQTZcXHUxQkE3XFx1MUJBQVxcdTFCRTdcXHUxQkVBLVxcdTFCRUNcXHUxQkVFXFx1MUJGMlxcdTFCRjNcXHUxQzI0LVxcdTFDMkJcXHUxQzM0XFx1MUMzNVxcdTFDRTFcXHUxQ0Y3XFx1QTgyM1xcdUE4MjRcXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzNcXHVBOTUyXFx1QTk1M1xcdUE5ODNcXHVBOUI0XFx1QTlCNVxcdUE5QkFcXHVBOUJCXFx1QTlCRS1cXHVBOUMwXFx1QUEyRlxcdUFBMzBcXHVBQTMzXFx1QUEzNFxcdUFBNERcXHVBQUVCXFx1QUFFRVxcdUFBRUZcXHVBQUY1XFx1QUJFM1xcdUFCRTRcXHVBQkU2XFx1QUJFN1xcdUFCRTlcXHVBQkVBXFx1QUJFQ118XFx1RDgwNFtcXHVEQzAwXFx1REMwMlxcdURDODJcXHVEQ0IwLVxcdURDQjJcXHVEQ0I3XFx1RENCOFxcdUREMkNcXHVERDQ1XFx1REQ0NlxcdUREODJcXHVEREIzLVxcdUREQjVcXHVEREJGXFx1RERDMFxcdUREQ0VcXHVERTJDLVxcdURFMkVcXHVERTMyXFx1REUzM1xcdURFMzVcXHVERUUwLVxcdURFRTJcXHVERjAyXFx1REYwM1xcdURGM0ZcXHVERjQxLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNjJcXHVERjYzXXxcXHVEODA1W1xcdURDMzUtXFx1REMzN1xcdURDNDBcXHVEQzQxXFx1REM0NVxcdURDQjFcXHVEQ0IyXFx1RENCOVxcdURDQkJcXHVEQ0JDXFx1RENCRVxcdURDQzFcXHVEREIwXFx1RERCMVxcdUREQjgtXFx1RERCQlxcdUREQkVcXHVERTMwLVxcdURFMzJcXHVERTNCXFx1REUzQ1xcdURFM0VcXHVERUFDXFx1REVBRVxcdURFQUZcXHVERUI2XFx1REYyNl18XFx1RDgwNltcXHVEQzJDLVxcdURDMkVcXHVEQzM4XFx1REQzMS1cXHVERDM1XFx1REQzN1xcdUREMzhcXHVERDNEXFx1REQ0MFxcdURENDJcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREZcXHVEREU0XFx1REUzOVxcdURFNTdcXHVERTU4XFx1REU5N118XFx1RDgwN1tcXHVEQzJGXFx1REMzRVxcdURDQTlcXHVEQ0IxXFx1RENCNFxcdUREOEEtXFx1REQ4RVxcdUREOTNcXHVERDk0XFx1REQ5NlxcdURFRjVcXHVERUY2XXxcXHVEODFCW1xcdURGNTEtXFx1REY4N1xcdURGRjBcXHVERkYxXXxcXHVEODM0W1xcdURENjZcXHVERDZEXSkkLztcbnZhciByZUwgPSAvXltcXHUxMTAwLVxcdTExNUZcXHVBOTYwLVxcdUE5N0NdJC87XG52YXIgcmVWID0gL15bXFx1MTE2MC1cXHUxMUE3XFx1RDdCMC1cXHVEN0M2XSQvO1xudmFyIHJlVCA9IC9eW1xcdTExQTgtXFx1MTFGRlxcdUQ3Q0ItXFx1RDdGQl0kLztcbnZhciByZUxWID0gL15bXFx1QUMwMFxcdUFDMUNcXHVBQzM4XFx1QUM1NFxcdUFDNzBcXHVBQzhDXFx1QUNBOFxcdUFDQzRcXHVBQ0UwXFx1QUNGQ1xcdUFEMThcXHVBRDM0XFx1QUQ1MFxcdUFENkNcXHVBRDg4XFx1QURBNFxcdUFEQzBcXHVBRERDXFx1QURGOFxcdUFFMTRcXHVBRTMwXFx1QUU0Q1xcdUFFNjhcXHVBRTg0XFx1QUVBMFxcdUFFQkNcXHVBRUQ4XFx1QUVGNFxcdUFGMTBcXHVBRjJDXFx1QUY0OFxcdUFGNjRcXHVBRjgwXFx1QUY5Q1xcdUFGQjhcXHVBRkQ0XFx1QUZGMFxcdUIwMENcXHVCMDI4XFx1QjA0NFxcdUIwNjBcXHVCMDdDXFx1QjA5OFxcdUIwQjRcXHVCMEQwXFx1QjBFQ1xcdUIxMDhcXHVCMTI0XFx1QjE0MFxcdUIxNUNcXHVCMTc4XFx1QjE5NFxcdUIxQjBcXHVCMUNDXFx1QjFFOFxcdUIyMDRcXHVCMjIwXFx1QjIzQ1xcdUIyNThcXHVCMjc0XFx1QjI5MFxcdUIyQUNcXHVCMkM4XFx1QjJFNFxcdUIzMDBcXHVCMzFDXFx1QjMzOFxcdUIzNTRcXHVCMzcwXFx1QjM4Q1xcdUIzQThcXHVCM0M0XFx1QjNFMFxcdUIzRkNcXHVCNDE4XFx1QjQzNFxcdUI0NTBcXHVCNDZDXFx1QjQ4OFxcdUI0QTRcXHVCNEMwXFx1QjREQ1xcdUI0RjhcXHVCNTE0XFx1QjUzMFxcdUI1NENcXHVCNTY4XFx1QjU4NFxcdUI1QTBcXHVCNUJDXFx1QjVEOFxcdUI1RjRcXHVCNjEwXFx1QjYyQ1xcdUI2NDhcXHVCNjY0XFx1QjY4MFxcdUI2OUNcXHVCNkI4XFx1QjZENFxcdUI2RjBcXHVCNzBDXFx1QjcyOFxcdUI3NDRcXHVCNzYwXFx1Qjc3Q1xcdUI3OThcXHVCN0I0XFx1QjdEMFxcdUI3RUNcXHVCODA4XFx1QjgyNFxcdUI4NDBcXHVCODVDXFx1Qjg3OFxcdUI4OTRcXHVCOEIwXFx1QjhDQ1xcdUI4RThcXHVCOTA0XFx1QjkyMFxcdUI5M0NcXHVCOTU4XFx1Qjk3NFxcdUI5OTBcXHVCOUFDXFx1QjlDOFxcdUI5RTRcXHVCQTAwXFx1QkExQ1xcdUJBMzhcXHVCQTU0XFx1QkE3MFxcdUJBOENcXHVCQUE4XFx1QkFDNFxcdUJBRTBcXHVCQUZDXFx1QkIxOFxcdUJCMzRcXHVCQjUwXFx1QkI2Q1xcdUJCODhcXHVCQkE0XFx1QkJDMFxcdUJCRENcXHVCQkY4XFx1QkMxNFxcdUJDMzBcXHVCQzRDXFx1QkM2OFxcdUJDODRcXHVCQ0EwXFx1QkNCQ1xcdUJDRDhcXHVCQ0Y0XFx1QkQxMFxcdUJEMkNcXHVCRDQ4XFx1QkQ2NFxcdUJEODBcXHVCRDlDXFx1QkRCOFxcdUJERDRcXHVCREYwXFx1QkUwQ1xcdUJFMjhcXHVCRTQ0XFx1QkU2MFxcdUJFN0NcXHVCRTk4XFx1QkVCNFxcdUJFRDBcXHVCRUVDXFx1QkYwOFxcdUJGMjRcXHVCRjQwXFx1QkY1Q1xcdUJGNzhcXHVCRjk0XFx1QkZCMFxcdUJGQ0NcXHVCRkU4XFx1QzAwNFxcdUMwMjBcXHVDMDNDXFx1QzA1OFxcdUMwNzRcXHVDMDkwXFx1QzBBQ1xcdUMwQzhcXHVDMEU0XFx1QzEwMFxcdUMxMUNcXHVDMTM4XFx1QzE1NFxcdUMxNzBcXHVDMThDXFx1QzFBOFxcdUMxQzRcXHVDMUUwXFx1QzFGQ1xcdUMyMThcXHVDMjM0XFx1QzI1MFxcdUMyNkNcXHVDMjg4XFx1QzJBNFxcdUMyQzBcXHVDMkRDXFx1QzJGOFxcdUMzMTRcXHVDMzMwXFx1QzM0Q1xcdUMzNjhcXHVDMzg0XFx1QzNBMFxcdUMzQkNcXHVDM0Q4XFx1QzNGNFxcdUM0MTBcXHVDNDJDXFx1QzQ0OFxcdUM0NjRcXHVDNDgwXFx1QzQ5Q1xcdUM0QjhcXHVDNEQ0XFx1QzRGMFxcdUM1MENcXHVDNTI4XFx1QzU0NFxcdUM1NjBcXHVDNTdDXFx1QzU5OFxcdUM1QjRcXHVDNUQwXFx1QzVFQ1xcdUM2MDhcXHVDNjI0XFx1QzY0MFxcdUM2NUNcXHVDNjc4XFx1QzY5NFxcdUM2QjBcXHVDNkNDXFx1QzZFOFxcdUM3MDRcXHVDNzIwXFx1QzczQ1xcdUM3NThcXHVDNzc0XFx1Qzc5MFxcdUM3QUNcXHVDN0M4XFx1QzdFNFxcdUM4MDBcXHVDODFDXFx1QzgzOFxcdUM4NTRcXHVDODcwXFx1Qzg4Q1xcdUM4QThcXHVDOEM0XFx1QzhFMFxcdUM4RkNcXHVDOTE4XFx1QzkzNFxcdUM5NTBcXHVDOTZDXFx1Qzk4OFxcdUM5QTRcXHVDOUMwXFx1QzlEQ1xcdUM5RjhcXHVDQTE0XFx1Q0EzMFxcdUNBNENcXHVDQTY4XFx1Q0E4NFxcdUNBQTBcXHVDQUJDXFx1Q0FEOFxcdUNBRjRcXHVDQjEwXFx1Q0IyQ1xcdUNCNDhcXHVDQjY0XFx1Q0I4MFxcdUNCOUNcXHVDQkI4XFx1Q0JENFxcdUNCRjBcXHVDQzBDXFx1Q0MyOFxcdUNDNDRcXHVDQzYwXFx1Q0M3Q1xcdUNDOThcXHVDQ0I0XFx1Q0NEMFxcdUNDRUNcXHVDRDA4XFx1Q0QyNFxcdUNENDBcXHVDRDVDXFx1Q0Q3OFxcdUNEOTRcXHVDREIwXFx1Q0RDQ1xcdUNERThcXHVDRTA0XFx1Q0UyMFxcdUNFM0NcXHVDRTU4XFx1Q0U3NFxcdUNFOTBcXHVDRUFDXFx1Q0VDOFxcdUNFRTRcXHVDRjAwXFx1Q0YxQ1xcdUNGMzhcXHVDRjU0XFx1Q0Y3MFxcdUNGOENcXHVDRkE4XFx1Q0ZDNFxcdUNGRTBcXHVDRkZDXFx1RDAxOFxcdUQwMzRcXHVEMDUwXFx1RDA2Q1xcdUQwODhcXHVEMEE0XFx1RDBDMFxcdUQwRENcXHVEMEY4XFx1RDExNFxcdUQxMzBcXHVEMTRDXFx1RDE2OFxcdUQxODRcXHVEMUEwXFx1RDFCQ1xcdUQxRDhcXHVEMUY0XFx1RDIxMFxcdUQyMkNcXHVEMjQ4XFx1RDI2NFxcdUQyODBcXHVEMjlDXFx1RDJCOFxcdUQyRDRcXHVEMkYwXFx1RDMwQ1xcdUQzMjhcXHVEMzQ0XFx1RDM2MFxcdUQzN0NcXHVEMzk4XFx1RDNCNFxcdUQzRDBcXHVEM0VDXFx1RDQwOFxcdUQ0MjRcXHVENDQwXFx1RDQ1Q1xcdUQ0NzhcXHVENDk0XFx1RDRCMFxcdUQ0Q0NcXHVENEU4XFx1RDUwNFxcdUQ1MjBcXHVENTNDXFx1RDU1OFxcdUQ1NzRcXHVENTkwXFx1RDVBQ1xcdUQ1QzhcXHVENUU0XFx1RDYwMFxcdUQ2MUNcXHVENjM4XFx1RDY1NFxcdUQ2NzBcXHVENjhDXFx1RDZBOFxcdUQ2QzRcXHVENkUwXFx1RDZGQ1xcdUQ3MThcXHVENzM0XFx1RDc1MFxcdUQ3NkNcXHVENzg4XSQvO1xudmFyIHJlTFZUID0gL15bXFx1QUMwMS1cXHVBQzFCXFx1QUMxRC1cXHVBQzM3XFx1QUMzOS1cXHVBQzUzXFx1QUM1NS1cXHVBQzZGXFx1QUM3MS1cXHVBQzhCXFx1QUM4RC1cXHVBQ0E3XFx1QUNBOS1cXHVBQ0MzXFx1QUNDNS1cXHVBQ0RGXFx1QUNFMS1cXHVBQ0ZCXFx1QUNGRC1cXHVBRDE3XFx1QUQxOS1cXHVBRDMzXFx1QUQzNS1cXHVBRDRGXFx1QUQ1MS1cXHVBRDZCXFx1QUQ2RC1cXHVBRDg3XFx1QUQ4OS1cXHVBREEzXFx1QURBNS1cXHVBREJGXFx1QURDMS1cXHVBRERCXFx1QURERC1cXHVBREY3XFx1QURGOS1cXHVBRTEzXFx1QUUxNS1cXHVBRTJGXFx1QUUzMS1cXHVBRTRCXFx1QUU0RC1cXHVBRTY3XFx1QUU2OS1cXHVBRTgzXFx1QUU4NS1cXHVBRTlGXFx1QUVBMS1cXHVBRUJCXFx1QUVCRC1cXHVBRUQ3XFx1QUVEOS1cXHVBRUYzXFx1QUVGNS1cXHVBRjBGXFx1QUYxMS1cXHVBRjJCXFx1QUYyRC1cXHVBRjQ3XFx1QUY0OS1cXHVBRjYzXFx1QUY2NS1cXHVBRjdGXFx1QUY4MS1cXHVBRjlCXFx1QUY5RC1cXHVBRkI3XFx1QUZCOS1cXHVBRkQzXFx1QUZENS1cXHVBRkVGXFx1QUZGMS1cXHVCMDBCXFx1QjAwRC1cXHVCMDI3XFx1QjAyOS1cXHVCMDQzXFx1QjA0NS1cXHVCMDVGXFx1QjA2MS1cXHVCMDdCXFx1QjA3RC1cXHVCMDk3XFx1QjA5OS1cXHVCMEIzXFx1QjBCNS1cXHVCMENGXFx1QjBEMS1cXHVCMEVCXFx1QjBFRC1cXHVCMTA3XFx1QjEwOS1cXHVCMTIzXFx1QjEyNS1cXHVCMTNGXFx1QjE0MS1cXHVCMTVCXFx1QjE1RC1cXHVCMTc3XFx1QjE3OS1cXHVCMTkzXFx1QjE5NS1cXHVCMUFGXFx1QjFCMS1cXHVCMUNCXFx1QjFDRC1cXHVCMUU3XFx1QjFFOS1cXHVCMjAzXFx1QjIwNS1cXHVCMjFGXFx1QjIyMS1cXHVCMjNCXFx1QjIzRC1cXHVCMjU3XFx1QjI1OS1cXHVCMjczXFx1QjI3NS1cXHVCMjhGXFx1QjI5MS1cXHVCMkFCXFx1QjJBRC1cXHVCMkM3XFx1QjJDOS1cXHVCMkUzXFx1QjJFNS1cXHVCMkZGXFx1QjMwMS1cXHVCMzFCXFx1QjMxRC1cXHVCMzM3XFx1QjMzOS1cXHVCMzUzXFx1QjM1NS1cXHVCMzZGXFx1QjM3MS1cXHVCMzhCXFx1QjM4RC1cXHVCM0E3XFx1QjNBOS1cXHVCM0MzXFx1QjNDNS1cXHVCM0RGXFx1QjNFMS1cXHVCM0ZCXFx1QjNGRC1cXHVCNDE3XFx1QjQxOS1cXHVCNDMzXFx1QjQzNS1cXHVCNDRGXFx1QjQ1MS1cXHVCNDZCXFx1QjQ2RC1cXHVCNDg3XFx1QjQ4OS1cXHVCNEEzXFx1QjRBNS1cXHVCNEJGXFx1QjRDMS1cXHVCNERCXFx1QjRERC1cXHVCNEY3XFx1QjRGOS1cXHVCNTEzXFx1QjUxNS1cXHVCNTJGXFx1QjUzMS1cXHVCNTRCXFx1QjU0RC1cXHVCNTY3XFx1QjU2OS1cXHVCNTgzXFx1QjU4NS1cXHVCNTlGXFx1QjVBMS1cXHVCNUJCXFx1QjVCRC1cXHVCNUQ3XFx1QjVEOS1cXHVCNUYzXFx1QjVGNS1cXHVCNjBGXFx1QjYxMS1cXHVCNjJCXFx1QjYyRC1cXHVCNjQ3XFx1QjY0OS1cXHVCNjYzXFx1QjY2NS1cXHVCNjdGXFx1QjY4MS1cXHVCNjlCXFx1QjY5RC1cXHVCNkI3XFx1QjZCOS1cXHVCNkQzXFx1QjZENS1cXHVCNkVGXFx1QjZGMS1cXHVCNzBCXFx1QjcwRC1cXHVCNzI3XFx1QjcyOS1cXHVCNzQzXFx1Qjc0NS1cXHVCNzVGXFx1Qjc2MS1cXHVCNzdCXFx1Qjc3RC1cXHVCNzk3XFx1Qjc5OS1cXHVCN0IzXFx1QjdCNS1cXHVCN0NGXFx1QjdEMS1cXHVCN0VCXFx1QjdFRC1cXHVCODA3XFx1QjgwOS1cXHVCODIzXFx1QjgyNS1cXHVCODNGXFx1Qjg0MS1cXHVCODVCXFx1Qjg1RC1cXHVCODc3XFx1Qjg3OS1cXHVCODkzXFx1Qjg5NS1cXHVCOEFGXFx1QjhCMS1cXHVCOENCXFx1QjhDRC1cXHVCOEU3XFx1QjhFOS1cXHVCOTAzXFx1QjkwNS1cXHVCOTFGXFx1QjkyMS1cXHVCOTNCXFx1QjkzRC1cXHVCOTU3XFx1Qjk1OS1cXHVCOTczXFx1Qjk3NS1cXHVCOThGXFx1Qjk5MS1cXHVCOUFCXFx1QjlBRC1cXHVCOUM3XFx1QjlDOS1cXHVCOUUzXFx1QjlFNS1cXHVCOUZGXFx1QkEwMS1cXHVCQTFCXFx1QkExRC1cXHVCQTM3XFx1QkEzOS1cXHVCQTUzXFx1QkE1NS1cXHVCQTZGXFx1QkE3MS1cXHVCQThCXFx1QkE4RC1cXHVCQUE3XFx1QkFBOS1cXHVCQUMzXFx1QkFDNS1cXHVCQURGXFx1QkFFMS1cXHVCQUZCXFx1QkFGRC1cXHVCQjE3XFx1QkIxOS1cXHVCQjMzXFx1QkIzNS1cXHVCQjRGXFx1QkI1MS1cXHVCQjZCXFx1QkI2RC1cXHVCQjg3XFx1QkI4OS1cXHVCQkEzXFx1QkJBNS1cXHVCQkJGXFx1QkJDMS1cXHVCQkRCXFx1QkJERC1cXHVCQkY3XFx1QkJGOS1cXHVCQzEzXFx1QkMxNS1cXHVCQzJGXFx1QkMzMS1cXHVCQzRCXFx1QkM0RC1cXHVCQzY3XFx1QkM2OS1cXHVCQzgzXFx1QkM4NS1cXHVCQzlGXFx1QkNBMS1cXHVCQ0JCXFx1QkNCRC1cXHVCQ0Q3XFx1QkNEOS1cXHVCQ0YzXFx1QkNGNS1cXHVCRDBGXFx1QkQxMS1cXHVCRDJCXFx1QkQyRC1cXHVCRDQ3XFx1QkQ0OS1cXHVCRDYzXFx1QkQ2NS1cXHVCRDdGXFx1QkQ4MS1cXHVCRDlCXFx1QkQ5RC1cXHVCREI3XFx1QkRCOS1cXHVCREQzXFx1QkRENS1cXHVCREVGXFx1QkRGMS1cXHVCRTBCXFx1QkUwRC1cXHVCRTI3XFx1QkUyOS1cXHVCRTQzXFx1QkU0NS1cXHVCRTVGXFx1QkU2MS1cXHVCRTdCXFx1QkU3RC1cXHVCRTk3XFx1QkU5OS1cXHVCRUIzXFx1QkVCNS1cXHVCRUNGXFx1QkVEMS1cXHVCRUVCXFx1QkVFRC1cXHVCRjA3XFx1QkYwOS1cXHVCRjIzXFx1QkYyNS1cXHVCRjNGXFx1QkY0MS1cXHVCRjVCXFx1QkY1RC1cXHVCRjc3XFx1QkY3OS1cXHVCRjkzXFx1QkY5NS1cXHVCRkFGXFx1QkZCMS1cXHVCRkNCXFx1QkZDRC1cXHVCRkU3XFx1QkZFOS1cXHVDMDAzXFx1QzAwNS1cXHVDMDFGXFx1QzAyMS1cXHVDMDNCXFx1QzAzRC1cXHVDMDU3XFx1QzA1OS1cXHVDMDczXFx1QzA3NS1cXHVDMDhGXFx1QzA5MS1cXHVDMEFCXFx1QzBBRC1cXHVDMEM3XFx1QzBDOS1cXHVDMEUzXFx1QzBFNS1cXHVDMEZGXFx1QzEwMS1cXHVDMTFCXFx1QzExRC1cXHVDMTM3XFx1QzEzOS1cXHVDMTUzXFx1QzE1NS1cXHVDMTZGXFx1QzE3MS1cXHVDMThCXFx1QzE4RC1cXHVDMUE3XFx1QzFBOS1cXHVDMUMzXFx1QzFDNS1cXHVDMURGXFx1QzFFMS1cXHVDMUZCXFx1QzFGRC1cXHVDMjE3XFx1QzIxOS1cXHVDMjMzXFx1QzIzNS1cXHVDMjRGXFx1QzI1MS1cXHVDMjZCXFx1QzI2RC1cXHVDMjg3XFx1QzI4OS1cXHVDMkEzXFx1QzJBNS1cXHVDMkJGXFx1QzJDMS1cXHVDMkRCXFx1QzJERC1cXHVDMkY3XFx1QzJGOS1cXHVDMzEzXFx1QzMxNS1cXHVDMzJGXFx1QzMzMS1cXHVDMzRCXFx1QzM0RC1cXHVDMzY3XFx1QzM2OS1cXHVDMzgzXFx1QzM4NS1cXHVDMzlGXFx1QzNBMS1cXHVDM0JCXFx1QzNCRC1cXHVDM0Q3XFx1QzNEOS1cXHVDM0YzXFx1QzNGNS1cXHVDNDBGXFx1QzQxMS1cXHVDNDJCXFx1QzQyRC1cXHVDNDQ3XFx1QzQ0OS1cXHVDNDYzXFx1QzQ2NS1cXHVDNDdGXFx1QzQ4MS1cXHVDNDlCXFx1QzQ5RC1cXHVDNEI3XFx1QzRCOS1cXHVDNEQzXFx1QzRENS1cXHVDNEVGXFx1QzRGMS1cXHVDNTBCXFx1QzUwRC1cXHVDNTI3XFx1QzUyOS1cXHVDNTQzXFx1QzU0NS1cXHVDNTVGXFx1QzU2MS1cXHVDNTdCXFx1QzU3RC1cXHVDNTk3XFx1QzU5OS1cXHVDNUIzXFx1QzVCNS1cXHVDNUNGXFx1QzVEMS1cXHVDNUVCXFx1QzVFRC1cXHVDNjA3XFx1QzYwOS1cXHVDNjIzXFx1QzYyNS1cXHVDNjNGXFx1QzY0MS1cXHVDNjVCXFx1QzY1RC1cXHVDNjc3XFx1QzY3OS1cXHVDNjkzXFx1QzY5NS1cXHVDNkFGXFx1QzZCMS1cXHVDNkNCXFx1QzZDRC1cXHVDNkU3XFx1QzZFOS1cXHVDNzAzXFx1QzcwNS1cXHVDNzFGXFx1QzcyMS1cXHVDNzNCXFx1QzczRC1cXHVDNzU3XFx1Qzc1OS1cXHVDNzczXFx1Qzc3NS1cXHVDNzhGXFx1Qzc5MS1cXHVDN0FCXFx1QzdBRC1cXHVDN0M3XFx1QzdDOS1cXHVDN0UzXFx1QzdFNS1cXHVDN0ZGXFx1QzgwMS1cXHVDODFCXFx1QzgxRC1cXHVDODM3XFx1QzgzOS1cXHVDODUzXFx1Qzg1NS1cXHVDODZGXFx1Qzg3MS1cXHVDODhCXFx1Qzg4RC1cXHVDOEE3XFx1QzhBOS1cXHVDOEMzXFx1QzhDNS1cXHVDOERGXFx1QzhFMS1cXHVDOEZCXFx1QzhGRC1cXHVDOTE3XFx1QzkxOS1cXHVDOTMzXFx1QzkzNS1cXHVDOTRGXFx1Qzk1MS1cXHVDOTZCXFx1Qzk2RC1cXHVDOTg3XFx1Qzk4OS1cXHVDOUEzXFx1QzlBNS1cXHVDOUJGXFx1QzlDMS1cXHVDOURCXFx1QzlERC1cXHVDOUY3XFx1QzlGOS1cXHVDQTEzXFx1Q0ExNS1cXHVDQTJGXFx1Q0EzMS1cXHVDQTRCXFx1Q0E0RC1cXHVDQTY3XFx1Q0E2OS1cXHVDQTgzXFx1Q0E4NS1cXHVDQTlGXFx1Q0FBMS1cXHVDQUJCXFx1Q0FCRC1cXHVDQUQ3XFx1Q0FEOS1cXHVDQUYzXFx1Q0FGNS1cXHVDQjBGXFx1Q0IxMS1cXHVDQjJCXFx1Q0IyRC1cXHVDQjQ3XFx1Q0I0OS1cXHVDQjYzXFx1Q0I2NS1cXHVDQjdGXFx1Q0I4MS1cXHVDQjlCXFx1Q0I5RC1cXHVDQkI3XFx1Q0JCOS1cXHVDQkQzXFx1Q0JENS1cXHVDQkVGXFx1Q0JGMS1cXHVDQzBCXFx1Q0MwRC1cXHVDQzI3XFx1Q0MyOS1cXHVDQzQzXFx1Q0M0NS1cXHVDQzVGXFx1Q0M2MS1cXHVDQzdCXFx1Q0M3RC1cXHVDQzk3XFx1Q0M5OS1cXHVDQ0IzXFx1Q0NCNS1cXHVDQ0NGXFx1Q0NEMS1cXHVDQ0VCXFx1Q0NFRC1cXHVDRDA3XFx1Q0QwOS1cXHVDRDIzXFx1Q0QyNS1cXHVDRDNGXFx1Q0Q0MS1cXHVDRDVCXFx1Q0Q1RC1cXHVDRDc3XFx1Q0Q3OS1cXHVDRDkzXFx1Q0Q5NS1cXHVDREFGXFx1Q0RCMS1cXHVDRENCXFx1Q0RDRC1cXHVDREU3XFx1Q0RFOS1cXHVDRTAzXFx1Q0UwNS1cXHVDRTFGXFx1Q0UyMS1cXHVDRTNCXFx1Q0UzRC1cXHVDRTU3XFx1Q0U1OS1cXHVDRTczXFx1Q0U3NS1cXHVDRThGXFx1Q0U5MS1cXHVDRUFCXFx1Q0VBRC1cXHVDRUM3XFx1Q0VDOS1cXHVDRUUzXFx1Q0VFNS1cXHVDRUZGXFx1Q0YwMS1cXHVDRjFCXFx1Q0YxRC1cXHVDRjM3XFx1Q0YzOS1cXHVDRjUzXFx1Q0Y1NS1cXHVDRjZGXFx1Q0Y3MS1cXHVDRjhCXFx1Q0Y4RC1cXHVDRkE3XFx1Q0ZBOS1cXHVDRkMzXFx1Q0ZDNS1cXHVDRkRGXFx1Q0ZFMS1cXHVDRkZCXFx1Q0ZGRC1cXHVEMDE3XFx1RDAxOS1cXHVEMDMzXFx1RDAzNS1cXHVEMDRGXFx1RDA1MS1cXHVEMDZCXFx1RDA2RC1cXHVEMDg3XFx1RDA4OS1cXHVEMEEzXFx1RDBBNS1cXHVEMEJGXFx1RDBDMS1cXHVEMERCXFx1RDBERC1cXHVEMEY3XFx1RDBGOS1cXHVEMTEzXFx1RDExNS1cXHVEMTJGXFx1RDEzMS1cXHVEMTRCXFx1RDE0RC1cXHVEMTY3XFx1RDE2OS1cXHVEMTgzXFx1RDE4NS1cXHVEMTlGXFx1RDFBMS1cXHVEMUJCXFx1RDFCRC1cXHVEMUQ3XFx1RDFEOS1cXHVEMUYzXFx1RDFGNS1cXHVEMjBGXFx1RDIxMS1cXHVEMjJCXFx1RDIyRC1cXHVEMjQ3XFx1RDI0OS1cXHVEMjYzXFx1RDI2NS1cXHVEMjdGXFx1RDI4MS1cXHVEMjlCXFx1RDI5RC1cXHVEMkI3XFx1RDJCOS1cXHVEMkQzXFx1RDJENS1cXHVEMkVGXFx1RDJGMS1cXHVEMzBCXFx1RDMwRC1cXHVEMzI3XFx1RDMyOS1cXHVEMzQzXFx1RDM0NS1cXHVEMzVGXFx1RDM2MS1cXHVEMzdCXFx1RDM3RC1cXHVEMzk3XFx1RDM5OS1cXHVEM0IzXFx1RDNCNS1cXHVEM0NGXFx1RDNEMS1cXHVEM0VCXFx1RDNFRC1cXHVENDA3XFx1RDQwOS1cXHVENDIzXFx1RDQyNS1cXHVENDNGXFx1RDQ0MS1cXHVENDVCXFx1RDQ1RC1cXHVENDc3XFx1RDQ3OS1cXHVENDkzXFx1RDQ5NS1cXHVENEFGXFx1RDRCMS1cXHVENENCXFx1RDRDRC1cXHVENEU3XFx1RDRFOS1cXHVENTAzXFx1RDUwNS1cXHVENTFGXFx1RDUyMS1cXHVENTNCXFx1RDUzRC1cXHVENTU3XFx1RDU1OS1cXHVENTczXFx1RDU3NS1cXHVENThGXFx1RDU5MS1cXHVENUFCXFx1RDVBRC1cXHVENUM3XFx1RDVDOS1cXHVENUUzXFx1RDVFNS1cXHVENUZGXFx1RDYwMS1cXHVENjFCXFx1RDYxRC1cXHVENjM3XFx1RDYzOS1cXHVENjUzXFx1RDY1NS1cXHVENjZGXFx1RDY3MS1cXHVENjhCXFx1RDY4RC1cXHVENkE3XFx1RDZBOS1cXHVENkMzXFx1RDZDNS1cXHVENkRGXFx1RDZFMS1cXHVENkZCXFx1RDZGRC1cXHVENzE3XFx1RDcxOS1cXHVENzMzXFx1RDczNS1cXHVENzRGXFx1RDc1MS1cXHVENzZCXFx1RDc2RC1cXHVENzg3XFx1RDc4OS1cXHVEN0EzXSQvO1xudmFyIHJlRXh0UGljdCA9IC9eKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSQvO1xuXG52YXIgZ2V0Q29kZXBvaW50VHlwZSA9IChjaGFyLCBjb2RlKSA9PiB7XG4gIHZhciB0eXBlID0gQ29kZXBvaW50VHlwZS5Bbnk7XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlRXh0ZW5kKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuRXh0ZW5kO1xuICB9XG5cbiAgaWYgKGNvZGUgPT09IDB4MjAwZCkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5aV0o7XG4gIH1cblxuICBpZiAoY29kZSA+PSAweDFmMWU2ICYmIGNvZGUgPD0gMHgxZjFmZikge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5SSTtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZVByZXBlbmQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5QcmVwZW5kO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlU3BhY2luZ01hcmspICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFyaztcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZUwpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlY7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVDtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZUxWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFY7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVMVlQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MVlQ7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVFeHRQaWN0KSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuRXh0UGljdDtcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufTtcblxuZnVuY3Rpb24gaW50ZXJzZWN0cyh4LCB5KSB7XG4gIHJldHVybiAoeCAmIHkpICE9PSAwO1xufVxuXG52YXIgTm9uQm91bmRhcnlQYWlycyA9IFsvLyBHQjZcbltDb2RlcG9pbnRUeXBlLkwsIENvZGVwb2ludFR5cGUuTCB8IENvZGVwb2ludFR5cGUuViB8IENvZGVwb2ludFR5cGUuTFYgfCBDb2RlcG9pbnRUeXBlLkxWVF0sIC8vIEdCN1xuW0NvZGVwb2ludFR5cGUuTFYgfCBDb2RlcG9pbnRUeXBlLlYsIENvZGVwb2ludFR5cGUuViB8IENvZGVwb2ludFR5cGUuVF0sIC8vIEdCOFxuW0NvZGVwb2ludFR5cGUuTFZUIHwgQ29kZXBvaW50VHlwZS5ULCBDb2RlcG9pbnRUeXBlLlRdLCAvLyBHQjlcbltDb2RlcG9pbnRUeXBlLkFueSwgQ29kZXBvaW50VHlwZS5FeHRlbmQgfCBDb2RlcG9pbnRUeXBlLlpXSl0sIC8vIEdCOWFcbltDb2RlcG9pbnRUeXBlLkFueSwgQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFya10sIC8vIEdCOWJcbltDb2RlcG9pbnRUeXBlLlByZXBlbmQsIENvZGVwb2ludFR5cGUuQW55XSwgLy8gR0IxMVxuW0NvZGVwb2ludFR5cGUuWldKLCBDb2RlcG9pbnRUeXBlLkV4dFBpY3RdLCAvLyBHQjEyIGFuZCBHQjEzXG5bQ29kZXBvaW50VHlwZS5SSSwgQ29kZXBvaW50VHlwZS5SSV1dO1xuXG5mdW5jdGlvbiBpc0JvdW5kYXJ5UGFpcihsZWZ0LCByaWdodCkge1xuICByZXR1cm4gTm9uQm91bmRhcnlQYWlycy5maW5kSW5kZXgociA9PiBpbnRlcnNlY3RzKGxlZnQsIHJbMF0pICYmIGludGVyc2VjdHMocmlnaHQsIHJbMV0pKSA9PT0gLTE7XG59XG5cbnZhciBlbmRpbmdFbW9qaVpXSiA9IC8oPzpbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzODhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDVcXHUyNjA3LVxcdTI2MTJcXHUyNjE0LVxcdTI2ODVcXHUyNjkwLVxcdTI3MDVcXHUyNzA4LVxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzLVxcdTI3NjdcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDAtXFx1RENGRlxcdUREMEQtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREFELVxcdURERTVcXHVERTAxLVxcdURFMEZcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFM0MtXFx1REUzRlxcdURFNDktXFx1REZGQV18XFx1RDgzRFtcXHVEQzAwLVxcdUREM0RcXHVERDQ2LVxcdURFNEZcXHVERTgwLVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVEQ0ZGXFx1REQwQy1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERUZGXXxcXHVEODNGW1xcdURDMDAtXFx1REZGRF0pKD86W1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwN0ZEXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhEMy1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QkVcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxXFx1MEIzQ1xcdTBCM0VcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTUtXFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkVcXHUwQkMwXFx1MEJDRFxcdTBCRDdcXHUwQzAwXFx1MEMwNFxcdTBDM0UtXFx1MEM0MFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxXFx1MENCQ1xcdTBDQkZcXHUwQ0MyXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDBcXHUwRDAxXFx1MEQzQlxcdTBEM0NcXHUwRDNFXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODFcXHUwRENBXFx1MERDRlxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRERGXFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGNzEtXFx1MEY3RVxcdTBGODAtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNBXFx1MTAzRFxcdTEwM0VcXHUxMDU4XFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOERcXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODg1XFx1MTg4NlxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUMwXFx1MUIwMC1cXHUxQjAzXFx1MUIzNC1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGOVxcdTFERkItXFx1MURGRlxcdTIwMENcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyNVxcdUE4MjZcXHVBODJDXFx1QThDNFxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOEZGXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUxXFx1QTk4MC1cXHVBOTgyXFx1QTlCM1xcdUE5QjYtXFx1QTlCOVxcdUE5QkNcXHVBOUJEXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkY5RVxcdUZGOUZdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDNbXFx1REQyNC1cXHVERDI3XFx1REVBQlxcdURFQUNcXHVERjQ2LVxcdURGNTBdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDOS1cXHVERENDXFx1RERDRlxcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFM0VcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNCXFx1REYzQ1xcdURGM0VcXHVERjQwXFx1REY1N1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1REM1RVxcdURDQjBcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRFxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREFGXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA2W1xcdURDMkYtXFx1REMzN1xcdURDMzlcXHVEQzNBXFx1REQzMFxcdUREM0JcXHVERDNDXFx1REQzRVxcdURENDNcXHVEREQ0LVxcdURERDdcXHVERERBXFx1REREQlxcdURERTBcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzhcXHVERTNCLVxcdURFM0VcXHVERTQ3XFx1REU1MS1cXHVERTU2XFx1REU1OS1cXHVERTVCXFx1REU4QS1cXHVERTk2XFx1REU5OFxcdURFOTldfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZcXHVERDMxLVxcdUREMzZcXHVERDNBXFx1REQzQ1xcdUREM0RcXHVERDNGLVxcdURENDVcXHVERDQ3XFx1REQ5MFxcdUREOTFcXHVERDk1XFx1REQ5N1xcdURFRjNcXHVERUY0XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjRGXFx1REY4Ri1cXHVERjkyXFx1REZFNF18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1XFx1REQ2Ny1cXHVERDY5XFx1REQ2RS1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXFx1REQzMC1cXHVERDM2XFx1REVFQy1cXHVERUVGXXxcXHVEODNBW1xcdURDRDAtXFx1RENENlxcdURENDQtXFx1REQ0QV18XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdURCNDBbXFx1REMyMC1cXHVEQzdGXFx1REQwMC1cXHVEREVGXSkqXFx1MjAwRCQvO1xuXG52YXIgZW5kc1dpdGhFbW9qaVpXSiA9IHN0ciA9PiB7XG4gIHJldHVybiBzdHIuc2VhcmNoKGVuZGluZ0Vtb2ppWldKKSAhPT0gLTE7XG59O1xuXG52YXIgZW5kaW5nUklzID0gLyg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREZGXSkrJC9nO1xuXG52YXIgZW5kc1dpdGhPZGROdW1iZXJPZlJJcyA9IHN0ciA9PiB7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChlbmRpbmdSSXMpO1xuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBIFJJIGlzIHJlcHJlc2VudGVkIGJ5IGEgc3Vycm9nYXRlIHBhaXIuXG4gICAgdmFyIG51bVJJcyA9IG1hdGNoWzBdLmxlbmd0aCAvIDI7XG4gICAgcmV0dXJuIG51bVJJcyAlIDIgPT09IDE7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBTaGFyZWQgdGhlIGZ1bmN0aW9uIHdpdGggaXNFbGVtZW50VHlwZSB1dGlsaXR5XHJcbiAqL1xuXG52YXIgaXNFbGVtZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiAhRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXG52YXIgRWxlbWVudCA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSAnQW5jZXN0b3InIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNBbmNlc3Rvcih2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYEVsZW1lbnRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNFbGVtZW50LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gYXJyYXkgb2YgYEVsZW1lbnRgIG9iamVjdHMuXHJcbiAgICovXG4gIGlzRWxlbWVudExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsID0+IEVsZW1lbnQuaXNFbGVtZW50KHZhbCkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgc2V0IG9mIHByb3BzIGlzIGEgcGFydGlhbCBvZiBFbGVtZW50LlxyXG4gICAqL1xuICBpc0VsZW1lbnRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYEVsZW1lbnRgIGludGVyZmFjZSBhbmQgaGFzIGVsZW1lbnRLZXkgd2l0aCBzZWxlY3RlZCB2YWx1ZS5cclxuICAgKiBEZWZhdWx0IGl0IGNoZWNrIHRvIGB0eXBlYCBrZXkgdmFsdWVcclxuICAgKi9cbiAgaXNFbGVtZW50VHlwZTogZnVuY3Rpb24gaXNFbGVtZW50VHlwZSh2YWx1ZSwgZWxlbWVudFZhbCkge1xuICAgIHZhciBlbGVtZW50S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndHlwZSc7XG4gICAgcmV0dXJuIGlzRWxlbWVudCh2YWx1ZSkgJiYgdmFsdWVbZWxlbWVudEtleV0gPT09IGVsZW1lbnRWYWw7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gZWxlbWVudCBtYXRjaGVzIHNldCBvZiBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogTm90ZTogdGhpcyBjaGVja3MgY3VzdG9tIHByb3BlcnRpZXMsIGFuZCBpdCBkb2VzIG5vdCBlbnN1cmUgdGhhdCBhbnlcclxuICAgKiBjaGlsZHJlbiBhcmUgZXF1aXZhbGVudC5cclxuICAgKi9cbiAgbWF0Y2hlcyhlbGVtZW50LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufTtcblxudmFyIF9leGNsdWRlZCQ0ID0gW1widGV4dFwiXSxcbiAgICBfZXhjbHVkZWQyJDMgPSBbXCJ0ZXh0XCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDgob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDgodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ4KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkOChPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBJU19FRElUT1JfQ0FDSEUgPSBuZXcgV2Vha01hcCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBFZGl0b3IgPSB7XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgYW5jZXN0b3IgYWJvdmUgYSBsb2NhdGlvbiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIGFib3ZlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcbiAgICB2YXIgcmV2ZXJzZSA9IG1vZGUgPT09ICdsb3dlc3QnO1xuXG4gICAgZm9yICh2YXIgW24sIHBdIG9mIEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIHZvaWRzLFxuICAgICAgbWF0Y2gsXG4gICAgICByZXZlcnNlXG4gICAgfSkpIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSkgY29udGludWU7XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGF0LmFuY2hvci5wYXRoKSAmJiBQYXRoLmlzQW5jZXN0b3IocCwgYXQuZm9jdXMucGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKHBhdGgsIHApKSB7XG4gICAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBBZGQgYSBjdXN0b20gcHJvcGVydHkgdG8gdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQsIHRoZSBtYXJrcyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxyXG4gICAqIGBlZGl0b3IubWFya3NgIHByb3BlcnR5IGluc3RlYWQsIGFuZCBhcHBsaWVkIHdoZW4gdGV4dCBpcyBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICBhZGRNYXJrKGVkaXRvciwga2V5LCB2YWx1ZSkge1xuICAgIGVkaXRvci5hZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYWZ0ZXIgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgYWZ0ZXIoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgYW5jaG9yID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KSkpIHtcbiAgICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIHRhcmdldCA9IHA7XG4gICAgICB9XG5cbiAgICAgIGQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYmVmb3JlIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGJlZm9yZShlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBhbmNob3IgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSkpKSB7XG4gICAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgfVxuXG4gICAgICBkKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGJhY2t3YXJkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVCYWNrd2FyZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGZvcndhcmQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlbGV0ZUZvcndhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICBlZGl0b3IuZGVsZXRlRm9yd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgdGhlIGNvbnRlbnQgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVGcmFnbWVudChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudChkaXJlY3Rpb24pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBbRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpLCBFZGl0b3IuZW5kKGVkaXRvciwgYXQpXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ2VuZCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGZpcnN0IG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICAgIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZnJhZ21lbnQgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZnJhZ21lbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB2YXIgZnJhZ21lbnQgPSBOb2RlLmZyYWdtZW50KGVkaXRvciwgcmFuZ2UpO1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgaGFzIGJsb2NrIGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNCbG9ja3MoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBoYXMgaW5saW5lIGFuZCB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5ldmVyeShuID0+IFRleHQuaXNUZXh0KG4pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBibG9jayBicmVhayBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBzb2Z0IGJyZWFrIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFNvZnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgbm9kZSBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnROb2RlKGVkaXRvciwgbm9kZSkge1xuICAgIGVkaXRvci5pbnNlcnROb2RlKG5vZGUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGJsb2NrIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiAhZWRpdG9yLmlzSW5saW5lKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGBFZGl0b3JgIG9iamVjdC5cclxuICAgKi9cbiAgaXNFZGl0b3IodmFsdWUpIHtcbiAgICB2YXIgY2FjaGVkSXNFZGl0b3IgPSBJU19FRElUT1JfQ0FDSEUuZ2V0KHZhbHVlKTtcblxuICAgIGlmIChjYWNoZWRJc0VkaXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkSXNFZGl0b3I7XG4gICAgfVxuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpc0VkaXRvciA9IHR5cGVvZiB2YWx1ZS5hZGRNYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5hcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlQmFja3dhcmQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUZvcndhcmQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUZyYWdtZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0U29mdEJyZWFrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0VGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNJbmxpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzVm9pZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUubm9ybWFsaXplTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUub25DaGFuZ2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnJlbW92ZU1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmdldERpcnR5UGF0aHMgPT09ICdmdW5jdGlvbicgJiYgKHZhbHVlLm1hcmtzID09PSBudWxsIHx8IGlzUGxhaW5PYmplY3QodmFsdWUubWFya3MpKSAmJiAodmFsdWUuc2VsZWN0aW9uID09PSBudWxsIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUuc2VsZWN0aW9uKSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiBPcGVyYXRpb24uaXNPcGVyYXRpb25MaXN0KHZhbHVlLm9wZXJhdGlvbnMpO1xuICAgIElTX0VESVRPUl9DQUNIRS5zZXQodmFsdWUsIGlzRWRpdG9yKTtcbiAgICByZXR1cm4gaXNFZGl0b3I7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyB0aGUgZW5kIHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgZW5kKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGFuIGVkZ2Ugb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgaXNFZGdlKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgcG9pbnQsIGF0KSB8fCBFZGl0b3IuaXNFbmQoZWRpdG9yLCBwb2ludCwgYXQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgZW1wdHksIGFjY291bnRpbmcgZm9yIHZvaWQgbm9kZXMuXHJcbiAgICovXG4gIGlzRW1wdHkoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgdmFyIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgdmFyIFtmaXJzdF0gPSBjaGlsZHJlbjtcbiAgICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBUZXh0LmlzVGV4dChmaXJzdCkgJiYgZmlyc3QudGV4dCA9PT0gJycgJiYgIWVkaXRvci5pc1ZvaWQoZWxlbWVudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpbmxpbmUgYEVsZW1lbnRgIG9iamVjdC5cclxuICAgKi9cbiAgaXNJbmxpbmUoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgY3VycmVudGx5IG5vcm1hbGl6aW5nIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxyXG4gICAqL1xuICBpc05vcm1hbGl6aW5nKGVkaXRvcikge1xuICAgIHZhciBpc05vcm1hbGl6aW5nID0gTk9STUFMSVpJTkcuZ2V0KGVkaXRvcik7XG4gICAgcmV0dXJuIGlzTm9ybWFsaXppbmcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpc05vcm1hbGl6aW5nO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgdGhlIHN0YXJ0IHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICAvLyBQRVJGOiBJZiB0aGUgb2Zmc2V0IGlzbid0IGAwYCB3ZSBrbm93IGl0J3Mgbm90IHRoZSBzdGFydC5cbiAgICBpZiAocG9pbnQub2Zmc2V0ICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIHN0YXJ0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgdm9pZCBgRWxlbWVudGAgb2JqZWN0LlxyXG4gICAqL1xuICBpc1ZvaWQoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNWb2lkKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxhc3Qgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsYXN0KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsZWFmIHRleHQgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsZWFmKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIHBhdGgpO1xuICAgIHJldHVybiBbbm9kZSwgcGF0aF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgbGV2ZWxzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gICpsZXZlbHMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcblxuICAgIGZvciAodmFyIFtuLCBwXSBvZiBOb2RlLmxldmVscyhlZGl0b3IsIHBhdGgpKSB7XG4gICAgICBpZiAoIW1hdGNoKG4sIHApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXZlbHMucHVzaChbbiwgcF0pO1xuXG4gICAgICBpZiAoIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGV2ZWxzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB5aWVsZCogbGV2ZWxzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWFya3MgdGhhdCB3b3VsZCBiZSBhZGRlZCB0byB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgbWFya3MoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIG1hcmtzLFxuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobWFya3MpIHtcbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgW21hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBbX25vZGVdID0gbWF0Y2g7XG5cbiAgICAgICAgdmFyIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlLCBfZXhjbHVkZWQkNCk7XG5cbiAgICAgICAgcmV0dXJuIF9yZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIHZhciB7XG4gICAgICBwYXRoXG4gICAgfSA9IGFuY2hvcjtcbiAgICB2YXIgW25vZGVdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKTtcblxuICAgIGlmIChhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgICAgfSk7XG4gICAgICB2YXIgbWFya2VkVm9pZCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pICYmIGVkaXRvci5tYXJrYWJsZVZvaWQobilcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW1hcmtlZFZvaWQpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByZXYgJiYgYmxvY2spIHtcbiAgICAgICAgICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2O1xuICAgICAgICAgIHZhciBbLCBibG9ja1BhdGhdID0gYmxvY2s7XG5cbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKGJsb2NrUGF0aCwgcHJldlBhdGgpKSB7XG4gICAgICAgICAgICBub2RlID0gcHJldk5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMiQzKTtcblxuICAgIHJldHVybiByZXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgYnJhbmNoIG9mIHRoZSBkb2N1bWVudCBhZnRlciBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBuZXh0KGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludEFmdGVyTG9jYXRpb24gPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwge1xuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICBpZiAoIXBvaW50QWZ0ZXJMb2NhdGlvbikgcmV0dXJuO1xuICAgIHZhciBbLCB0b10gPSBFZGl0b3IubGFzdChlZGl0b3IsIFtdKTtcbiAgICB2YXIgc3BhbiA9IFtwb2ludEFmdGVyTG9jYXRpb24ucGF0aCwgdG9dO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIG5leHQgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgW25leHRdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBub2RlKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBub2RlcyBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICAqbm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2FsbCcsXG4gICAgICB1bml2ZXJzYWwgPSBmYWxzZSxcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuXG4gICAgaWYgKFNwYW4uaXNTcGFuKGF0KSkge1xuICAgICAgZnJvbSA9IGF0WzBdO1xuICAgICAgdG8gPSBhdFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnZW5kJ1xuICAgICAgfSk7XG4gICAgICBmcm9tID0gcmV2ZXJzZSA/IGxhc3QgOiBmaXJzdDtcbiAgICAgIHRvID0gcmV2ZXJzZSA/IGZpcnN0IDogbGFzdDtcbiAgICB9XG5cbiAgICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgICB2YXIgW25dID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIHZvaWRzID8gZmFsc2UgOiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgaGl0O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIG5vZGVFbnRyaWVzKSB7XG4gICAgICB2YXIgaXNMb3dlciA9IGhpdCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgaGl0WzFdKSA9PT0gMDsgLy8gSW4gaGlnaGVzdCBtb2RlIGFueSBub2RlIGxvd2VyIHRoYW4gdGhlIGxhc3QgaGl0IGlzIG5vdCBhIG1hdGNoLlxuXG4gICAgICBpZiAobW9kZSA9PT0gJ2hpZ2hlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbWF0Y2gobm9kZSwgcGF0aCkpIHtcbiAgICAgICAgLy8gSWYgd2UndmUgYXJyaXZlZCBhdCBhIGxlYWYgdGV4dCBub2RlIHRoYXQgaXMgbm90IGxvd2VyIHRoYW4gdGhlIGxhc3RcbiAgICAgICAgLy8gaGl0LCB0aGVuIHdlJ3ZlIGZvdW5kIGEgYnJhbmNoIHRoYXQgZG9lc24ndCBpbmNsdWRlIGEgbWF0Y2gsIHdoaWNoXG4gICAgICAgIC8vIG1lYW5zIHRoZSBtYXRjaCBpcyBub3QgdW5pdmVyc2FsLlxuICAgICAgICBpZiAodW5pdmVyc2FsICYmICFpc0xvd2VyICYmIFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIElmIHRoZXJlJ3MgYSBtYXRjaCBhbmQgaXQncyBsb3dlciB0aGFuIHRoZSBsYXN0LCB1cGRhdGUgdGhlIGhpdC5cblxuXG4gICAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJbiBsb3dlc3QgbW9kZSB3ZSBlbWl0IHRoZSBsYXN0IGhpdCwgb25jZSBpdCdzIGd1YXJhbnRlZWQgbG93ZXN0LlxuXG5cbiAgICAgIHZhciBlbWl0ID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyBoaXQgOiBbbm9kZSwgcGF0aF07XG5cbiAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZW1pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgZW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgfSAvLyBTaW5jZSBsb3dlc3QgaXMgYWx3YXlzIGVtaXR0aW5nIG9uZSBiZWhpbmQsIGNhdGNoIHVwIGF0IHRoZSBlbmQuXG5cblxuICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBoaXQpIHtcbiAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGhpdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBoaXQ7XG4gICAgICB9XG4gICAgfSAvLyBVbml2ZXJzYWwgZGVmZXJzIHRvIGVuc3VyZSB0aGF0IHRoZSBtYXRjaCBvY2N1cnMgaW4gZXZlcnkgYnJhbmNoLCBzbyB3ZVxuICAgIC8vIHlpZWxkIGFsbCBvZiB0aGUgbWF0Y2hlcyBhZnRlciBpdGVyYXRpbmcuXG5cblxuICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgIHlpZWxkKiBtYXRjaGVzO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBOb3JtYWxpemUgYW55IGRpcnR5IG9iamVjdHMgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgbm9ybWFsaXplKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZm9yY2UgPSBmYWxzZSxcbiAgICAgIG9wZXJhdGlvblxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgdmFyIGdldERpcnR5UGF0aHMgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RGlydHlQYXRoS2V5cyA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgICB9O1xuXG4gICAgdmFyIHBvcERpcnR5UGF0aCA9IGVkaXRvciA9PiB7XG4gICAgICB2YXIgcGF0aCA9IGdldERpcnR5UGF0aHMoZWRpdG9yKS5wb3AoKTtcbiAgICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcbiAgICAgIGdldERpcnR5UGF0aEtleXMoZWRpdG9yKS5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cbiAgICBpZiAoIUVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIHZhciBhbGxQYXRocyA9IEFycmF5LmZyb20oTm9kZS5ub2RlcyhlZGl0b3IpLCBfcmVmMiA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFsbFBhdGhLZXlzID0gbmV3IFNldChhbGxQYXRocy5tYXAocCA9PiBwLmpvaW4oJywnKSkpO1xuICAgICAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgYWxsUGF0aHMpO1xuICAgICAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGFsbFBhdGhLZXlzKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAvKlxyXG4gICAgICAgIEZpeCBkaXJ0eSBlbGVtZW50cyB3aXRoIG5vIGNoaWxkcmVuLlxyXG4gICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKCkgZG9lcyBmaXggdGhpcywgYnV0IHNvbWUgbm9ybWFsaXphdGlvbiBmaXhlcyBhbHNvIHJlcXVpcmUgaXQgdG8gd29yay5cclxuICAgICAgICBSdW5uaW5nIGFuIGluaXRpYWwgcGFzcyBhdm9pZHMgdGhlIGNhdGNoLTIyIHJhY2UgY29uZGl0aW9uLlxyXG4gICAgICAqL1xuICAgICAgZm9yICh2YXIgZGlydHlQYXRoIG9mIGdldERpcnR5UGF0aHMoZWRpdG9yKSkge1xuICAgICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBkaXJ0eVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBkaXJ0eVBhdGgpO1xuICAgICAgICAgIHZhciBbbm9kZSwgX10gPSBlbnRyeTtcbiAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBUaGUgZGVmYXVsdCBub3JtYWxpemVyIGluc2VydHMgYW4gZW1wdHkgdGV4dCBub2RlIGluIHRoaXMgc2NlbmFyaW8sIGJ1dCBpdCBjYW4gYmUgY3VzdG9taXNlZC5cclxuICAgICAgICAgICAgU28gdGhlcmUgaXMgc29tZSByaXNrIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgQXMgbG9uZyBhcyB0aGUgbm9ybWFsaXplciBvbmx5IGluc2VydHMgY2hpbGQgbm9kZXMgZm9yIHRoaXMgY2FzZSBpdCBpcyBzYWZlIHRvIGRvIGluIGFueSBvcmRlcjtcclxuICAgICAgICAgICAgYnkgZGVmaW5pdGlvbiBhZGRpbmcgY2hpbGRyZW4gdG8gYW4gZW1wdHkgbm9kZSBjYW4ndCBjYXVzZSBvdGhlciBwYXRocyB0byBjaGFuZ2UuXHJcbiAgICAgICAgICAqL1xuXG4gICAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShlbnRyeSwge1xuICAgICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICAgIHZhciBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCA9IGRpcnR5UGF0aHMubGVuZ3RoO1xuICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG5cbiAgICAgIHdoaWxlIChkaXJ0eVBhdGhzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBpZiAoIWVkaXRvci5zaG91bGROb3JtYWxpemUoe1xuICAgICAgICAgIGRpcnR5UGF0aHMsXG4gICAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICAgIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoLFxuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZGlydHlQYXRoID0gcG9wRGlydHlQYXRoKGVkaXRvcik7IC8vIElmIHRoZSBub2RlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHRyZWUsIGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgbm9ybWFsaXplZC5cblxuXG4gICAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIF9kaXJ0eVBhdGgpKSB7XG4gICAgICAgICAgdmFyIF9lbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgX2RpcnR5UGF0aCk7XG5cbiAgICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShfZW50cnksIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlcmF0aW9uKys7XG4gICAgICAgIGRpcnR5UGF0aHMgPSBnZXREaXJ0eVBhdGhzKGVkaXRvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXJlbnQgbm9kZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBwYXJlbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXJlbnRQYXRoKTtcbiAgICByZXR1cm4gZW50cnk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXRoIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBhdGgoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZGVwdGgsXG4gICAgICBlZGdlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIGF0ID0gZmlyc3RQYXRoO1xuICAgICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpO1xuICAgICAgICBhdCA9IGxhc3RQYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgICAgYXQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIGF0ID0gUmFuZ2UuZW5kKGF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0ID0gUGF0aC5jb21tb24oYXQuYW5jaG9yLnBhdGgsIGF0LmZvY3VzLnBhdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgYXQgPSBhdC5wYXRoO1xuICAgIH1cblxuICAgIGlmIChkZXB0aCAhPSBudWxsKSB7XG4gICAgICBhdCA9IGF0LnNsaWNlKDAsIGRlcHRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG5cbiAgaGFzUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgICByZXR1cm4gTm9kZS5oYXMoZWRpdG9yLCBwYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUGF0aGAgb2JqZWN0LCB3aGljaCB3aWxsIHN0YXkgaW4gc3luYyBhcyBuZXdcclxuICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBhdGhSZWYoZWRpdG9yLCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBwYXRoLFxuICAgICAgYWZmaW5pdHksXG5cbiAgICAgIHVucmVmKCkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgfSA9IHJlZjtcbiAgICAgICAgdmFyIHBhdGhSZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgICAgIHBhdGhSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuXG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwYXRoIHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcGF0aFJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBQQVRIX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBQQVRIX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBvciBlbmQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcG9pbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZWRnZSA9ICdzdGFydCdcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBwYXRoO1xuXG4gICAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdChlZGl0b3IsIGF0KTtcbiAgICAgICAgcGF0aCA9IGxhc3RQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KGVkaXRvciwgYXQpO1xuICAgICAgICBwYXRoID0gZmlyc3RQYXRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgXCIuY29uY2F0KGVkZ2UsIFwiIHBvaW50IGluIHRoZSBub2RlIGF0IHBhdGggW1wiKS5jb25jYXQoYXQsIFwiXSBiZWNhdXNlIGl0IGhhcyBubyBcIikuY29uY2F0KGVkZ2UsIFwiIHRleHQgbm9kZS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQ6IGVkZ2UgPT09ICdlbmQnID8gbm9kZS50ZXh0Lmxlbmd0aCA6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgcmV0dXJuIGVkZ2UgPT09ICdzdGFydCcgPyBzdGFydCA6IGVuZDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSByZWYgZm9yIGEgYFBvaW50YCBvYmplY3QsIHdoaWNoIHdpbGwgc3RheSBpbiBzeW5jIGFzIG5ld1xyXG4gICAqIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcG9pbnRSZWYoZWRpdG9yLCBwb2ludCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogcG9pbnQsXG4gICAgICBhZmZpbml0eSxcblxuICAgICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgY3VycmVudFxuICAgICAgICB9ID0gcmVmO1xuICAgICAgICB2YXIgcG9pbnRSZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgICAgICBwb2ludFJlZnMuZGVsZXRlKHJlZik7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHZhciByZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwb2ludCByZWZzIG9mIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBvaW50UmVmcyhlZGl0b3IpIHtcbiAgICB2YXIgcmVmcyA9IFBPSU5UX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBQT0lOVF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbGwgdGhlIHBvc2l0aW9ucyBpbiBgYXRgIHJhbmdlIHdoZXJlIGEgYFBvaW50YCBjYW4gYmUgcGxhY2VkLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCwgbW92ZXMgZm9yd2FyZCBieSBpbmRpdmlkdWFsIG9mZnNldHMgYXQgYSB0aW1lLCBidXRcclxuICAgKiB0aGUgYHVuaXRgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byB0byBtb3ZlIGJ5IGNoYXJhY3Rlciwgd29yZCwgbGluZSwgb3IgYmxvY2suXHJcbiAgICpcclxuICAgKiBUaGUgYHJldmVyc2VgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgaXRlcmF0aW9uIGRpcmVjdGlvbi5cclxuICAgKlxyXG4gICAqIE5vdGU6IEJ5IGRlZmF1bHQgdm9pZCBub2RlcyBhcmUgdHJlYXRlZCBhcyBhIHNpbmdsZSBwb2ludCBhbmQgaXRlcmF0aW9uXHJcbiAgICogd2lsbCBub3QgaGFwcGVuIGluc2lkZSB0aGVpciBjb250ZW50IHVubGVzcyB5b3UgcGFzcyBpbiB0cnVlIGZvciB0aGVcclxuICAgKiBgdm9pZHNgIG9wdGlvbiwgdGhlbiBpdGVyYXRpb24gd2lsbCBvY2N1ci5cclxuICAgKi9cbiAgKnBvc2l0aW9ucyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIHVuaXQgPSAnb2Zmc2V0JyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBBbGdvcml0aG0gbm90ZXM6XHJcbiAgICAgKlxyXG4gICAgICogRWFjaCBzdGVwIGBkaXN0YW5jZWAgaXMgZHluYW1pYyBkZXBlbmRpbmcgb24gdGhlIHVuZGVybHlpbmcgdGV4dFxyXG4gICAgICogYW5kIHRoZSBgdW5pdGAgc3BlY2lmaWVkLiAgRWFjaCBzdGVwLCBlLmcuLCBhIGxpbmUgb3Igd29yZCwgbWF5XHJcbiAgICAgKiBzcGFuIG11bHRpcGxlIHRleHQgbm9kZXMsIHNvIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgdGV4dCBib3RoIG9uXHJcbiAgICAgKiB0d28gbGV2ZWxzIGluIHN0ZXAtc3luYzpcclxuICAgICAqXHJcbiAgICAgKiBgbGVhZlRleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIHRleHQgbGVhZiBsZXZlbCwgYW5kIGlzIGFkdmFuY2VkXHJcbiAgICAgKiB0aHJvdWdoIHVzaW5nIHRoZSBjb3VudGVycyBgbGVhZlRleHRPZmZzZXRgIGFuZCBgbGVhZlRleHRSZW1haW5pbmdgLlxyXG4gICAgICpcclxuICAgICAqIGBibG9ja1RleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIGJsb2NrIGxldmVsLCBhbmQgaXMgc2hvcnRlbmVkXHJcbiAgICAgKiBieSBgZGlzdGFuY2VgIGV2ZXJ5IHRpbWUgaXQgaXMgYWR2YW5jZWQuXHJcbiAgICAgKlxyXG4gICAgICogV2Ugb25seSBtYWludGFpbiBhIHdpbmRvdyBvZiBvbmUgYmxvY2tUZXh0IGFuZCBvbmUgbGVhZlRleHQgYmVjYXVzZVxyXG4gICAgICogYSBibG9jayBub2RlIGFsd2F5cyBhcHBlYXJzIGJlZm9yZSBhbGwgb2YgaXRzIGxlYWYgbm9kZXMuXHJcbiAgICAgKi9cblxuXG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIGZpcnN0ID0gcmV2ZXJzZSA/IGVuZCA6IHN0YXJ0O1xuICAgIHZhciBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgdmFyIGJsb2NrVGV4dCA9ICcnO1xuICAgIHZhciBkaXN0YW5jZSA9IDA7IC8vIERpc3RhbmNlIGZvciBsZWFmVGV4dCB0byBjYXRjaCB1cCB0byBibG9ja1RleHQuXG5cbiAgICB2YXIgbGVhZlRleHRSZW1haW5pbmcgPSAwO1xuICAgIHZhciBsZWFmVGV4dE9mZnNldCA9IDA7IC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgbm9kZXMgaW4gcmFuZ2UsIGdyYWJiaW5nIGVudGlyZSB0ZXh0dWFsIGNvbnRlbnRcbiAgICAvLyBvZiBibG9jayBub2RlcyBpbiBibG9ja1RleHQsIGFuZCB0ZXh0IG5vZGVzIGluIGxlYWZUZXh0LlxuICAgIC8vIEV4cGxvaXRzIHRoZSBmYWN0IHRoYXQgbm9kZXMgYXJlIHNlcXVlbmNlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgZmlyc3RcbiAgICAvLyBlbmNvdW50ZXIgdGhlIGJsb2NrIG5vZGUsIHRoZW4gYWxsIG9mIGl0cyB0ZXh0IG5vZGVzLCBzbyB3aGVuIGl0ZXJhdGluZ1xuICAgIC8vIHRocm91Z2ggdGhlIGJsb2NrVGV4dCBhbmQgbGVhZlRleHQgd2UganVzdCBuZWVkIHRvIHJlbWVtYmVyIGEgd2luZG93IG9mXG4gICAgLy8gb25lIGJsb2NrIG5vZGUgYW5kIGxlYWYgbm9kZSwgcmVzcGVjdGl2ZWx5LlxuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIC8qXHJcbiAgICAgICAqIEVMRU1FTlQgTk9ERSAtIFlpZWxkIHBvc2l0aW9uKHMpIGZvciB2b2lkcywgY29sbGVjdCBibG9ja1RleHQgZm9yIGJsb2Nrc1xyXG4gICAgICAgKi9cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICAvLyBWb2lkIG5vZGVzIGFyZSBhIHNwZWNpYWwgY2FzZSwgc28gYnkgZGVmYXVsdCB3ZSB3aWxsIGFsd2F5c1xuICAgICAgICAvLyB5aWVsZCB0aGVpciBmaXJzdCBwb2ludC4gSWYgdGhlIGB2b2lkc2Agb3B0aW9uIGlzIHNldCB0byB0cnVlLFxuICAgICAgICAvLyB0aGVuIHdlIHdpbGwgaXRlcmF0ZSBvdmVyIHRoZWlyIGNvbnRlbnQuXG4gICAgICAgIGlmICghdm9pZHMgJiYgZWRpdG9yLmlzVm9pZChub2RlKSkge1xuICAgICAgICAgIHlpZWxkIEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIElubGluZSBlbGVtZW50IG5vZGVzIGFyZSBpZ25vcmVkIGFzIHRoZXkgZG9uJ3QgdGhlbXNlbHZlc1xuICAgICAgICAvLyBjb250cmlidXRlIHRvIGBibG9ja1RleHRgIG9yIGBsZWFmVGV4dGAgLSB0aGVpciBwYXJlbnQgYW5kXG4gICAgICAgIC8vIGNoaWxkcmVuIGRvLlxuXG5cbiAgICAgICAgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkgY29udGludWU7IC8vIEJsb2NrIGVsZW1lbnQgbm9kZSAtIHNldCBgYmxvY2tUZXh0YCB0byBpdHMgdGV4dCBjb250ZW50LlxuXG4gICAgICAgIGlmIChFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgLy8gV2UgYWx3YXlzIGV4aGF1c3QgYmxvY2sgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLFxuICAgICAgICAgIC8vICAgICBgYmxvY2tUZXh0PScke2Jsb2NrVGV4dH0nIC0gYCtcbiAgICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBibG9jayBub2RlYCwgcGF0aClcbiAgICAgICAgICAvLyBFbnN1cmUgcmFuZ2UgY29uc2lkZXJlZCBpcyBjYXBwZWQgdG8gYHJhbmdlYCwgaW4gdGhlXG4gICAgICAgICAgLy8gc3RhcnQvZW5kIGVkZ2UgY2FzZXMgd2hlcmUgYmxvY2sgZXh0ZW5kcyBiZXlvbmQgcmFuZ2UuXG4gICAgICAgICAgLy8gRXF1aXZhbGVudCB0byB0aGlzLCBidXQgcHJlc3VtYWJseSBtb3JlIHBlcmZvcm1hbnQ6XG4gICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgLi4uRWRpdG9yLmVkZ2VzKGVkaXRvciwgcGF0aCkpXG4gICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBibG9ja1JhbmdlKSAvLyBpbnRlcnNlY3RcbiAgICAgICAgICAvLyAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBibG9ja1JhbmdlLCB7IHZvaWRzIH0pXG4gICAgICAgICAgdmFyIGUgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgZW5kLnBhdGgpID8gZW5kIDogRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIHZhciBzID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIHN0YXJ0LnBhdGgpID8gc3RhcnQgOiBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICBibG9ja1RleHQgPSBFZGl0b3Iuc3RyaW5nKGVkaXRvciwge1xuICAgICAgICAgICAgYW5jaG9yOiBzLFxuICAgICAgICAgICAgZm9jdXM6IGVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlzTmV3QmxvY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKlxyXG4gICAgICAgKiBURVhUIExFQUYgTk9ERSAtIEl0ZXJhdGUgdGhyb3VnaCB0ZXh0IGNvbnRlbnQsIHlpZWxkaW5nXHJcbiAgICAgICAqIHBvc2l0aW9ucyBldmVyeSBgZGlzdGFuY2VgIG9mZnNldCBhY2NvcmRpbmcgdG8gYHVuaXRgLlxyXG4gICAgICAgKi9cblxuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgdmFyIGlzRmlyc3QgPSBQYXRoLmVxdWFscyhwYXRoLCBmaXJzdC5wYXRoKTsgLy8gUHJvb2YgdGhhdCB3ZSBhbHdheXMgZXhoYXVzdCB0ZXh0IG5vZGVzIGJlZm9yZSBlbmNvdW50ZXJpbmcgYSBuZXcgb25lOlxuICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsXG4gICAgICAgIC8vICAgICBgbGVhZlRleHRSZW1haW5pbmc9JHtsZWFmVGV4dFJlbWFpbmluZ30gLSBgK1xuICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBsZWFmIHRleHQgbm9kZWAsIHBhdGgpXG4gICAgICAgIC8vIFJlc2V0IGBsZWFmVGV4dGAgY291bnRlcnMgZm9yIG5ldyB0ZXh0IG5vZGUuXG5cbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IHJldmVyc2UgPyBmaXJzdC5vZmZzZXQgOiBub2RlLnRleHQubGVuZ3RoIC0gZmlyc3Qub2Zmc2V0O1xuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gZmlyc3Qub2Zmc2V0OyAvLyBXb3JrcyBmb3IgcmV2ZXJzZSB0b28uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSBub2RlLnRleHQubGVuZ3RoO1xuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0UmVtYWluaW5nIDogMDtcbiAgICAgICAgfSAvLyBZaWVsZCBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2Ygbm9kZSAocG90ZW50aWFsbHkpLlxuXG5cbiAgICAgICAgaWYgKGlzRmlyc3QgfHwgaXNOZXdCbG9jayB8fCB1bml0ID09PSAnb2Zmc2V0Jykge1xuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgICAgIH0gLy8gWWllbGQgcG9zaXRpb25zIGV2ZXJ5IChkeW5hbWljYWxseSBjYWxjdWxhdGVkKSBgZGlzdGFuY2VgIG9mZnNldC5cblxuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgLy8gSWYgYGxlYWZUZXh0YCBoYXMgY2F1Z2h0IHVwIHdpdGggYGJsb2NrVGV4dGAgKGRpc3RhbmNlPTApLFxuICAgICAgICAgIC8vIGFuZCBpZiBibG9ja1RleHQgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYW5vdGhlciBibG9jayBub2RlLFxuICAgICAgICAgIC8vIG90aGVyd2lzZSBhZHZhbmNlIGJsb2NrVGV4dCBmb3J3YXJkIGJ5IHRoZSBuZXcgYGRpc3RhbmNlYC5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChibG9ja1RleHQgPT09ICcnKSBicmVhaztcbiAgICAgICAgICAgIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKGJsb2NrVGV4dCwgdW5pdCwgcmV2ZXJzZSk7IC8vIFNwbGl0IHRoZSBzdHJpbmcgYXQgdGhlIHByZXZpb3VzbHkgZm91bmQgZGlzdGFuY2UgYW5kIHVzZSB0aGVcbiAgICAgICAgICAgIC8vIHJlbWFpbmluZyBzdHJpbmcgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cblxuICAgICAgICAgICAgYmxvY2tUZXh0ID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKGJsb2NrVGV4dCwgZGlzdGFuY2UsIHJldmVyc2UpWzFdO1xuICAgICAgICAgIH0gLy8gQWR2YW5jZSBgbGVhZlRleHRgIGJ5IHRoZSBjdXJyZW50IGBkaXN0YW5jZWAuXG5cblxuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0T2Zmc2V0IC0gZGlzdGFuY2UgOiBsZWFmVGV4dE9mZnNldCArIGRpc3RhbmNlO1xuICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbGVhZlRleHRSZW1haW5pbmcgLSBkaXN0YW5jZTsgLy8gSWYgYGxlYWZUZXh0YCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhIG5ldyBsZWFmIG5vZGVcbiAgICAgICAgICAvLyBhbmQgc2V0IGRpc3RhbmNlIHRvIHRoZSBvdmVyZmxvdyBhbW91bnQsIHNvIHdlJ2xsIChtYXliZSlcbiAgICAgICAgICAvLyBjYXRjaCB1cCB0byBibG9ja1RleHQgaW4gdGhlIG5leHQgbGVhZiB0ZXh0IG5vZGUuXG5cbiAgICAgICAgICBpZiAobGVhZlRleHRSZW1haW5pbmcgPCAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IC1sZWFmVGV4dFJlbWFpbmluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gLy8gU3VjY2Vzc2Z1bGx5IHdhbGtlZCBgZGlzdGFuY2VgIG9mZnNldHMgdGhyb3VnaCBgbGVhZlRleHRgXG4gICAgICAgICAgLy8gdG8gY2F0Y2ggdXAgd2l0aCBgYmxvY2tUZXh0YCwgc28gd2UgY2FuIHJlc2V0IGBkaXN0YW5jZWBcbiAgICAgICAgICAvLyBhbmQgeWllbGQgdGhpcyBwb3NpdGlvbiBpbiB0aGlzIG5vZGUuXG5cblxuICAgICAgICAgIGRpc3RhbmNlID0gMDtcbiAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiBsZWFmVGV4dE9mZnNldFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFByb29mIHRoYXQgdXBvbiBjb21wbGV0aW9uLCB3ZSd2ZSBleGFodXN0ZWQgYm90aCBsZWFmIGFuZCBibG9jayB0ZXh0OlxuICAgIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCwgXCJsZWFmVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLCBcImJsb2NrVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gICAgLy8gSGVscGVyOlxuICAgIC8vIFJldHVybiB0aGUgZGlzdGFuY2UgaW4gb2Zmc2V0cyBmb3IgYSBzdGVwIG9mIHNpemUgYHVuaXRgIG9uIGdpdmVuIHN0cmluZy5cblxuXG4gICAgZnVuY3Rpb24gY2FsY0Rpc3RhbmNlKHRleHQsIHVuaXQsIHJldmVyc2UpIHtcbiAgICAgIGlmICh1bml0ID09PSAnY2hhcmFjdGVyJykge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICd3b3JkJykge1xuICAgICAgICByZXR1cm4gZ2V0V29yZERpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnbGluZScgfHwgdW5pdCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG1hdGNoaW5nIG5vZGUgaW4gdGhlIGJyYW5jaCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHByZXZpb3VzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludEJlZm9yZUxvY2F0aW9uID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGF0LCB7XG4gICAgICB2b2lkc1xuICAgIH0pO1xuXG4gICAgaWYgKCFwb2ludEJlZm9yZUxvY2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIFssIHRvXSA9IEVkaXRvci5maXJzdChlZGl0b3IsIFtdKTsgLy8gVGhlIHNlYXJjaCBsb2NhdGlvbiBpcyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgdG8gdGhlIHBhdGggb2ZcbiAgICAvLyB0aGUgcG9pbnQgYmVmb3JlIHRoZSBsb2NhdGlvbiBwYXNzZWQgaW5cblxuICAgIHZhciBzcGFuID0gW3BvaW50QmVmb3JlTG9jYXRpb24ucGF0aCwgdG9dO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuXG4gICAgICAgIG1hdGNoID0gbiA9PiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFtwcmV2aW91c10gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgYSByYW5nZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICByYW5nZShlZGl0b3IsIGF0LCB0bykge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiAhdG8pIHtcbiAgICAgIHJldHVybiBhdDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCB0byB8fCBhdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUmFuZ2VgIG9iamVjdCwgd2hpY2ggd2lsbCBzdGF5IGluIHN5bmMgYXMgbmV3XHJcbiAgICogb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICByYW5nZVJlZihlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiByYW5nZSxcbiAgICAgIGFmZmluaXR5LFxuXG4gICAgICB1bnJlZigpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBjdXJyZW50XG4gICAgICAgIH0gPSByZWY7XG4gICAgICAgIHZhciByYW5nZVJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgICAgIHJhbmdlUmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cblxuICAgIH07XG4gICAgdmFyIHJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgcmVmcy5hZGQocmVmKTtcbiAgICByZXR1cm4gcmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSB0cmFja2VkIHJhbmdlIHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcmFuZ2VSZWZzKGVkaXRvcikge1xuICAgIHZhciByZWZzID0gUkFOR0VfUkVGUy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcmVmcykge1xuICAgICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgIFJBTkdFX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgY3VzdG9tIHByb3BlcnR5IGZyb20gYWxsIG9mIHRoZSBsZWFmIHRleHQgbm9kZXMgaW4gdGhlIGN1cnJlbnRcclxuICAgKiBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQsIHRoZSByZW1vdmFsIHdpbGwgYmUgc3RvcmVkIG9uXHJcbiAgICogYGVkaXRvci5tYXJrc2AgYW5kIGFwcGxpZWQgdG8gdGhlIHRleHQgaW5zZXJ0ZWQgbmV4dC5cclxuICAgKi9cbiAgcmVtb3ZlTWFyayhlZGl0b3IsIGtleSkge1xuICAgIGVkaXRvci5yZW1vdmVNYXJrKGtleSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWFudWFsbHkgc2V0IGlmIHRoZSBlZGl0b3Igc2hvdWxkIGN1cnJlbnRseSBiZSBub3JtYWxpemluZy5cclxuICAgKlxyXG4gICAqIE5vdGU6IFVzaW5nIHRoaXMgaW5jb3JyZWN0bHkgY2FuIGxlYXZlIHRoZSBlZGl0b3IgaW4gYW4gaW52YWxpZCBzdGF0ZS5cclxuICAgKlxyXG4gICAqL1xuICBzZXROb3JtYWxpemluZyhlZGl0b3IsIGlzTm9ybWFsaXppbmcpIHtcbiAgICBOT1JNQUxJWklORy5zZXQoZWRpdG9yLCBpc05vcm1hbGl6aW5nKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHN0YXJ0KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHRleHQgc3RyaW5nIGNvbnRlbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKlxyXG4gICAqIE5vdGU6IGJ5IGRlZmF1bHQgdGhlIHRleHQgb2Ygdm9pZCBub2RlcyBpcyBjb25zaWRlcmVkIHRvIGJlIGFuIGVtcHR5XHJcbiAgICogc3RyaW5nLCByZWdhcmRsZXNzIG9mIGNvbnRlbnQsIHVubGVzcyB5b3UgcGFzcyBpbiB0cnVlIGZvciB0aGUgdm9pZHMgb3B0aW9uXHJcbiAgICovXG4gIHN0cmluZyhlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIHRleHQgPSAnJztcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICB2b2lkc1xuICAgIH0pKSB7XG4gICAgICB2YXIgdCA9IG5vZGUudGV4dDtcblxuICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICB0ID0gdC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgIHQgPSB0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHRleHQgKz0gdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIG5vbi1oYW5naW5nIG9uZS5cclxuICAgKi9cbiAgdW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7IC8vIFBFUkY6IGV4aXQgZWFybHkgaWYgd2UgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZSBpc24ndCBoYW5naW5nLlxuXG4gICAgaWYgKHN0YXJ0Lm9mZnNldCAhPT0gMCB8fCBlbmQub2Zmc2V0ICE9PSAwIHx8IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSB8fCBQYXRoLmhhc1ByZXZpb3VzKGVuZC5wYXRoKSkge1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cblxuICAgIHZhciBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIGF0OiBlbmQsXG4gICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgYmxvY2tQYXRoID0gZW5kQmxvY2sgPyBlbmRCbG9ja1sxXSA6IFtdO1xuICAgIHZhciBmaXJzdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHN0YXJ0KTtcbiAgICB2YXIgYmVmb3JlID0ge1xuICAgICAgYW5jaG9yOiBmaXJzdCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICAgIHZhciBza2lwID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYmVmb3JlLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRleHQgIT09ICcnIHx8IFBhdGguaXNCZWZvcmUocGF0aCwgYmxvY2tQYXRoKSkge1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IG5vZGUudGV4dC5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaCBhIHZvaWQgbm9kZSBpbiB0aGUgY3VycmVudCBicmFuY2ggb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgdm9pZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIEVkaXRvci5hYm92ZShlZGl0b3IsIF9vYmplY3RTcHJlYWQkOChfb2JqZWN0U3ByZWFkJDgoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pXG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENhbGwgYSBmdW5jdGlvbiwgZGVmZXJyaW5nIG5vcm1hbGl6YXRpb24gdW50aWwgYWZ0ZXIgaXQgY29tcGxldGVzLlxyXG4gICAqL1xuICB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIHZhciB2YWx1ZSA9IEVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcik7XG4gICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgZmFsc2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7XG4gIH1cblxufTtcblxudmFyIExvY2F0aW9uID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0xvY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlKSB8fCBQb2ludC5pc1BvaW50KHZhbHVlKSB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlKTtcbiAgfVxuXG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTcGFuID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBTcGFuYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzU3Bhbih2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdmFsdWUuZXZlcnkoUGF0aC5pc1BhdGgpO1xuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcImNoaWxkcmVuXCJdLFxuICAgIF9leGNsdWRlZDIkMiA9IFtcInRleHRcIl07XG52YXIgSVNfTk9ERV9MSVNUX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgTm9kZSA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aCwgYXNzZXJ0aW5nIHRoYXQgaXQncyBhbiBhbmNlc3RvciBub2RlLlxyXG4gICAqL1xuICBhbmNlc3Rvcihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgYW5jZXN0b3Igbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgdGV4dCBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgYW5jZXN0b3Igbm9kZXMgYWJvdmUgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCB0aGUgb3JkZXIgaXMgdG9wLWRvd24sIGZyb20gaGlnaGVzdCB0byBsb3dlc3QgYW5jZXN0b3IgaW5cclxuICAgKiB0aGUgdHJlZSwgYnV0IHlvdSBjYW4gcGFzcyB0aGUgYHJldmVyc2U6IHRydWVgIG9wdGlvbiB0byBnbyBib3R0b20tdXAuXHJcbiAgICovXG4gICphbmNlc3RvcnMocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGZvciAodmFyIHAgb2YgUGF0aC5hbmNlc3RvcnMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgIHZhciBuID0gTm9kZS5hbmNlc3Rvcihyb290LCBwKTtcbiAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgIHlpZWxkIGVudHJ5O1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNoaWxkIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIGluZGV4LlxyXG4gICAqL1xuICBjaGlsZChyb290LCBpbmRleCkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgY2hpbGQgb2YgYSB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHJvb3QuY2hpbGRyZW5baW5kZXhdO1xuXG4gICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBjaGlsZCBhdCBpbmRleCBgXCIuY29uY2F0KGluZGV4LCBcImAgaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIG92ZXIgdGhlIGNoaWxkcmVuIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gICpjaGlsZHJlbihyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBhbmNlc3RvcjtcbiAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICB3aGlsZSAocmV2ZXJzZSA/IGluZGV4ID49IDAgOiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gTm9kZS5jaGlsZChhbmNlc3RvciwgaW5kZXgpO1xuICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgIHlpZWxkIFtjaGlsZCwgY2hpbGRQYXRoXTtcbiAgICAgIGluZGV4ID0gcmV2ZXJzZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGFuIGVudHJ5IGZvciB0aGUgY29tbW9uIGFuY2VzZXRvciBub2RlIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHJvb3QsIHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgcCA9IFBhdGguY29tbW9uKHBhdGgsIGFub3RoZXIpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBhc3NlcnRpbmcgdGhhdCBpdCdzIGEgZGVzY2VuZGFudCBub2RlLlxyXG4gICAqL1xuICBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuXG4gICAgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgZGVzY2VuZGFudCBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gdGhlIHJvb3QgZWRpdG9yIG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBkZXNjZW5kYW50IG5vZGUgZW50cmllcyBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gICpkZXNjZW5kYW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNvZXJjZSBoZXJlIGJlY2F1c2UgY2hlY2tpbmcgdGhlIHBhdGgncyBsZW5ndGggZG9lc1xuICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgbm9kZWAgaXMgbm90IGEgYEVkaXRvcmAsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdy5cbiAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBlbGVtZW50IG5vZGVzIGluc2lkZSBhIHJvb3Qgbm9kZS4gRWFjaCBpdGVyYXRpb25cclxuICAgKiB3aWxsIHJldHVybiBhbiBgRWxlbWVudEVudHJ5YCB0dXBsZSBjb25zaXN0aW5nIG9mIGBbRWxlbWVudCwgUGF0aF1gLiBJZiB0aGVcclxuICAgKiByb290IG5vZGUgaXMgYW4gZWxlbWVudCBpdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBpdGVyYXRpb24gYXMgd2VsbC5cclxuICAgKi9cbiAgKmVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRXh0cmFjdCBwcm9wcyBmcm9tIGEgTm9kZS5cclxuICAgKi9cbiAgZXh0cmFjdFByb3BzKG5vZGUpIHtcbiAgICBpZiAoRWxlbWVudC5pc0FuY2VzdG9yKG5vZGUpKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQkMyk7XG5cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDIpO1xuXG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBmaXJzdCBub2RlIGVudHJ5IGluIGEgcm9vdCBub2RlIGZyb20gYSBwYXRoLlxyXG4gICAqL1xuICBmaXJzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcblxuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5jaGlsZHJlblswXTtcbiAgICAgICAgcC5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzbGljZWQgZnJhZ21lbnQgcmVwcmVzZW50ZWQgYnkgYSByYW5nZSBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gIGZyYWdtZW50KHJvb3QsIHJhbmdlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgZnJhZ21lbnQgc3RhcnRpbmcgZnJvbSBhIHJvb3QgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1Jvb3QgPSBwcm9kdWNlKHtcbiAgICAgIGNoaWxkcmVuOiByb290LmNoaWxkcmVuXG4gICAgfSwgciA9PiB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgICAgdmFyIG5vZGVFbnRyaWVzID0gTm9kZS5ub2RlcyhyLCB7XG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgICAgIHZhciBbLCBwYXRoXSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBbLCBwYXRoXSBvZiBub2RlRW50cmllcykge1xuICAgICAgICBpZiAoIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChyLCBwYXRoKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIGxlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgbGVhZi50ZXh0ID0gbGVhZi50ZXh0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgICAgdmFyIF9sZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuXG4gICAgICAgICAgX2xlYWYudGV4dCA9IF9sZWFmLnRleHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKHIpKSB7XG4gICAgICAgIHIuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Um9vdC5jaGlsZHJlbjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSByZWZlcnJlZCB0byBieSBhIHNwZWNpZmljIHBhdGguIElmIHRoZSBwYXRoIGlzIGFuXHJcbiAgICogZW1wdHkgYXJyYXksIGl0IHJlZmVycyB0byB0aGUgcm9vdCBub2RlIGl0c2VsZi5cclxuICAgKi9cbiAgZ2V0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGVzY2VuZGFudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgZGVzY2VuZGFudCBub2RlIGV4aXN0cyBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gIGhhcyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYE5vZGVgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBgTm9kZWAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNOb2RlTGlzdCh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVkUmVzdWx0ID0gSVNfTk9ERV9MSVNUX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGlzTm9kZUxpc3QgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gTm9kZS5pc05vZGUodmFsKSk7XG4gICAgSVNfTk9ERV9MSVNUX0NBQ0hFLnNldCh2YWx1ZSwgaXNOb2RlTGlzdCk7XG4gICAgcmV0dXJuIGlzTm9kZUxpc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsYXN0IG5vZGUgZW50cnkgaW4gYSByb290IG5vZGUgZnJvbSBhIHBhdGguXHJcbiAgICovXG4gIGxhc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG5cbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pIHx8IG4uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSBuLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIG4gPSBuLmNoaWxkcmVuW2ldO1xuICAgICAgICBwLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBlbnN1cmluZyBpdCdzIGEgbGVhZiB0ZXh0IG5vZGUuXHJcbiAgICovXG4gIGxlYWYocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBsZWFmIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIG5vbi1sZWFmIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIHRoZSBpbiBhIGJyYW5jaCBvZiB0aGUgdHJlZSwgZnJvbSBhIHNwZWNpZmljIHBhdGguXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0IHRoZSBvcmRlciBpcyB0b3AtZG93biwgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBub2RlIGluIHRoZSB0cmVlLFxyXG4gICAqIGJ1dCB5b3UgY2FuIHBhc3MgdGhlIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gdG8gZ28gYm90dG9tLXVwLlxyXG4gICAqL1xuICAqbGV2ZWxzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBmb3IgKHZhciBwIG9mIFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgeWllbGQgW24sIHBdO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgbWF0Y2hlcyBhIHNldCBvZiBwcm9wcy5cclxuICAgKi9cbiAgbWF0Y2hlcyhub2RlLCBwcm9wcykge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudFByb3BzKHByb3BzKSAmJiBFbGVtZW50Lm1hdGNoZXMobm9kZSwgcHJvcHMpIHx8IFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0UHJvcHMocHJvcHMpICYmIFRleHQubWF0Y2hlcyhub2RlLCBwcm9wcyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgbm9kZSBlbnRyaWVzIG9mIGEgcm9vdCBub2RlLiBFYWNoIGVudHJ5IGlzXHJcbiAgICogcmV0dXJuZWQgYXMgYSBgW05vZGUsIFBhdGhdYCB0dXBsZSwgd2l0aCB0aGUgcGF0aCByZWZlcnJpbmcgdG8gdGhlIG5vZGUnc1xyXG4gICAqIHBvc2l0aW9uIGluc2lkZSB0aGUgcm9vdCBub2RlLlxyXG4gICAqL1xuICAqbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcGFzcyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBmcm9tID0gW10sXG4gICAgICB0b1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIG4gPSByb290O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikpIHtcbiAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGdvIGRvd253YXJkIGFuZCB3ZSBoYXZlbid0IGRlc2NlbmRlZCB5ZXQsIGRvLlxuXG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSByZXZlcnNlID8gbi5jaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGZyb20pKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5jb25jYXQobmV4dEluZGV4KTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYXQgdGhlIHJvb3QgYW5kIHdlIGNhbid0IGdvIGRvd24sIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBmb3J3YXJkLi4uXG5cblxuICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHApO1xuXG4gICAgICAgIGlmIChOb2RlLmhhcyhyb290LCBuZXdQYXRoKSkge1xuICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBiYWNrd2FyZC4uLlxuXG5cbiAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICB2YXIgX25ld1BhdGggPSBQYXRoLnByZXZpb3VzKHApO1xuXG4gICAgICAgIHAgPSBfbmV3UGF0aDtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlJ3JlIGdvaW5nIHVwd2FyZC4uLlxuXG5cbiAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqL1xuICBwYXJlbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIHAgPSBOb2RlLmdldChyb290LCBwYXJlbnRQYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29uY2F0ZW5hdGVkIHRleHQgc3RyaW5nIG9mIGEgbm9kZSdzIGNvbnRlbnQuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBpbmNsdWRlIHNwYWNlcyBvciBsaW5lIGJyZWFrcyBiZXR3ZWVuIGJsb2NrIG5vZGVzLlxyXG4gICAqIEl0IGlzIG5vdCBhIHVzZXItZmFjaW5nIHN0cmluZywgYnV0IGEgc3RyaW5nIGZvciBwZXJmb3JtaW5nIG9mZnNldC1yZWxhdGVkXHJcbiAgICogY29tcHV0YXRpb25zIGZvciBhIG5vZGUuXHJcbiAgICovXG4gIHN0cmluZyhub2RlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoTm9kZS5zdHJpbmcpLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIGxlYWYgdGV4dCBub2RlcyBpbiBhIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgKnRleHRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ3KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ3KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDcoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBPcGVyYXRpb24gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgTm9kZU9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc05vZGVPcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfbm9kZScpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gYE9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc09wZXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgUGF0aC5pc1BhdGgodmFsdWUubmV3UGF0aCk7XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUubmV3UHJvcGVydGllcykgfHwgdmFsdWUubmV3UHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLnByb3BlcnRpZXMpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYE9wZXJhdGlvbmAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBTZWxlY3Rpb25PcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNTZWxlY3Rpb25PcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfc2VsZWN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBUZXh0T3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzVGV4dE9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ190ZXh0Jyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW52ZXJ0IGFuIG9wZXJhdGlvbiwgcmV0dXJuaW5nIGEgbmV3IG9wZXJhdGlvbiB0aGF0IHdpbGwgZXhhY3RseSB1bmRvIHRoZVxyXG4gICAqIG9yaWdpbmFsIHdoZW4gYXBwbGllZC5cclxuICAgKi9cbiAgaW52ZXJzZShvcCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgucHJldmlvdXMob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIG5ld1BhdGgsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfSA9IG9wOyAvLyBQRVJGOiBpbiB0aGlzIGNhc2UgdGhlIG1vdmUgb3BlcmF0aW9uIGlzIGEgbm8tb3AgYW55d2F5cy5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgaGFwcGVucyBjb21wbGV0ZWx5IHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgdGhlIHBhdGggYW5kXG4gICAgICAgICAgLy8gbmV3UGF0aCBhcmUgc3RhYmxlIHdpdGggcmVzcGVjdCB0byBlYWNoIG90aGVyLlxuXG5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgZG9lcyBub3QgaGFwcGVuIHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgaXQgaXMgcG9zc2libGVcbiAgICAgICAgICAvLyBmb3IgdGhlIG1vdmUgdG8gaW1wYWN0IHRoZSB0cnVlIHBhdGggdG8gdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHJlbW92ZWQgZnJvbSBhbmQgd2hlcmUgaXQgd2FzIGluc2VydGVkLiBXZSBoYXZlIHRvIGFkanVzdCBmb3IgdGhpc1xuICAgICAgICAgIC8vIGFuZCBmaW5kIHRoZSBvcmlnaW5hbCBwYXRoLiBXZSBjYW4gYWNjb21wbGlzaCB0aGlzIChvbmx5IGluIG5vbi1zaWJsaW5nKVxuICAgICAgICAgIC8vIG1vdmVzIGJ5IGxvb2tpbmcgYXQgdGhlIGltcGFjdCBvZiB0aGUgbW92ZSBvcGVyYXRpb24gb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBhZnRlciB0aGUgb3JpZ2luYWwgbW92ZSBwYXRoLlxuXG5cbiAgICAgICAgICB2YXIgaW52ZXJzZVBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgdmFyIGludmVyc2VOZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0oUGF0aC5uZXh0KHBhdGgpLCBvcCk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aDogaW52ZXJzZU5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IF9wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX3Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLm5leHQob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUGF0aCA9IHtcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBhbmNlc3RvciBwYXRocyBmb3IgYSBnaXZlbiBwYXRoLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QgYW5jZXN0b3IuIEhvd2V2ZXIsIGlmIHRoZVxyXG4gICAqIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgYW5jZXN0b3JzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBwYXRocyA9IFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRocztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoICYmIGkgPCBhbm90aGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcblxuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tb247XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBhdGggdG8gYW5vdGhlciwgcmV0dXJuaW5nIGFuIGludGVnZXIgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYXRoXHJcbiAgICogd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKlxyXG4gICAqIE5vdGU6IFR3byBwYXRocyBvZiB1bmVxdWFsIGxlbmd0aCBjYW4gc3RpbGwgcmVjZWl2ZSBhIGAwYCByZXN1bHQgaWYgb25lIGlzXHJcbiAgICogZGlyZWN0bHkgYWJvdmUgb3IgYmVsb3cgdGhlIG90aGVyLiBJZiB5b3Ugd2FudCBleGFjdCBtYXRjaGluZywgdXNlXHJcbiAgICogW1tQYXRoLmVxdWFsc11dIGluc3RlYWQuXHJcbiAgICovXG4gIGNvbXBhcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihwYXRoLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBlbmRzIGFmdGVyIG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPiBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBhdCBvbmUgb2YgdGhlIGluZGV4ZXMgaW4gYW5vdGhlci5cclxuICAgKi9cbiAgZW5kc0F0KHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBiZWZvcmUgb25lIG9mIHRoZSBpbmRleGVzIGluIGFub3RoZXIuXHJcbiAgICovXG4gIGVuZHNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPCBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHMocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggJiYgcGF0aC5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYW5vdGhlcltpXSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHBhdGggb2YgcHJldmlvdXMgc2libGluZyBub2RlIGV4aXN0c1xyXG4gICAqL1xuICBoYXNQcmV2aW91cyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA+IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFmdGVyIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQW5jZXN0b3IocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYSBjaGlsZCBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0NoaWxkKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICsgMSAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGVxdWFsIHRvIG9yIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNEZXNjZW5kYW50KHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIHRoZSBwYXJlbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNQYXJlbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCArIDEgPT09IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpcyBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQYXRoYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIHNpYmxpbmcgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNTaWJsaW5nKHBhdGgsIGFub3RoZXIpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGFsID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHZhciBibCA9IGFub3RoZXJbYW5vdGhlci5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gYWwgIT09IGJsICYmIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBwYXRocyBhdCBldmVyeSBsZXZlbCBkb3duIHRvIGEgcGF0aC4gTm90ZTogdGhpcyBpcyB0aGUgc2FtZVxyXG4gICAqIGFzIGBQYXRoLmFuY2VzdG9yc2AsIGJ1dCBpbmNsdWRpbmcgdGhlIHBhdGggaXRzZWxmLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QuIEhvd2V2ZXIsIGlmIHRoZSBgcmV2ZXJzZTpcclxuICAgKiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBsaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2gocGF0aC5zbGljZSgwLCBpKSk7XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxpc3QucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgcGF0aCwgZ2V0IHRoZSBwYXRoIHRvIHRoZSBuZXh0IHNpYmxpbmcgbm9kZS5cclxuICAgKi9cbiAgbmV4dChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIG5leHQgaW5kZXguXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgKyAxKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvcGVyYXRpb24gY2FuIGFmZmVjdCBwYXRocyBvciBub3QuIFVzZWQgYXMgYW5cclxuICAgKiBvcHRpbWl6YXRpb24gd2hlbiB1cGRhdGluZyBkaXJ0eSBwYXRocyBkdXJpbmcgbm9ybWFsaXphdGlvblxyXG4gICAqXHJcbiAgICogTk9URTogVGhpcyAqbXVzdCogYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIGltcGxlbWVudGF0aW9uIG9mICd0cmFuc2Zvcm0nXHJcbiAgICogYmVsb3dcclxuICAgKi9cbiAgb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcGVyYXRpb24pIHtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBwYXRoLCByZXR1cm4gYSBuZXcgcGF0aCByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCBub2RlIGFib3ZlIGl0LlxyXG4gICAqL1xuICBwYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IHBhdGggb2YgdGhlIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXS5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIGdldCB0aGUgcGF0aCB0byB0aGUgcHJldmlvdXMgc2libGluZyBub2RlLlxyXG4gICAqL1xuICBwcmV2aW91cyhwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBwcmV2aW91cyBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIGZpcnN0IGNoaWxkIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBuZWdhdGl2ZSBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCAtIDEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHBhdGggcmVsYXRpdmUgdG8gYW4gYW5jZXN0b3IuXHJcbiAgICovXG4gIHJlbGF0aXZlKHBhdGgsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFQYXRoLmlzQW5jZXN0b3IoYW5jZXN0b3IsIHBhdGgpICYmICFQYXRoLmVxdWFscyhwYXRoLCBhbmNlc3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHJlbGF0aXZlIHBhdGggb2YgW1wiLmNvbmNhdChwYXRoLCBcIl0gaW5zaWRlIGFuY2VzdG9yIFtcIikuY29uY2F0KGFuY2VzdG9yLCBcIl0sIGJlY2F1c2UgaXQgaXMgbm90IGFib3ZlIG9yIGVxdWFsIHRvIHRoZSBwYXRoLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoYW5jZXN0b3IubGVuZ3RoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwYXRoIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHBhdGgsIG9wZXJhdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsOyAvLyBQRVJGOiB1c2UgZGVzdHJ1Y3RpbmcgaW5zdGVhZCBvZiBpbW1lclxuXG4gICAgdmFyIHAgPSBbLi4ucGF0aF07XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7IC8vIFBFUkY6IEV4aXQgZWFybHkgaWYgdGhlIG9wZXJhdGlvbiBpcyBndWFyYW50ZWVkIG5vdCB0byBoYXZlIGFuIGVmZmVjdC5cblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IG9wXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcCwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKG9wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AsIHApKSB7XG4gICAgICAgICAgICBwW29wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcFxuICAgICAgICAgIH0gPSBvcGVyYXRpb247XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfb3AyLFxuICAgICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDIsIHApIHx8IFBhdGguZW5kc0JlZm9yZShfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aF0gKz0gcG9zaXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wMyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBfcG9zaXRpb25cbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBpZiAoYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICBwW3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdiYWNrd2FyZCcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3AzLCBwKSAmJiBwYXRoW19vcDMubGVuZ3RoXSA+PSBfcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aF0gLT0gX3Bvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wNCxcbiAgICAgICAgICAgIG5ld1BhdGg6IG9ucFxuICAgICAgICAgIH0gPSBvcGVyYXRpb247IC8vIElmIHRoZSBvbGQgYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZSwgaXQncyBhIG5vLW9wLlxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDQsIG9ucCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wNCwgcCkgfHwgUGF0aC5lcXVhbHMoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb25wLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgb25wKSAmJiBfb3A0Lmxlbmd0aCA8IG9ucC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29weVtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb3B5LmNvbmNhdChwLnNsaWNlKF9vcDQubGVuZ3RoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzU2libGluZyhfb3A0LCBvbnApICYmIChQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9ucCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfVxuXG59O1xuXG52YXIgUGF0aFJlZiA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBwYXRoIHJlZidzIGN1cnJlbnQgdmFsdWUgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gUGF0aC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDYoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ2KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgUG9pbnQgPSB7XG4gIC8qKlxyXG4gICAqIENvbXBhcmUgYSBwb2ludCB0byBhbm90aGVyLCByZXR1cm5pbmcgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlXHJcbiAgICogcG9pbnQgd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKi9cbiAgY29tcGFyZShwb2ludCwgYW5vdGhlcikge1xuICAgIHZhciByZXN1bHQgPSBQYXRoLmNvbXBhcmUocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcblxuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBhbm90aGVyLm9mZnNldCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA+IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBhZnRlciBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FmdGVyKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzKHBvaW50LCBhbm90aGVyKSB7XG4gICAgLy8gUEVSRjogZW5zdXJlIHRoZSBvZmZzZXRzIGFyZSBlcXVhbCBmaXJzdCBzaW5jZSB0aGV5IGFyZSBjaGVhcGVyIHRvIGNoZWNrLlxuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IGFub3RoZXIub2Zmc2V0ICYmIFBhdGguZXF1YWxzKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgUG9pbnRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNQb2ludCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwb2ludCBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShwb2ludCwgb3ApIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIHByb2R1Y2UocG9pbnQsIHAgPT4ge1xuICAgICAgaWYgKHAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IHA7XG5cbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgKG9wLm9mZnNldCA8IG9mZnNldCB8fCBvcC5vZmZzZXQgPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgb3Aub2Zmc2V0IDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICBwLm9mZnNldCAtPSBNYXRoLm1pbihvZmZzZXQgLSBvcC5vZmZzZXQsIG9wLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcC5wb3NpdGlvbiA8IG9mZnNldCB8fCBvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgICBwLm9mZnNldCAtPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59O1xuXG52YXIgUG9pbnRSZWYgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcG9pbnQgcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50ID0gUG9pbnQudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcG9pbnQ7XG5cbiAgICBpZiAocG9pbnQgPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDUob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDUodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ1KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFJhbmdlID0ge1xuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIG9mIGEgcmFuZ2UsIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFwcGVhclxyXG4gICAqIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgZWRnZXMocmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkgPT09IHJldmVyc2UgPyBbYW5jaG9yLCBmb2N1c10gOiBbZm9jdXMsIGFuY2hvcl07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBlbmQgcG9pbnQgb2YgYSByYW5nZS5cclxuICAgKi9cbiAgZW5kKHJhbmdlKSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgcmV0dXJuIGVuZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhyYW5nZS5hbmNob3IsIGFub3RoZXIuYW5jaG9yKSAmJiBQb2ludC5lcXVhbHMocmFuZ2UuZm9jdXMsIGFub3RoZXIuZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaW5jbHVkZXMgYSBwYXRoLCBhIHBvaW50IG9yIHBhcnQgb2YgYW5vdGhlciByYW5nZS5cclxuICAgKi9cbiAgaW5jbHVkZXMocmFuZ2UsIHRhcmdldCkge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICAgIGlmIChSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmFuY2hvcikgfHwgUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5mb2N1cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBbcnMsIHJlXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICAgIHZhciBbdHMsIHRlXSA9IFJhbmdlLmVkZ2VzKHRhcmdldCk7XG4gICAgICByZXR1cm4gUG9pbnQuaXNCZWZvcmUocnMsIHRzKSAmJiBQb2ludC5pc0FmdGVyKHJlLCB0ZSk7XG4gICAgfVxuXG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgaXNBZnRlclN0YXJ0ID0gZmFsc2U7XG4gICAgdmFyIGlzQmVmb3JlRW5kID0gZmFsc2U7XG5cbiAgICBpZiAoUG9pbnQuaXNQb2ludCh0YXJnZXQpKSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgc3RhcnQpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBlbmQpIDw9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIHN0YXJ0LnBhdGgpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIGVuZC5wYXRoKSA8PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gb2YgYSByYW5nZSB3aXRoIGFub3RoZXIuXHJcbiAgICovXG4gIGludGVyc2VjdGlvbihyYW5nZSwgYW5vdGhlcikge1xuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQkMik7XG5cbiAgICB2YXIgW3MxLCBlMV0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIFtzMiwgZTJdID0gUmFuZ2UuZWRnZXMoYW5vdGhlcik7XG4gICAgdmFyIHN0YXJ0ID0gUG9pbnQuaXNCZWZvcmUoczEsIHMyKSA/IHMyIDogczE7XG4gICAgdmFyIGVuZCA9IFBvaW50LmlzQmVmb3JlKGUxLCBlMikgPyBlMSA6IGUyO1xuXG4gICAgaWYgKFBvaW50LmlzQmVmb3JlKGVuZCwgc3RhcnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNSh7XG4gICAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICAgIGZvY3VzOiBlbmRcbiAgICAgIH0sIHJlc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGJhY2t3YXJkLCBtZWFuaW5nIHRoYXQgaXRzIGFuY2hvciBwb2ludCBhcHBlYXJzIGluIHRoZVxyXG4gICAqIGRvY3VtZW50IF9hZnRlcl8gaXRzIGZvY3VzIHBvaW50LlxyXG4gICAqL1xuICBpc0JhY2t3YXJkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5pc0FmdGVyKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgY29sbGFwc2VkLCBtZWFuaW5nIHRoYXQgYm90aCBpdHMgYW5jaG9yIGFuZCBmb2N1c1xyXG4gICAqIHBvaW50cyByZWZlciB0byB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIGlzQ29sbGFwc2VkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBleHBhbmRlZC5cclxuICAgKlxyXG4gICAqIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIFtbUmFuZ2UuaXNDb2xsYXBzZWRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRXhwYW5kZWQocmFuZ2UpIHtcbiAgICByZXR1cm4gIVJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGZvcndhcmQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBbW1JhbmdlLmlzQmFja3dhcmRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRm9yd2FyZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBbW1JhbmdlXV0gaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1JhbmdlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuYW5jaG9yKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBwb2ludCBlbnRyaWVzIGluIGEgcmFuZ2UuXHJcbiAgICovXG4gICpwb2ludHMocmFuZ2UpIHtcbiAgICB5aWVsZCBbcmFuZ2UuYW5jaG9yLCAnYW5jaG9yJ107XG4gICAgeWllbGQgW3JhbmdlLmZvY3VzLCAnZm9jdXMnXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgcmFuZ2UuXHJcbiAgICovXG4gIHN0YXJ0KHJhbmdlKSB7XG4gICAgdmFyIFtzdGFydF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHJhbmdlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHJhbmdlLCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gcHJvZHVjZShyYW5nZSwgciA9PiB7XG4gICAgICBpZiAociA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgYWZmaW5pdHkgPSAnaW53YXJkJ1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIgYWZmaW5pdHlBbmNob3I7XG4gICAgICB2YXIgYWZmaW5pdHlGb2N1cztcblxuICAgICAgaWYgKGFmZmluaXR5ID09PSAnaW53YXJkJykge1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLCBtYWtlIHN1cmUgdG8gdXNlIHRoZSBzYW1lIGFmZmluaXR5IHRvXG4gICAgICAgIC8vIGF2b2lkIHRoZSB0d28gcG9pbnRzIHBhc3NpbmcgZWFjaCBvdGhlciBhbmQgZXhwYW5kaW5nIGluIHRoZSBvcHBvc2l0ZVxuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgdmFyIGlzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQocik7XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyKSkge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2JhY2t3YXJkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnZm9yd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdvdXR3YXJkJykge1xuICAgICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHIpKSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnZm9yd2FyZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdiYWNrd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gYWZmaW5pdHk7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSBhZmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuY2hvciA9IFBvaW50LnRyYW5zZm9ybShyLmFuY2hvciwgb3AsIHtcbiAgICAgICAgYWZmaW5pdHk6IGFmZmluaXR5QW5jaG9yXG4gICAgICB9KTtcbiAgICAgIHZhciBmb2N1cyA9IFBvaW50LnRyYW5zZm9ybShyLmZvY3VzLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlGb2N1c1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghYW5jaG9yIHx8ICFmb2N1cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgci5hbmNob3IgPSBhbmNob3I7XG4gICAgICByLmZvY3VzID0gZm9jdXM7XG4gICAgfSk7XG4gIH1cblxufTtcblxudmFyIFJhbmdlUmVmID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIHJhbmdlIHJlZidzIGN1cnJlbnQgdmFsdWUgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gUmFuZ2UudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcGF0aDtcblxuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxuXG59O1xuXG52YXIgX3NjcnViYmVyID0gdW5kZWZpbmVkO1xuLyoqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIGltcGxlbWVudHMgYSBzdHJpbmdpZnkoKSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBieSBTbGF0ZVxyXG4gKiBpbnRlcm5hbGx5IHdoZW4gZ2VuZXJhdGluZyBleGNlcHRpb25zIGNvbnRhaW5pbmcgZW5kIHVzZXIgZGF0YS4gRGV2ZWxvcGVyc1xyXG4gKiB1c2luZyBTbGF0ZSBtYXkgY2FsbCBTY3J1YmJlci5zZXRTY3J1YmJlcigpIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGlzXHJcbiAqIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgdG8gcHJldmVudCB0aGUgY2xlYXJ0ZXh0IGxvZ2dpbmcgb2YgJ3RleHQnIGZpZWxkcyB3aXRoaW4gTm9kZXM6XHJcbiAqXHJcbiAqICAgIGltcG9ydCB7IFNjcnViYmVyIH0gZnJvbSAnc2xhdGUnO1xyXG4gKiAgICBTY3J1YmJlci5zZXRTY3J1YmJlcigoa2V5LCB2YWwpID0+IHtcclxuICogICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHJldHVybiAnLi4uc2NydWJiZWQuLi4nXHJcbiAqICAgICAgcmV0dXJuIHZhbFxyXG4gKiAgICB9KTtcclxuICpcclxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTY3J1YmJlciA9IHtcbiAgc2V0U2NydWJiZXIoc2NydWJiZXIpIHtcbiAgICBfc2NydWJiZXIgPSBzY3J1YmJlcjtcbiAgfSxcblxuICBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIF9zY3J1YmJlcik7XG4gIH1cblxufTtcblxuLypcclxuICBDdXN0b20gZGVlcCBlcXVhbCBjb21wYXJpc29uIGZvciBTbGF0ZSBub2Rlcy5cclxuXG4gIFdlIGRvbid0IG5lZWQgZ2VuZXJhbCBwdXJwb3NlIGRlZXAgZXF1YWxpdHk7XHJcbiAgU2xhdGUgb25seSBzdXBwb3J0cyBwbGFpbiB2YWx1ZXMsIEFycmF5cywgYW5kIG5lc3RlZCBvYmplY3RzLlxyXG4gIENvbXBsZXggdmFsdWVzIG5lc3RlZCBpbnNpZGUgQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG5cbiAgU2xhdGUgb2JqZWN0cyBhcmUgZGVzaWduZWQgdG8gYmUgc2VyaWFsaXNlZCwgc29cclxuICBtaXNzaW5nIGtleXMgYXJlIGRlbGliZXJhdGVseSBub3JtYWxpc2VkIHRvIHVuZGVmaW5lZC5cclxuICovXG5cbnZhciBpc0RlZXBFcXVhbCA9IChub2RlLCBhbm90aGVyKSA9PiB7XG4gIGZvciAodmFyIGtleSBpbiBub2RlKSB7XG4gICAgdmFyIGEgPSBub2RlW2tleV07XG4gICAgdmFyIGIgPSBhbm90aGVyW2tleV07XG5cbiAgICBpZiAoaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsKGEsIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhICE9PSBiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qXHJcbiAgICBEZWVwIG9iamVjdCBlcXVhbGl0eSBpcyBvbmx5IG5lY2Vzc2FyeSBpbiBvbmUgZGlyZWN0aW9uOyBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cclxuICAgIHdlIGFyZSBvbmx5IGxvb2tpbmcgZm9yIGtleXMgdGhhdCBhcmUgbWlzc2luZy5cclxuICAgIEFzIGFib3ZlLCB1bmRlZmluZWQga2V5cyBhcmUgbm9ybWFsaXNlZCB0byBtaXNzaW5nLlxyXG4gICovXG5cblxuICBmb3IgKHZhciBfa2V5IGluIGFub3RoZXIpIHtcbiAgICBpZiAobm9kZVtfa2V5XSA9PT0gdW5kZWZpbmVkICYmIGFub3RoZXJbX2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIF9leGNsdWRlZCQxID0gW1widGV4dFwiXSxcbiAgICBfZXhjbHVkZWQyJDEgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQ0KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNChPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDQoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBUZXh0ID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiB0d28gdGV4dCBub2RlcyBhcmUgZXF1YWwuXHJcbiAgICpcclxuICAgKiBXaGVuIGxvb3NlIGlzIHNldCwgdGhlIHRleHQgaXMgbm90IGNvbXBhcmVkLiBUaGlzIGlzXHJcbiAgICogdXNlZCB0byBjaGVjayB3aGV0aGVyIHNpYmxpbmcgdGV4dCBub2RlcyBjYW4gYmUgbWVyZ2VkLlxyXG4gICAqL1xuICBlcXVhbHModGV4dCwgYW5vdGhlcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbG9vc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgZnVuY3Rpb24gb21pdFRleHQob2JqKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIF9leGNsdWRlZCQxKTtcblxuICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRGVlcEVxdWFsKGxvb3NlID8gb21pdFRleHQodGV4dCkgOiB0ZXh0LCBsb29zZSA/IG9taXRUZXh0KGFub3RoZXIpIDogYW5vdGhlcik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgVGV4dGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1RleHQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIGBUZXh0YCBvYmplY3RzLlxyXG4gICAqL1xuICBpc1RleHRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBUZXh0LmlzVGV4dCh2YWwpKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBzb21lIHByb3BzIGFyZSBhIHBhcnRpYWwgb2YgVGV4dC5cclxuICAgKi9cbiAgaXNUZXh0UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dCAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIHRleHQgbWF0Y2hlcyBzZXQgb2YgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIE5vdGU6IHRoaXMgaXMgZm9yIG1hdGNoaW5nIGN1c3RvbSBwcm9wZXJ0aWVzLCBhbmQgaXQgZG9lcyBub3QgZW5zdXJlIHRoYXRcclxuICAgKiB0aGUgYHRleHRgIHByb3BlcnR5IGFyZSB0d28gbm9kZXMgZXF1YWwuXHJcbiAgICovXG4gIG1hdGNoZXModGV4dCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0ZXh0Lmhhc093blByb3BlcnR5KGtleSkgfHwgdGV4dFtrZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxlYXZlcyBmb3IgYSB0ZXh0IG5vZGUgZ2l2ZW4gZGVjb3JhdGlvbnMuXHJcbiAgICovXG4gIGRlY29yYXRpb25zKG5vZGUsIGRlY29yYXRpb25zKSB7XG4gICAgdmFyIGxlYXZlcyA9IFtfb2JqZWN0U3ByZWFkJDQoe30sIG5vZGUpXTtcblxuICAgIGZvciAodmFyIGRlYyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZGVjLCBfZXhjbHVkZWQyJDEpO1xuXG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoZGVjKTtcbiAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICB2YXIgbGVhZkVuZCA9IDA7XG4gICAgICB2YXIgZGVjb3JhdGlvblN0YXJ0ID0gc3RhcnQub2Zmc2V0O1xuICAgICAgdmFyIGRlY29yYXRpb25FbmQgPSBlbmQub2Zmc2V0O1xuXG4gICAgICBmb3IgKHZhciBsZWFmIG9mIGxlYXZlcykge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGxlbmd0aFxuICAgICAgICB9ID0gbGVhZi50ZXh0O1xuICAgICAgICB2YXIgbGVhZlN0YXJ0ID0gbGVhZkVuZDtcbiAgICAgICAgbGVhZkVuZCArPSBsZW5ndGg7IC8vIElmIHRoZSByYW5nZSBlbmNvbXBhc3NlcyB0aGUgZW50aXJlIGxlYWYsIGFkZCB0aGUgcmFuZ2UuXG5cbiAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCA8PSBsZWFmU3RhcnQgJiYgbGVhZkVuZCA8PSBkZWNvcmF0aW9uRW5kKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihsZWFmLCByZXN0KTtcbiAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSWYgdGhlIHJhbmdlIGV4cGFuZGVkIGFuZCBtYXRjaCB0aGUgbGVhZiwgb3Igc3RhcnRzIGFmdGVyLCBvciBlbmRzIGJlZm9yZSBpdCwgY29udGludWUuXG5cblxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ICE9PSBkZWNvcmF0aW9uRW5kICYmIChkZWNvcmF0aW9uU3RhcnQgPT09IGxlYWZFbmQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0KSB8fCBkZWNvcmF0aW9uU3RhcnQgPiBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPCBsZWFmU3RhcnQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0ICYmIGxlYWZTdGFydCAhPT0gMCkge1xuICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBzcGxpdCB0aGUgbGVhZiwgYXQgdGhlIHN0YXJ0LCBlbmQsIG9yIGJvdGgsXG4gICAgICAgIC8vIGFuZCBhZGQgdGhlIHJhbmdlIHRvIHRoZSBtaWRkbGUgaW50ZXJzZWN0aW5nIHNlY3Rpb24uIERvIHRoZSBlbmRcbiAgICAgICAgLy8gc3BsaXQgZmlyc3Qgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIG9mZnNldCB0aGF0IHdheS5cblxuXG4gICAgICAgIHZhciBtaWRkbGUgPSBsZWFmO1xuICAgICAgICB2YXIgYmVmb3JlID0gdm9pZCAwO1xuICAgICAgICB2YXIgYWZ0ZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGRlY29yYXRpb25FbmQgPCBsZWFmRW5kKSB7XG4gICAgICAgICAgdmFyIG9mZiA9IGRlY29yYXRpb25FbmQgLSBsZWFmU3RhcnQ7XG4gICAgICAgICAgYWZ0ZXIgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2Uob2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZSgwLCBvZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ID4gbGVhZlN0YXJ0KSB7XG4gICAgICAgICAgdmFyIF9vZmYgPSBkZWNvcmF0aW9uU3RhcnQgLSBsZWFmU3RhcnQ7XG5cbiAgICAgICAgICBiZWZvcmUgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWlkZGxlLCByZXN0KTtcblxuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGJlZm9yZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0LnB1c2gobWlkZGxlKTtcblxuICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICBuZXh0LnB1c2goYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxlYXZlcyA9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIGFwcGx5VG9EcmFmdCA9IChlZGl0b3IsIHNlbGVjdGlvbiwgb3ApID0+IHtcbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgbm9kZVxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGluZGV4ID4gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBcXFwiaW5zZXJ0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiB0aGUgbm9kZS5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgbm9kZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtwb2ludCwga2V5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW2tleV0gPSBQb2ludC50cmFuc2Zvcm0ocG9pbnQsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIF9ub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgX3BhdGgpO1xuXG4gICAgICAgIHZhciBiZWZvcmUgPSBfbm9kZS50ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgICAgICAgdmFyIGFmdGVyID0gX25vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuXG4gICAgICAgIF9ub2RlLnRleHQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQsIF9rZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIHZhciBfbm9kZTIgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMik7XG5cbiAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDIpO1xuICAgICAgICB2YXIgcHJldiA9IE5vZGUuZ2V0KGVkaXRvciwgcHJldlBhdGgpO1xuXG4gICAgICAgIHZhciBfcGFyZW50ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDIpO1xuXG4gICAgICAgIHZhciBfaW5kZXggPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTIpICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgcHJldi50ZXh0ICs9IF9ub2RlMi50ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCFUZXh0LmlzVGV4dChfbm9kZTIpICYmICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHByZXYuY2hpbGRyZW4ucHVzaCguLi5fbm9kZTIuY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJtZXJnZV9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoMiwgXCJdIHRvIG5vZGVzIG9mIGRpZmZlcmVudCBpbnRlcmZhY2VzOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbm9kZTIpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BhcmVudC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4LCAxKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDIsIF9rZXkyXSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkyXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQyLCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoMyxcbiAgICAgICAgICBuZXdQYXRoXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbW92ZSBhIHBhdGggW1wiLmNvbmNhdChfcGF0aDMsIFwiXSB0byBuZXcgcGF0aCBbXCIpLmNvbmNhdChuZXdQYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgaW5zaWRlIGl0c2VsZi5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9ub2RlMyA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICB2YXIgX3BhcmVudDIgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMyk7XG5cbiAgICAgICAgdmFyIF9pbmRleDIgPSBfcGF0aDNbX3BhdGgzLmxlbmd0aCAtIDFdOyAvLyBUaGlzIGlzIHRyaWNreSwgYnV0IHNpbmNlIHRoZSBgcGF0aGAgYW5kIGBuZXdQYXRoYCBib3RoIHJlZmVyIHRvXG4gICAgICAgIC8vIHRoZSBzYW1lIHNuYXBzaG90IGluIHRpbWUsIHRoZXJlJ3MgYSBtaXNtYXRjaC4gQWZ0ZXIgZWl0aGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiwgdGhlIHNlY29uZCBzdGVwJ3MgcGF0aCBjYW4gYmUgb3V0XG4gICAgICAgIC8vIG9mIGRhdGUuIFNvIGluc3RlYWQgb2YgdXNpbmcgdGhlIGBvcC5uZXdQYXRoYCBkaXJlY3RseSwgd2VcbiAgICAgICAgLy8gdHJhbnNmb3JtIGBvcC5wYXRoYCB0byBhc2NlcnRhaW4gd2hhdCB0aGUgYG5ld1BhdGhgIHdvdWxkIGJlIGFmdGVyXG4gICAgICAgIC8vIHRoZSBvcGVyYXRpb24gd2FzIGFwcGxpZWQuXG5cbiAgICAgICAgX3BhcmVudDIuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDIsIDEpO1xuXG4gICAgICAgIHZhciB0cnVlUGF0aCA9IFBhdGgudHJhbnNmb3JtKF9wYXRoMywgb3ApO1xuICAgICAgICB2YXIgbmV3UGFyZW50ID0gTm9kZS5nZXQoZWRpdG9yLCBQYXRoLnBhcmVudCh0cnVlUGF0aCkpO1xuICAgICAgICB2YXIgbmV3SW5kZXggPSB0cnVlUGF0aFt0cnVlUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgbmV3UGFyZW50LmNoaWxkcmVuLnNwbGljZShuZXdJbmRleCwgMCwgX25vZGUzKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDMsIF9rZXkzXSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkzXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQzLCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg0XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIF9pbmRleDMgPSBfcGF0aDRbX3BhdGg0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHZhciBfcGFyZW50MyA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGg0KTtcblxuICAgICAgICBfcGFyZW50My5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MywgMSk7IC8vIFRyYW5zZm9ybSBhbGwgb2YgdGhlIHBvaW50cyBpbiB0aGUgdmFsdWUsIGJ1dCBpZiB0aGUgcG9pbnQgd2FzIGluIHRoZVxuICAgICAgICAvLyBub2RlIHRoYXQgd2FzIHJlbW92ZWQgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJhbmdlIG9yIHJlbW92ZSBpdC5cblxuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50NCwgX2tleTRdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDQsIG9wKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAhPSBudWxsICYmIHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NF0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX3ByZXYgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgW24sIHBdIG9mIE5vZGUudGV4dHMoZWRpdG9yKSkge1xuICAgICAgICAgICAgICAgIGlmIChQYXRoLmNvbXBhcmUocCwgX3BhdGg0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIF9wcmV2ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXh0ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHByZWZlck5leHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAoX3ByZXYgJiYgbmV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXh0WzFdLCBfcGF0aDQpKSB7XG4gICAgICAgICAgICAgICAgICBwcmVmZXJOZXh0ID0gIVBhdGguaGFzUHJldmlvdXMobmV4dFsxXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSBQYXRoLmNvbW1vbihfcHJldlsxXSwgX3BhdGg0KS5sZW5ndGggPCBQYXRoLmNvbW1vbihuZXh0WzFdLCBfcGF0aDQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoX3ByZXYgJiYgIXByZWZlck5leHQpIHtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBfcHJldlsxXTtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0Lm9mZnNldCA9IF9wcmV2WzBdLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBuZXh0WzFdO1xuICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg1LFxuICAgICAgICAgIG9mZnNldDogX29mZnNldCxcbiAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIGlmIChfdGV4dC5sZW5ndGggPT09IDApIGJyZWFrO1xuXG4gICAgICAgIHZhciBfbm9kZTQgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aDUpO1xuXG4gICAgICAgIHZhciBfYmVmb3JlID0gX25vZGU0LnRleHQuc2xpY2UoMCwgX29mZnNldCk7XG5cbiAgICAgICAgdmFyIF9hZnRlciA9IF9ub2RlNC50ZXh0LnNsaWNlKF9vZmZzZXQgKyBfdGV4dC5sZW5ndGgpO1xuXG4gICAgICAgIF9ub2RlNC50ZXh0ID0gX2JlZm9yZSArIF9hZnRlcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDUsIF9rZXk1XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk1XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ1LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg2LFxuICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgaWYgKF9wYXRoNi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHByb3BlcnRpZXMgb24gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGU1ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDYpO1xuXG4gICAgICAgIGZvciAodmFyIF9rZXk2IGluIG5ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoX2tleTYgPT09ICdjaGlsZHJlbicgfHwgX2tleTYgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB0aGUgXFxcIlwiLmNvbmNhdChfa2V5NiwgXCJcXFwiIHByb3BlcnR5IG9mIG5vZGVzIVwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbHVlID0gbmV3UHJvcGVydGllc1tfa2V5Nl07XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIF9ub2RlNVtfa2V5Nl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9ub2RlNVtfa2V5Nl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gcHJvcGVydGllcyB0aGF0IHdlcmUgcHJldmlvdXNseSBkZWZpbmVkLCBidXQgYXJlIG5vdyBtaXNzaW5nLCBtdXN0IGJlIGRlbGV0ZWRcblxuXG4gICAgICAgIGZvciAodmFyIF9rZXk3IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoX2tleTcpKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk3XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgIHNlbGVjdGlvbiA9IF9uZXdQcm9wZXJ0aWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKF9uZXdQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gaW5jb21wbGV0ZSBcXFwic2V0X3NlbGVjdGlvblxcXCIgb3BlcmF0aW9uIHByb3BlcnRpZXMgXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbmV3UHJvcGVydGllcyksIFwiIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudCBzZWxlY3Rpb24uXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0aW9uID0gX29iamVjdFNwcmVhZCQzKHt9LCBfbmV3UHJvcGVydGllcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2tleTggaW4gX25ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciBfdmFsdWUgPSBfbmV3UHJvcGVydGllc1tfa2V5OF07XG5cbiAgICAgICAgICAgIGlmIChfdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoX2tleTggPT09ICdhbmNob3InIHx8IF9rZXk4ID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgXFxcIlwiLmNvbmNhdChfa2V5OCwgXCJcXFwiIHNlbGVjdGlvbiBwcm9wZXJ0eVwiKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWxldGUgc2VsZWN0aW9uW19rZXk4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5OF0gPSBfdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDcsXG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgcHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChfcGF0aDcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcInNwbGl0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGg3LCBcIl0gYmVjYXVzZSB0aGUgcm9vdCBub2RlIGNhbm5vdCBiZSBzcGxpdC5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9ub2RlNiA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGg3KTtcblxuICAgICAgICB2YXIgX3BhcmVudDQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNyk7XG5cbiAgICAgICAgdmFyIF9pbmRleDQgPSBfcGF0aDdbX3BhdGg3Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbmV3Tm9kZTtcblxuICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGU2KSkge1xuICAgICAgICAgIHZhciBfYmVmb3JlMiA9IF9ub2RlNi50ZXh0LnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICAgIHZhciBfYWZ0ZXIyID0gX25vZGU2LnRleHQuc2xpY2UocG9zaXRpb24pO1xuXG4gICAgICAgICAgX25vZGU2LnRleHQgPSBfYmVmb3JlMjtcbiAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgX3Byb3BlcnRpZXMpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogX2FmdGVyMlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfYmVmb3JlMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZSgwLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICB2YXIgX2FmdGVyMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICBfbm9kZTYuY2hpbGRyZW4gPSBfYmVmb3JlMztcbiAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgX3Byb3BlcnRpZXMpLCB7fSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IF9hZnRlcjNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wYXJlbnQ0LmNoaWxkcmVuLnNwbGljZShfaW5kZXg0ICsgMSwgMCwgbmV3Tm9kZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ2LCBfa2V5OV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5OV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Niwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXG52YXIgR2VuZXJhbFRyYW5zZm9ybXMgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgZWRpdG9yIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKGVkaXRvciwgb3ApIHtcbiAgICBlZGl0b3IuY2hpbGRyZW4gPSBjcmVhdGVEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uICYmIGNyZWF0ZURyYWZ0KGVkaXRvci5zZWxlY3Rpb24pO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGVjdGlvbiA9IGFwcGx5VG9EcmFmdChlZGl0b3IsIHNlbGVjdGlvbiwgb3ApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlZGl0b3IuY2hpbGRyZW4gPSBmaW5pc2hEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBpc0RyYWZ0KHNlbGVjdGlvbikgPyBmaW5pc2hEcmFmdChzZWxlY3Rpb24pIDogc2VsZWN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJjaGlsZHJlblwiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBOb2RlVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogSW5zZXJ0IG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIEVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2Rlcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBzZWxlY3RcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoTm9kZS5pc05vZGUobm9kZXMpKSB7XG4gICAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBbbm9kZV0gPSBub2RlczsgLy8gQnkgZGVmYXVsdCwgdXNlIHRoZSBzZWxlY3Rpb24gYXMgdGhlIHRhcmdldCBsb2NhdGlvbi4gQnV0IGlmIHRoZXJlIGlzXG4gICAgICAvLyBubyBzZWxlY3Rpb24sIGluc2VydCBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCBzaW5jZSB0aGF0IGlzIHN1Y2ggYVxuICAgICAgLy8gY29tbW9uIHVzZSBjYXNlIHdoZW4gaW5zZXJ0aW5nIGZyb20gYSBub24tc2VsZWN0ZWQgc3RhdGUuXG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXQgPSBbMF07XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ID09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbiA9PiBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgW2VudHJ5XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQucGF0aCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBbLCBfbWF0Y2hQYXRoXSA9IGVudHJ5O1xuICAgICAgICAgIHZhciBwYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICB2YXIgaXNBdEVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBpc0F0RW5kID8gUGF0aC5uZXh0KHBhdGgpIDogcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChhdCk7XG4gICAgICB2YXIgaW5kZXggPSBhdFthdC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhcmVudFBhdGhcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX25vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgdmFyIF9wYXRoID0gcGFyZW50UGF0aC5jb25jYXQoaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBub2RlOiBfbm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgICAgfVxuXG4gICAgICBhdCA9IFBhdGgucHJldmlvdXMoYXQpO1xuXG4gICAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBMaWZ0IG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gdXB3YXJkcyBpbiB0aGUgZG9jdW1lbnQgdHJlZSwgc3BsaXR0aW5nXHJcbiAgICogdGhlaXIgcGFyZW50IGluIHR3byBpZiBuZWNlc3NhcnkuXHJcbiAgICovXG4gIGxpZnROb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbGlmdCBub2RlIGF0IGEgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGhhcyBhIGRlcHRoIG9mIGxlc3MgdGhhbiBgMmAuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnROb2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpKTtcbiAgICAgICAgdmFyIFtwYXJlbnQsIHBhcmVudFBhdGhdID0gcGFyZW50Tm9kZUVudHJ5O1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbGVuZ3RoXG4gICAgICAgIH0gPSBwYXJlbnQuY2hpbGRyZW47XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciB0b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiB0b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IHBhcmVudFBhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIF90b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcGxpdFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgICAgICAgICB2YXIgX3RvUGF0aDIgPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogc3BsaXRQYXRoLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgyLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1lcmdlIGEgbm9kZSBhdCBhIGxvY2F0aW9uIHdpdGggdGhlIHByZXZpb3VzIG5vZGUgb2YgdGhlIHNhbWUgZGVwdGgsXHJcbiAgICogcmVtb3ZpbmcgYW55IGVtcHR5IGNvbnRhaW5pbmcgbm9kZXMgYWZ0ZXIgdGhlIG1lcmdlIGlmIG5lY2Vzc2FyeS5cclxuICAgKi9cbiAgbWVyZ2VOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbY3VycmVudF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdm9pZHMsXG4gICAgICAgIG1vZGVcbiAgICAgIH0pO1xuICAgICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdm9pZHMsXG4gICAgICAgIG1vZGVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWN1cnJlbnQgfHwgIXByZXYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgW25vZGUsIHBhdGhdID0gY3VycmVudDtcbiAgICAgIHZhciBbcHJldk5vZGUsIHByZXZQYXRoXSA9IHByZXY7XG5cbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCB8fCBwcmV2UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwcmV2UGF0aCk7XG4gICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguY29tbW9uKHBhdGgsIHByZXZQYXRoKTtcbiAgICAgIHZhciBpc1ByZXZpb3VzU2libGluZyA9IFBhdGguaXNTaWJsaW5nKHBhdGgsIHByZXZQYXRoKTtcbiAgICAgIHZhciBsZXZlbHMgPSBBcnJheS5mcm9tKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoXG4gICAgICB9KSwgX3JlZjIgPT4ge1xuICAgICAgICB2YXIgW25dID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSkuc2xpY2UoY29tbW9uUGF0aC5sZW5ndGgpLnNsaWNlKDAsIC0xKTsgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtZXJnZSB3aWxsIGxlYXZlIGFuIGFuY2VzdG9yIG9mIHRoZSBwYXRoIGVtcHR5IGFzIGFcbiAgICAgIC8vIHJlc3VsdCwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHJlbW92ZSBpdCBhZnRlciBtZXJnaW5nLlxuXG4gICAgICB2YXIgZW1wdHlBbmNlc3RvciA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgbWF0Y2g6IG4gPT4gbGV2ZWxzLmluY2x1ZGVzKG4pICYmIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIG4pXG4gICAgICB9KTtcbiAgICAgIHZhciBlbXB0eVJlZiA9IGVtcHR5QW5jZXN0b3IgJiYgRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBlbXB0eUFuY2VzdG9yWzFdKTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzO1xuICAgICAgdmFyIHBvc2l0aW9uOyAvLyBFbnN1cmUgdGhhdCB0aGUgbm9kZXMgYXJlIGVxdWl2YWxlbnQsIGFuZCBmaWd1cmUgb3V0IHdoYXQgdGhlIHBvc2l0aW9uXG4gICAgICAvLyBhbmQgZXh0cmEgcHJvcGVydGllcyBvZiB0aGUgbWVyZ2Ugd2lsbCBiZS5cblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0KHByZXZOb2RlKSkge1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQpO1xuXG4gICAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUudGV4dC5sZW5ndGg7XG4gICAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkpIHtcbiAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHRoZSBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gd2l0aCB0aGUgcHJldmlvdXMgc2libGluZyBiZWNhdXNlIGl0IGlzIG5vdCB0aGUgc2FtZSBraW5kOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldk5vZGUpKSk7XG4gICAgICB9IC8vIElmIHRoZSBub2RlIGlzbid0IGFscmVhZHkgdGhlIG5leHQgc2libGluZyBvZiB0aGUgcHJldmlvdXMgbm9kZSwgbW92ZVxuICAgICAgLy8gaXQgc28gdGhhdCBpdCBpcyBiZWZvcmUgbWVyZ2luZy5cblxuXG4gICAgICBpZiAoIWlzUHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiBuZXdQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBJZiB0aGVyZSB3YXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgYW5jZXN0b3Igb2YgdGhlIG5vZGUgdGhhdCB3YXMgbWVyZ2VkLFxuICAgICAgLy8gd2UgcmVtb3ZlIGl0IGZyb20gdGhlIHRyZWUuXG5cblxuICAgICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVtcHR5UmVmLmN1cnJlbnQsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIHRoZSB0YXJnZXQgbm9kZSB0aGF0IHdlJ3JlIG1lcmdpbmcgd2l0aCBpcyBlbXB0eSwgcmVtb3ZlIGl0IGluc3RlYWRcbiAgICAgIC8vIG9mIG1lcmdpbmcgdGhlIHR3by4gVGhpcyBpcyBhIGNvbW1vbiByaWNoIHRleHQgZWRpdG9yIGJlaGF2aW9yIHRvXG4gICAgICAvLyBwcmV2ZW50IGxvc2luZyBmb3JtYXR0aW5nIHdoZW4gZGVsZXRpbmcgZW50aXJlIG5vZGVzIHdoZW4geW91IGhhdmUgYVxuICAgICAgLy8gaGFuZ2luZyBzZWxlY3Rpb24uXG4gICAgICAvLyBpZiBwcmV2Tm9kZSBpcyBmaXJzdCBjaGlsZCBpbiBwYXJlbnQsZG9uJ3QgcmVtb3ZlIGl0LlxuXG5cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkgJiYgRWRpdG9yLmlzRW1wdHkoZWRpdG9yLCBwcmV2Tm9kZSkgfHwgVGV4dC5pc1RleHQocHJldk5vZGUpICYmIHByZXZOb2RlLnRleHQgPT09ICcnICYmIHByZXZQYXRoW3ByZXZQYXRoLmxlbmd0aCAtIDFdICE9PSAwKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHByZXZQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgICAgZW1wdHlSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNb3ZlIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uIHRvIGEgbmV3IGxvY2F0aW9uLlxyXG4gICAqL1xuICBtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHRvLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCB0byk7XG4gICAgICB2YXIgdGFyZ2V0cyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKHRhcmdldHMsIF9yZWYzID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjM7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgIHZhciBuZXdQYXRoID0gdG9SZWYuY3VycmVudDtcblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ21vdmVfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgbmV3UGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvUmVmLmN1cnJlbnQgJiYgUGF0aC5pc1NpYmxpbmcobmV3UGF0aCwgcGF0aCkgJiYgUGF0aC5pc0FmdGVyKG5ld1BhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgc2libGluZyBtb3ZlIHRvIGEgbGF0ZXIgaW5kZXgsIHRoZSBwYXRoIGF0IHRoZSBkZXN0aW5hdGlvbiBpcyBzaGlmdGVkXG4gICAgICAgICAgLy8gdG8gYmVmb3JlIHRoZSBpbnNlcnRpb24gcG9pbnQgaW5zdGVhZCBvZiBhZnRlci4gVG8gZW5zdXJlIG91ciBncm91cCBvZiBub2RlcyBhcmUgaW5zZXJ0ZWRcbiAgICAgICAgICAvLyBpbiB0aGUgY29ycmVjdCBvcmRlciB3ZSBpbmNyZW1lbnQgdG9SZWYgdG8gYWNjb3VudCBmb3IgdGhhdFxuICAgICAgICAgIHRvUmVmLmN1cnJlbnQgPSBQYXRoLm5leHQodG9SZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9SZWYudW5yZWYoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICByZW1vdmVOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2hcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXB0aHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShkZXB0aHMsIF9yZWY0ID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjQ7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGNvbXBhcmUsXG4gICAgICAgIG1lcmdlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSAmJiBFZGl0b3IubGVhZihlZGl0b3IsIGF0LmFuY2hvcilbMF0udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCBpbiBhIG5vbi1lbXB0eSBub2RlIGFuZCAnc3BsaXQnIGlzIHRydWUsIHRoZXJlJ3Mgbm90aGluZyB0b1xuICAgICAgICAgIC8vIHNldCB0aGF0IHdvbid0IGdldCBub3JtYWxpemVkIGF3YXlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHNwbGl0TW9kZSA9IG1vZGUgPT09ICdsb3dlc3QnID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCc7XG4gICAgICAgIHZhciBlbmRBdEVuZE9mTm9kZSA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGVuZCwgZW5kLnBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhZW5kQXRFbmRPZk5vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdGFydEF0U3RhcnRPZk5vZGUgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHN0YXJ0LCBzdGFydC5wYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhc3RhcnRBdFN0YXJ0T2ZOb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY29tcGFyZSkge1xuICAgICAgICBjb21wYXJlID0gKHByb3AsIG5vZGVQcm9wKSA9PiBwcm9wICE9PSBub2RlUHJvcDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTsgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNDaGFuZ2VzID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgICAgIGlmIChrID09PSAnY2hpbGRyZW4nIHx8IGsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbXBhcmUocHJvcHNba10sIG5vZGVba10pKSB7XG4gICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTsgLy8gT21pdCBuZXcgcHJvcGVydGllcyBmcm9tIHRoZSBvbGQgcHJvcGVydGllcyBsaXN0XG5cbiAgICAgICAgICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KGspKSBwcm9wZXJ0aWVzW2tdID0gbm9kZVtrXTsgLy8gT21pdCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbmV3IHByb3BlcnRpZXMgbGlzdFxuXG4gICAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBtZXJnZShub2RlW2tdLCBwcm9wc1trXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IHByb3BzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNwbGl0IHRoZSBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxyXG4gICAqL1xuICBzcGxpdE5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGFsd2F5cyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IGRlbGV0ZVJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfSAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgcGF0aCwgdGhlIGRlZmF1bHQgaGVpZ2h0LXNraXBwaW5nIGFuZCBwb3NpdGlvblxuICAgICAgLy8gY291bnRlcnMgbmVlZCB0byBhY2NvdW50IGZvciB1cyBwb3RlbnRpYWxseSBzcGxpdHRpbmcgYXQgYSBub24tbGVhZi5cblxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBwYXRoID0gYXQ7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgbWF0Y2ggPSBuID0+IG4gPT09IHBhcmVudDtcblxuICAgICAgICBoZWlnaHQgPSBwb2ludC5wYXRoLmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgYXQgPSBwb2ludDtcbiAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiZWZvcmVSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgICAgfSk7XG4gICAgICB2YXIgYWZ0ZXJSZWY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBbaGlnaGVzdF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWhpZ2hlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbnVkZ2UgPSAwO1xuXG4gICAgICAgIGlmICghdm9pZHMgJiYgdm9pZE1hdGNoKSB7XG4gICAgICAgICAgdmFyIFt2b2lkTm9kZSwgdm9pZFBhdGhdID0gdm9pZE1hdGNoO1xuXG4gICAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHZvaWROb2RlKSAmJiBlZGl0b3IuaXNJbmxpbmUodm9pZE5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCB2b2lkUGF0aCk7XG5cbiAgICAgICAgICAgIGlmICghYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIGFmdGVyUGF0aCA9IFBhdGgubmV4dCh2b2lkUGF0aCk7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB0ZXh0LCB7XG4gICAgICAgICAgICAgICAgYXQ6IGFmdGVyUGF0aCxcbiAgICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2libGluZ0hlaWdodCA9IGF0LnBhdGgubGVuZ3RoIC0gdm9pZFBhdGgubGVuZ3RoO1xuICAgICAgICAgIGhlaWdodCA9IHNpYmxpbmdIZWlnaHQgKyAxO1xuICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgICAgdmFyIGRlcHRoID0gYXQucGF0aC5sZW5ndGggLSBoZWlnaHQ7XG4gICAgICAgIHZhciBbLCBoaWdoZXN0UGF0aF0gPSBoaWdoZXN0O1xuICAgICAgICB2YXIgbG93ZXN0UGF0aCA9IGF0LnBhdGguc2xpY2UoMCwgZGVwdGgpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBoZWlnaHQgPT09IDAgPyBhdC5vZmZzZXQgOiBhdC5wYXRoW2RlcHRoXSArIG51ZGdlO1xuXG4gICAgICAgIGZvciAodmFyIFtub2RlLCBfcGF0aDJdIG9mIEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKF9wYXRoMi5sZW5ndGggPCBoaWdoZXN0UGF0aC5sZW5ndGggfHwgX3BhdGgyLmxlbmd0aCA9PT0gMCB8fCAhdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3BvaW50ID0gYmVmb3JlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpO1xuXG4gICAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpKSB7XG4gICAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IE5vZGUuZXh0cmFjdFByb3BzKG5vZGUpO1xuICAgICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgICBwYXRoOiBfcGF0aDIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3NpdGlvbiA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV0gKyAoc3BsaXQgfHwgaXNFbmQgPyAxIDogMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9wb2ludDIgPSBhZnRlclJlZi5jdXJyZW50IHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9wb2ludDIpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB2YXIgX2FmdGVyUmVmO1xuXG4gICAgICAgIGJlZm9yZVJlZi51bnJlZigpO1xuICAgICAgICAoX2FmdGVyUmVmID0gYWZ0ZXJSZWYpID09PSBudWxsIHx8IF9hZnRlclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FmdGVyUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgcHJvcGVydGllcyBvbiB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgcHJvcHMgPSBbcHJvcHNdO1xuICAgIH1cblxuICAgIHZhciBvYmogPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBvZiBwcm9wcykge1xuICAgICAgb2JqW2tleV0gPSBudWxsO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBvYmosIG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVud3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBmcm9tIGEgcGFyZW50IG5vZGUsIHNwbGl0dGluZyB0aGUgcGFyZW50IGlmXHJcbiAgICogbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGNvbnRlbnQgaW4gdGhlIHJhbmdlIGlzIHVud3JhcHBlZC5cclxuICAgKi9cbiAgdW53cmFwTm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlUmVmID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCkgOiBudWxsO1xuICAgICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBfcmVmNSA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY1O1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0gLy8gdW53cmFwTm9kZSB3aWxsIGNhbGwgbGlmdE5vZGUgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBzcGxpdHRpbmcgdGhlIG5vZGUgd2hlbiBuZXN0ZWQuXG4gICAgICAvLyBJZiB3ZSBkbyBub3QgcmV2ZXJzZSB0aGUgb3JkZXIgYW5kIGNhbGwgaXQgZnJvbSB0b3AgdG8gdGhlIGJvdHRvbSwgaXQgd2lsbCByZW1vdmUgYWxsIGJsb2Nrc1xuICAgICAgLy8gdGhhdCB3cmFwIHRhcmdldCBub2RlLiBTbyB3ZSByZXZlcnNlIHRoZSBvcmRlci5cbiAgICAgICkucmV2ZXJzZSgpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwYXRoUmVmKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHNwbGl0ICYmIHJhbmdlUmVmKSB7XG4gICAgICAgICAgcmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2VSZWYuY3VycmVudCwgcmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5saWZ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSAmJiBub2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgICBfbG9vcChwYXRoUmVmKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhbmdlUmVmKSB7XG4gICAgICAgIHJhbmdlUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogV3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBpbiBhIG5ldyBjb250YWluZXIgbm9kZSwgc3BsaXR0aW5nIHRoZSBlZGdlc1xyXG4gICAqIG9mIHRoZSByYW5nZSBmaXJzdCB0byBlbnN1cmUgdGhhdCBvbmx5IHRoZSBjb250ZW50IGluIHRoZSByYW5nZSBpcyB3cmFwcGVkLlxyXG4gICAqL1xuICB3cmFwTm9kZXMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoZWRpdG9yLCBhdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pIHx8IFRleHQuaXNUZXh0KG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJvb3RzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaDogZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpID8gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogbiA9PiBFZGl0b3IuaXNFZGl0b3IobiksXG4gICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpO1xuXG4gICAgICBmb3IgKHZhciBbLCByb290UGF0aF0gb2Ygcm9vdHMpIHtcbiAgICAgICAgdmFyIGEgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IFJhbmdlLmludGVyc2VjdGlvbihhdCwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcm9vdFBhdGgpKSA6IGF0O1xuXG4gICAgICAgIGlmICghYSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYSxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgW2ZpcnN0XSA9IG1hdGNoZXM7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gZmlyc3Q7XG4gICAgICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gbGFzdDtcblxuICAgICAgICAgICAgaWYgKGZpcnN0UGF0aC5sZW5ndGggPT09IDAgJiYgbGFzdFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgcGFyZW50IC0gdXN1YWxseSBtZWFucyB0aGUgbm9kZSBpcyBhbiBlZGl0b3IgLSBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguZXF1YWxzKGZpcnN0UGF0aCwgbGFzdFBhdGgpID8gUGF0aC5wYXJlbnQoZmlyc3RQYXRoKSA6IFBhdGguY29tbW9uKGZpcnN0UGF0aCwgbGFzdFBhdGgpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgICB2YXIgY29tbW9uTm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBjb21tb25QYXRoKTtcbiAgICAgICAgICAgIHZhciBbY29tbW9uTm9kZV0gPSBjb21tb25Ob2RlRW50cnk7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSBjb21tb25QYXRoLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB2YXIgd3JhcHBlclBhdGggPSBQYXRoLm5leHQobGFzdFBhdGguc2xpY2UoMCwgZGVwdGgpKTtcblxuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBlbGVtZW50KSwge30sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHdyYXBwZXIsIHtcbiAgICAgICAgICAgICAgYXQ6IHdyYXBwZXJQYXRoLFxuICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzQW5jZXN0b3IoY29tbW9uTm9kZSkgJiYgY29tbW9uTm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKSxcbiAgICAgICAgICAgICAgdG86IHdyYXBwZXJQYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufTtcblxudmFyIGhhc1NpbmdsZUNoaWxkTmVzdCA9IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuXG4gICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbi8qKlxyXG4gKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIHBvaW50IGJ5IGRlbGV0aW5nIGl0J3MgY29udGVudC5cclxuICovXG5cblxudmFyIGRlbGV0ZVJhbmdlID0gKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiByYW5nZS5hbmNob3I7XG4gIH0gZWxzZSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFJlZi51bnJlZigpO1xuICB9XG59O1xuXG52YXIgbWF0Y2hQYXRoID0gKGVkaXRvciwgcGF0aCkgPT4ge1xuICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgcmV0dXJuIG4gPT4gbiA9PT0gbm9kZTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgU2VsZWN0aW9uVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogQ29sbGFwc2UgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgY29sbGFwc2UoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBlZGdlID0gJ2FuY2hvcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIHZhciBbc3RhcnRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc3RhcnQpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgZW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgZGVzZWxlY3QoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIHNlbGVjdGlvbidzIHBvaW50IGZvcndhcmQgb3IgYmFja3dhcmQuXHJcbiAgICovXG4gIG1vdmUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciB7XG4gICAgICBkaXN0YW5jZSA9IDEsXG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgZWRnZSA9IG51bGxcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBkaXN0YW5jZSxcbiAgICAgIHVuaXRcbiAgICB9O1xuICAgIHZhciBwcm9wcyA9IHt9O1xuXG4gICAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhbmNob3IsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYW5jaG9yLCBvcHRzKTtcblxuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIHByb3BzLmFuY2hvciA9IHBvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlZGdlID09IG51bGwgfHwgZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgdmFyIF9wb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgZm9jdXMsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgZm9jdXMsIG9wdHMpO1xuXG4gICAgICBpZiAoX3BvaW50KSB7XG4gICAgICAgIHByb3BzLmZvY3VzID0gX3BvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc2VsZWN0aW9uIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xuICBzZWxlY3QoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB0YXJnZXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGBudWxsYCB5b3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IGFuIGBhbmNob3JgIGFuZCBgZm9jdXNgLCBidXQgeW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeSh0YXJnZXQpKSk7XG4gICAgfVxuXG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgIG5ld1Byb3BlcnRpZXM6IHRhcmdldFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiBvbmUgb2YgdGhlIHNlbGVjdGlvbidzIHBvaW50cy5cclxuICAgKi9cbiAgc2V0UG9pbnQoZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIge1xuICAgICAgZWRnZSA9ICdib3RoJ1xuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICB2YXIgcG9pbnQgPSBlZGdlID09PSAnYW5jaG9yJyA/IGFuY2hvciA6IGZvY3VzO1xuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgW2VkZ2UgPT09ICdhbmNob3InID8gJ2FuY2hvcicgOiAnZm9jdXMnXTogX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgcG9pbnQpLCBwcm9wcylcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgb2xkUHJvcHMgPSB7fTtcbiAgICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgaWYgKGsgPT09ICdhbmNob3InICYmIHByb3BzLmFuY2hvciAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuYW5jaG9yLCBzZWxlY3Rpb24uYW5jaG9yKSB8fCBrID09PSAnZm9jdXMnICYmIHByb3BzLmZvY3VzICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5mb2N1cywgc2VsZWN0aW9uLmZvY3VzKSB8fCBrICE9PSAnYW5jaG9yJyAmJiBrICE9PSAnZm9jdXMnICYmIHByb3BzW2tdICE9PSBzZWxlY3Rpb25ba10pIHtcbiAgICAgICAgb2xkUHJvcHNba10gPSBzZWxlY3Rpb25ba107XG4gICAgICAgIG5ld1Byb3BzW2tdID0gcHJvcHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKG9sZFByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IG9sZFByb3BzLFxuICAgICAgICBuZXdQcm9wZXJ0aWVzOiBuZXdQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBUZXh0VHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogRGVsZXRlIGNvbnRlbnQgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgZGVsZXRlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICAgIGRpc3RhbmNlID0gMSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb2xsYXBzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmIFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgdmFyIGZ1cnRoZXN0Vm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0LFxuICAgICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXZvaWRzICYmIGZ1cnRoZXN0Vm9pZCkge1xuICAgICAgICAgIHZhciBbLCB2b2lkUGF0aF0gPSBmdXJ0aGVzdFZvaWQ7XG4gICAgICAgICAgYXQgPSB2b2lkUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICAgIGF0ID0ge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiB0YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhhbmdpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgIHZhciBbLCBfZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIGVuZE9mRG9jID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcblxuICAgICAgICBpZiAoIVBvaW50LmVxdWFscyhfZW5kLCBlbmRPZkRvYykpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBpc0Fjcm9zc0Jsb2NrcyA9IHN0YXJ0QmxvY2sgJiYgZW5kQmxvY2sgJiYgIVBhdGguZXF1YWxzKHN0YXJ0QmxvY2tbMV0sIGVuZEJsb2NrWzFdKTtcbiAgICAgIHZhciBpc1NpbmdsZVRleHQgPSBQYXRoLmVxdWFscyhzdGFydC5wYXRoLCBlbmQucGF0aCk7XG4gICAgICB2YXIgc3RhcnRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbmRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7IC8vIElmIHRoZSBzdGFydCBvciBlbmQgcG9pbnRzIGFyZSBpbnNpZGUgYW4gaW5saW5lIHZvaWQsIG51ZGdlIHRoZW0gb3V0LlxuXG4gICAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChiZWZvcmUgJiYgc3RhcnRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3Ioc3RhcnRCbG9ja1sxXSwgYmVmb3JlLnBhdGgpKSB7XG4gICAgICAgICAgc3RhcnQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgZW5kKTtcblxuICAgICAgICBpZiAoYWZ0ZXIgJiYgZW5kQmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKGVuZEJsb2NrWzFdLCBhZnRlci5wYXRoKSkge1xuICAgICAgICAgIGVuZCA9IGFmdGVyO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdldCB0aGUgaGlnaGVzdCBub2RlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmFuZ2UsIGFzIHdlbGwgYXNcbiAgICAgIC8vIHRoZSBzdGFydCBhbmQgZW5kIG5vZGVzLlxuXG5cbiAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICB2YXIgbGFzdFBhdGg7XG5cbiAgICAgIGZvciAodmFyIGVudHJ5IG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7XG5cbiAgICAgICAgaWYgKGxhc3RQYXRoICYmIFBhdGguY29tcGFyZShwYXRoLCBsYXN0UGF0aCkgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8ICFQYXRoLmlzQ29tbW9uKHBhdGgsIHN0YXJ0LnBhdGgpICYmICFQYXRoLmlzQ29tbW9uKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgbGFzdFBhdGggPSBwYXRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgX3JlZiA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgIHZhciByZW1vdmVkVGV4dCA9ICcnO1xuXG4gICAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgW19ub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50KTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aFxuICAgICAgICB9ID0gX3BvaW50O1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG9mZnNldFxuICAgICAgICB9ID0gc3RhcnQ7XG5cbiAgICAgICAgdmFyIHRleHQgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVtb3ZlZFRleHQgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhdGhSZWZzLnJldmVyc2UoKS5tYXAociA9PiByLnVucmVmKCkpLmZpbHRlcihyID0+IHIgIT09IG51bGwpLmZvckVhY2gocCA9PiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKCFlbmRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQyID0gZW5kUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBbX25vZGUyXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50Mik7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgIH0gPSBfcG9pbnQyO1xuXG4gICAgICAgIHZhciBfb2Zmc2V0ID0gaXNTaW5nbGVUZXh0ID8gc3RhcnQub2Zmc2V0IDogMDtcblxuICAgICAgICB2YXIgX3RleHQgPSBfbm9kZTIudGV4dC5zbGljZShfb2Zmc2V0LCBlbmQub2Zmc2V0KTtcblxuICAgICAgICBpZiAoX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgyLFxuICAgICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgICAgdGV4dDogX3RleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZW1vdmVkVGV4dCA9IF90ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNTaW5nbGVUZXh0ICYmIGlzQWNyb3NzQmxvY2tzICYmIGVuZFJlZi5jdXJyZW50ICYmIHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgICAgICBoYW5naW5nOiB0cnVlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBGb3IgVGhhaSBzY3JpcHQsIGRlbGV0aW5nIE4gY2hhcmFjdGVyKHMpIGJhY2t3YXJkIHNob3VsZCBkZWxldGVcbiAgICAgIC8vIE4gY29kZSBwb2ludChzKSBpbnN0ZWFkIG9mIGFuIGVudGlyZSBncmFwaGVtZSBjbHVzdGVyLlxuICAgICAgLy8gVGhlcmVmb3JlLCB0aGUgcmVtYWluaW5nIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbnNlcnRlZCBiYWNrLlxuXG5cbiAgICAgIGlmIChpc0NvbGxhcHNlZCAmJiByZXZlcnNlICYmIHVuaXQgPT09ICdjaGFyYWN0ZXInICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCA+IDEgJiYgcmVtb3ZlZFRleHQubWF0Y2goL1tcXHUwRTAwLVxcdTBFN0ZdKy8pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIHJlbW92ZWRUZXh0LnNsaWNlKDAsIHJlbW92ZWRUZXh0Lmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydFVucmVmID0gc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgIHZhciBlbmRVbnJlZiA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IHN0YXJ0VW5yZWYgfHwgZW5kVW5yZWYgOiBlbmRVbnJlZiB8fCBzdGFydFVucmVmO1xuXG4gICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsICYmIHBvaW50KSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIGZyYWdtZW50IGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghZnJhZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXRcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gSWYgdGhlIGluc2VydCBwb2ludCBpcyBhdCB0aGUgZWRnZSBvZiBhbiBpbmxpbmUgbm9kZSwgbW92ZSBpdCBvdXRzaWRlXG4gICAgICAvLyBpbnN0ZWFkIHNpbmNlIGl0IHdpbGwgbmVlZCB0byBiZSBzcGxpdCBvdGhlcndpc2UuXG5cblxuICAgICAgdmFyIGlubGluZUVsZW1lbnRNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlubGluZUVsZW1lbnRNYXRjaCkge1xuICAgICAgICB2YXIgWywgX2lubGluZVBhdGhdID0gaW5saW5lRWxlbWVudE1hdGNoO1xuXG4gICAgICAgIGlmIChFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgX2lubGluZVBhdGgpO1xuICAgICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgICAgYXQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrTWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIGF0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgWywgYmxvY2tQYXRoXSA9IGJsb2NrTWF0Y2g7XG4gICAgICB2YXIgaXNCbG9ja1N0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICAgIHZhciBpc0Jsb2NrRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgICB2YXIgaXNCbG9ja0VtcHR5ID0gaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgICB2YXIgbWVyZ2VTdGFydCA9ICFpc0Jsb2NrU3RhcnQgfHwgaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgICB2YXIgbWVyZ2VFbmQgPSAhaXNCbG9ja0VuZDtcbiAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pO1xuICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pO1xuICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgICAgdmFyIG1hdGNoZXIgPSBfcmVmMiA9PiB7XG4gICAgICAgIHZhciBbbiwgcF0gPSBfcmVmMjtcbiAgICAgICAgdmFyIGlzUm9vdCA9IHAubGVuZ3RoID09PSAwO1xuXG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbG9ja0VtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VTdGFydCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgZmlyc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lcmdlRW5kICYmIFBhdGguaXNBbmNlc3RvcihwLCBsYXN0UGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgZW50cnkgb2YgTm9kZS5ub2Rlcyh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwge1xuICAgICAgICBwYXNzOiBtYXRjaGVyXG4gICAgICB9KSkge1xuICAgICAgICBpZiAobWF0Y2hlcihlbnRyeSkpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydHMgPSBbXTtcbiAgICAgIHZhciBtaWRkbGVzID0gW107XG4gICAgICB2YXIgZW5kcyA9IFtdO1xuICAgICAgdmFyIHN0YXJ0aW5nID0gdHJ1ZTtcbiAgICAgIHZhciBoYXNCbG9ja3MgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgW25vZGVdIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgICAgICBzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgIGhhc0Jsb2NrcyA9IHRydWU7XG4gICAgICAgICAgbWlkZGxlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgICAgc3RhcnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbaW5saW5lTWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIFssIGlubGluZVBhdGhdID0gaW5saW5lTWF0Y2g7XG4gICAgICB2YXIgaXNJbmxpbmVTdGFydCA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgICAgdmFyIGlzSW5saW5lRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgICAgdmFyIG1pZGRsZVJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNCbG9ja0VuZCAmJiAhZW5kcy5sZW5ndGggPyBQYXRoLm5leHQoYmxvY2tQYXRoKSA6IGJsb2NrUGF0aCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBpc0lubGluZUVuZCA/IFBhdGgubmV4dChpbmxpbmVQYXRoKSA6IGlubGluZVBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gaGFzQmxvY2tzID8gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSA6IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiBoYXNCbG9ja3MgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JyxcbiAgICAgICAgYWx3YXlzOiBoYXNCbG9ja3MgJiYgKCFpc0Jsb2NrU3RhcnQgfHwgc3RhcnRzLmxlbmd0aCA+IDApICYmICghaXNCbG9ja0VuZCB8fCBlbmRzLmxlbmd0aCA+IDApLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsICFpc0lubGluZVN0YXJ0IHx8IGlzSW5saW5lU3RhcnQgJiYgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBzdGFydHMsIHtcbiAgICAgICAgYXQ6IHN0YXJ0UmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzQmxvY2tFbXB0eSAmJiAhc3RhcnRzLmxlbmd0aCAmJiBtaWRkbGVzLmxlbmd0aCAmJiAhZW5kcy5sZW5ndGgpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG1pZGRsZXMsIHtcbiAgICAgICAgYXQ6IG1pZGRsZVJlZi5jdXJyZW50LFxuICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGVuZHMsIHtcbiAgICAgICAgYXQ6IGVuZFJlZi5jdXJyZW50LFxuICAgICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5hdCkge1xuICAgICAgICB2YXIgcGF0aDtcblxuICAgICAgICBpZiAoZW5kcy5sZW5ndGggPiAwICYmIGVuZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoZW5kUmVmLmN1cnJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1pZGRsZXMubGVuZ3RoID4gMCAmJiBtaWRkbGVSZWYuY3VycmVudCkge1xuICAgICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKG1pZGRsZVJlZi5jdXJyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoc3RhcnRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBfZW5kMiA9IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX2VuZDIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICBtaWRkbGVSZWYudW5yZWYoKTtcbiAgICAgIGVuZFJlZi51bnJlZigpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIHN0cmluZyBvZiB0ZXh0IGluIHRoZSBFZGl0b3IuXHJcbiAgICovXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbmQgPSBSYW5nZS5lbmQoYXQpO1xuXG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzdGFydFJlZi51bnJlZigpO1xuICAgICAgICAgIHZhciBlbmRQb2ludCA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgICAgIGF0ID0gc3RhcnRQb2ludCB8fCBlbmRQb2ludDtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgICBmb2N1czogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBhdDtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdpbnNlcnRfdGV4dCcsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgdGV4dFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIFRyYW5zZm9ybXMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBHZW5lcmFsVHJhbnNmb3JtcyksIE5vZGVUcmFuc2Zvcm1zKSwgU2VsZWN0aW9uVHJhbnNmb3JtcyksIFRleHRUcmFuc2Zvcm1zKTtcblxuZXhwb3J0IHsgRWRpdG9yLCBFbGVtZW50LCBMb2NhdGlvbiwgTm9kZSwgT3BlcmF0aW9uLCBQYXRoLCBQYXRoUmVmLCBQb2ludCwgUG9pbnRSZWYsIFJhbmdlLCBSYW5nZVJlZiwgU2NydWJiZXIsIFNwYW4sIFRleHQsIFRyYW5zZm9ybXMsIGNyZWF0ZUVkaXRvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOlsiaXNQbGFpbk9iamVjdCIsInByb2R1Y2UiLCJjcmVhdGVEcmFmdCIsImZpbmlzaERyYWZ0IiwiaXNEcmFmdCIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJESVJUWV9QQVRIUyIsIldlYWtNYXAiLCJESVJUWV9QQVRIX0tFWVMiLCJGTFVTSElORyIsIk5PUk1BTElaSU5HIiwiUEFUSF9SRUZTIiwiUE9JTlRfUkVGUyIsIlJBTkdFX1JFRlMiLCJvd25LZXlzJDkiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCQ5IiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVkaXRvciIsImVkaXRvciIsImNoaWxkcmVuIiwib3BlcmF0aW9ucyIsInNlbGVjdGlvbiIsIm1hcmtzIiwiaXNJbmxpbmUiLCJpc1ZvaWQiLCJtYXJrYWJsZVZvaWQiLCJvbkNoYW5nZSIsIm9wIiwicmVmIiwiRWRpdG9yIiwicGF0aFJlZnMiLCJQYXRoUmVmIiwidHJhbnNmb3JtIiwiX3JlZiIsInBvaW50UmVmcyIsIlBvaW50UmVmIiwiX3JlZjIiLCJyYW5nZVJlZnMiLCJSYW5nZVJlZiIsIm9sZERpcnR5UGF0aHMiLCJnZXQiLCJvbGREaXJ0eVBhdGhLZXlzIiwiU2V0IiwiZGlydHlQYXRocyIsImRpcnR5UGF0aEtleXMiLCJhZGQiLCJwYXRoIiwiam9pbiIsImhhcyIsIlBhdGgiLCJvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoIiwibmV3UGF0aCIsIm5ld0RpcnR5UGF0aHMiLCJnZXREaXJ0eVBhdGhzIiwiX3BhdGgiLCJzZXQiLCJUcmFuc2Zvcm1zIiwibm9ybWFsaXplIiwib3BlcmF0aW9uIiwidHlwZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImFkZE1hcmsiLCJtYXRjaCIsIm5vZGUiLCJUZXh0IiwiaXNUZXh0IiwicGFyZW50Tm9kZSIsInBhcmVudFBhdGgiLCJwYXJlbnQiLCJleHBhbmRlZFNlbGVjdGlvbiIsIlJhbmdlIiwiaXNFeHBhbmRlZCIsIm1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQiLCJzZWxlY3RlZE5vZGUiLCJzZWxlY3RlZFBhdGgiLCJzZXROb2RlcyIsInNwbGl0Iiwidm9pZHMiLCJkZWxldGVCYWNrd2FyZCIsInVuaXQiLCJpc0NvbGxhcHNlZCIsImRlbGV0ZSIsInJldmVyc2UiLCJkZWxldGVGb3J3YXJkIiwiZGVsZXRlRnJhZ21lbnQiLCJkaXJlY3Rpb24iLCJnZXRGcmFnbWVudCIsIk5vZGUiLCJmcmFnbWVudCIsImluc2VydEJyZWFrIiwic3BsaXROb2RlcyIsImFsd2F5cyIsImluc2VydFNvZnRCcmVhayIsImluc2VydEZyYWdtZW50IiwiaW5zZXJ0Tm9kZSIsImluc2VydE5vZGVzIiwiaW5zZXJ0VGV4dCIsInRleHQiLCJub3JtYWxpemVOb2RlIiwiZW50cnkiLCJFbGVtZW50IiwiaXNFbGVtZW50IiwiY2hpbGQiLCJhdCIsImNvbmNhdCIsInNob3VsZEhhdmVJbmxpbmVzIiwiaXNFZGl0b3IiLCJuIiwiY3VycmVudE5vZGUiLCJfY2hpbGQiLCJwcmV2IiwiaXNMYXN0IiwiaXNJbmxpbmVPclRleHQiLCJyZW1vdmVOb2RlcyIsIm5ld0NoaWxkIiwiX25ld0NoaWxkIiwiZXF1YWxzIiwibG9vc2UiLCJtZXJnZU5vZGVzIiwicmVtb3ZlTWFyayIsInVuc2V0Tm9kZXMiLCJsZXZlbHMiLCJfcGF0aDIiLCJkZXNjZW5kYW50cyIsIkFycmF5IiwiZnJvbSIsIm5vZGVzIiwiX3JlZjMiLCJwIiwiX3BhdGgzIiwiYW5jZXN0b3JzIiwicHJldmlvdXNQYXRoIiwicHJldmlvdXMiLCJfcGF0aDQiLCJvbGRBbmNlc3RvcnMiLCJuZXdBbmNlc3RvcnMiLCJhbmNlc3RvciIsIl9hbmNlc3RvciIsIl9wIiwibmV3UGFyZW50IiwibmV3SW5kZXgiLCJyZXN1bHRQYXRoIiwiX3BhdGg1IiwiX2FuY2VzdG9ycyIsIl9wYXRoNiIsIl9sZXZlbHMiLCJuZXh0UGF0aCIsIm5leHQiLCJzaG91bGROb3JtYWxpemUiLCJfcmVmNCIsIml0ZXJhdGlvbiIsImluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoIiwibWF4SXRlcmF0aW9ucyIsIkVycm9yIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJpbmRleE9mIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlU3ltYm9sS2V5cyIsInByb3RvdHlwZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY2FsbCIsImdldENoYXJhY3RlckRpc3RhbmNlIiwic3RyIiwiaXNSVEwiLCJ1bmRlZmluZWQiLCJpc0xUUiIsImNvZGVwb2ludHMiLCJjb2RlcG9pbnRzSXRlcmF0b3JSVEwiLCJsZWZ0IiwiQ29kZXBvaW50VHlwZSIsIk5vbmUiLCJyaWdodCIsImRpc3RhbmNlIiwiZ2IxMSIsImdiMTJPcjEzIiwiY2hhciIsImNvZGUiLCJjb2RlUG9pbnRBdCIsImdldENvZGVwb2ludFR5cGUiLCJpbnRlcnNlY3RzIiwiWldKIiwiRXh0UGljdCIsImVuZHNXaXRoRW1vamlaV0oiLCJzdWJzdHJpbmciLCJSSSIsImVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMiLCJpc0JvdW5kYXJ5UGFpciIsIlNQQUNFIiwiUFVOQ1RVQVRJT04iLCJDSEFNRUxFT04iLCJnZXRXb3JkRGlzdGFuY2UiLCJkaXN0Iiwic3RhcnRlZCIsImNoYXJEaXN0IiwicmVtYWluaW5nIiwic3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlIiwiaXNXb3JkQ2hhcmFjdGVyIiwic2xpY2UiLCJ0ZXN0IiwibmV4dENoYXIiLCJuZXh0UmVtYWluaW5nIiwiZW5kIiwiY2hhcjEiLCJjaGFyQXQiLCJpc0xvd1N1cnJvZ2F0ZSIsImNoYXJDb2RlQXQiLCJjaGFyMiIsImlzSGlnaFN1cnJvZ2F0ZSIsImNoYXJDb2RlIiwicmVFeHRlbmQiLCJyZVByZXBlbmQiLCJyZVNwYWNpbmdNYXJrIiwicmVMIiwicmVWIiwicmVUIiwicmVMViIsInJlTFZUIiwicmVFeHRQaWN0IiwiQW55Iiwic2VhcmNoIiwiRXh0ZW5kIiwiUHJlcGVuZCIsIlNwYWNpbmdNYXJrIiwiTCIsIlYiLCJUIiwiTFYiLCJMVlQiLCJ4IiwieSIsIk5vbkJvdW5kYXJ5UGFpcnMiLCJmaW5kSW5kZXgiLCJyIiwiZW5kaW5nRW1vamlaV0oiLCJlbmRpbmdSSXMiLCJudW1SSXMiLCJpc05vZGVMaXN0IiwiaXNBbmNlc3RvciIsImlzRWxlbWVudExpc3QiLCJpc0FycmF5IiwiZXZlcnkiLCJ2YWwiLCJpc0VsZW1lbnRQcm9wcyIsInByb3BzIiwiaXNFbGVtZW50VHlwZSIsImVsZW1lbnRWYWwiLCJlbGVtZW50S2V5IiwibWF0Y2hlcyIsImVsZW1lbnQiLCJfZXhjbHVkZWQkNCIsIl9leGNsdWRlZDIkMyIsIm93bktleXMkOCIsIl9vYmplY3RTcHJlYWQkOCIsIklTX0VESVRPUl9DQUNIRSIsImFib3ZlIiwib3B0aW9ucyIsIm1vZGUiLCJpc1JhbmdlIiwiYW5jaG9yIiwiZm9jdXMiLCJhZnRlciIsInBvaW50IiwiZWRnZSIsInJhbmdlIiwiZCIsInBvc2l0aW9ucyIsImJlZm9yZSIsInN0YXJ0IiwiZWRnZXMiLCJmaXJzdCIsImhhc0Jsb2NrcyIsInNvbWUiLCJpc0Jsb2NrIiwiaGFzSW5saW5lcyIsImhhc1RleHRzIiwiY2FjaGVkSXNFZGl0b3IiLCJPcGVyYXRpb24iLCJpc09wZXJhdGlvbkxpc3QiLCJpc0VuZCIsIlBvaW50IiwiaXNFZGdlIiwiaXNTdGFydCIsImlzRW1wdHkiLCJpc05vcm1hbGl6aW5nIiwib2Zmc2V0IiwibGFzdCIsImxlYWYiLCJfbm9kZSIsIl9yZXN0IiwibWFya2VkVm9pZCIsImJsb2NrIiwicHJldk5vZGUiLCJwcmV2UGF0aCIsImJsb2NrUGF0aCIsInJlc3QiLCJwb2ludEFmdGVyTG9jYXRpb24iLCJ0byIsInNwYW4iLCJpc1BhdGgiLCJpbmNsdWRlcyIsInVuaXZlcnNhbCIsIlNwYW4iLCJpc1NwYW4iLCJub2RlRW50cmllcyIsInBhc3MiLCJoaXQiLCJpc0xvd2VyIiwiY29tcGFyZSIsImVtaXQiLCJmb3JjZSIsImdldERpcnR5UGF0aEtleXMiLCJwb3BEaXJ0eVBhdGgiLCJwb3AiLCJhbGxQYXRocyIsImFsbFBhdGhLZXlzIiwibWFwIiwid2l0aG91dE5vcm1hbGl6aW5nIiwiZGlydHlQYXRoIiwiXyIsIl9kaXJ0eVBhdGgiLCJfZW50cnkiLCJkZXB0aCIsImZpcnN0UGF0aCIsImxhc3RQYXRoIiwiY29tbW9uIiwiaXNQb2ludCIsImhhc1BhdGgiLCJwYXRoUmVmIiwiYWZmaW5pdHkiLCJjdXJyZW50IiwidW5yZWYiLCJyZWZzIiwicG9pbnRSZWYiLCJpc05ld0Jsb2NrIiwiYmxvY2tUZXh0IiwibGVhZlRleHRSZW1haW5pbmciLCJsZWFmVGV4dE9mZnNldCIsImUiLCJzIiwic3RyaW5nIiwiaXNGaXJzdCIsImNhbGNEaXN0YW5jZSIsInBvaW50QmVmb3JlTG9jYXRpb24iLCJyYW5nZVJlZiIsInNldE5vcm1hbGl6aW5nIiwidCIsInVuaGFuZ1JhbmdlIiwiaGFzUHJldmlvdXMiLCJlbmRCbG9jayIsInNraXAiLCJpc0JlZm9yZSIsInZvaWQiLCJmbiIsIkxvY2F0aW9uIiwiaXNMb2NhdGlvbiIsIl9leGNsdWRlZCQzIiwiX2V4Y2x1ZGVkMiQyIiwiSVNfTk9ERV9MSVNUX0NBQ0hFIiwicm9vdCIsIlNjcnViYmVyIiwic3RyaW5naWZ5IiwiaW5kZXgiLCJjIiwiY2hpbGRQYXRoIiwiYW5vdGhlciIsImRlc2NlbmRhbnQiLCJlbGVtZW50cyIsImV4dHJhY3RQcm9wcyIsInByb3BlcnRpZXMiLCJuZXdSb290Iiwic3BsaWNlIiwiX2xlYWYiLCJpc05vZGUiLCJjYWNoZWRSZXN1bHQiLCJpc1RleHRQcm9wcyIsInZpc2l0ZWQiLCJpc0FmdGVyIiwibmV4dEluZGV4IiwiX25ld1BhdGgiLCJ0ZXh0cyIsIm93bktleXMkNyIsIl9vYmplY3RTcHJlYWQkNyIsImlzTm9kZU9wZXJhdGlvbiIsImlzT3BlcmF0aW9uIiwiZW5kc1dpdGgiLCJwb3NpdGlvbiIsIm5ld1Byb3BlcnRpZXMiLCJpc1NlbGVjdGlvbk9wZXJhdGlvbiIsImlzVGV4dE9wZXJhdGlvbiIsImludmVyc2UiLCJpc1NpYmxpbmciLCJpbnZlcnNlUGF0aCIsImludmVyc2VOZXdQYXRoIiwiX3Byb3BlcnRpZXMiLCJfbmV3UHJvcGVydGllcyIsInBhdGhzIiwiYXYiLCJidiIsIm1pbiIsIk1hdGgiLCJlbmRzQWZ0ZXIiLCJhcyIsImJzIiwiZW5kc0F0IiwiZW5kc0JlZm9yZSIsImlzQ2hpbGQiLCJpc0NvbW1vbiIsImlzRGVzY2VuZGFudCIsImlzUGFyZW50IiwiYWwiLCJibCIsImxpc3QiLCJyZWxhdGl2ZSIsIl9vcCIsIl9vcDIiLCJfb3AzIiwiX3Bvc2l0aW9uIiwiX29wNCIsIm9ucCIsImNvcHkiLCJvd25LZXlzJDYiLCJfb2JqZWN0U3ByZWFkJDYiLCJyZXN1bHQiLCJfZXhjbHVkZWQkMiIsIm93bktleXMkNSIsIl9vYmplY3RTcHJlYWQkNSIsImlzQmFja3dhcmQiLCJycyIsInJlIiwidHMiLCJ0ZSIsImlzQWZ0ZXJTdGFydCIsImlzQmVmb3JlRW5kIiwiaW50ZXJzZWN0aW9uIiwiczEiLCJlMSIsInMyIiwiZTIiLCJpc0ZvcndhcmQiLCJwb2ludHMiLCJhZmZpbml0eUFuY2hvciIsImFmZmluaXR5Rm9jdXMiLCJfc2NydWJiZXIiLCJzZXRTY3J1YmJlciIsInNjcnViYmVyIiwiSlNPTiIsImlzRGVlcEVxdWFsIiwiYSIsImIiLCJfa2V5IiwiX2V4Y2x1ZGVkJDEiLCJfZXhjbHVkZWQyJDEiLCJvd25LZXlzJDQiLCJfb2JqZWN0U3ByZWFkJDQiLCJvbWl0VGV4dCIsImlzVGV4dExpc3QiLCJoYXNPd25Qcm9wZXJ0eSIsImRlY29yYXRpb25zIiwibGVhdmVzIiwiZGVjIiwibGVhZkVuZCIsImRlY29yYXRpb25TdGFydCIsImRlY29yYXRpb25FbmQiLCJsZWFmU3RhcnQiLCJhc3NpZ24iLCJtaWRkbGUiLCJvZmYiLCJfb2ZmIiwib3duS2V5cyQzIiwiX29iamVjdFNwcmVhZCQzIiwiYXBwbHlUb0RyYWZ0IiwiX3BvaW50IiwiX25vZGUyIiwiX3BhcmVudCIsIl9pbmRleCIsIl9wb2ludDIiLCJfa2V5MiIsIl9ub2RlMyIsIl9wYXJlbnQyIiwiX2luZGV4MiIsInRydWVQYXRoIiwiX3BvaW50MyIsIl9rZXkzIiwiX2luZGV4MyIsIl9wYXJlbnQzIiwiX3BvaW50NCIsIl9rZXk0IiwiX3ByZXYiLCJwcmVmZXJOZXh0IiwiX29mZnNldCIsIl90ZXh0IiwiX25vZGU0IiwiX2JlZm9yZSIsIl9hZnRlciIsIl9wb2ludDUiLCJfa2V5NSIsIl9ub2RlNSIsIl9rZXk2IiwiX2tleTciLCJfa2V5OCIsIl92YWx1ZSIsIl9wYXRoNyIsIl9ub2RlNiIsIl9wYXJlbnQ0IiwiX2luZGV4NCIsIm5ld05vZGUiLCJfYmVmb3JlMiIsIl9hZnRlcjIiLCJfYmVmb3JlMyIsIl9hZnRlcjMiLCJfcG9pbnQ2IiwiX2tleTkiLCJHZW5lcmFsVHJhbnNmb3JtcyIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJvd25LZXlzJDIiLCJfb2JqZWN0U3ByZWFkJDIiLCJOb2RlVHJhbnNmb3JtcyIsImhhbmdpbmciLCJzZWxlY3QiLCJfbWF0Y2hQYXRoIiwiaXNBdEVuZCIsImxpZnROb2RlcyIsIm1hdGNoUGF0aCIsInBhcmVudE5vZGVFbnRyeSIsInRvUGF0aCIsIm1vdmVOb2RlcyIsIl90b1BhdGgiLCJzcGxpdFBhdGgiLCJfdG9QYXRoMiIsImNvbW1vblBhdGgiLCJpc1ByZXZpb3VzU2libGluZyIsImVtcHR5QW5jZXN0b3IiLCJoYXNTaW5nbGVDaGlsZE5lc3QiLCJlbXB0eVJlZiIsInRvUmVmIiwidGFyZ2V0cyIsImRlcHRocyIsIm1lcmdlIiwic3BsaXRNb2RlIiwiZW5kQXRFbmRPZk5vZGUiLCJzdGFydEF0U3RhcnRPZk5vZGUiLCJwcm9wIiwibm9kZVByb3AiLCJoYXNDaGFuZ2VzIiwiayIsImhlaWdodCIsImRlbGV0ZVJhbmdlIiwiYmVmb3JlUmVmIiwiYWZ0ZXJSZWYiLCJoaWdoZXN0Iiwidm9pZE1hdGNoIiwibnVkZ2UiLCJ2b2lkTm9kZSIsInZvaWRQYXRoIiwiYWZ0ZXJQYXRoIiwic2libGluZ0hlaWdodCIsImhpZ2hlc3RQYXRoIiwibG93ZXN0UGF0aCIsIl9hZnRlclJlZiIsInVud3JhcE5vZGVzIiwiX3JlZjUiLCJfbG9vcCIsIndyYXBOb2RlcyIsInJvb3RzIiwicm9vdFBhdGgiLCJfcmV0IiwiY29tbW9uTm9kZUVudHJ5IiwiY29tbW9uTm9kZSIsIndyYXBwZXJQYXRoIiwid3JhcHBlciIsIm93bktleXMkMSIsIl9vYmplY3RTcHJlYWQkMSIsIlNlbGVjdGlvblRyYW5zZm9ybXMiLCJjb2xsYXBzZSIsImRlc2VsZWN0IiwibW92ZSIsIm9wdHMiLCJzZXRTZWxlY3Rpb24iLCJzZXRQb2ludCIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJUZXh0VHJhbnNmb3JtcyIsImZ1cnRoZXN0Vm9pZCIsIl9lbmQiLCJlbmRPZkRvYyIsInN0YXJ0QmxvY2siLCJpc0Fjcm9zc0Jsb2NrcyIsImlzU2luZ2xlVGV4dCIsInN0YXJ0Vm9pZCIsImVuZFZvaWQiLCJzdGFydFJlZiIsImVuZFJlZiIsInJlbW92ZWRUZXh0Iiwic3RhcnRVbnJlZiIsImVuZFVucmVmIiwiaW5saW5lRWxlbWVudE1hdGNoIiwiX2lubGluZVBhdGgiLCJibG9ja01hdGNoIiwiaXNCbG9ja1N0YXJ0IiwiaXNCbG9ja0VuZCIsImlzQmxvY2tFbXB0eSIsIm1lcmdlU3RhcnQiLCJtZXJnZUVuZCIsIm1hdGNoZXIiLCJpc1Jvb3QiLCJzdGFydHMiLCJtaWRkbGVzIiwiZW5kcyIsInN0YXJ0aW5nIiwiaW5saW5lTWF0Y2giLCJpbmxpbmVQYXRoIiwiaXNJbmxpbmVTdGFydCIsImlzSW5saW5lRW5kIiwibWlkZGxlUmVmIiwiX2VuZDIiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJvd25LZXlzIiwiX29iamVjdFNwcmVhZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/slate/dist/index.es.js\n");

/***/ })

};
;