"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-find-and-replace";
exports.ids = ["vendor-chunks/mdast-util-find-and-replace"];
exports.modules = {

/***/ "(ssr)/./node_modules/mdast-util-find-and-replace/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/mdast-util-find-and-replace/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = findAndReplace;\nvar visit = __webpack_require__(/*! unist-util-visit-parents */ \"(ssr)/./node_modules/unist-util-visit-parents/index.js\");\nvar convert = __webpack_require__(/*! unist-util-is/convert */ \"(ssr)/./node_modules/unist-util-is/convert.js\");\nvar escape = __webpack_require__(/*! escape-string-regexp */ \"(ssr)/./node_modules/escape-string-regexp/index.js\");\nvar splice = [].splice;\nfunction findAndReplace(tree, find, replace, options) {\n    var settings;\n    var schema;\n    if (typeof find === \"string\" || find && typeof find.exec === \"function\") {\n        schema = [\n            [\n                find,\n                replace\n            ]\n        ];\n    } else {\n        schema = find;\n        options = replace;\n    }\n    settings = options || {};\n    search(tree, settings, handlerFactory(toPairs(schema)));\n    return tree;\n    function handlerFactory(pairs) {\n        var pair = pairs[0];\n        return handler;\n        function handler(node, parent) {\n            var find = pair[0];\n            var replace = pair[1];\n            var nodes = [];\n            var start = 0;\n            var index = parent.children.indexOf(node);\n            var position;\n            var match;\n            var subhandler;\n            var value;\n            find.lastIndex = 0;\n            match = find.exec(node.value);\n            while(match){\n                position = match.index;\n                value = replace.apply(null, [].concat(match, {\n                    index: match.index,\n                    input: match.input\n                }));\n                if (value !== false) {\n                    if (start !== position) {\n                        nodes.push({\n                            type: \"text\",\n                            value: node.value.slice(start, position)\n                        });\n                    }\n                    if (typeof value === \"string\" && value.length > 0) {\n                        value = {\n                            type: \"text\",\n                            value: value\n                        };\n                    }\n                    if (value) {\n                        nodes = [].concat(nodes, value);\n                    }\n                    start = position + match[0].length;\n                }\n                if (!find.global) {\n                    break;\n                }\n                match = find.exec(node.value);\n            }\n            if (position === undefined) {\n                nodes = [\n                    node\n                ];\n                index--;\n            } else {\n                if (start < node.value.length) {\n                    nodes.push({\n                        type: \"text\",\n                        value: node.value.slice(start)\n                    });\n                }\n                nodes.unshift(index, 1);\n                splice.apply(parent.children, nodes);\n            }\n            if (pairs.length > 1) {\n                subhandler = handlerFactory(pairs.slice(1));\n                position = -1;\n                while(++position < nodes.length){\n                    node = nodes[position];\n                    if (node.type === \"text\") {\n                        subhandler(node, parent);\n                    } else {\n                        search(node, settings, subhandler);\n                    }\n                }\n            }\n            return index + nodes.length + 1;\n        }\n    }\n}\nfunction search(tree, settings, handler) {\n    var ignored = convert(settings.ignore || []);\n    var result = [];\n    visit(tree, \"text\", visitor);\n    return result;\n    function visitor(node, parents) {\n        var index = -1;\n        var parent;\n        var grandparent;\n        while(++index < parents.length){\n            parent = parents[index];\n            if (ignored(parent, grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {\n                return;\n            }\n            grandparent = parent;\n        }\n        return handler(node, grandparent);\n    }\n}\nfunction toPairs(schema) {\n    var result = [];\n    var key;\n    var index;\n    if (typeof schema !== \"object\") {\n        throw new Error(\"Expected array or object as schema\");\n    }\n    if (\"length\" in schema) {\n        index = -1;\n        while(++index < schema.length){\n            result.push([\n                toExpression(schema[index][0]),\n                toFunction(schema[index][1])\n            ]);\n        }\n    } else {\n        for(key in schema){\n            result.push([\n                toExpression(key),\n                toFunction(schema[key])\n            ]);\n        }\n    }\n    return result;\n}\nfunction toExpression(find) {\n    return typeof find === \"string\" ? new RegExp(escape(find), \"g\") : find;\n}\nfunction toFunction(replace) {\n    return typeof replace === \"function\" ? replace : returner;\n    function returner() {\n        return replace;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsVUFBVUQsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUUsU0FBU0YsbUJBQU9BLENBQUM7QUFFckIsSUFBSUcsU0FBUyxFQUFFLENBQUNBLE1BQU07QUFFdEIsU0FBU0wsZUFBZU0sSUFBSSxFQUFFQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsT0FBTztJQUNsRCxJQUFJQztJQUNKLElBQUlDO0lBRUosSUFBSSxPQUFPSixTQUFTLFlBQWFBLFFBQVEsT0FBT0EsS0FBS0ssSUFBSSxLQUFLLFlBQWE7UUFDekVELFNBQVM7WUFBQztnQkFBQ0o7Z0JBQU1DO2FBQVE7U0FBQztJQUM1QixPQUFPO1FBQ0xHLFNBQVNKO1FBQ1RFLFVBQVVEO0lBQ1o7SUFFQUUsV0FBV0QsV0FBVyxDQUFDO0lBRXZCSSxPQUFPUCxNQUFNSSxVQUFVSSxlQUFlQyxRQUFRSjtJQUU5QyxPQUFPTDtJQUVQLFNBQVNRLGVBQWVFLEtBQUs7UUFDM0IsSUFBSUMsT0FBT0QsS0FBSyxDQUFDLEVBQUU7UUFFbkIsT0FBT0U7UUFFUCxTQUFTQSxRQUFRQyxJQUFJLEVBQUVDLE1BQU07WUFDM0IsSUFBSWIsT0FBT1UsSUFBSSxDQUFDLEVBQUU7WUFDbEIsSUFBSVQsVUFBVVMsSUFBSSxDQUFDLEVBQUU7WUFDckIsSUFBSUksUUFBUSxFQUFFO1lBQ2QsSUFBSUMsUUFBUTtZQUNaLElBQUlDLFFBQVFILE9BQU9JLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDTjtZQUNwQyxJQUFJTztZQUNKLElBQUlDO1lBQ0osSUFBSUM7WUFDSixJQUFJQztZQUVKdEIsS0FBS3VCLFNBQVMsR0FBRztZQUVqQkgsUUFBUXBCLEtBQUtLLElBQUksQ0FBQ08sS0FBS1UsS0FBSztZQUU1QixN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ckMsUUFBUTtRQUN0QlksUUFBUSxDQUFDO1FBRVQsTUFBTyxFQUFFQSxRQUFRWixPQUFPMEIsTUFBTSxDQUFFO1lBQzlCTSxPQUFPVCxJQUFJLENBQUM7Z0JBQ1ZlLGFBQWF0QyxNQUFNLENBQUNZLE1BQU0sQ0FBQyxFQUFFO2dCQUM3QjJCLFdBQVd2QyxNQUFNLENBQUNZLE1BQU0sQ0FBQyxFQUFFO2FBQzVCO1FBQ0g7SUFDRixPQUFPO1FBQ0wsSUFBS3dCLE9BQU9wQyxPQUFRO1lBQ2xCZ0MsT0FBT1QsSUFBSSxDQUFDO2dCQUFDZSxhQUFhRjtnQkFBTUcsV0FBV3ZDLE1BQU0sQ0FBQ29DLElBQUk7YUFBRTtRQUMxRDtJQUNGO0lBRUEsT0FBT0o7QUFDVDtBQUVBLFNBQVNNLGFBQWExQyxJQUFJO0lBQ3hCLE9BQU8sT0FBT0EsU0FBUyxXQUFXLElBQUk0QyxPQUFPL0MsT0FBT0csT0FBTyxPQUFPQTtBQUNwRTtBQUVBLFNBQVMyQyxXQUFXMUMsT0FBTztJQUN6QixPQUFPLE9BQU9BLFlBQVksYUFBYUEsVUFBVTRDO0lBRWpELFNBQVNBO1FBQ1AsT0FBTzVDO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZpbmQtYW5kLXJlcGxhY2UvaW5kZXguanM/NTZkNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kQW5kUmVwbGFjZVxuXG52YXIgdmlzaXQgPSByZXF1aXJlKCd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnKVxudmFyIGNvbnZlcnQgPSByZXF1aXJlKCd1bmlzdC11dGlsLWlzL2NvbnZlcnQnKVxudmFyIGVzY2FwZSA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJylcblxudmFyIHNwbGljZSA9IFtdLnNwbGljZVxuXG5mdW5jdGlvbiBmaW5kQW5kUmVwbGFjZSh0cmVlLCBmaW5kLCByZXBsYWNlLCBvcHRpb25zKSB7XG4gIHZhciBzZXR0aW5nc1xuICB2YXIgc2NoZW1hXG5cbiAgaWYgKHR5cGVvZiBmaW5kID09PSAnc3RyaW5nJyB8fCAoZmluZCAmJiB0eXBlb2YgZmluZC5leGVjID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHNjaGVtYSA9IFtbZmluZCwgcmVwbGFjZV1dXG4gIH0gZWxzZSB7XG4gICAgc2NoZW1hID0gZmluZFxuICAgIG9wdGlvbnMgPSByZXBsYWNlXG4gIH1cblxuICBzZXR0aW5ncyA9IG9wdGlvbnMgfHwge31cblxuICBzZWFyY2godHJlZSwgc2V0dGluZ3MsIGhhbmRsZXJGYWN0b3J5KHRvUGFpcnMoc2NoZW1hKSkpXG5cbiAgcmV0dXJuIHRyZWVcblxuICBmdW5jdGlvbiBoYW5kbGVyRmFjdG9yeShwYWlycykge1xuICAgIHZhciBwYWlyID0gcGFpcnNbMF1cblxuICAgIHJldHVybiBoYW5kbGVyXG5cbiAgICBmdW5jdGlvbiBoYW5kbGVyKG5vZGUsIHBhcmVudCkge1xuICAgICAgdmFyIGZpbmQgPSBwYWlyWzBdXG4gICAgICB2YXIgcmVwbGFjZSA9IHBhaXJbMV1cbiAgICAgIHZhciBub2RlcyA9IFtdXG4gICAgICB2YXIgc3RhcnQgPSAwXG4gICAgICB2YXIgaW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihub2RlKVxuICAgICAgdmFyIHBvc2l0aW9uXG4gICAgICB2YXIgbWF0Y2hcbiAgICAgIHZhciBzdWJoYW5kbGVyXG4gICAgICB2YXIgdmFsdWVcblxuICAgICAgZmluZC5sYXN0SW5kZXggPSAwXG5cbiAgICAgIG1hdGNoID0gZmluZC5leGVjKG5vZGUudmFsdWUpXG5cbiAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICBwb3NpdGlvbiA9IG1hdGNoLmluZGV4XG4gICAgICAgIHZhbHVlID0gcmVwbGFjZS5hcHBseShcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIFtdLmNvbmNhdChtYXRjaCwge2luZGV4OiBtYXRjaC5pbmRleCwgaW5wdXQ6IG1hdGNoLmlucHV0fSlcbiAgICAgICAgKVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoc3RhcnQgIT09IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHt0eXBlOiAndGV4dCcsIHZhbHVlOiBub2RlLnZhbHVlLnNsaWNlKHN0YXJ0LCBwb3NpdGlvbil9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0ge3R5cGU6ICd0ZXh0JywgdmFsdWU6IHZhbHVlfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbXS5jb25jYXQobm9kZXMsIHZhbHVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXJ0ID0gcG9zaXRpb24gKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmluZC5nbG9iYWwpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2ggPSBmaW5kLmV4ZWMobm9kZS52YWx1ZSlcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZXMgPSBbbm9kZV1cbiAgICAgICAgaW5kZXgtLVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgbm9kZS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHt0eXBlOiAndGV4dCcsIHZhbHVlOiBub2RlLnZhbHVlLnNsaWNlKHN0YXJ0KX0pXG4gICAgICAgIH1cblxuICAgICAgICBub2Rlcy51bnNoaWZ0KGluZGV4LCAxKVxuICAgICAgICBzcGxpY2UuYXBwbHkocGFyZW50LmNoaWxkcmVuLCBub2RlcylcbiAgICAgIH1cblxuICAgICAgaWYgKHBhaXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc3ViaGFuZGxlciA9IGhhbmRsZXJGYWN0b3J5KHBhaXJzLnNsaWNlKDEpKVxuICAgICAgICBwb3NpdGlvbiA9IC0xXG5cbiAgICAgICAgd2hpbGUgKCsrcG9zaXRpb24gPCBub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbcG9zaXRpb25dXG5cbiAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHN1YmhhbmRsZXIobm9kZSwgcGFyZW50KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWFyY2gobm9kZSwgc2V0dGluZ3MsIHN1YmhhbmRsZXIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleCArIG5vZGVzLmxlbmd0aCArIDFcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VhcmNoKHRyZWUsIHNldHRpbmdzLCBoYW5kbGVyKSB7XG4gIHZhciBpZ25vcmVkID0gY29udmVydChzZXR0aW5ncy5pZ25vcmUgfHwgW10pXG4gIHZhciByZXN1bHQgPSBbXVxuXG4gIHZpc2l0KHRyZWUsICd0ZXh0JywgdmlzaXRvcilcblxuICByZXR1cm4gcmVzdWx0XG5cbiAgZnVuY3Rpb24gdmlzaXRvcihub2RlLCBwYXJlbnRzKSB7XG4gICAgdmFyIGluZGV4ID0gLTFcbiAgICB2YXIgcGFyZW50XG4gICAgdmFyIGdyYW5kcGFyZW50XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IHBhcmVudHMubGVuZ3RoKSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRzW2luZGV4XVxuXG4gICAgICBpZiAoXG4gICAgICAgIGlnbm9yZWQoXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIGdyYW5kcGFyZW50ID8gZ3JhbmRwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihwYXJlbnQpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGdyYW5kcGFyZW50XG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgZ3JhbmRwYXJlbnQgPSBwYXJlbnRcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlcihub2RlLCBncmFuZHBhcmVudClcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1BhaXJzKHNjaGVtYSkge1xuICB2YXIgcmVzdWx0ID0gW11cbiAgdmFyIGtleVxuICB2YXIgaW5kZXhcblxuICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFycmF5IG9yIG9iamVjdCBhcyBzY2hlbWEnKVxuICB9XG5cbiAgaWYgKCdsZW5ndGgnIGluIHNjaGVtYSkge1xuICAgIGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgc2NoZW1hLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goW1xuICAgICAgICB0b0V4cHJlc3Npb24oc2NoZW1hW2luZGV4XVswXSksXG4gICAgICAgIHRvRnVuY3Rpb24oc2NoZW1hW2luZGV4XVsxXSlcbiAgICAgIF0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoa2V5IGluIHNjaGVtYSkge1xuICAgICAgcmVzdWx0LnB1c2goW3RvRXhwcmVzc2lvbihrZXkpLCB0b0Z1bmN0aW9uKHNjaGVtYVtrZXldKV0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiB0b0V4cHJlc3Npb24oZmluZCkge1xuICByZXR1cm4gdHlwZW9mIGZpbmQgPT09ICdzdHJpbmcnID8gbmV3IFJlZ0V4cChlc2NhcGUoZmluZCksICdnJykgOiBmaW5kXG59XG5cbmZ1bmN0aW9uIHRvRnVuY3Rpb24ocmVwbGFjZSkge1xuICByZXR1cm4gdHlwZW9mIHJlcGxhY2UgPT09ICdmdW5jdGlvbicgPyByZXBsYWNlIDogcmV0dXJuZXJcblxuICBmdW5jdGlvbiByZXR1cm5lcigpIHtcbiAgICByZXR1cm4gcmVwbGFjZVxuICB9XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImZpbmRBbmRSZXBsYWNlIiwidmlzaXQiLCJyZXF1aXJlIiwiY29udmVydCIsImVzY2FwZSIsInNwbGljZSIsInRyZWUiLCJmaW5kIiwicmVwbGFjZSIsIm9wdGlvbnMiLCJzZXR0aW5ncyIsInNjaGVtYSIsImV4ZWMiLCJzZWFyY2giLCJoYW5kbGVyRmFjdG9yeSIsInRvUGFpcnMiLCJwYWlycyIsInBhaXIiLCJoYW5kbGVyIiwibm9kZSIsInBhcmVudCIsIm5vZGVzIiwic3RhcnQiLCJpbmRleCIsImNoaWxkcmVuIiwiaW5kZXhPZiIsInBvc2l0aW9uIiwibWF0Y2giLCJzdWJoYW5kbGVyIiwidmFsdWUiLCJsYXN0SW5kZXgiLCJhcHBseSIsImNvbmNhdCIsImlucHV0IiwicHVzaCIsInR5cGUiLCJzbGljZSIsImxlbmd0aCIsImdsb2JhbCIsInVuZGVmaW5lZCIsInVuc2hpZnQiLCJpZ25vcmVkIiwiaWdub3JlIiwicmVzdWx0IiwidmlzaXRvciIsInBhcmVudHMiLCJncmFuZHBhcmVudCIsImtleSIsIkVycm9yIiwidG9FeHByZXNzaW9uIiwidG9GdW5jdGlvbiIsIlJlZ0V4cCIsInJldHVybmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mdast-util-find-and-replace/index.js\n");

/***/ })

};
;