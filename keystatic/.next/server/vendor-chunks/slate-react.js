"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-react";
exports.ids = ["vendor-chunks/slate-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate-react/dist/index.es.js":
/*!***************************************************!*\
  !*** ./node_modules/slate-react/dist/index.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultElement: () => (/* binding */ DefaultElement),\n/* harmony export */   DefaultLeaf: () => (/* binding */ DefaultLeaf),\n/* harmony export */   DefaultPlaceholder: () => (/* binding */ DefaultPlaceholder),\n/* harmony export */   Editable: () => (/* binding */ Editable),\n/* harmony export */   ReactEditor: () => (/* binding */ ReactEditor),\n/* harmony export */   Slate: () => (/* binding */ Slate),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useFocused: () => (/* binding */ useFocused),\n/* harmony export */   useReadOnly: () => (/* binding */ useReadOnly),\n/* harmony export */   useSelected: () => (/* binding */ useSelected),\n/* harmony export */   useSlate: () => (/* binding */ useSlate),\n/* harmony export */   useSlateSelection: () => (/* binding */ useSlateSelection),\n/* harmony export */   useSlateSelector: () => (/* binding */ useSlateSelector),\n/* harmony export */   useSlateStatic: () => (/* binding */ useSlateStatic),\n/* harmony export */   useSlateWithV: () => (/* binding */ useSlateWithV),\n/* harmony export */   withReact: () => (/* binding */ withReact)\n/* harmony export */ });\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! direction */ \"(ssr)/./node_modules/direction/index.js\");\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(direction__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ \"(ssr)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/throttle */ \"(ssr)/./node_modules/lodash/throttle.js\");\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! scroll-into-view-if-needed */ \"(ssr)/./node_modules/slate-react/node_modules/scroll-into-view-if-needed/es/index.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @juggle/resize-observer */ \"(ssr)/./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\");\n/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! is-hotkey */ \"(ssr)/./node_modules/slate-react/node_modules/is-hotkey/lib/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\n\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n/**\r\n * An auto-incrementing identifier for keys.\r\n */ var n = 0;\n/**\r\n * A class that keeps track of a key string. We use a full class here because we\r\n * want to be able to use them as keys in `WeakMap` objects.\r\n */ class Key {\n    constructor(){\n        this.id = \"\".concat(n++);\n    }\n}\n/**\r\n * Two weak maps that allow us rebuild a path given a node. They are populated\r\n * at render time such that after a render occurs we can always backtrack.\r\n */ var NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\r\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\r\n * are used to resolve DOM event-related logic into Slate actions.\r\n */ var EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\r\n * Weak maps for storing editor-related state.\r\n */ var IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\r\n * Weak map for associating the context `onChange` context with the plugin.\r\n */ var EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\r\n * Weak maps for saving pending state on composition stage.\r\n */ var EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\r\n * Android input handling specific weak-maps\r\n */ var EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\r\n * Symbols.\r\n */ var PLACEHOLDER_SYMBOL = Symbol(\"placeholder\");\nvar MARK_PLACEHOLDER_SYMBOL = Symbol(\"mark-placeholder\");\n/**\r\n * Types.\r\n */ var DOMText = globalThis.Text;\n/**\r\n * Returns the host window of a DOM node\r\n */ var getDefaultView = (value)=>{\n    return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\r\n * Check if a DOM node is a comment node.\r\n */ var isDOMComment = (value)=>{\n    return isDOMNode(value) && value.nodeType === 8;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */ var isDOMElement = (value)=>{\n    return isDOMNode(value) && value.nodeType === 1;\n};\n/**\r\n * Check if a value is a DOM node.\r\n */ var isDOMNode = (value)=>{\n    var window1 = getDefaultView(value);\n    return !!window1 && value instanceof window1.Node;\n};\n/**\r\n * Check if a value is a DOM selection.\r\n */ var isDOMSelection = (value)=>{\n    var window1 = value && value.anchorNode && getDefaultView(value.anchorNode);\n    return !!window1 && value instanceof window1.Selection;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */ var isDOMText = (value)=>{\n    return isDOMNode(value) && value.nodeType === 3;\n};\n/**\r\n * Checks whether a paste event is a plaintext-only event.\r\n */ var isPlainTextOnlyPaste = (event)=>{\n    return event.clipboardData && event.clipboardData.getData(\"text/plain\") !== \"\" && event.clipboardData.types.length === 1;\n};\n/**\r\n * Normalize a DOM point so that it always refers to a text node.\r\n */ var normalizeDOMPoint = (domPoint)=>{\n    var [node, offset] = domPoint; // If it's an element node, its offset refers to the index of its children\n    // including comment nodes, so try to find the right text child node.\n    if (isDOMElement(node) && node.childNodes.length) {\n        var isLast = offset === node.childNodes.length;\n        var index = isLast ? offset - 1 : offset;\n        [node, index] = getEditableChildAndIndex(node, index, isLast ? \"backward\" : \"forward\"); // If the editable child found is in front of input offset, we instead seek to its end\n        isLast = index < offset; // If the node has children, traverse until we have a leaf node. Leaf nodes\n        // can be either text nodes, or other void DOM nodes.\n        while(isDOMElement(node) && node.childNodes.length){\n            var i = isLast ? node.childNodes.length - 1 : 0;\n            node = getEditableChild(node, i, isLast ? \"backward\" : \"forward\");\n        } // Determine the new offset inside the text node.\n        offset = isLast && node.textContent != null ? node.textContent.length : 0;\n    } // Return the node and offset.\n    return [\n        node,\n        offset\n    ];\n};\n/**\r\n * Determines wether the active element is nested within a shadowRoot\r\n */ var hasShadowRoot = (node)=>{\n    var parent = node && node.parentNode;\n    while(parent){\n        if (parent.toString() === \"[object ShadowRoot]\") {\n            return true;\n        }\n        parent = parent.parentNode;\n    }\n    return false;\n};\n/**\r\n * Get the nearest editable child and index at `index` in a `parent`, preferring\r\n * `direction`.\r\n */ var getEditableChildAndIndex = (parent, index, direction)=>{\n    var { childNodes } = parent;\n    var child = childNodes[index];\n    var i = index;\n    var triedForward = false;\n    var triedBackward = false; // While the child is a comment node, or an element node with no children,\n    // keep iterating to find a sibling non-void, non-comment node.\n    while(isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute(\"contenteditable\") === \"false\"){\n        if (triedForward && triedBackward) {\n            break;\n        }\n        if (i >= childNodes.length) {\n            triedForward = true;\n            i = index - 1;\n            direction = \"backward\";\n            continue;\n        }\n        if (i < 0) {\n            triedBackward = true;\n            i = index + 1;\n            direction = \"forward\";\n            continue;\n        }\n        child = childNodes[i];\n        index = i;\n        i += direction === \"forward\" ? 1 : -1;\n    }\n    return [\n        child,\n        index\n    ];\n};\n/**\r\n * Get the nearest editable child at `index` in a `parent`, preferring\r\n * `direction`.\r\n */ var getEditableChild = (parent, index, direction)=>{\n    var [child] = getEditableChildAndIndex(parent, index, direction);\n    return child;\n};\n/**\r\n * Get a plaintext representation of the content of a node, accounting for block\r\n * elements which get a newline appended.\r\n *\r\n * The domNode must be attached to the DOM.\r\n */ var getPlainText = (domNode)=>{\n    var text = \"\";\n    if (isDOMText(domNode) && domNode.nodeValue) {\n        return domNode.nodeValue;\n    }\n    if (isDOMElement(domNode)) {\n        for (var childNode of Array.from(domNode.childNodes)){\n            text += getPlainText(childNode);\n        }\n        var display = getComputedStyle(domNode).getPropertyValue(\"display\");\n        if (display === \"block\" || display === \"list\" || domNode.tagName === \"BR\") {\n            text += \"\\n\";\n        }\n    }\n    return text;\n};\n/**\r\n * Get x-slate-fragment attribute from data-slate-fragment\r\n */ var catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = (dataTransfer)=>{\n    var htmlData = dataTransfer.getData(\"text/html\");\n    var [, fragment] = htmlData.match(catchSlateFragment) || [];\n    return fragment;\n};\n/**\r\n * Check whether a mutation originates from a editable element inside the editor.\r\n */ var isTrackedMutation = (editor, mutation, batch)=>{\n    var { target } = mutation;\n    if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n        return false;\n    }\n    var { document: document1 } = ReactEditor.getWindow(editor);\n    if (document1.contains(target)) {\n        return ReactEditor.hasDOMNode(editor, target, {\n            editable: true\n        });\n    }\n    var parentMutation = batch.find((_ref)=>{\n        var { addedNodes, removedNodes } = _ref;\n        for (var node of addedNodes){\n            if (node === target || node.contains(target)) {\n                return true;\n            }\n        }\n        for (var _node of removedNodes){\n            if (_node === target || _node.contains(target)) {\n                return true;\n            }\n        }\n    });\n    if (!parentMutation || parentMutation === mutation) {\n        return false;\n    } // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n    return isTrackedMutation(editor, parentMutation, batch);\n};\nvar IS_REACT_VERSION_17_OR_ABOVE = parseInt(react__WEBPACK_IMPORTED_MODULE_3___default().version.split(\".\")[0], 10) >= 17;\nvar IS_IOS = typeof navigator !== \"undefined\" && \"undefined\" !== \"undefined\" && 0 && 0;\nvar IS_APPLE = typeof navigator !== \"undefined\" && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== \"undefined\" && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== \"undefined\" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_SAFARI = typeof navigator !== \"undefined\" && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent); // \"modern\" Edge was released at 79.x\nvar IS_EDGE_LEGACY = typeof navigator !== \"undefined\" && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== \"undefined\" && /Chrome/i.test(navigator.userAgent); // Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nvar IS_CHROME_LEGACY = typeof navigator !== \"undefined\" && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== \"undefined\" && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent); // Firefox did not support `beforeInput` until `v87`.\nvar IS_FIREFOX_LEGACY = typeof navigator !== \"undefined\" && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent); // UC mobile browser\nvar IS_UC_MOBILE = typeof navigator !== \"undefined\" && /.*UCBrowser/.test(navigator.userAgent); // Wechat browser\nvar IS_WECHATBROWSER = typeof navigator !== \"undefined\" && /.*Wechat/.test(navigator.userAgent); // Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nvar CAN_USE_DOM = !!( false && 0); // COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers\ntypeof globalThis !== \"undefined\" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === \"function\";\nvar ReactEditor = {\n    /**\r\n   * Check if the user is currently composing inside the editor.\r\n   */ isComposing (editor) {\n        return !!IS_COMPOSING.get(editor);\n    },\n    /**\r\n   * Return the host window of the current editor.\r\n   */ getWindow (editor) {\n        var window1 = EDITOR_TO_WINDOW.get(editor);\n        if (!window1) {\n            throw new Error(\"Unable to find a host window element for this editor\");\n        }\n        return window1;\n    },\n    /**\r\n   * Find a key for a Slate node.\r\n   */ findKey (editor, node) {\n        var key = NODE_TO_KEY.get(node);\n        if (!key) {\n            key = new Key();\n            NODE_TO_KEY.set(node, key);\n        }\n        return key;\n    },\n    /**\r\n   * Find the path of Slate node.\r\n   */ findPath (editor, node) {\n        var path = [];\n        var child = node;\n        while(true){\n            var parent = NODE_TO_PARENT.get(child);\n            if (parent == null) {\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(child)) {\n                    return path;\n                } else {\n                    break;\n                }\n            }\n            var i = NODE_TO_INDEX.get(child);\n            if (i == null) {\n                break;\n            }\n            path.unshift(i);\n            child = parent;\n        }\n        throw new Error(\"Unable to find the path for Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(node)));\n    },\n    /**\r\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\r\n   */ findDocumentOrShadowRoot (editor) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = el.getRootNode();\n        if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {\n            return root;\n        }\n        return el.ownerDocument;\n    },\n    /**\r\n   * Check if the editor is focused.\r\n   */ isFocused (editor) {\n        return !!IS_FOCUSED.get(editor);\n    },\n    /**\r\n   * Check if the editor is in read-only mode.\r\n   */ isReadOnly (editor) {\n        return !!IS_READ_ONLY.get(editor);\n    },\n    /**\r\n   * Blur the editor.\r\n   */ blur (editor) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        IS_FOCUSED.set(editor, false);\n        if (root.activeElement === el) {\n            el.blur();\n        }\n    },\n    /**\r\n   * Focus the editor.\r\n   */ focus (editor) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        IS_FOCUSED.set(editor, true);\n        if (root.activeElement !== el) {\n            el.focus({\n                preventScroll: true\n            });\n        }\n    },\n    /**\r\n   * Deselect the editor.\r\n   */ deselect (editor) {\n        var { selection } = editor;\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        var domSelection = root.getSelection();\n        if (domSelection && domSelection.rangeCount > 0) {\n            domSelection.removeAllRanges();\n        }\n        if (selection) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n        }\n    },\n    /**\r\n   * Check if a DOM node is within the editor.\r\n   */ hasDOMNode (editor, target) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { editable = false } = options;\n        var editorEl = ReactEditor.toDOMNode(editor, editor);\n        var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n        // target is originating from an internal \"restricted\" element (e.g. a\n        // stepper arrow on a number input). (2018/05/04)\n        // https://github.com/ianstormtaylor/slate/issues/1819\n        try {\n            targetEl = isDOMElement(target) ? target : target.parentElement;\n        } catch (err) {\n            if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n                throw err;\n            }\n        }\n        if (!targetEl) {\n            return false;\n        }\n        return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === \"boolean\" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n        // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n        targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute(\"data-slate-zero-width\"));\n    },\n    /**\r\n   * Insert data from a `DataTransfer` into the editor.\r\n   */ insertData (editor, data) {\n        editor.insertData(data);\n    },\n    /**\r\n   * Insert fragment data from a `DataTransfer` into the editor.\r\n   */ insertFragmentData (editor, data) {\n        return editor.insertFragmentData(data);\n    },\n    /**\r\n   * Insert text data from a `DataTransfer` into the editor.\r\n   */ insertTextData (editor, data) {\n        return editor.insertTextData(data);\n    },\n    /**\r\n   * Sets data from the currently selected fragment on a `DataTransfer`.\r\n   */ setFragmentData (editor, data, originEvent) {\n        editor.setFragmentData(data, originEvent);\n    },\n    /**\r\n   * Find the native DOM element from a Slate node.\r\n   */ toDOMNode (editor, node) {\n        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        var domNode = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n        if (!domNode) {\n            throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(node)));\n        }\n        return domNode;\n    },\n    /**\r\n   * Find a native DOM selection point from a Slate point.\r\n   */ toDOMPoint (editor, point) {\n        var [node] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.node(editor, point.path);\n        var el = ReactEditor.toDOMNode(editor, node);\n        var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero\n        // width spacing character will result in an incorrect offset of 1\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n            at: point\n        })) {\n            point = {\n                path: point.path,\n                offset: 0\n            };\n        } // For each leaf, we need to isolate its content, which means filtering\n        // to its direct text and zero-width spans. (We have to filter out any\n        // other siblings that may have been rendered alongside them.)\n        var selector = \"[data-slate-string], [data-slate-zero-width]\";\n        var texts = Array.from(el.querySelectorAll(selector));\n        var start = 0;\n        for(var i = 0; i < texts.length; i++){\n            var text = texts[i];\n            var domNode = text.childNodes[0];\n            if (domNode == null || domNode.textContent == null) {\n                continue;\n            }\n            var { length } = domNode.textContent;\n            var attr = text.getAttribute(\"data-slate-length\");\n            var trueLength = attr == null ? length : parseInt(attr, 10);\n            var end = start + trueLength; // Prefer putting the selection inside the mark placeholder to ensure\n            // composed text is displayed with the correct marks.\n            var nextText = texts[i + 1];\n            if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute(\"data-slate-mark-placeholder\")) {\n                var _nextText$textContent;\n                var domText = nextText.childNodes[0];\n                domPoint = [\n                    // dom text element, chrome will put the selection behind the actual dom\n                    // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n                    // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n                    // which will cause issues when scrolling to it.\n                    domText instanceof DOMText ? domText : nextText,\n                    (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith(\"\\uFEFF\") ? 1 : 0\n                ];\n                break;\n            }\n            if (point.offset <= end) {\n                var offset = Math.min(length, Math.max(0, point.offset - start));\n                domPoint = [\n                    domNode,\n                    offset\n                ];\n                break;\n            }\n            start = end;\n        }\n        if (!domPoint) {\n            throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(point)));\n        }\n        return domPoint;\n    },\n    /**\r\n   * Find a native DOM range from a Slate `range`.\r\n   *\r\n   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.\r\n   *\r\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\r\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\r\n   */ toDOMRange (editor, range) {\n        var { anchor, focus } = range;\n        var isBackward = slate__WEBPACK_IMPORTED_MODULE_7__.Range.isBackward(range);\n        var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n        var domFocus = slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n        var window1 = ReactEditor.getWindow(editor);\n        var domRange = window1.document.createRange();\n        var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n        var [endNode, endOffset] = isBackward ? domAnchor : domFocus; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n        // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n        // adjust the offset accordingly.\n        var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n        var isStartAtZeroWidth = !!startEl.getAttribute(\"data-slate-zero-width\");\n        var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n        var isEndAtZeroWidth = !!endEl.getAttribute(\"data-slate-zero-width\");\n        domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n        domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n        return domRange;\n    },\n    /**\r\n   * Find a Slate node from a native DOM `element`.\r\n   */ toSlateNode (editor, domNode) {\n        var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n        if (domEl && !domEl.hasAttribute(\"data-slate-node\")) {\n            domEl = domEl.closest(\"[data-slate-node]\");\n        }\n        var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n        if (!node) {\n            throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n        }\n        return node;\n    },\n    /**\r\n   * Get the target range from a DOM `event`.\r\n   */ findEventRange (editor, event) {\n        if (\"nativeEvent\" in event) {\n            event = event.nativeEvent;\n        }\n        var { clientX: x, clientY: y, target } = event;\n        if (x == null || y == null) {\n            throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n        }\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the\n        // next or previous node, depending on which side the `x` and `y`\n        // coordinates are closest to.\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n            var rect = target.getBoundingClientRect();\n            var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n            var edge = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.point(editor, path, {\n                edge: isPrev ? \"start\" : \"end\"\n            });\n            var point = isPrev ? slate__WEBPACK_IMPORTED_MODULE_7__.Editor.before(editor, edge) : slate__WEBPACK_IMPORTED_MODULE_7__.Editor.after(editor, edge);\n            if (point) {\n                var _range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, point);\n                return _range;\n            }\n        } // Else resolve a range from the caret position where the drop occured.\n        var domRange;\n        var { document: document1 } = ReactEditor.getWindow(editor); // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n        if (document1.caretRangeFromPoint) {\n            domRange = document1.caretRangeFromPoint(x, y);\n        } else {\n            var position = document1.caretPositionFromPoint(x, y);\n            if (position) {\n                domRange = document1.createRange();\n                domRange.setStart(position.offsetNode, position.offset);\n                domRange.setEnd(position.offsetNode, position.offset);\n            }\n        }\n        if (!domRange) {\n            throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n        } // Resolve a Slate range from the DOM range.\n        var range = ReactEditor.toSlateRange(editor, domRange, {\n            exactMatch: false,\n            suppressThrow: false\n        });\n        return range;\n    },\n    /**\r\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\r\n   */ toSlatePoint (editor, domPoint, options) {\n        var { exactMatch, suppressThrow } = options;\n        var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n        var parentNode = nearestNode.parentNode;\n        var textNode = null;\n        var offset = 0;\n        if (parentNode) {\n            var _domNode$textContent, _domNode$textContent2;\n            var editorEl = ReactEditor.toDOMNode(editor, editor);\n            var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]'); // Need to ensure that the closest void node is actually a void node\n            // within this editor, and not a void node within some parent editor. This can happen\n            // if this editor is within a void node of another editor (\"nested editors\", like in\n            // the \"Editable Voids\" example on the docs site).\n            var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n            var leafNode = parentNode.closest(\"[data-slate-leaf]\");\n            var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we\n            // can determine what the offset relative to the text node is.\n            if (leafNode) {\n                textNode = leafNode.closest('[data-slate-node=\"text\"]');\n                if (textNode) {\n                    var window1 = ReactEditor.getWindow(editor);\n                    var range = window1.document.createRange();\n                    range.setStart(textNode, 0);\n                    range.setEnd(nearestNode, nearestOffset);\n                    var contents = range.cloneContents();\n                    var removals = [\n                        ...Array.prototype.slice.call(contents.querySelectorAll(\"[data-slate-zero-width]\")),\n                        ...Array.prototype.slice.call(contents.querySelectorAll(\"[contenteditable=false]\"))\n                    ];\n                    removals.forEach((el)=>{\n                        // COMPAT: While composing at the start of a text node, some keyboards put\n                        // the text content inside the zero width space.\n                        if (IS_ANDROID && !exactMatch && el.hasAttribute(\"data-slate-zero-width\") && el.textContent.length > 0 && el.textContext !== \"\\uFEFF\") {\n                            if (el.textContent.startsWith(\"\\uFEFF\")) {\n                                el.textContent = el.textContent.slice(1);\n                            }\n                            return;\n                        }\n                        el.parentNode.removeChild(el);\n                    }); // COMPAT: Edge has a bug where Range.prototype.toString() will\n                    // convert \\n into \\r\\n. The bug causes a loop when slate-react\n                    // attempts to reposition its cursor to match the native position. Use\n                    // textContent.length instead.\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n                    offset = contents.textContent.length;\n                    domNode = textNode;\n                }\n            } else if (voidNode) {\n                // For void nodes, the element with the offset key will be a cousin, not an\n                // ancestor, so find it by going down from the nearest void parent and taking the\n                // first one that isn't inside a nested editor.\n                var leafNodes = voidNode.querySelectorAll(\"[data-slate-leaf]\");\n                for(var index = 0; index < leafNodes.length; index++){\n                    var current = leafNodes[index];\n                    if (ReactEditor.hasDOMNode(editor, current)) {\n                        leafNode = current;\n                        break;\n                    }\n                } // COMPAT: In read-only editors the leaf is not rendered.\n                if (!leafNode) {\n                    offset = 1;\n                } else {\n                    textNode = leafNode.closest('[data-slate-node=\"text\"]');\n                    domNode = leafNode;\n                    offset = domNode.textContent.length;\n                    domNode.querySelectorAll(\"[data-slate-zero-width]\").forEach((el)=>{\n                        offset -= el.textContent.length;\n                    });\n                }\n            }\n            if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,\n            // and we don't add it for line-breaks.\n            IS_ANDROID && domNode.getAttribute(\"data-slate-zero-width\") === \"z\" && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith(\"\\uFEFF\") && (parentNode.hasAttribute(\"data-slate-zero-width\") || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith(\"\\n\\n\"))) {\n                offset--;\n            }\n        }\n        if (IS_ANDROID && !textNode && !exactMatch) {\n            var node = parentNode.hasAttribute(\"data-slate-node\") ? parentNode : parentNode.closest(\"[data-slate-node]\");\n            if (node && ReactEditor.hasDOMNode(editor, node, {\n                editable: true\n            })) {\n                var _slateNode = ReactEditor.toSlateNode(editor, node);\n                var { path: _path, offset: _offset } = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, ReactEditor.findPath(editor, _slateNode));\n                if (!node.querySelector(\"[data-slate-leaf]\")) {\n                    _offset = nearestOffset;\n                }\n                return {\n                    path: _path,\n                    offset: _offset\n                };\n            }\n        }\n        if (!textNode) {\n            if (suppressThrow) {\n                return null;\n            }\n            throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n        } // COMPAT: If someone is clicking from one Slate editor into another,\n        // the select event fires twice, once for the old editor's `element`\n        // first, and then afterwards for the correct `element`. (2017/03/03)\n        var slateNode = ReactEditor.toSlateNode(editor, textNode);\n        var path = ReactEditor.findPath(editor, slateNode);\n        return {\n            path,\n            offset\n        };\n    },\n    /**\r\n   * Find a Slate range from a DOM range or selection.\r\n   */ toSlateRange (editor, domRange, options) {\n        var { exactMatch, suppressThrow } = options;\n        var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n        var anchorNode;\n        var anchorOffset;\n        var focusNode;\n        var focusOffset;\n        var isCollapsed;\n        if (el) {\n            if (isDOMSelection(domRange)) {\n                anchorNode = domRange.anchorNode;\n                anchorOffset = domRange.anchorOffset;\n                focusNode = domRange.focusNode;\n                focusOffset = domRange.focusOffset; // COMPAT: There's a bug in chrome that always returns `true` for\n                // `isCollapsed` for a Selection that comes from a ShadowRoot.\n                // (2020/08/08)\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n                if (IS_CHROME && hasShadowRoot(anchorNode)) {\n                    isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n                } else {\n                    isCollapsed = domRange.isCollapsed;\n                }\n            } else {\n                anchorNode = domRange.startContainer;\n                anchorOffset = domRange.startOffset;\n                focusNode = domRange.endContainer;\n                focusOffset = domRange.endOffset;\n                isCollapsed = domRange.collapsed;\n            }\n        }\n        if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n            throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n        } // COMPAT: Triple-clicking a word in chrome will sometimes place the focus\n        // inside a `contenteditable=\"false\"` DOM node following the word, which\n        // will cause `toSlatePoint` to throw an error. (2023/03/07)\n        if (\"getAttribute\" in focusNode && focusNode.getAttribute(\"contenteditable\") === \"false\") {\n            var _anchorNode$textConte;\n            focusNode = anchorNode;\n            focusOffset = ((_anchorNode$textConte = anchorNode.textContent) === null || _anchorNode$textConte === void 0 ? void 0 : _anchorNode$textConte.length) || 0;\n        }\n        var anchor = ReactEditor.toSlatePoint(editor, [\n            anchorNode,\n            anchorOffset\n        ], {\n            exactMatch,\n            suppressThrow\n        });\n        if (!anchor) {\n            return null;\n        }\n        var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [\n            focusNode,\n            focusOffset\n        ], {\n            exactMatch,\n            suppressThrow\n        });\n        if (!focus) {\n            return null;\n        }\n        /**\r\n     * suppose we have this document:\r\n     *\r\n     * { type: 'paragraph',\r\n     *   children: [\r\n     *     { text: 'foo ' },\r\n     *     { text: 'bar' },\r\n     *     { text: ' baz' }\r\n     *   ]\r\n     * }\r\n     *\r\n     * a double click on \"bar\" on chrome will create this range:\r\n     *\r\n     * anchor -> [0,1] offset 0\r\n     * focus  -> [0,1] offset 3\r\n     *\r\n     * while on firefox will create this range:\r\n     *\r\n     * anchor -> [0,0] offset 4\r\n     * focus  -> [0,2] offset 0\r\n     *\r\n     * let's try to fix it...\r\n     */ if (IS_FIREFOX && !isCollapsed && anchorNode !== focusNode) {\n            var isEnd = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEnd(editor, anchor, anchor.path);\n            var isStart = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isStart(editor, focus, focus.path);\n            if (isEnd) {\n                var after = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.after(editor, anchor); // Editor.after() might return undefined\n                anchor = after || anchor;\n            }\n            if (isStart) {\n                var before = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.before(editor, focus);\n                focus = before || focus;\n            }\n        }\n        var range = {\n            anchor: anchor,\n            focus: focus\n        }; // if the selection is a hanging range that ends in a void\n        // and the DOM focus is an Element\n        // (meaning that the selection ends before the element)\n        // unhang the range to avoid mistakenly including the void\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(range) && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isForward(range) && isDOMElement(focusNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n            at: range.focus,\n            mode: \"highest\"\n        })) {\n            range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.unhangRange(editor, range, {\n                voids: true\n            });\n        }\n        return range;\n    },\n    hasRange (editor, range) {\n        var { anchor, focus } = range;\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, anchor.path) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, focus.path);\n    },\n    /**\r\n   * Check if the target is in the editor.\r\n   */ hasTarget (editor, target) {\n        return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);\n    },\n    /**\r\n   * Check if the target is editable and in the editor.\r\n   */ hasEditableTarget (editor, target) {\n        return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n            editable: true\n        });\n    },\n    /**\r\n   * Check if the target can be selectable\r\n   */ hasSelectableTarget (editor, target) {\n        return ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target);\n    },\n    /**\r\n   * Check if the target is inside void and in an non-readonly editor.\r\n   */ isTargetInsideNonReadonlyVoid (editor, target) {\n        if (IS_READ_ONLY.get(editor)) return false;\n        var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(slateNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, slateNode);\n    },\n    /**\r\n   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.\r\n   */ androidScheduleFlush (editor) {\n        var _EDITOR_TO_SCHEDULE_F;\n        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n    },\n    /**\r\n   * Experimental and android specific: Get pending diffs\r\n   */ androidPendingDiffs (editor) {\n        return EDITOR_TO_PENDING_DIFFS.get(editor);\n    }\n};\nvar _excluded$3 = [\n    \"anchor\",\n    \"focus\"\n], _excluded2$1 = [\n    \"anchor\",\n    \"focus\"\n];\nvar shallowCompare = (obj1, obj2)=>Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key)=>obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\nvar isDecorationFlagsEqual = (range, other)=>{\n    var rangeOwnProps = _objectWithoutProperties(range, _excluded$3);\n    var otherOwnProps = _objectWithoutProperties(other, _excluded2$1);\n    return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */ var isElementDecorationsEqual = (list, another)=>{\n    if (list.length !== another.length) {\n        return false;\n    }\n    for(var i = 0; i < list.length; i++){\n        var range = list[i];\n        var other = another[i];\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */ var isTextDecorationsEqual = (list, another)=>{\n    if (list.length !== another.length) {\n        return false;\n    }\n    for(var i = 0; i < list.length; i++){\n        var range = list[i];\n        var other = another[i]; // compare only offsets because paths doesn't matter for text\n        if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\r\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\r\n */ var useIsomorphicLayoutEffect = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n/**\r\n * Leaf content strings.\r\n */ var String = (props)=>{\n    var { isLast, leaf, parent, text } = props;\n    var editor = useSlateStatic();\n    var path = ReactEditor.findPath(editor, text);\n    var parentPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(path);\n    var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true; // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    if (editor.isVoid(parent)) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            length: slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(parent).length\n        });\n    } // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    if (leaf.text === \"\" && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.string(editor, parentPath) === \"\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            isLineBreak: true,\n            isMarkPlaceholder: isMarkPlaceholder\n        });\n    } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    if (leaf.text === \"\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            isMarkPlaceholder: isMarkPlaceholder\n        });\n    } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    if (isLast && leaf.text.slice(-1) === \"\\n\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n            isTrailing: true,\n            text: leaf.text\n        });\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n        text: leaf.text\n    });\n};\n/**\r\n * Leaf strings with text in them.\r\n */ var TextString = (props)=>{\n    var { text, isTrailing = false } = props;\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var getTextContent = ()=>{\n        return \"\".concat(text !== null && text !== void 0 ? text : \"\").concat(isTrailing ? \"\\n\" : \"\");\n    };\n    var [initialText] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(getTextContent); // This is the actual text rendering boundary where we interface with the DOM\n    // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n    // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n    // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n    // exactly if and only if its current content does not match our current virtual DOM.\n    // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n    // eg makes native spellcheck opt out from checking the text node.\n    // useLayoutEffect: updating our span before browser paint\n    useIsomorphicLayoutEffect(()=>{\n        // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n        var textWithTrailing = getTextContent();\n        if (ref.current && ref.current.textContent !== textWithTrailing) {\n            ref.current.textContent = textWithTrailing;\n        } // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n    }); // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.\n    // We defer to the layout effect above to update the `textContent` of the span element when needed.\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText$1, {\n        ref: ref\n    }, initialText);\n};\nvar MemoizedText$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)((props, ref)=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n        \"data-slate-string\": true,\n        ref: ref\n    }, props.children);\n}));\n/**\r\n * Leaf strings without text, render as zero-width strings.\r\n */ var ZeroWidthString = (props)=>{\n    var { length = 0, isLineBreak = false, isMarkPlaceholder = false } = props;\n    var attributes = {\n        \"data-slate-zero-width\": isLineBreak ? \"n\" : \"z\",\n        \"data-slate-length\": length\n    };\n    if (isMarkPlaceholder) {\n        attributes[\"data-slate-mark-placeholder\"] = true;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? \"\\uFEFF\" : null, isLineBreak ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null) : null);\n};\n/**\r\n * A React context for sharing the editor object.\r\n */ var EditorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\r\n * Get the current editor object from the React context.\r\n */ var useSlateStatic = ()=>{\n    var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n    if (!editor) {\n        throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n    }\n    return editor;\n};\n/**\r\n * Individual leaves in a text node with unique formatting.\r\n */ var Leaf = (props)=>{\n    var { leaf, isLast, text, parent, renderPlaceholder, renderLeaf = (props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultLeaf, Object.assign({}, props)) } = props;\n    var lastPlaceholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var editor = useSlateStatic();\n    var placeholderResizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        return ()=>{\n            if (placeholderResizeObserver.current) {\n                placeholderResizeObserver.current.disconnect();\n            }\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;\n        if (placeholderEl) {\n            EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n        } else {\n            EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n        }\n        if (placeholderResizeObserver.current) {\n            // Update existing observer.\n            placeholderResizeObserver.current.disconnect();\n            if (placeholderEl) placeholderResizeObserver.current.observe(placeholderEl);\n        } else if (placeholderEl) {\n            // Create a new observer and observe the placeholder element.\n            var ResizeObserver$1 = window.ResizeObserver || _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_4__.ResizeObserver;\n            placeholderResizeObserver.current = new ResizeObserver$1(()=>{\n                // Force a re-render of the editor so its min-height can be updated\n                // to the new height of the placeholder.\n                var forceRender = EDITOR_TO_FORCE_RENDER.get(editor);\n                forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n            });\n            placeholderResizeObserver.current.observe(placeholderEl);\n        }\n        if (!placeholderEl && lastPlaceholderRef.current) {\n            // No placeholder element, so no need for a resize observer.\n            // Force a re-render of the editor so its min-height can be reset.\n            var forceRender = EDITOR_TO_FORCE_RENDER.get(editor);\n            forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n        }\n        lastPlaceholderRef.current = placeholderRef.current;\n        return ()=>{\n            EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n        };\n    }, [\n        placeholderRef,\n        leaf\n    ]);\n    var children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(String, {\n        isLast: isLast,\n        leaf: leaf,\n        parent: parent,\n        text: text\n    });\n    if (leaf[PLACEHOLDER_SYMBOL]) {\n        var placeholderProps = {\n            children: leaf.placeholder,\n            attributes: {\n                \"data-slate-placeholder\": true,\n                style: {\n                    position: \"absolute\",\n                    pointerEvents: \"none\",\n                    width: \"100%\",\n                    maxWidth: \"100%\",\n                    display: \"block\",\n                    opacity: \"0.333\",\n                    userSelect: \"none\",\n                    textDecoration: \"none\"\n                },\n                contentEditable: false,\n                ref: placeholderRef\n            }\n        };\n        children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, renderPlaceholder(placeholderProps), children);\n    } // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n    // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n    // contenteditable behaviors. (2019/05/08)\n    var attributes = {\n        \"data-slate-leaf\": true\n    };\n    return renderLeaf({\n        attributes,\n        children,\n        leaf,\n        text\n    });\n};\nvar MemoizedLeaf = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Leaf, (prev, next)=>{\n    return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = (props)=>{\n    var { attributes, children } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), children);\n};\n/**\r\n * Text.\r\n */ var Text = (props)=>{\n    var { decorations, isLast, parent, renderPlaceholder, renderLeaf, text } = props;\n    var editor = useSlateStatic();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var leaves = slate__WEBPACK_IMPORTED_MODULE_7__.Text.decorations(text, decorations);\n    var key = ReactEditor.findKey(editor, text);\n    var children = [];\n    for(var i = 0; i < leaves.length; i++){\n        var leaf = leaves[i];\n        children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedLeaf, {\n            isLast: isLast && i === leaves.length - 1,\n            key: \"\".concat(key.id, \"-\").concat(i),\n            renderPlaceholder: renderPlaceholder,\n            leaf: leaf,\n            text: text,\n            parent: parent,\n            renderLeaf: renderLeaf\n        }));\n    } // Update element-related weak maps with the DOM element ref.\n    var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((span)=>{\n        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        if (span) {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, span);\n            NODE_TO_ELEMENT.set(text, span);\n            ELEMENT_TO_NODE.set(span, text);\n        } else {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n            NODE_TO_ELEMENT.delete(text);\n            if (ref.current) {\n                ELEMENT_TO_NODE.delete(ref.current);\n            }\n        }\n        ref.current = span;\n    }, [\n        ref,\n        editor,\n        key,\n        text\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n        \"data-slate-node\": \"text\",\n        ref: callbackRef\n    }, children);\n};\nvar MemoizedText = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Text, (prev, next)=>{\n    return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && isTextDecorationsEqual(next.decorations, prev.decorations);\n});\n/**\r\n * Element.\r\n */ var Element = (props)=>{\n    var { decorations, element, renderElement = (p)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultElement, Object.assign({}, p)), renderPlaceholder, renderLeaf, selection } = props;\n    var editor = useSlateStatic();\n    var readOnly = useReadOnly();\n    var isInline = editor.isInline(element);\n    var key = ReactEditor.findKey(editor, element);\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((ref)=>{\n        // Update element-related weak maps with the DOM element ref.\n        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        if (ref) {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref);\n            NODE_TO_ELEMENT.set(element, ref);\n            ELEMENT_TO_NODE.set(ref, element);\n        } else {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n            NODE_TO_ELEMENT.delete(element);\n        }\n    }, [\n        editor,\n        key,\n        element\n    ]);\n    var children = useChildren({\n        decorations,\n        node: element,\n        renderElement,\n        renderPlaceholder,\n        renderLeaf,\n        selection\n    }); // Attributes that the developer must mix into the element in their\n    // custom node renderer component.\n    var attributes = {\n        \"data-slate-node\": \"element\",\n        ref\n    };\n    if (isInline) {\n        attributes[\"data-slate-inline\"] = true;\n    } // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (!isInline && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, element)) {\n        var text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element);\n        var dir = direction__WEBPACK_IMPORTED_MODULE_0___default()(text);\n        if (dir === \"rtl\") {\n            attributes.dir = dir;\n        }\n    } // If it's a void node, wrap the children in extra void-specific elements.\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, element)) {\n        attributes[\"data-slate-void\"] = true;\n        if (!readOnly && isInline) {\n            attributes.contentEditable = false;\n        }\n        var Tag = isInline ? \"span\" : \"div\";\n        var [[_text]] = slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(element);\n        children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, {\n            \"data-slate-spacer\": true,\n            style: {\n                height: \"0\",\n                color: \"transparent\",\n                outline: \"none\",\n                position: \"absolute\"\n            }\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n            renderPlaceholder: renderPlaceholder,\n            decorations: [],\n            isLast: false,\n            parent: element,\n            text: _text\n        }));\n        NODE_TO_INDEX.set(_text, 0);\n        NODE_TO_PARENT.set(_text, element);\n    }\n    return renderElement({\n        attributes,\n        children,\n        element\n    });\n};\nvar MemoizedElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Element, (prev, next)=>{\n    return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && prev.renderPlaceholder === next.renderPlaceholder && isElementDecorationsEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(prev.selection, next.selection));\n});\n/**\r\n * The default element renderer.\r\n */ var DefaultElement = (props)=>{\n    var { attributes, children, element } = props;\n    var editor = useSlateStatic();\n    var Tag = editor.isInline(element) ? \"span\" : \"div\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, Object.assign({}, attributes, {\n        style: {\n            position: \"relative\"\n        }\n    }), children);\n};\n/**\r\n * A React context for sharing the `decorate` prop of the editable.\r\n */ var DecorateContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(()=>[]);\n/**\r\n * Get the current `decorate` prop of the editable.\r\n */ var useDecorate = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(DecorateContext);\n};\n/**\r\n * A React context for sharing the `selected` state of an element.\r\n */ var SelectedContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `selected` state of an element.\r\n */ var useSelected = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SelectedContext);\n};\n/**\r\n * Children.\r\n */ var useChildren = (props)=>{\n    var { decorations, node, renderElement, renderPlaceholder, renderLeaf, selection } = props;\n    var decorate = useDecorate();\n    var editor = useSlateStatic();\n    var path = ReactEditor.findPath(editor, node);\n    var children = [];\n    var isLeafBlock = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isInline(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, node);\n    for(var i = 0; i < node.children.length; i++){\n        var p = path.concat(i);\n        var n = node.children[i];\n        var key = ReactEditor.findKey(editor, n);\n        var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, p);\n        var sel = selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(range, selection);\n        var ds = decorate([\n            n,\n            p\n        ]);\n        for (var dec of decorations){\n            var d = slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(dec, range);\n            if (d) {\n                ds.push(d);\n            }\n        }\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n)) {\n            children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SelectedContext.Provider, {\n                key: \"provider-\".concat(key.id),\n                value: !!sel\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedElement, {\n                decorations: ds,\n                element: n,\n                key: key.id,\n                renderElement: renderElement,\n                renderPlaceholder: renderPlaceholder,\n                renderLeaf: renderLeaf,\n                selection: sel\n            })));\n        } else {\n            children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n                decorations: ds,\n                key: key.id,\n                isLast: isLeafBlock && i === node.children.length - 1,\n                parent: node,\n                renderPlaceholder: renderPlaceholder,\n                renderLeaf: renderLeaf,\n                text: n\n            }));\n        }\n        NODE_TO_INDEX.set(n, i);\n        NODE_TO_PARENT.set(n, node);\n    }\n    return children;\n};\n/**\r\n * A React context for sharing the `readOnly` state of the editor.\r\n */ var ReadOnlyContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `readOnly` state of the editor.\r\n */ var useReadOnly = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ReadOnlyContext);\n};\nvar SlateContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\r\n * Get the current editor object from the React context.\r\n */ var useSlate = ()=>{\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n    if (!context) {\n        throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n    }\n    var { editor } = context;\n    return editor;\n};\nvar useSlateWithV = ()=>{\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n    if (!context) {\n        throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n    }\n    return context;\n};\nvar TRIPLE_CLICK = 3;\n/**\r\n * Hotkey mappings for each platform.\r\n */ var HOTKEYS = {\n    bold: \"mod+b\",\n    compose: [\n        \"down\",\n        \"left\",\n        \"right\",\n        \"up\",\n        \"backspace\",\n        \"enter\"\n    ],\n    moveBackward: \"left\",\n    moveForward: \"right\",\n    moveWordBackward: \"ctrl+left\",\n    moveWordForward: \"ctrl+right\",\n    deleteBackward: \"shift?+backspace\",\n    deleteForward: \"shift?+delete\",\n    extendBackward: \"shift+left\",\n    extendForward: \"shift+right\",\n    italic: \"mod+i\",\n    insertSoftBreak: \"shift+enter\",\n    splitBlock: \"enter\",\n    undo: \"mod+z\"\n};\nvar APPLE_HOTKEYS = {\n    moveLineBackward: \"opt+up\",\n    moveLineForward: \"opt+down\",\n    moveWordBackward: \"opt+left\",\n    moveWordForward: \"opt+right\",\n    deleteBackward: [\n        \"ctrl+backspace\",\n        \"ctrl+h\"\n    ],\n    deleteForward: [\n        \"ctrl+delete\",\n        \"ctrl+d\"\n    ],\n    deleteLineBackward: \"cmd+shift?+backspace\",\n    deleteLineForward: [\n        \"cmd+shift?+delete\",\n        \"ctrl+k\"\n    ],\n    deleteWordBackward: \"opt+shift?+backspace\",\n    deleteWordForward: \"opt+shift?+delete\",\n    extendLineBackward: \"opt+shift+up\",\n    extendLineForward: \"opt+shift+down\",\n    redo: \"cmd+shift+z\",\n    transposeCharacter: \"ctrl+t\"\n};\nvar WINDOWS_HOTKEYS = {\n    deleteWordBackward: \"ctrl+shift?+backspace\",\n    deleteWordForward: \"ctrl+shift?+delete\",\n    redo: [\n        \"ctrl+y\",\n        \"ctrl+shift+z\"\n    ]\n};\n/**\r\n * Create a platform-aware hotkey checker.\r\n */ var create = (key)=>{\n    var generic = HOTKEYS[key];\n    var apple = APPLE_HOTKEYS[key];\n    var windows = WINDOWS_HOTKEYS[key];\n    var isGeneric = generic && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isKeyHotkey)(generic);\n    var isApple = apple && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isKeyHotkey)(apple);\n    var isWindows = windows && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isKeyHotkey)(windows);\n    return (event)=>{\n        if (isGeneric && isGeneric(event)) return true;\n        if (IS_APPLE && isApple && isApple(event)) return true;\n        if (!IS_APPLE && isWindows && isWindows(event)) return true;\n        return false;\n    };\n};\n/**\r\n * Hotkeys.\r\n */ var Hotkeys = {\n    isBold: create(\"bold\"),\n    isCompose: create(\"compose\"),\n    isMoveBackward: create(\"moveBackward\"),\n    isMoveForward: create(\"moveForward\"),\n    isDeleteBackward: create(\"deleteBackward\"),\n    isDeleteForward: create(\"deleteForward\"),\n    isDeleteLineBackward: create(\"deleteLineBackward\"),\n    isDeleteLineForward: create(\"deleteLineForward\"),\n    isDeleteWordBackward: create(\"deleteWordBackward\"),\n    isDeleteWordForward: create(\"deleteWordForward\"),\n    isExtendBackward: create(\"extendBackward\"),\n    isExtendForward: create(\"extendForward\"),\n    isExtendLineBackward: create(\"extendLineBackward\"),\n    isExtendLineForward: create(\"extendLineForward\"),\n    isItalic: create(\"italic\"),\n    isMoveLineBackward: create(\"moveLineBackward\"),\n    isMoveLineForward: create(\"moveLineForward\"),\n    isMoveWordBackward: create(\"moveWordBackward\"),\n    isMoveWordForward: create(\"moveWordForward\"),\n    isRedo: create(\"redo\"),\n    isSoftBreak: create(\"insertSoftBreak\"),\n    isSplitBlock: create(\"splitBlock\"),\n    isTransposeCharacter: create(\"transposeCharacter\"),\n    isUndo: create(\"undo\")\n};\nvar createRestoreDomManager = (editor, receivedUserInput)=>{\n    var bufferedMutations = [];\n    var clear = ()=>{\n        bufferedMutations = [];\n    };\n    var registerMutations = (mutations)=>{\n        if (!receivedUserInput.current) {\n            return;\n        }\n        var trackedMutations = mutations.filter((mutation)=>isTrackedMutation(editor, mutation, mutations));\n        bufferedMutations.push(...trackedMutations);\n    };\n    function restoreDOM() {\n        if (bufferedMutations.length > 0) {\n            bufferedMutations.reverse().forEach((mutation)=>{\n                if (mutation.type === \"characterData\") {\n                    // We don't want to restore the DOM for characterData mutations\n                    // because this interrupts the composition.\n                    return;\n                }\n                mutation.removedNodes.forEach((node)=>{\n                    mutation.target.insertBefore(node, mutation.nextSibling);\n                });\n                mutation.addedNodes.forEach((node)=>{\n                    mutation.target.removeChild(node);\n                });\n            }); // Clear buffered mutations to ensure we don't undo them twice\n            clear();\n        }\n    }\n    return {\n        registerMutations,\n        restoreDOM,\n        clear\n    };\n};\nvar MUTATION_OBSERVER_CONFIG$1 = {\n    subtree: true,\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true\n}; // We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\nclass RestoreDOMComponent extends react__WEBPACK_IMPORTED_MODULE_3__.Component {\n    constructor(){\n        super(...arguments);\n        this.context = null;\n        this.manager = null;\n        this.mutationObserver = null;\n    }\n    observe() {\n        var _this$mutationObserve;\n        var { node } = this.props;\n        if (!node.current) {\n            throw new Error(\"Failed to attach MutationObserver, `node` is undefined\");\n        }\n        (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG$1);\n    }\n    componentDidMount() {\n        var { receivedUserInput } = this.props;\n        var editor = this.context;\n        this.manager = createRestoreDomManager(editor, receivedUserInput);\n        this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n        this.observe();\n    }\n    getSnapshotBeforeUpdate() {\n        var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n        var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n        if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n            var _this$manager;\n            (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);\n        }\n        (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();\n        (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();\n        return null;\n    }\n    componentDidUpdate() {\n        var _this$manager3;\n        (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();\n        this.observe();\n    }\n    componentWillUnmount() {\n        var _this$mutationObserve4;\n        (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();\n    }\n    render() {\n        return this.props.children;\n    }\n}\nRestoreDOMComponent.contextType = EditorContext;\nvar RestoreDOM = IS_ANDROID ? RestoreDOMComponent : (_ref)=>{\n    var { children } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, children);\n};\n/**\r\n * Check whether a text diff was applied in a way we can perform the pending action on /\r\n * recover the pending selection.\r\n */ function verifyDiffState(editor, textDiff) {\n    var { path, diff } = textDiff;\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path)) {\n        return false;\n    }\n    var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(node)) {\n        return false;\n    }\n    if (diff.start !== node.text.length || diff.text.length === 0) {\n        return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n    }\n    var nextPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, nextPath)) {\n        return false;\n    }\n    var nextNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, nextPath);\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n    for(var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        diffs[_key - 1] = arguments[_key];\n    }\n    return diffs.reduce((text, diff)=>text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\nfunction longestCommonPrefixLength(str, another) {\n    var length = Math.min(str.length, another.length);\n    for(var i = 0; i < length; i++){\n        if (str.charAt(i) !== another.charAt(i)) {\n            return i;\n        }\n    }\n    return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n    var length = Math.min(str.length, another.length, max);\n    for(var i = 0; i < length; i++){\n        if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n            return i;\n        }\n    }\n    return length;\n}\n/**\r\n * Remove redundant changes from the diff so that it spans the minimal possible range\r\n */ function normalizeStringDiff(targetText, diff) {\n    var { start, end, text } = diff;\n    var removedText = targetText.slice(start, end);\n    var prefixLength = longestCommonPrefixLength(removedText, text);\n    var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n    var suffixLength = longestCommonSuffixLength(removedText, text, max);\n    var normalized = {\n        start: start + prefixLength,\n        end: end - suffixLength,\n        text: text.slice(prefixLength, text.length - suffixLength)\n    };\n    if (normalized.start === normalized.end && normalized.text.length === 0) {\n        return null;\n    }\n    return normalized;\n}\n/**\r\n * Return a string diff that is equivalent to applying b after a spanning the range of\r\n * both changes\r\n */ function mergeStringDiffs(targetText, a, b) {\n    var start = Math.min(a.start, b.start);\n    var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n    var applied = applyStringDiff(targetText, a, b);\n    var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n    var text = applied.slice(start, sliceEnd);\n    var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n    return normalizeStringDiff(targetText, {\n        start,\n        end,\n        text\n    });\n}\n/**\r\n * Get the slate range the text diff spans.\r\n */ function targetRange(textDiff) {\n    var { path, diff } = textDiff;\n    return {\n        anchor: {\n            path,\n            offset: diff.start\n        },\n        focus: {\n            path,\n            offset: diff.end\n        }\n    };\n}\n/**\r\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\r\n * the pending diffs. Since the pending diffs might have been inserted with different\r\n * marks we have to 'walk' the offset from the starting position to ensure we still\r\n * have a valid point inside the document\r\n */ function normalizePoint(editor, point) {\n    var { path, offset } = point;\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path)) {\n        return null;\n    }\n    var leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(leaf)) {\n        return null;\n    }\n    var parentBlock = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n        match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n),\n        at: path\n    });\n    if (!parentBlock) {\n        return null;\n    }\n    while(offset > leaf.text.length){\n        var entry = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor, {\n            at: path,\n            match: slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText\n        });\n        if (!entry || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.isDescendant(entry[1], parentBlock[1])) {\n            return null;\n        }\n        offset -= leaf.text.length;\n        leaf = entry[0];\n        path = entry[1];\n    }\n    return {\n        path,\n        offset\n    };\n}\n/**\r\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\r\n */ function normalizeRange(editor, range) {\n    var anchor = normalizePoint(editor, range.anchor);\n    if (!anchor) {\n        return null;\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range)) {\n        return {\n            anchor,\n            focus: anchor\n        };\n    }\n    var focus = normalizePoint(editor, range.focus);\n    if (!focus) {\n        return null;\n    }\n    return {\n        anchor,\n        focus\n    };\n}\nfunction transformPendingPoint(editor, point, op) {\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n    var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((_ref)=>{\n        var { path } = _ref;\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(path, point.path);\n    });\n    if (!textDiff || point.offset <= textDiff.diff.start) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(point, op, {\n            affinity: \"backward\"\n        });\n    }\n    var { diff } = textDiff; // Point references location inside the diff => transform the point based on the location\n    // the diff will be applied to and add the offset inside the diff.\n    if (point.offset <= diff.start + diff.text.length) {\n        var _anchor = {\n            path: point.path,\n            offset: diff.start\n        };\n        var _transformed = slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(_anchor, op, {\n            affinity: \"backward\"\n        });\n        if (!_transformed) {\n            return null;\n        }\n        return {\n            path: _transformed.path,\n            offset: _transformed.offset + point.offset - diff.start\n        };\n    } // Point references location after the diff\n    var anchor = {\n        path: point.path,\n        offset: point.offset - diff.text.length + diff.end - diff.start\n    };\n    var transformed = slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(anchor, op, {\n        affinity: \"backward\"\n    });\n    if (!transformed) {\n        return null;\n    }\n    if (op.type === \"split_node\" && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n        return transformed;\n    }\n    return {\n        path: transformed.path,\n        offset: transformed.offset + diff.text.length - diff.end + diff.start\n    };\n}\nfunction transformPendingRange(editor, range, op) {\n    var anchor = transformPendingPoint(editor, range.anchor, op);\n    if (!anchor) {\n        return null;\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range)) {\n        return {\n            anchor,\n            focus: anchor\n        };\n    }\n    var focus = transformPendingPoint(editor, range.focus, op);\n    if (!focus) {\n        return null;\n    }\n    return {\n        anchor,\n        focus\n    };\n}\nfunction transformTextDiff(textDiff, op) {\n    var { path, diff, id } = textDiff;\n    switch(op.type){\n        case \"insert_text\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.offset >= diff.end) {\n                    return textDiff;\n                }\n                if (op.offset <= diff.start) {\n                    return {\n                        diff: {\n                            start: op.text.length + diff.start,\n                            end: op.text.length + diff.end,\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start,\n                        end: diff.end + op.text.length,\n                        text: diff.text\n                    },\n                    id,\n                    path\n                };\n            }\n        case \"remove_text\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.offset >= diff.end) {\n                    return textDiff;\n                }\n                if (op.offset + op.text.length <= diff.start) {\n                    return {\n                        diff: {\n                            start: diff.start - op.text.length,\n                            end: diff.end - op.text.length,\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start,\n                        end: diff.end - op.text.length,\n                        text: diff.text\n                    },\n                    id,\n                    path\n                };\n            }\n        case \"split_node\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.position >= diff.end) {\n                    return {\n                        diff,\n                        id,\n                        path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op, {\n                            affinity: \"backward\"\n                        })\n                    };\n                }\n                if (op.position > diff.start) {\n                    return {\n                        diff: {\n                            start: diff.start,\n                            end: Math.min(op.position, diff.end),\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start - op.position,\n                        end: diff.end - op.position,\n                        text: diff.text\n                    },\n                    id,\n                    path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op, {\n                        affinity: \"forward\"\n                    })\n                };\n            }\n        case \"merge_node\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path)) {\n                    return {\n                        diff,\n                        id,\n                        path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op)\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start + op.position,\n                        end: diff.end + op.position,\n                        text: diff.text\n                    },\n                    id,\n                    path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op)\n                };\n            }\n    }\n    var newPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op);\n    if (!newPath) {\n        return null;\n    }\n    return {\n        diff,\n        path: newPath,\n        id\n    };\n}\nfunction ownKeys$3(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$3(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$3(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\nvar RESOLVE_DELAY = 25; // Time with no user interaction before the current user action is considered as done.\nvar FLUSH_DELAY = 200; // Replace with `const debug = console.log` to debug\nvar debug = function debug() {}; // Type guard to check if a value is a DataTransfer\nvar isDataTransfer = (value)=>(value === null || value === void 0 ? void 0 : value.constructor.name) === \"DataTransfer\";\nfunction createAndroidInputManager(_ref) {\n    var { editor, scheduleOnDOMSelectionChange, onDOMSelectionChange } = _ref;\n    var flushing = false;\n    var compositionEndTimeoutId = null;\n    var flushTimeoutId = null;\n    var actionTimeoutId = null;\n    var idCounter = 0;\n    var insertPositionHint = false;\n    var applyPendingSelection = ()=>{\n        var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        if (pendingSelection) {\n            var { selection } = editor;\n            var normalized = normalizeRange(editor, pendingSelection);\n            if (normalized && (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(normalized, selection))) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, normalized);\n            }\n        }\n    };\n    var performAction = ()=>{\n        var action = EDITOR_TO_PENDING_ACTION.get(editor);\n        EDITOR_TO_PENDING_ACTION.delete(editor);\n        if (!action) {\n            return;\n        }\n        if (action.at) {\n            var target = slate__WEBPACK_IMPORTED_MODULE_7__.Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);\n            if (!target) {\n                return;\n            }\n            var _targetRange = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, target);\n            if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, _targetRange)) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, target);\n            }\n        }\n        action.run();\n    };\n    var flush = ()=>{\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        if (actionTimeoutId) {\n            clearTimeout(actionTimeoutId);\n            actionTimeoutId = null;\n        }\n        if (!hasPendingDiffs() && !hasPendingAction()) {\n            applyPendingSelection();\n            return;\n        }\n        if (!flushing) {\n            flushing = true;\n            setTimeout(()=>flushing = false);\n        }\n        if (hasPendingAction()) {\n            flushing = \"action\";\n        }\n        var selectionRef = editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection, {\n            affinity: \"forward\"\n        });\n        EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n        debug(\"flush\", EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));\n        var scheduleSelectionChange = hasPendingDiffs();\n        var diff;\n        while(diff = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]){\n            var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;\n            var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n            if (pendingMarks !== undefined) {\n                EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n                editor.marks = pendingMarks;\n            }\n            if (pendingMarks && insertPositionHint === false) {\n                insertPositionHint = null;\n            }\n            var range = targetRange(diff);\n            if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, range)) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n            }\n            if (diff.diff.text) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, diff.diff.text);\n            } else {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n            } // Remove diff only after we have applied it to account for it when transforming\n            // pending ranges.\n            EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter((_ref2)=>{\n                var { id } = _ref2;\n                return id !== diff.id;\n            }));\n            if (!verifyDiffState(editor, diff)) {\n                scheduleSelectionChange = false;\n                EDITOR_TO_PENDING_ACTION.delete(editor);\n                EDITOR_TO_USER_MARKS.delete(editor);\n                flushing = \"action\"; // Ensure we don't restore the pending user (dom) selection\n                // since the document and dom state do not match.\n                EDITOR_TO_PENDING_SELECTION.delete(editor);\n                scheduleOnDOMSelectionChange.cancel();\n                onDOMSelectionChange.cancel();\n                selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n            }\n        }\n        var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n        if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, editor.selection))) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, selection);\n        }\n        if (hasPendingAction()) {\n            performAction();\n            return;\n        } // COMPAT: The selectionChange event is fired after the action is performed,\n        // so we have to manually schedule it to ensure we don't 'throw away' the selection\n        // while rendering if we have pending changes.\n        if (scheduleSelectionChange) {\n            scheduleOnDOMSelectionChange();\n        }\n        scheduleOnDOMSelectionChange.flush();\n        onDOMSelectionChange.flush();\n        applyPendingSelection();\n        var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n        EDITOR_TO_USER_MARKS.delete(editor);\n        if (userMarks !== undefined) {\n            editor.marks = userMarks;\n            editor.onChange();\n        }\n    };\n    var handleCompositionEnd = (_event)=>{\n        if (compositionEndTimeoutId) {\n            clearTimeout(compositionEndTimeoutId);\n        }\n        compositionEndTimeoutId = setTimeout(()=>{\n            IS_COMPOSING.set(editor, false);\n            flush();\n        }, RESOLVE_DELAY);\n    };\n    var handleCompositionStart = (_event)=>{\n        IS_COMPOSING.set(editor, true);\n        if (compositionEndTimeoutId) {\n            clearTimeout(compositionEndTimeoutId);\n            compositionEndTimeoutId = null;\n        }\n    };\n    var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n        var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n        if (!placeholderElement) {\n            return;\n        }\n        if (hasPendingDiffs() || forceHide) {\n            placeholderElement.style.display = \"none\";\n            return;\n        }\n        placeholderElement.style.removeProperty(\"display\");\n    };\n    var storeDiff = (path, diff)=>{\n        var _EDITOR_TO_PENDING_DI3;\n        var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];\n        EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n        var target = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, path);\n        var idx = pendingDiffs.findIndex((change)=>slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n        if (idx < 0) {\n            var normalized = normalizeStringDiff(target.text, diff);\n            if (normalized) {\n                pendingDiffs.push({\n                    path,\n                    diff,\n                    id: idCounter++\n                });\n            }\n            updatePlaceholderVisibility();\n            return;\n        }\n        var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);\n        if (!merged) {\n            pendingDiffs.splice(idx, 1);\n            updatePlaceholderVisibility();\n            return;\n        }\n        pendingDiffs[idx] = _objectSpread$3(_objectSpread$3({}, pendingDiffs[idx]), {}, {\n            diff: merged\n        });\n    };\n    var scheduleAction = function scheduleAction(run) {\n        var { at } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        insertPositionHint = false;\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        if (hasPendingAction()) {\n            flush();\n        }\n        EDITOR_TO_PENDING_ACTION.set(editor, {\n            at,\n            run\n        }); // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n        // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n        // in this case and thus never actually perform the action.\n        actionTimeoutId = setTimeout(flush);\n    };\n    var handleDOMBeforeInput = (event)=>{\n        var _targetRange2;\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        var { inputType: type } = event;\n        var targetRange = null;\n        var data = event.dataTransfer || event.data || undefined;\n        if (insertPositionHint !== false && type !== \"insertText\" && type !== \"insertCompositionText\") {\n            insertPositionHint = false;\n        }\n        var [nativeTargetRange] = event.getTargetRanges();\n        if (nativeTargetRange) {\n            targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n                exactMatch: false,\n                suppressThrow: true\n            });\n        } // COMPAT: SelectionChange event is fired after the action is performed, so we\n        // have to manually get the selection here to ensure it's up-to-date.\n        var window1 = ReactEditor.getWindow(editor);\n        var domSelection = window1.getSelection();\n        if (!targetRange && domSelection) {\n            nativeTargetRange = domSelection;\n            targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n                exactMatch: false,\n                suppressThrow: true\n            });\n        }\n        targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n        if (!targetRange) {\n            return;\n        } // By default, the input manager tries to store text diffs so that we can\n        // defer flushing them at a later point in time. We don't want to flush\n        // for every input event as this can be expensive. However, there are some\n        // scenarios where we cannot safely store the text diff and must instead\n        // schedule an action to let Slate normalize the editor state.\n        var canStoreDiff = true;\n        if (type.startsWith(\"delete\")) {\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n                var [_start, _end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n                var _leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _start.path);\n                if (_leaf.text.length === _start.offset && _end.offset === 0) {\n                    var next = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor, {\n                        at: _start.path,\n                        match: slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText\n                    });\n                    if (next && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(next[1], _end.path)) {\n                        targetRange = {\n                            anchor: _end,\n                            focus: _end\n                        };\n                    }\n                }\n            }\n            var direction = type.endsWith(\"Backward\") ? \"backward\" : \"forward\";\n            var [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n            var [leaf, path] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.leaf(editor, start.path);\n            var diff = {\n                text: \"\",\n                start: start.offset,\n                end: end.offset\n            };\n            var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n            var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((change)=>slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n            var diffs = relevantPendingDiffs ? [\n                relevantPendingDiffs.diff,\n                diff\n            ] : [\n                diff\n            ];\n            var text = applyStringDiff(leaf.text, ...diffs);\n            if (text.length === 0) {\n                // Text leaf will be removed, so we need to schedule an\n                // action to remove it so that Slate can normalize instead\n                // of storing as a diff\n                canStoreDiff = false;\n            }\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n                if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n                    var point = {\n                        path: targetRange.anchor.path,\n                        offset: start.offset\n                    };\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, point, point);\n                    handleUserSelect(range);\n                    return storeDiff(targetRange.anchor.path, {\n                        text: \"\",\n                        end: end.offset,\n                        start: start.offset\n                    });\n                }\n                return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                        direction\n                    }), {\n                    at: targetRange\n                });\n            }\n        }\n        switch(type){\n            case \"deleteByComposition\":\n            case \"deleteByCut\":\n            case \"deleteByDrag\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteContent\":\n            case \"deleteContentForward\":\n                {\n                    var { anchor } = targetRange;\n                    if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange)) {\n                        var targetNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n                        if (anchor.offset < targetNode.text.length) {\n                            return storeDiff(anchor.path, {\n                                text: \"\",\n                                start: anchor.offset,\n                                end: anchor.offset + 1\n                            });\n                        }\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteContentBackward\":\n                {\n                    var _nativeTargetRange;\n                    var { anchor: _anchor } = targetRange; // If we have a mismatch between the native and slate selection being collapsed\n                    // we are most likely deleting a zero-width placeholder and thus should perform it\n                    // as an action to ensure correct behavior (mostly happens with mark placeholders)\n                    var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n                    if (canStoreDiff && nativeCollapsed && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n                        return storeDiff(_anchor.path, {\n                            text: \"\",\n                            start: _anchor.offset - 1,\n                            end: _anchor.offset\n                        });\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteEntireSoftLine\":\n                {\n                    return scheduleAction(()=>{\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                    }, {\n                        at: targetRange\n                    });\n                }\n            case \"deleteHardLineBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"block\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteSoftLineBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteHardLineForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"block\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteSoftLineForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteWordBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"word\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteWordForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"word\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"insertLineBreak\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"insertParagraph\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"insertCompositionText\":\n            case \"deleteCompositionText\":\n            case \"insertFromComposition\":\n            case \"insertFromDrop\":\n            case \"insertFromPaste\":\n            case \"insertFromYank\":\n            case \"insertReplacementText\":\n            case \"insertText\":\n                {\n                    if (isDataTransfer(data)) {\n                        return scheduleAction(()=>ReactEditor.insertData(editor, data), {\n                            at: targetRange\n                        });\n                    }\n                    var _text = data !== null && data !== void 0 ? data : \"\"; // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n                    // the placeholder itself and thus includes the zero-width space inside edit events.\n                    if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n                        _text = _text.replace(\"\\uFEFF\", \"\");\n                    } // Pastes from the Android clipboard will generate `insertText` events.\n                    // If the copied text contains any newlines, Android will append an\n                    // extra newline to the end of the copied text.\n                    if (type === \"insertText\" && /.*\\n.*\\n$/.test(_text)) {\n                        _text = _text.slice(0, -1);\n                    } // If the text includes a newline, split it at newlines and paste each component\n                    // string, with soft breaks in between each.\n                    if (_text.includes(\"\\n\")) {\n                        return scheduleAction(()=>{\n                            var parts = _text.split(\"\\n\");\n                            parts.forEach((line, i)=>{\n                                if (line) {\n                                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, line);\n                                }\n                                if (i !== parts.length - 1) {\n                                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                                }\n                            });\n                        }, {\n                            at: targetRange\n                        });\n                    }\n                    if (slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n                        var [_start2, _end2] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n                        var _diff = {\n                            start: _start2.offset,\n                            end: _end2.offset,\n                            text: _text\n                        }; // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n                        // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n                        // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n                        // text events are fired with the correct target ranges, only the final 'insertComposition'\n                        // isn't, so we can adjust the target range start offset if we are confident this is the\n                        // swiftkey insert causing the issue.\n                        if (_text && insertPositionHint && type === \"insertCompositionText\") {\n                            var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n                            var diffPosition = _diff.start + _diff.text.search(/\\S|$/);\n                            if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                                _diff.start -= 1;\n                                insertPositionHint = null;\n                                scheduleFlush();\n                            } else {\n                                insertPositionHint = false;\n                            }\n                        } else if (type === \"insertText\") {\n                            if (insertPositionHint === null) {\n                                insertPositionHint = _diff;\n                            } else if (insertPositionHint && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                                insertPositionHint = _objectSpread$3(_objectSpread$3({}, insertPositionHint), {}, {\n                                    text: insertPositionHint.text + _text\n                                });\n                            } else {\n                                insertPositionHint = false;\n                            }\n                        } else {\n                            insertPositionHint = false;\n                        }\n                        if (canStoreDiff) {\n                            storeDiff(_start2.path, _diff);\n                            return;\n                        }\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text), {\n                        at: targetRange\n                    });\n                }\n        }\n    };\n    var hasPendingAction = ()=>{\n        return !!EDITOR_TO_PENDING_ACTION.get(editor);\n    };\n    var hasPendingDiffs = ()=>{\n        var _EDITOR_TO_PENDING_DI4;\n        return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);\n    };\n    var hasPendingChanges = ()=>{\n        return hasPendingAction() || hasPendingDiffs();\n    };\n    var isFlushing = ()=>{\n        return flushing;\n    };\n    var handleUserSelect = (range)=>{\n        EDITOR_TO_PENDING_SELECTION.set(editor, range);\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        var { selection } = editor;\n        if (!range) {\n            return;\n        }\n        var pathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path, range.anchor.path);\n        var parentPathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n        if (pathChanged && insertPositionHint || parentPathChanged) {\n            insertPositionHint = false;\n        }\n        if (pathChanged || hasPendingDiffs()) {\n            flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n        }\n    };\n    var handleInput = ()=>{\n        if (hasPendingAction() || !hasPendingDiffs()) {\n            flush();\n        }\n    };\n    var handleKeyDown = (_)=>{\n        // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n        // directly next to a non-contenteditable element (= the placeholder).\n        // The only event fired soon enough for us to allow hiding the placeholder\n        // without swiftkey picking it up is the keydown event, so we have to hide it\n        // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n        if (!hasPendingDiffs()) {\n            updatePlaceholderVisibility(true);\n            setTimeout(updatePlaceholderVisibility);\n        }\n    };\n    var scheduleFlush = ()=>{\n        if (!hasPendingAction()) {\n            actionTimeoutId = setTimeout(flush);\n        }\n    };\n    var handleDomMutations = (mutations)=>{\n        if (hasPendingDiffs() || hasPendingAction()) {\n            return;\n        }\n        if (mutations.some((mutation)=>isTrackedMutation(editor, mutation, mutations))) {\n            var _EDITOR_TO_FORCE_REND;\n            // Cause a re-render to restore the dom state if we encounter tracked mutations without\n            // a corresponding pending action.\n            (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();\n        }\n    };\n    return {\n        flush,\n        scheduleFlush,\n        hasPendingDiffs,\n        hasPendingAction,\n        hasPendingChanges,\n        isFlushing,\n        handleUserSelect,\n        handleCompositionEnd,\n        handleCompositionStart,\n        handleDOMBeforeInput,\n        handleKeyDown,\n        handleDomMutations,\n        handleInput\n    };\n}\nfunction useIsMounted() {\n    var isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    return isMountedRef.current;\n}\nfunction useMutationObserver(node, callback, options) {\n    var [mutationObserver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(()=>new MutationObserver(callback));\n    useIsomorphicLayoutEffect(()=>{\n        // Discard mutations caused during render phase. This works due to react calling\n        // useLayoutEffect synchronously after the render phase before the next tick.\n        mutationObserver.takeRecords();\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (!node.current) {\n            throw new Error(\"Failed to attach MutationObserver, `node` is undefined\");\n        }\n        mutationObserver.observe(node.current, options);\n        return ()=>mutationObserver.disconnect();\n    }, []);\n}\nvar _excluded$2 = [\n    \"node\"\n];\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar MUTATION_OBSERVER_CONFIG = {\n    subtree: true,\n    childList: true,\n    characterData: true\n};\nfunction useAndroidInputManager(_ref) {\n    var { node } = _ref, options = _objectWithoutProperties(_ref, _excluded$2);\n    if (!IS_ANDROID) {\n        return null;\n    }\n    var editor = useSlateStatic();\n    var isMounted = useIsMounted();\n    var [inputManager] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(()=>createAndroidInputManager(_objectSpread$2({\n            editor\n        }, options)));\n    useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG);\n    EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n    if (isMounted) {\n        inputManager.flush();\n    }\n    return inputManager;\n}\nfunction useTrackUserInput() {\n    var editor = useSlateStatic();\n    var receivedUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    var animationFrameIdRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);\n    var onUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(()=>{\n        if (receivedUserInput.current) {\n            return;\n        }\n        receivedUserInput.current = true;\n        var window1 = ReactEditor.getWindow(editor);\n        window1.cancelAnimationFrame(animationFrameIdRef.current);\n        animationFrameIdRef.current = window1.requestAnimationFrame(()=>{\n            receivedUserInput.current = false;\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>()=>cancelAnimationFrame(animationFrameIdRef.current), []);\n    return {\n        receivedUserInput,\n        onUserInput\n    };\n}\nvar _excluded$1 = [\n    \"autoFocus\",\n    \"decorate\",\n    \"onDOMBeforeInput\",\n    \"placeholder\",\n    \"readOnly\",\n    \"renderElement\",\n    \"renderLeaf\",\n    \"renderPlaceholder\",\n    \"scrollSelectionIntoView\",\n    \"style\",\n    \"as\",\n    \"disableDefaultStyles\"\n], _excluded2 = [\n    \"text\"\n];\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Children = (props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, useChildren(props));\n/**\r\n * Editable.\r\n */ var Editable = (props)=>{\n    var _EDITOR_TO_PLACEHOLDE, _EDITOR_TO_PLACEHOLDE2;\n    var defaultRenderPlaceholder = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultPlaceholder, Object.assign({}, props)), []);\n    var { autoFocus, decorate = defaultDecorate, onDOMBeforeInput: propsOnDOMBeforeInput, placeholder, readOnly = false, renderElement, renderLeaf, renderPlaceholder = defaultRenderPlaceholder, scrollSelectionIntoView = defaultScrollSelectionIntoView, style: userStyle = {}, as: Component = \"div\", disableDefaultStyles = false } = props, attributes = _objectWithoutProperties(props, _excluded$1);\n    var editor = useSlate(); // Rerender editor when composition status changed\n    var [isComposing, setIsComposing] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var deferredOperations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n    var { onUserInput, receivedUserInput } = useTrackUserInput();\n    var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)((s)=>s + 1, 0);\n    EDITOR_TO_FORCE_RENDER.set(editor, forceRender); // Update internal state on each render.\n    IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.\n    var state = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>({\n            isDraggingInternally: false,\n            isUpdatingSelection: false,\n            latestElement: null,\n            hasMarkPlaceholder: false\n        }), []); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n    // needs to be manually focused.\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (ref.current && autoFocus) {\n            ref.current.focus();\n        }\n    }, [\n        autoFocus\n    ]); // Listen on the native `selectionchange` event to be able to update any time\n    // the selection changes. This is required because React's `onSelect` is leaky\n    // and non-standard so it doesn't fire until after a selection has been\n    // released. This causes issues in situations where another change happens\n    // while a selection is being dragged.\n    var onDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default()(()=>{\n        if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n            var root = ReactEditor.findDocumentOrShadowRoot(editor);\n            var { activeElement } = root;\n            var el = ReactEditor.toDOMNode(editor, editor);\n            var domSelection = root.getSelection();\n            if (activeElement === el) {\n                state.latestElement = activeElement;\n                IS_FOCUSED.set(editor, true);\n            } else {\n                IS_FOCUSED.delete(editor);\n            }\n            if (!domSelection) {\n                return slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n            }\n            var { anchorNode, focusNode } = domSelection;\n            var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n            var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);\n            if (anchorNodeSelectable && focusNodeSelectable) {\n                var range = ReactEditor.toSlateRange(editor, domSelection, {\n                    exactMatch: false,\n                    suppressThrow: true\n                });\n                if (range) {\n                    if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                    } else {\n                        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);\n                    }\n                }\n            } // Deselect the editor if the dom selection is not selectable in readonly mode\n            if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n            }\n        }\n    }, 100), [\n        readOnly\n    ]);\n    var scheduleOnDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(onDOMSelectionChange, 0), [\n        onDOMSelectionChange\n    ]);\n    var androidInputManager = useAndroidInputManager({\n        node: ref,\n        onDOMSelectionChange,\n        scheduleOnDOMSelectionChange\n    });\n    useIsomorphicLayoutEffect(()=>{\n        // Update element-related weak maps with the DOM element ref.\n        var window1;\n        if (ref.current && (window1 = getDefaultView(ref.current))) {\n            EDITOR_TO_WINDOW.set(editor, window1);\n            EDITOR_TO_ELEMENT.set(editor, ref.current);\n            NODE_TO_ELEMENT.set(editor, ref.current);\n            ELEMENT_TO_NODE.set(ref.current, editor);\n        } else {\n            NODE_TO_ELEMENT.delete(editor);\n        } // Make sure the DOM selection state is in sync.\n        var { selection } = editor;\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        var domSelection = root.getSelection();\n        if (!domSelection || !ReactEditor.isFocused(editor) || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingAction()) {\n            return;\n        }\n        var setDomSelection = (forceChange)=>{\n            var hasDomSelection = domSelection.type !== \"None\"; // If the DOM selection is properly unset, we're done.\n            if (!selection && !hasDomSelection) {\n                return;\n            } // verify that the dom selection is in the editor\n            var editorElement = EDITOR_TO_ELEMENT.get(editor);\n            var hasDomSelectionInEditor = false;\n            if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {\n                hasDomSelectionInEditor = true;\n            } // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n            if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n                var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n                    exactMatch: true,\n                    // domSelection is not necessarily a valid Slate range\n                    // (e.g. when clicking on contentEditable:false element)\n                    suppressThrow: true\n                });\n                if (slateRange && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(slateRange, selection)) {\n                    var _anchorNode$parentEle;\n                    if (!state.hasMarkPlaceholder) {\n                        return;\n                    } // Ensure selection is inside the mark placeholder\n                    var { anchorNode } = domSelection;\n                    if (anchorNode !== null && anchorNode !== void 0 && (_anchorNode$parentEle = anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute(\"data-slate-mark-placeholder\")) {\n                        return;\n                    }\n                }\n            } // when <Editable/> is being controlled through external value\n            // then its children might just change - DOM responds to it on its own\n            // but Slate's value is not being updated through any operation\n            // and thus it doesn't transform selection on its own\n            if (selection && !ReactEditor.hasRange(editor, selection)) {\n                editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n                    exactMatch: false,\n                    suppressThrow: true\n                });\n                return;\n            } // Otherwise the DOM selection is out of sync, so update it.\n            state.isUpdatingSelection = true;\n            var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n            if (newDomRange) {\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isBackward(selection)) {\n                    domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n                } else {\n                    domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n                }\n                scrollSelectionIntoView(editor, newDomRange);\n            } else {\n                domSelection.removeAllRanges();\n            }\n            return newDomRange;\n        };\n        var newDomRange = setDomSelection();\n        var ensureSelection = (androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.isFlushing()) === \"action\";\n        if (!IS_ANDROID || !ensureSelection) {\n            setTimeout(()=>{\n                // COMPAT: In Firefox, it's not enough to create a range, you also need\n                // to focus the contenteditable element too. (2016/11/16)\n                if (newDomRange && IS_FIREFOX) {\n                    var el = ReactEditor.toDOMNode(editor, editor);\n                    el.focus();\n                }\n                state.isUpdatingSelection = false;\n            });\n            return;\n        }\n        var timeoutId = null;\n        var animationFrameId = requestAnimationFrame(()=>{\n            if (ensureSelection) {\n                var ensureDomSelection = (forceChange)=>{\n                    try {\n                        var el = ReactEditor.toDOMNode(editor, editor);\n                        el.focus();\n                        setDomSelection(forceChange);\n                    } catch (e) {}\n                }; // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n                // This essentially would make setting the slate selection during an update meaningless, so we force it\n                // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n                // visible flicker.\n                ensureDomSelection();\n                timeoutId = setTimeout(()=>{\n                    // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n                    // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n                    // the animation frame to ensure it displays the correct state.\n                    ensureDomSelection(true);\n                    state.isUpdatingSelection = false;\n                });\n            }\n        });\n        return ()=>{\n            cancelAnimationFrame(animationFrameId);\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n        };\n    }); // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n    // is required because React's `beforeinput` is fake and never really attaches\n    // to the real event sadly. (2019/11/01)\n    // https://github.com/facebook/react/issues/11211\n    var onDOMBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n        onUserInput();\n        if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n            var _EDITOR_TO_USER_SELEC;\n            // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n            if (androidInputManager) {\n                return androidInputManager.handleDOMBeforeInput(event);\n            } // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n            // triggering a `beforeinput` expecting the change to be applied to the immediately before\n            // set selection.\n            scheduleOnDOMSelectionChange.flush();\n            onDOMSelectionChange.flush();\n            var { selection } = editor;\n            var { inputType: type } = event;\n            var data = event.dataTransfer || event.data || undefined;\n            var isCompositionChange = type === \"insertCompositionText\" || type === \"deleteCompositionText\"; // COMPAT: use composition change events as a hint to where we should insert\n            // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n            if (isCompositionChange && ReactEditor.isComposing(editor)) {\n                return;\n            }\n            var native = false;\n            if (type === \"insertText\" && selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.\n            // Long-press events (hold a + press 4 = ) to choose a special character otherwise\n            // causes duplicate inserts.\n            event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n            // When there is an inline element, e.g. a link, and you select\n            // right after it (the start of the next node).\n            selection.anchor.offset !== 0) {\n                var _node$parentElement, _window$getComputedSt;\n                native = true; // Skip native if there are marks, as\n                // `insertText` will insert a node, not just text.\n                if (editor.marks) {\n                    native = false;\n                } // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n                // Therefore we don't allow native events to insert text at the end of anchor nodes.\n                var { anchor } = selection;\n                var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);\n                var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest(\"a\");\n                var window1 = ReactEditor.getWindow(editor);\n                if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n                    var _lastText$textContent;\n                    // Find the last text node inside the anchor.\n                    var lastText = window1 === null || window1 === void 0 ? void 0 : window1.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n                    if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n                        native = false;\n                    }\n                } // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n                // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n                if (native && node.parentElement && (window1 === null || window1 === void 0 ? void 0 : (_window$getComputedSt = window1.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === \"pre\") {\n                    var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                        at: anchor.path,\n                        match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n)\n                    });\n                    if (block && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(block[0]).includes(\"\t\")) {\n                        native = false;\n                    }\n                }\n            } // COMPAT: For the deleting forward/backward input types we don't want\n            // to change the selection because it is the range that will be deleted,\n            // and those commands determine that for themselves.\n            if (!type.startsWith(\"delete\") || type.startsWith(\"deleteBy\")) {\n                var [targetRange] = event.getTargetRanges();\n                if (targetRange) {\n                    var range = ReactEditor.toSlateRange(editor, targetRange, {\n                        exactMatch: false,\n                        suppressThrow: false\n                    });\n                    if (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, range)) {\n                        native = false;\n                        var selectionRef = !isCompositionChange && editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection);\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                        if (selectionRef) {\n                            EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n                        }\n                    }\n                }\n            } // Composition change types occur while a user is composing text and can't be\n            // cancelled. Let them through and wait for the composition to end.\n            if (isCompositionChange) {\n                return;\n            }\n            if (!native) {\n                event.preventDefault();\n            } // COMPAT: If the selection is expanded, even if the command seems like\n            // a delete forward/backward command it should delete the selection.\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection) && type.startsWith(\"delete\")) {\n                var direction = type.endsWith(\"Backward\") ? \"backward\" : \"forward\";\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                    direction\n                });\n                return;\n            }\n            switch(type){\n                case \"deleteByComposition\":\n                case \"deleteByCut\":\n                case \"deleteByDrag\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                        break;\n                    }\n                case \"deleteContent\":\n                case \"deleteContentForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n                        break;\n                    }\n                case \"deleteContentBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n                        break;\n                    }\n                case \"deleteEntireSoftLine\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteHardLineBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"block\"\n                        });\n                        break;\n                    }\n                case \"deleteSoftLineBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteHardLineForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"block\"\n                        });\n                        break;\n                    }\n                case \"deleteSoftLineForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteWordBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"word\"\n                        });\n                        break;\n                    }\n                case \"deleteWordForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"word\"\n                        });\n                        break;\n                    }\n                case \"insertLineBreak\":\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                    break;\n                case \"insertParagraph\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n                        break;\n                    }\n                case \"insertFromComposition\":\n                case \"insertFromDrop\":\n                case \"insertFromPaste\":\n                case \"insertFromYank\":\n                case \"insertReplacementText\":\n                case \"insertText\":\n                    {\n                        if (type === \"insertFromComposition\") {\n                            // COMPAT: in Safari, `compositionend` is dispatched after the\n                            // `beforeinput` for \"insertFromComposition\". But if we wait for it\n                            // then we will abort because we're still composing and the selection\n                            // won't be updated properly.\n                            // https://www.w3.org/TR/input-events-2/\n                            if (ReactEditor.isComposing(editor)) {\n                                setIsComposing(false);\n                                IS_COMPOSING.set(editor, false);\n                            }\n                        } // use a weak comparison instead of 'instanceof' to allow\n                        // programmatic access of paste events coming from external windows\n                        // like cypress where cy.window does not work realibly\n                        if ((data === null || data === void 0 ? void 0 : data.constructor.name) === \"DataTransfer\") {\n                            ReactEditor.insertData(editor, data);\n                        } else if (typeof data === \"string\") {\n                            // Only insertText operations use the native functionality, for now.\n                            // Potentially expand to single character deletes, as well.\n                            if (native) {\n                                deferredOperations.current.push(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data));\n                            } else {\n                                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data);\n                            }\n                        }\n                        break;\n                    }\n            } // Restore the actual user section if nothing manually set it.\n            var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n            EDITOR_TO_USER_SELECTION.delete(editor);\n            if (toRestore && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, toRestore))) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, toRestore);\n            }\n        }\n    }, [\n        readOnly,\n        propsOnDOMBeforeInput\n    ]);\n    var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((node)=>{\n        if (node == null) {\n            onDOMSelectionChange.cancel();\n            scheduleOnDOMSelectionChange.cancel();\n            EDITOR_TO_ELEMENT.delete(editor);\n            NODE_TO_ELEMENT.delete(editor);\n            if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n                // @ts-ignore The `beforeinput` event isn't recognized.\n                ref.current.removeEventListener(\"beforeinput\", onDOMBeforeInput);\n            }\n        } else {\n            // Attach a native DOM event handler for `beforeinput` events, because React's\n            // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n            // real `beforeinput` events sadly... (2019/11/04)\n            // https://github.com/facebook/react/issues/11211\n            if (HAS_BEFORE_INPUT_SUPPORT) {\n                // @ts-ignore The `beforeinput` event isn't recognized.\n                node.addEventListener(\"beforeinput\", onDOMBeforeInput);\n            }\n        }\n        ref.current = node;\n    }, [\n        ref,\n        onDOMBeforeInput,\n        onDOMSelectionChange,\n        scheduleOnDOMSelectionChange\n    ]); // Attach a native DOM event handler for `selectionchange`, because React's\n    // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n    // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n    // fire for any change to the selection inside the editor. (2019/11/04)\n    // https://github.com/facebook/react/issues/5785\n    useIsomorphicLayoutEffect(()=>{\n        var window1 = ReactEditor.getWindow(editor);\n        window1.document.addEventListener(\"selectionchange\", scheduleOnDOMSelectionChange);\n        return ()=>{\n            window1.document.removeEventListener(\"selectionchange\", scheduleOnDOMSelectionChange);\n        };\n    }, [\n        scheduleOnDOMSelectionChange\n    ]);\n    var decorations = decorate([\n        editor,\n        []\n    ]);\n    if (placeholder && editor.children.length === 1 && Array.from(slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(editor)).length === 1 && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(editor) === \"\" && !isComposing) {\n        var start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, []);\n        decorations.push({\n            [PLACEHOLDER_SYMBOL]: true,\n            placeholder,\n            anchor: start,\n            focus: start\n        });\n    }\n    var { marks } = editor;\n    state.hasMarkPlaceholder = false;\n    if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && marks) {\n        var { anchor } = editor.selection;\n        var leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n        var rest = _objectWithoutProperties(leaf, _excluded2); // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(leaf, marks, {\n            loose: true\n        })) {\n            state.hasMarkPlaceholder = true;\n            var unset = Object.fromEntries(Object.keys(rest).map((mark)=>[\n                    mark,\n                    null\n                ]));\n            decorations.push(_objectSpread$1(_objectSpread$1(_objectSpread$1({\n                [MARK_PLACEHOLDER_SYMBOL]: true\n            }, unset), marks), {}, {\n                anchor,\n                focus: anchor\n            }));\n        }\n    } // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n    // before we receive the composition end event.\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        setTimeout(()=>{\n            var { selection } = editor;\n            if (selection) {\n                var { anchor: _anchor } = selection;\n                var _text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _anchor.path); // While marks isn't a 'complete' text, we can still use loose Text.equals\n                // here which only compares marks anyway.\n                if (marks && !slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(_text, marks, {\n                    loose: true\n                })) {\n                    EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n                    return;\n                }\n            }\n            EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        });\n    });\n    var placeholderHeight = (_EDITOR_TO_PLACEHOLDE = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor)) === null || _EDITOR_TO_PLACEHOLDE === void 0 ? void 0 : (_EDITOR_TO_PLACEHOLDE2 = _EDITOR_TO_PLACEHOLDE.getBoundingClientRect()) === null || _EDITOR_TO_PLACEHOLDE2 === void 0 ? void 0 : _EDITOR_TO_PLACEHOLDE2.height;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ReadOnlyContext.Provider, {\n        value: readOnly\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DecorateContext.Provider, {\n        value: decorate\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(RestoreDOM, {\n        node: ref,\n        receivedUserInput: receivedUserInput\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Component, Object.assign({\n        role: readOnly ? undefined : \"textbox\",\n        \"aria-multiline\": readOnly ? undefined : true\n    }, attributes, {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n        // have to use hacks to make these replacement-based features work.\n        // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n        // mismatch warning app moves to browser. Pass-through consumer props when\n        // not CAN_USE_DOM (SSR) and default to falsy value\n        spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,\n        autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : \"false\",\n        autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : \"false\",\n        \"data-slate-editor\": true,\n        \"data-slate-node\": \"value\",\n        // explicitly set this\n        contentEditable: !readOnly,\n        // in some cases, a decoration needs access to the range / selection to decorate a text node,\n        // then you will select the whole text node when you select part the of text\n        // this magic zIndex=\"-1\" will fix it\n        zindex: -1,\n        suppressContentEditableWarning: true,\n        ref: callbackRef,\n        style: _objectSpread$1(_objectSpread$1({}, disableDefaultStyles ? {} : _objectSpread$1({\n            // Allow positioning relative to the editable element.\n            position: \"relative\",\n            // Prevent the default outline styles.\n            outline: \"none\",\n            // Preserve adjacent whitespace and new lines.\n            whiteSpace: \"pre-wrap\",\n            // Allow words to break if they are too long.\n            wordWrap: \"break-word\"\n        }, placeholderHeight ? {\n            minHeight: placeholderHeight\n        } : {})), userStyle),\n        onBeforeInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n            // fall back to React's leaky polyfill instead just for it. It\n            // only works for the `insertText` input type.\n            if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n                event.preventDefault();\n                if (!ReactEditor.isComposing(editor)) {\n                    var _text2 = event.data;\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text2);\n                }\n            }\n        }, [\n            readOnly\n        ]),\n        onInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (isEventHandled(event, attributes.onInput)) {\n                return;\n            }\n            if (androidInputManager) {\n                androidInputManager.handleInput();\n                return;\n            } // Flush native operations, as native events will have propogated\n            // and we can correctly compare DOM text values in components\n            // to stop rendering, so that browser functions like autocorrect\n            // and spellcheck work as expected.\n            for (var op of deferredOperations.current){\n                op();\n            }\n            deferredOperations.current = [];\n        }, []),\n        onBlur: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n                return;\n            } // COMPAT: If the current `activeElement` is still the previous\n            // one, this is due to the window being blurred when the tab\n            // itself becomes unfocused, so we want to abort early to allow to\n            // editor to stay focused when the tab becomes focused again.\n            var root = ReactEditor.findDocumentOrShadowRoot(editor);\n            if (state.latestElement === root.activeElement) {\n                return;\n            }\n            var { relatedTarget } = event;\n            var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning\n            // to the editor from an embedded editable element (eg. an <input>\n            // element inside a void node).\n            if (relatedTarget === el) {\n                return;\n            } // COMPAT: The event should be ignored if the focus is moving from\n            // the editor to inside a void node's spacer element.\n            if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute(\"data-slate-spacer\")) {\n                return;\n            } // COMPAT: The event should be ignored if the focus is moving to a\n            // non- editable section of an element that isn't a void node (eg.\n            // a list item of the check list example).\n            if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n                var node = ReactEditor.toSlateNode(editor, relatedTarget);\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isVoid(node)) {\n                    return;\n                }\n            } // COMPAT: Safari doesn't always remove the selection even if the content-\n            // editable element no longer has focus. Refer to:\n            // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n            if (IS_SAFARI) {\n                var domSelection = root.getSelection();\n                domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();\n            }\n            IS_FOCUSED.delete(editor);\n        }, [\n            readOnly,\n            attributes.onBlur\n        ]),\n        onClick: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                var path = ReactEditor.findPath(editor, node); // At this time, the Slate document may be arbitrarily different,\n                // because onClick handlers can change the document before we get here.\n                // Therefore we must check that this path actually exists,\n                // and that it still refers to the same node.\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path) || slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path) !== node) {\n                    return;\n                }\n                if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n                    var blockPath = path;\n                    if (!(slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, node))) {\n                        var _block$;\n                        var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                            match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n),\n                            at: path\n                        });\n                        blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n                    }\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, blockPath);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                    return;\n                }\n                if (readOnly) {\n                    return;\n                }\n                var _start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, path);\n                var end = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, path);\n                var startVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: _start\n                });\n                var endVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: end\n                });\n                if (startVoid && endVoid && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(startVoid[1], endVoid[1])) {\n                    var _range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, _start);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, _range);\n                }\n            }\n        }, [\n            readOnly,\n            attributes.onClick\n        ]),\n        onCompositionEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n                if (ReactEditor.isComposing(editor)) {\n                    setIsComposing(false);\n                    IS_COMPOSING.set(editor, false);\n                }\n                androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionEnd(event);\n                if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {\n                    return;\n                } // COMPAT: In Chrome, `beforeinput` events for compositions\n                // aren't correct and never fire the \"insertFromComposition\"\n                // type that we need. So instead, insert whenever a composition\n                // ends since it will already have been committed to the DOM.\n                if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {\n                    var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n                    EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor); // Ensure we insert text with the marks the user was actually seeing\n                    if (placeholderMarks !== undefined) {\n                        EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n                        editor.marks = placeholderMarks;\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, event.data);\n                    var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n                    EDITOR_TO_USER_MARKS.delete(editor);\n                    if (userMarks !== undefined) {\n                        editor.marks = userMarks;\n                    }\n                }\n            }\n        }, [\n            attributes.onCompositionEnd\n        ]),\n        onCompositionUpdate: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n                if (!ReactEditor.isComposing(editor)) {\n                    setIsComposing(true);\n                    IS_COMPOSING.set(editor, true);\n                }\n            }\n        }, [\n            attributes.onCompositionUpdate\n        ]),\n        onCompositionStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n                androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionStart(event);\n                if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {\n                    return;\n                }\n                setIsComposing(true);\n                var { selection } = editor;\n                if (selection) {\n                    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                        return;\n                    }\n                    var inline = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                        match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isInline(editor, n),\n                        mode: \"highest\"\n                    });\n                    if (inline) {\n                        var [, inlinePath] = inline;\n                        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEnd(editor, selection.anchor, inlinePath)) {\n                            var point = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.after(editor, inlinePath);\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setSelection(editor, {\n                                anchor: point,\n                                focus: point\n                            });\n                        }\n                    }\n                }\n            }\n        }, [\n            attributes.onCompositionStart\n        ]),\n        onCopy: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {\n                event.preventDefault();\n                ReactEditor.setFragmentData(editor, event.clipboardData, \"copy\");\n            }\n        }, [\n            attributes.onCopy\n        ]),\n        onCut: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {\n                event.preventDefault();\n                ReactEditor.setFragmentData(editor, event.clipboardData, \"cut\");\n                var { selection } = editor;\n                if (selection) {\n                    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                    } else {\n                        var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n                        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor);\n                        }\n                    }\n                }\n            }\n        }, [\n            readOnly,\n            attributes.onCut\n        ]),\n        onDragOver: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n                // Only when the target is void, call `preventDefault` to signal\n                // that drops are allowed. Editable content is droppable by\n                // default, and calling `preventDefault` hides the cursor.\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n                    event.preventDefault();\n                }\n            }\n        }, [\n            attributes.onDragOver\n        ]),\n        onDragStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                var path = ReactEditor.findPath(editor, node);\n                var voidMatch = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: path,\n                    voids: true\n                }); // If starting a drag on a void node, make sure it is selected\n                // so that it shows up in the selection's fragment.\n                if (voidMatch) {\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, path);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                }\n                state.isDraggingInternally = true;\n                ReactEditor.setFragmentData(editor, event.dataTransfer, \"drag\");\n            }\n        }, [\n            readOnly,\n            attributes.onDragStart\n        ]),\n        onDrop: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n                event.preventDefault(); // Keep a reference to the dragged range before updating selection\n                var draggedRange = editor.selection; // Find the range where the drop happened\n                var range = ReactEditor.findEventRange(editor, event);\n                var data = event.dataTransfer;\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                if (state.isDraggingInternally) {\n                    if (draggedRange && !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(draggedRange, range) && !slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                        at: range,\n                        voids: true\n                    })) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor, {\n                            at: draggedRange\n                        });\n                    }\n                }\n                ReactEditor.insertData(editor, data); // When dragging from another source into the editor, it's possible\n                // that the current editor does not have focus.\n                if (!ReactEditor.isFocused(editor)) {\n                    ReactEditor.focus(editor);\n                }\n            }\n            state.isDraggingInternally = false;\n        }, [\n            readOnly,\n            attributes.onDrop\n        ]),\n        onDragEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n                attributes.onDragEnd(event);\n            } // When dropping on a different droppable element than the current editor,\n            // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.\n            // Note: `onDragEnd` is only called when `onDrop` is not called\n            state.isDraggingInternally = false;\n        }, [\n            readOnly,\n            attributes.onDragEnd\n        ]),\n        onFocus: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n                var el = ReactEditor.toDOMNode(editor, editor);\n                var root = ReactEditor.findDocumentOrShadowRoot(editor);\n                state.latestElement = root.activeElement; // COMPAT: If the editor has nested editable elements, the focus\n                // can go to them. In Firefox, this must be prevented because it\n                // results in issues with keyboard navigation. (2017/03/30)\n                if (IS_FIREFOX && event.target !== el) {\n                    el.focus();\n                    return;\n                }\n                IS_FOCUSED.set(editor, true);\n            }\n        }, [\n            readOnly,\n            attributes.onFocus\n        ]),\n        onKeyDown: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n                androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleKeyDown(event);\n                var { nativeEvent } = event; // COMPAT: The composition end event isn't fired reliably in all browsers,\n                // so we sometimes might end up stuck in a composition state even though we\n                // aren't composing any more.\n                if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n                    IS_COMPOSING.set(editor, false);\n                    setIsComposing(false);\n                }\n                if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n                    return;\n                }\n                var { selection } = editor;\n                var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n                var isRTL = direction__WEBPACK_IMPORTED_MODULE_0___default()(slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element)) === \"rtl\"; // COMPAT: Since we prevent the default behavior on\n                // `beforeinput` events, the browser doesn't think there's ever\n                // any history stack to undo or redo, so we have to manage these\n                // hotkeys ourselves. (2019/11/06)\n                if (Hotkeys.isRedo(nativeEvent)) {\n                    event.preventDefault();\n                    var maybeHistoryEditor = editor;\n                    if (typeof maybeHistoryEditor.redo === \"function\") {\n                        maybeHistoryEditor.redo();\n                    }\n                    return;\n                }\n                if (Hotkeys.isUndo(nativeEvent)) {\n                    event.preventDefault();\n                    var _maybeHistoryEditor = editor;\n                    if (typeof _maybeHistoryEditor.undo === \"function\") {\n                        _maybeHistoryEditor.undo();\n                    }\n                    return;\n                } // COMPAT: Certain browsers don't handle the selection updates\n                // properly. In Chrome, the selection isn't properly extended.\n                // And in Firefox, the selection isn't properly collapsed.\n                // (2017/10/17)\n                if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        reverse: true\n                    });\n                    return;\n                }\n                if (Hotkeys.isMoveLineForward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\"\n                    });\n                    return;\n                }\n                if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        edge: \"focus\",\n                        reverse: true\n                    });\n                    return;\n                }\n                if (Hotkeys.isExtendLineForward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        edge: \"focus\"\n                    });\n                    return;\n                } // COMPAT: If a void node is selected, or a zero-width text node\n                // adjacent to an inline is selected, we need to handle these\n                // hotkeys manually because browsers won't be able to skip over\n                // the void node with the zero-width space not being an empty\n                // string.\n                if (Hotkeys.isMoveBackward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                            reverse: !isRTL\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"start\"\n                        });\n                    }\n                    return;\n                }\n                if (Hotkeys.isMoveForward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                            reverse: isRTL\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"end\"\n                        });\n                    }\n                    return;\n                }\n                if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"focus\"\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"word\",\n                        reverse: !isRTL\n                    });\n                    return;\n                }\n                if (Hotkeys.isMoveWordForward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"focus\"\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"word\",\n                        reverse: isRTL\n                    });\n                    return;\n                } // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                // fall back to guessing at the input intention for hotkeys.\n                // COMPAT: In iOS, some of these hotkeys are handled in the\n                if (!HAS_BEFORE_INPUT_SUPPORT) {\n                    // We don't have a core behavior for these, but they change the\n                    // DOM if we don't prevent them, so we have to.\n                    if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n                        event.preventDefault();\n                        return;\n                    }\n                    if (Hotkeys.isSoftBreak(nativeEvent)) {\n                        event.preventDefault();\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                        return;\n                    }\n                    if (Hotkeys.isSplitBlock(nativeEvent)) {\n                        event.preventDefault();\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n                        return;\n                    }\n                    if (Hotkeys.isDeleteBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                unit: \"line\"\n                            });\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                                unit: \"line\"\n                            });\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                unit: \"word\"\n                            });\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                                unit: \"word\"\n                            });\n                        }\n                        return;\n                    }\n                } else {\n                    if (IS_CHROME || IS_SAFARI) {\n                        // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n                        // an event when deleting backwards in a selected void inline node\n                        if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                            var currentNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n                            if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(currentNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, currentNode) && (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isInline(editor, currentNode) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, currentNode))) {\n                                event.preventDefault();\n                                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                    unit: \"block\"\n                                });\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }, [\n            readOnly,\n            attributes.onKeyDown\n        ]),\n        onPaste: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n                // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                // fall back to React's `onPaste` here instead.\n                // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n                // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n                // COMPAT: Safari InputEvents generated by pasting won't include\n                // application/x-slate-fragment items, so use the\n                // ClipboardEvent here. (2023/03/15)\n                if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_SAFARI) {\n                    event.preventDefault();\n                    ReactEditor.insertData(editor, event.clipboardData);\n                }\n            }\n        }, [\n            readOnly,\n            attributes.onPaste\n        ])\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Children, {\n        decorations: decorations,\n        node: editor,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: editor.selection\n    })))));\n};\n/**\r\n * The default placeholder element\r\n */ var DefaultPlaceholder = (_ref)=>{\n    var { attributes, children } = _ref;\n    return(/*#__PURE__*/ // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), children, IS_ANDROID && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null)));\n};\n/**\r\n * A default memoized decorate function.\r\n */ var defaultDecorate = ()=>[];\n/**\r\n * A default implement to scroll dom range into view.\r\n */ var defaultScrollSelectionIntoView = (editor, domRange)=>{\n    // This was affecting the selection of multiple blocks and dragging behavior,\n    // so enabled only if the selection has been collapsed.\n    if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection))) {\n        var leafEl = domRange.startContainer.parentElement;\n        leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n        (0,scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(leafEl, {\n            scrollMode: \"if-needed\"\n        }); // @ts-expect-error an unorthodox delete D:\n        delete leafEl.getBoundingClientRect;\n    }\n};\n/**\r\n * Check if an event is overrided by a handler.\r\n */ var isEventHandled = (event, handler)=>{\n    if (!handler) {\n        return false;\n    } // The custom event handler may return a boolean to specify whether the event\n    // shall be treated as being handled or not.\n    var shouldTreatEventAsHandled = handler(event);\n    if (shouldTreatEventAsHandled != null) {\n        return shouldTreatEventAsHandled;\n    }\n    return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\r\n * Check if a DOM event is overrided by a handler.\r\n */ var isDOMEventHandled = (event, handler)=>{\n    if (!handler) {\n        return false;\n    } // The custom event handler may return a boolean to specify whether the event\n    // shall be treated as being handled or not.\n    var shouldTreatEventAsHandled = handler(event);\n    if (shouldTreatEventAsHandled != null) {\n        return shouldTreatEventAsHandled;\n    }\n    return event.defaultPrevented;\n};\n/**\r\n * A React context for sharing the `focused` state of the editor.\r\n */ var FocusedContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `focused` state of the editor.\r\n */ var useFocused = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(FocusedContext);\n};\nfunction isError(error) {\n    return error instanceof Error;\n}\n/**\r\n * A React context for sharing the editor selector context in a way to control rerenders\r\n */ var SlateSelectorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\nvar refEquality = (a, b)=>a === b;\n/**\r\n * use redux style selectors to prevent rerendering on every keystroke.\r\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\r\n *\r\n * Example:\r\n * ```\r\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\r\n * ```\r\n */ function useSlateSelector(selector) {\n    var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n    var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)((s)=>s + 1, 0);\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateSelectorContext);\n    if (!context) {\n        throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n    }\n    var { getSlate, addEventListener } = context;\n    var latestSubscriptionCallbackError = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    var latestSelector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(()=>null);\n    var latestSelectedState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var selectedState;\n    try {\n        if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n            selectedState = selector(getSlate());\n        } else {\n            selectedState = latestSelectedState.current;\n        }\n    } catch (err) {\n        if (latestSubscriptionCallbackError.current && isError(err)) {\n            err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n        }\n        throw err;\n    }\n    useIsomorphicLayoutEffect(()=>{\n        latestSelector.current = selector;\n        latestSelectedState.current = selectedState;\n        latestSubscriptionCallbackError.current = undefined;\n    });\n    useIsomorphicLayoutEffect(()=>{\n        function checkForUpdates() {\n            try {\n                var newSelectedState = latestSelector.current(getSlate());\n                if (equalityFn(newSelectedState, latestSelectedState.current)) {\n                    return;\n                }\n                latestSelectedState.current = newSelectedState;\n            } catch (err) {\n                // we ignore all errors here, since when the component\n                // is re-rendered, the selectors are called again, and\n                // will throw again, if neither props nor store state\n                // changed\n                latestSubscriptionCallbackError.current = err;\n            }\n            forceRender();\n        }\n        var unsubscribe = addEventListener(checkForUpdates);\n        checkForUpdates();\n        return ()=>unsubscribe();\n    }, [\n        addEventListener,\n        getSlate\n    ]);\n    return selectedState;\n}\n/**\r\n * Create selector context with editor updating on every editor change\r\n */ function getSelectorContext(editor) {\n    var eventListeners = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]).current;\n    var slateRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)({\n        editor\n    }).current;\n    var onChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((editor)=>{\n        slateRef.editor = editor;\n        eventListeners.forEach((listener)=>listener(editor));\n    }, []);\n    var selectorContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>{\n        return {\n            getSlate: ()=>slateRef.editor,\n            addEventListener: (callback)=>{\n                eventListeners.push(callback);\n                return ()=>{\n                    eventListeners.splice(eventListeners.indexOf(callback), 1);\n                };\n            }\n        };\n    }, [\n        eventListeners,\n        slateRef\n    ]);\n    return {\n        selectorContext,\n        onChange\n    };\n}\nvar _excluded = [\n    \"editor\",\n    \"children\",\n    \"onChange\",\n    \"value\"\n];\n/**\r\n * A wrapper around the provider to handle `onChange` events, because the editor\r\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\r\n */ var Slate = (props)=>{\n    var { editor, children, onChange, value } = props, rest = _objectWithoutProperties(props, _excluded);\n    var unmountRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    var [context, setContext] = react__WEBPACK_IMPORTED_MODULE_3___default().useState(()=>{\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Node.isNodeList(value)) {\n            throw new Error(\"[Slate] value is invalid! Expected a list of elements but got: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(value)));\n        }\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(editor)) {\n            throw new Error(\"[Slate] editor is invalid! You passed: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(editor)));\n        }\n        editor.children = value;\n        Object.assign(editor, rest);\n        return {\n            v: 0,\n            editor\n        };\n    });\n    var { selectorContext, onChange: handleSelectorChange } = getSelectorContext(editor);\n    var onContextChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(()=>{\n        if (onChange) {\n            onChange(editor.children);\n        }\n        setContext((prevContext)=>({\n                v: prevContext.v + 1,\n                editor\n            }));\n        handleSelectorChange(editor);\n    }, [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n        return ()=>{\n            EDITOR_TO_ON_CHANGE.set(editor, ()=>{});\n            unmountRef.current = true;\n        };\n    }, [\n        onContextChange\n    ]);\n    var [isFocused, setIsFocused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(ReactEditor.isFocused(editor));\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        setIsFocused(ReactEditor.isFocused(editor));\n    });\n    useIsomorphicLayoutEffect(()=>{\n        var fn = ()=>setIsFocused(ReactEditor.isFocused(editor));\n        if (IS_REACT_VERSION_17_OR_ABOVE) {\n            // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n            // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n            // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n            document.addEventListener(\"focusin\", fn);\n            document.addEventListener(\"focusout\", fn);\n            return ()=>{\n                document.removeEventListener(\"focusin\", fn);\n                document.removeEventListener(\"focusout\", fn);\n            };\n        } else {\n            document.addEventListener(\"focus\", fn, true);\n            document.addEventListener(\"blur\", fn, true);\n            return ()=>{\n                document.removeEventListener(\"focus\", fn, true);\n                document.removeEventListener(\"blur\", fn, true);\n            };\n        }\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateSelectorContext.Provider, {\n        value: selectorContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateContext.Provider, {\n        value: context\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(EditorContext.Provider, {\n        value: context.editor\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(FocusedContext.Provider, {\n        value: isFocused\n    }, children))));\n};\n/**\r\n * Get the current editor object from the React context.\r\n * @deprecated Use useSlateStatic instead.\r\n */ var useEditor = ()=>{\n    var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n    if (!editor) {\n        throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n    }\n    return editor;\n};\n/**\r\n * Get the current slate selection.\r\n * Only triggers a rerender when the selection actually changes\r\n */ var useSlateSelection = ()=>{\n    return useSlateSelector((editor)=>editor.selection, isSelectionEqual);\n};\nvar isSelectionEqual = (a, b)=>{\n    if (!a && !b) return true;\n    if (!a || !b) return false;\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(a, b);\n};\n/**\r\n * Utilities for single-line deletion\r\n */ var doRectsIntersect = (rect, compareRect)=>{\n    var middle = (compareRect.top + compareRect.bottom) / 2;\n    return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = (editor, range1, range2)=>{\n    var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();\n    var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();\n    return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\r\n * A helper utility that returns the end portion of a `Range`\r\n * which is located on a single line.\r\n *\r\n * @param {Editor} editor The editor object to compare against\r\n * @param {Range} parentRange The parent range to compare against\r\n * @returns {Range} A valid portion of the parentRange which is one a single line\r\n */ var findCurrentLineRange = (editor, parentRange)=>{\n    var parentRangeBoundary = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Range.end(parentRange));\n    var positions = Array.from(slate__WEBPACK_IMPORTED_MODULE_7__.Editor.positions(editor, {\n        at: parentRange\n    }));\n    var left = 0;\n    var right = positions.length;\n    var middle = Math.floor(right / 2);\n    if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[left]), parentRangeBoundary)) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[left], parentRangeBoundary);\n    }\n    if (positions.length < 2) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n    }\n    while(middle !== positions.length && middle !== left){\n        if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n            right = middle;\n        } else {\n            left = middle;\n        }\n        middle = Math.floor((left + right) / 2);\n    }\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[right], parentRangeBoundary);\n};\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * `withReact` adds React and DOM specific behaviors to the editor.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */ var withReact = function withReact(editor) {\n    var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"x-slate-fragment\";\n    var e = editor;\n    var { apply, onChange, deleteBackward, addMark, removeMark } = e; // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n    // avoid collisions between editors in the DOM that share the same value.\n    EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n    e.addMark = (key, value)=>{\n        var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n            // Ensure the current pending diffs originating from changes before the addMark\n            // are applied with the current formatting\n            EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n        }\n        EDITOR_TO_USER_MARKS.delete(e);\n        addMark(key, value);\n    };\n    e.removeMark = (key)=>{\n        var _EDITOR_TO_PENDING_DI2;\n        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n            // Ensure the current pending diffs originating from changes before the addMark\n            // are applied with the current formatting\n            EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n        }\n        EDITOR_TO_USER_MARKS.delete(e);\n        removeMark(key);\n    };\n    e.deleteBackward = (unit)=>{\n        if (unit !== \"line\") {\n            return deleteBackward(unit);\n        }\n        if (e.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(e.selection)) {\n            var parentBlockEntry = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(e, {\n                match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(e, n),\n                at: e.selection\n            });\n            if (parentBlockEntry) {\n                var [, parentBlockPath] = parentBlockEntry;\n                var parentElementRange = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(e, parentBlockPath, e.selection.anchor);\n                var currentLineRange = findCurrentLineRange(e, parentElementRange);\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(currentLineRange)) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(e, {\n                        at: currentLineRange\n                    });\n                }\n            }\n        }\n    }; // This attempts to reset the NODE_TO_KEY entry to the correct value\n    // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n    e.apply = (op)=>{\n        var matches = [];\n        var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n        if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n            var transformed = pendingDiffs.map((textDiff)=>transformTextDiff(textDiff, op)).filter(Boolean);\n            EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n        }\n        var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n        if (pendingSelection) {\n            EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n        }\n        var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n        if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n            var at = slate__WEBPACK_IMPORTED_MODULE_7__.Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n            EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n                at\n            }) : null);\n        }\n        switch(op.type){\n            case \"insert_text\":\n            case \"remove_text\":\n            case \"set_node\":\n            case \"split_node\":\n                {\n                    matches.push(...getMatches(e, op.path));\n                    break;\n                }\n            case \"set_selection\":\n                {\n                    var _EDITOR_TO_USER_SELEC;\n                    // Selection was manually set, don't restore the user selection after the change.\n                    (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n                    EDITOR_TO_USER_SELECTION.delete(e);\n                    break;\n                }\n            case \"insert_node\":\n            case \"remove_node\":\n                {\n                    matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.path)));\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var prevPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.previous(op.path);\n                    matches.push(...getMatches(e, prevPath));\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var commonPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.common(slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.path), slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.newPath));\n                    matches.push(...getMatches(e, commonPath));\n                    break;\n                }\n        }\n        apply(op);\n        for (var [path, key] of matches){\n            var [node] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.node(e, path);\n            NODE_TO_KEY.set(node, key);\n        }\n    };\n    e.setFragmentData = (data)=>{\n        var { selection } = e;\n        if (!selection) {\n            return;\n        }\n        var [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(selection);\n        var startVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(e, {\n            at: start.path\n        });\n        var endVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(e, {\n            at: end.path\n        });\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection) && !startVoid) {\n            return;\n        } // Create a fake selection so that we can add a Base64-encoded copy of the\n        // fragment to the HTML, to decode on future pastes.\n        var domRange = ReactEditor.toDOMRange(e, selection);\n        var contents = domRange.cloneContents();\n        var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.\n        contents.childNodes.forEach((node)=>{\n            if (node.textContent && node.textContent.trim() !== \"\") {\n                attach = node;\n            }\n        }); // COMPAT: If the end node is a void node, we need to move the end of the\n        // range from the void node's spacer span, to the end of the void node's\n        // content, since the spacer is before void's content in the DOM.\n        if (endVoid) {\n            var [voidNode] = endVoid;\n            var r = domRange.cloneRange();\n            var domNode = ReactEditor.toDOMNode(e, voidNode);\n            r.setEndAfter(domNode);\n            contents = r.cloneContents();\n        } // COMPAT: If the start node is a void node, we need to attach the encoded\n        // fragment to the void node's content node instead of the spacer, because\n        // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n        // most browsers. (2018/04/27)\n        if (startVoid) {\n            attach = contents.querySelector(\"[data-slate-spacer]\");\n        } // Remove any zero-width space spans from the cloned DOM so that they don't\n        // show up elsewhere when pasted.\n        Array.from(contents.querySelectorAll(\"[data-slate-zero-width]\")).forEach((zw)=>{\n            var isNewline = zw.getAttribute(\"data-slate-zero-width\") === \"n\";\n            zw.textContent = isNewline ? \"\\n\" : \"\";\n        }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n        // in the HTML, and can be used for intra-Slate pasting. If it's a text\n        // node, wrap it in a `<span>` so we have something to set an attribute on.\n        if (isDOMText(attach)) {\n            var span = attach.ownerDocument.createElement(\"span\"); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n            // then leading and trailing spaces will be ignored. (2017/09/21)\n            span.style.whiteSpace = \"pre\";\n            span.appendChild(attach);\n            contents.appendChild(span);\n            attach = span;\n        }\n        var fragment = e.getFragment();\n        var string = JSON.stringify(fragment);\n        var encoded = window.btoa(encodeURIComponent(string));\n        attach.setAttribute(\"data-slate-fragment\", encoded);\n        data.setData(\"application/\".concat(clipboardFormatKey), encoded); // Add the content to a <div> so that we can get its inner HTML.\n        var div = contents.ownerDocument.createElement(\"div\");\n        div.appendChild(contents);\n        div.setAttribute(\"hidden\", \"true\");\n        contents.ownerDocument.body.appendChild(div);\n        data.setData(\"text/html\", div.innerHTML);\n        data.setData(\"text/plain\", getPlainText(div));\n        contents.ownerDocument.body.removeChild(div);\n        return data;\n    };\n    e.insertData = (data)=>{\n        if (!e.insertFragmentData(data)) {\n            e.insertTextData(data);\n        }\n    };\n    e.insertFragmentData = (data)=>{\n        /**\r\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\r\n     */ var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n        if (fragment) {\n            var decoded = decodeURIComponent(window.atob(fragment));\n            var parsed = JSON.parse(decoded);\n            e.insertFragment(parsed);\n            return true;\n        }\n        return false;\n    };\n    e.insertTextData = (data)=>{\n        var text = data.getData(\"text/plain\");\n        if (text) {\n            var lines = text.split(/\\r\\n|\\r|\\n/);\n            var split = false;\n            for (var line of lines){\n                if (split) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.splitNodes(e, {\n                        always: true\n                    });\n                }\n                e.insertText(line);\n                split = true;\n            }\n            return true;\n        }\n        return false;\n    };\n    e.onChange = (options)=>{\n        // COMPAT: React doesn't batch `setState` hook calls, which means that the\n        // children and selection can get out of sync for one render pass. So we\n        // have to use this unstable API to ensure it batches them. (2019/12/03)\n        // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n        react_dom__WEBPACK_IMPORTED_MODULE_6___default().unstable_batchedUpdates(()=>{\n            var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n            if (onContextChange) {\n                onContextChange();\n            }\n            onChange(options);\n        });\n    };\n    return e;\n};\nvar getMatches = (e, path)=>{\n    var matches = [];\n    for (var [n, p] of slate__WEBPACK_IMPORTED_MODULE_7__.Editor.levels(e, {\n        at: path\n    })){\n        var key = ReactEditor.findKey(e, n);\n        matches.push([\n            p,\n            key\n        ]);\n    }\n    return matches;\n};\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3QvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDRTtBQUNBO0FBQytIO0FBQzlHO0FBQzZEO0FBQzVEO0FBQ2pCO0FBQ1A7QUFFakMsU0FBUytCLGdCQUFnQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEtBQUs7SUFDdEMsSUFBSUQsT0FBT0QsS0FBSztRQUNkRyxPQUFPQyxjQUFjLENBQUNKLEtBQUtDLEtBQUs7WUFDOUJDLE9BQU9BO1lBQ1BHLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ1o7SUFDRixPQUFPO1FBQ0xQLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztJQUNiO0lBRUEsT0FBT0Y7QUFDVDtBQUVBLFNBQVNRLDhCQUE4QkMsTUFBTSxFQUFFQyxRQUFRO0lBQ3JELElBQUlELFVBQVUsTUFBTSxPQUFPLENBQUM7SUFDNUIsSUFBSUUsU0FBUyxDQUFDO0lBQ2QsSUFBSUMsYUFBYVQsT0FBT1UsSUFBSSxDQUFDSjtJQUM3QixJQUFJUixLQUFLYTtJQUVULElBQUtBLElBQUksR0FBR0EsSUFBSUYsV0FBV0csTUFBTSxFQUFFRCxJQUFLO1FBQ3RDYixNQUFNVyxVQUFVLENBQUNFLEVBQUU7UUFDbkIsSUFBSUosU0FBU00sT0FBTyxDQUFDZixRQUFRLEdBQUc7UUFDaENVLE1BQU0sQ0FBQ1YsSUFBSSxHQUFHUSxNQUFNLENBQUNSLElBQUk7SUFDM0I7SUFFQSxPQUFPVTtBQUNUO0FBRUEsU0FBU00seUJBQXlCUixNQUFNLEVBQUVDLFFBQVE7SUFDaEQsSUFBSUQsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUM1QixJQUFJRSxTQUFTSCw4QkFBOEJDLFFBQVFDO0lBQ25ELElBQUlULEtBQUthO0lBRVQsSUFBSVgsT0FBT2UscUJBQXFCLEVBQUU7UUFDaEMsSUFBSUMsbUJBQW1CaEIsT0FBT2UscUJBQXFCLENBQUNUO1FBRXBE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QUFnQyxDQUFDO1lBQy9CLElBQUkwekIsa0JBQWtCOXdCLG9CQUFvQjZHLEdBQUcsQ0FBQ3NqQjtZQUU5QyxJQUFJMkcsaUJBQWlCO2dCQUNuQkE7WUFDRjtZQUVBM04sU0FBUzFhO1FBQ1g7SUFDRjtJQUVBLE9BQU8waEI7QUFDVDtBQUVBLElBQUk2SSxhQUFhLENBQUM3SSxHQUFHampCO0lBQ25CLElBQUk1QyxVQUFVLEVBQUU7SUFFaEIsS0FBSyxJQUFJLENBQUN6RixHQUFHdVcsRUFBRSxJQUFJN1kseUNBQU1BLENBQUMwNEIsTUFBTSxDQUFDOUssR0FBRztRQUNsQ3JnQixJQUFJNUM7SUFDTixHQUFJO1FBQ0YsSUFBSTNKLE1BQU1pSCxZQUFZdUMsT0FBTyxDQUFDb2pCLEdBQUd0ckI7UUFDakN5RixRQUFRd1EsSUFBSSxDQUFDO1lBQUNNO1lBQUc3WDtTQUFJO0lBQ3ZCO0lBRUEsT0FBTytHO0FBQ1Q7QUFFbU8sQ0FDbk8sb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGtleXN0YXRpYy90ZW1wbGF0ZXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3NsYXRlLXJlYWN0L2Rpc3QvaW5kZXguZXMuanM/NGUyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0RGlyZWN0aW9uIGZyb20gJ2RpcmVjdGlvbic7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoL2RlYm91bmNlJztcbmltcG9ydCB0aHJvdHRsZSBmcm9tICdsb2Rhc2gvdGhyb3R0bGUnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCBtZW1vLCBmb3J3YXJkUmVmLCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VDYWxsYmFjaywgQ29tcG9uZW50LCB1c2VSZWR1Y2VyLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHNjcm9sbEludG9WaWV3IGZyb20gJ3Njcm9sbC1pbnRvLXZpZXctaWYtbmVlZGVkJztcbmltcG9ydCB7IEVkaXRvciwgU2NydWJiZXIsIFRyYW5zZm9ybXMsIFJhbmdlLCBFbGVtZW50IGFzIEVsZW1lbnQkMSwgUGF0aCwgTm9kZSwgVGV4dCBhcyBUZXh0JDEsIFBvaW50IH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXIgfSBmcm9tICdAanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlcic7XG5pbXBvcnQgeyBpc0tleUhvdGtleSB9IGZyb20gJ2lzLWhvdGtleSc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcclxuICogQW4gYXV0by1pbmNyZW1lbnRpbmcgaWRlbnRpZmllciBmb3Iga2V5cy5cclxuICovXG52YXIgbiA9IDA7XG4vKipcclxuICogQSBjbGFzcyB0aGF0IGtlZXBzIHRyYWNrIG9mIGEga2V5IHN0cmluZy4gV2UgdXNlIGEgZnVsbCBjbGFzcyBoZXJlIGJlY2F1c2Ugd2VcclxuICogd2FudCB0byBiZSBhYmxlIHRvIHVzZSB0aGVtIGFzIGtleXMgaW4gYFdlYWtNYXBgIG9iamVjdHMuXHJcbiAqL1xuXG5jbGFzcyBLZXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gXCJcIi5jb25jYXQobisrKTtcbiAgfVxuXG59XG5cbi8qKlxyXG4gKiBUd28gd2VhayBtYXBzIHRoYXQgYWxsb3cgdXMgcmVidWlsZCBhIHBhdGggZ2l2ZW4gYSBub2RlLiBUaGV5IGFyZSBwb3B1bGF0ZWRcclxuICogYXQgcmVuZGVyIHRpbWUgc3VjaCB0aGF0IGFmdGVyIGEgcmVuZGVyIG9jY3VycyB3ZSBjYW4gYWx3YXlzIGJhY2t0cmFjay5cclxuICovXG52YXIgTk9ERV9UT19JTkRFWCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19QQVJFTlQgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFdlYWsgbWFwcyB0aGF0IGFsbG93IHVzIHRvIGdvIGJldHdlZW4gU2xhdGUgbm9kZXMgYW5kIERPTSBub2Rlcy4gVGhlc2VcclxuICogYXJlIHVzZWQgdG8gcmVzb2x2ZSBET00gZXZlbnQtcmVsYXRlZCBsb2dpYyBpbnRvIFNsYXRlIGFjdGlvbnMuXHJcbiAqL1xuXG52YXIgRURJVE9SX1RPX1dJTkRPVyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFTEVNRU5UX1RPX05PREUgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19LRVkgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogV2VhayBtYXBzIGZvciBzdG9yaW5nIGVkaXRvci1yZWxhdGVkIHN0YXRlLlxyXG4gKi9cblxudmFyIElTX1JFQURfT05MWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgSVNfRk9DVVNFRCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgSVNfQ09NUE9TSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFdlYWsgbWFwIGZvciBhc3NvY2lhdGluZyB0aGUgY29udGV4dCBgb25DaGFuZ2VgIGNvbnRleHQgd2l0aCB0aGUgcGx1Z2luLlxyXG4gKi9cblxudmFyIEVESVRPUl9UT19PTl9DSEFOR0UgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFdlYWsgbWFwcyBmb3Igc2F2aW5nIHBlbmRpbmcgc3RhdGUgb24gY29tcG9zaXRpb24gc3RhZ2UuXHJcbiAqL1xuXG52YXIgRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNIID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19VU0VSX01BUktTID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBBbmRyb2lkIGlucHV0IGhhbmRsaW5nIHNwZWNpZmljIHdlYWstbWFwc1xyXG4gKi9cblxudmFyIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19BQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTiA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0ZPUkNFX1JFTkRFUiA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogU3ltYm9scy5cclxuICovXG5cbnZhciBQTEFDRUhPTERFUl9TWU1CT0wgPSBTeW1ib2woJ3BsYWNlaG9sZGVyJyk7XG52YXIgTUFSS19QTEFDRUhPTERFUl9TWU1CT0wgPSBTeW1ib2woJ21hcmstcGxhY2Vob2xkZXInKTtcblxuLyoqXHJcbiAqIFR5cGVzLlxyXG4gKi9cbnZhciBET01UZXh0ID0gZ2xvYmFsVGhpcy5UZXh0O1xuLyoqXHJcbiAqIFJldHVybnMgdGhlIGhvc3Qgd2luZG93IG9mIGEgRE9NIG5vZGVcclxuICovXG5cbnZhciBnZXREZWZhdWx0VmlldyA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm93bmVyRG9jdW1lbnQgJiYgdmFsdWUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCBudWxsO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGEgY29tbWVudCBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NQ29tbWVudCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDg7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gZWxlbWVudCBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NRWxlbWVudCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBET00gbm9kZS5cclxuICovXG5cbnZhciBpc0RPTU5vZGUgPSB2YWx1ZSA9PiB7XG4gIHZhciB3aW5kb3cgPSBnZXREZWZhdWx0Vmlldyh2YWx1ZSk7XG4gIHJldHVybiAhIXdpbmRvdyAmJiB2YWx1ZSBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgRE9NIHNlbGVjdGlvbi5cclxuICovXG5cbnZhciBpc0RPTVNlbGVjdGlvbiA9IHZhbHVlID0+IHtcbiAgdmFyIHdpbmRvdyA9IHZhbHVlICYmIHZhbHVlLmFuY2hvck5vZGUgJiYgZ2V0RGVmYXVsdFZpZXcodmFsdWUuYW5jaG9yTm9kZSk7XG4gIHJldHVybiAhIXdpbmRvdyAmJiB2YWx1ZSBpbnN0YW5jZW9mIHdpbmRvdy5TZWxlY3Rpb247XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gZWxlbWVudCBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NVGV4dCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDM7XG59O1xuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIGEgcGFzdGUgZXZlbnQgaXMgYSBwbGFpbnRleHQtb25seSBldmVudC5cclxuICovXG5cbnZhciBpc1BsYWluVGV4dE9ubHlQYXN0ZSA9IGV2ZW50ID0+IHtcbiAgcmV0dXJuIGV2ZW50LmNsaXBib2FyZERhdGEgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJykgIT09ICcnICYmIGV2ZW50LmNsaXBib2FyZERhdGEudHlwZXMubGVuZ3RoID09PSAxO1xufTtcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSBET00gcG9pbnQgc28gdGhhdCBpdCBhbHdheXMgcmVmZXJzIHRvIGEgdGV4dCBub2RlLlxyXG4gKi9cblxudmFyIG5vcm1hbGl6ZURPTVBvaW50ID0gZG9tUG9pbnQgPT4ge1xuICB2YXIgW25vZGUsIG9mZnNldF0gPSBkb21Qb2ludDsgLy8gSWYgaXQncyBhbiBlbGVtZW50IG5vZGUsIGl0cyBvZmZzZXQgcmVmZXJzIHRvIHRoZSBpbmRleCBvZiBpdHMgY2hpbGRyZW5cbiAgLy8gaW5jbHVkaW5nIGNvbW1lbnQgbm9kZXMsIHNvIHRyeSB0byBmaW5kIHRoZSByaWdodCB0ZXh0IGNoaWxkIG5vZGUuXG5cbiAgaWYgKGlzRE9NRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgdmFyIGlzTGFzdCA9IG9mZnNldCA9PT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSBpc0xhc3QgPyBvZmZzZXQgLSAxIDogb2Zmc2V0O1xuICAgIFtub2RlLCBpbmRleF0gPSBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgobm9kZSwgaW5kZXgsIGlzTGFzdCA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCcpOyAvLyBJZiB0aGUgZWRpdGFibGUgY2hpbGQgZm91bmQgaXMgaW4gZnJvbnQgb2YgaW5wdXQgb2Zmc2V0LCB3ZSBpbnN0ZWFkIHNlZWsgdG8gaXRzIGVuZFxuXG4gICAgaXNMYXN0ID0gaW5kZXggPCBvZmZzZXQ7IC8vIElmIHRoZSBub2RlIGhhcyBjaGlsZHJlbiwgdHJhdmVyc2UgdW50aWwgd2UgaGF2ZSBhIGxlYWYgbm9kZS4gTGVhZiBub2Rlc1xuICAgIC8vIGNhbiBiZSBlaXRoZXIgdGV4dCBub2Rlcywgb3Igb3RoZXIgdm9pZCBET00gbm9kZXMuXG5cbiAgICB3aGlsZSAoaXNET01FbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBpID0gaXNMYXN0ID8gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgbm9kZSA9IGdldEVkaXRhYmxlQ2hpbGQobm9kZSwgaSwgaXNMYXN0ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJyk7XG4gICAgfSAvLyBEZXRlcm1pbmUgdGhlIG5ldyBvZmZzZXQgaW5zaWRlIHRoZSB0ZXh0IG5vZGUuXG5cblxuICAgIG9mZnNldCA9IGlzTGFzdCAmJiBub2RlLnRleHRDb250ZW50ICE9IG51bGwgPyBub2RlLnRleHRDb250ZW50Lmxlbmd0aCA6IDA7XG4gIH0gLy8gUmV0dXJuIHRoZSBub2RlIGFuZCBvZmZzZXQuXG5cblxuICByZXR1cm4gW25vZGUsIG9mZnNldF07XG59O1xuLyoqXHJcbiAqIERldGVybWluZXMgd2V0aGVyIHRoZSBhY3RpdmUgZWxlbWVudCBpcyBuZXN0ZWQgd2l0aGluIGEgc2hhZG93Um9vdFxyXG4gKi9cblxudmFyIGhhc1NoYWRvd1Jvb3QgPSBub2RlID0+IHtcbiAgdmFyIHBhcmVudCA9IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlO1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgbmVhcmVzdCBlZGl0YWJsZSBjaGlsZCBhbmQgaW5kZXggYXQgYGluZGV4YCBpbiBhIGBwYXJlbnRgLCBwcmVmZXJyaW5nXHJcbiAqIGBkaXJlY3Rpb25gLlxyXG4gKi9cblxudmFyIGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleCA9IChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZE5vZGVzXG4gIH0gPSBwYXJlbnQ7XG4gIHZhciBjaGlsZCA9IGNoaWxkTm9kZXNbaW5kZXhdO1xuICB2YXIgaSA9IGluZGV4O1xuICB2YXIgdHJpZWRGb3J3YXJkID0gZmFsc2U7XG4gIHZhciB0cmllZEJhY2t3YXJkID0gZmFsc2U7IC8vIFdoaWxlIHRoZSBjaGlsZCBpcyBhIGNvbW1lbnQgbm9kZSwgb3IgYW4gZWxlbWVudCBub2RlIHdpdGggbm8gY2hpbGRyZW4sXG4gIC8vIGtlZXAgaXRlcmF0aW5nIHRvIGZpbmQgYSBzaWJsaW5nIG5vbi12b2lkLCBub24tY29tbWVudCBub2RlLlxuXG4gIHdoaWxlIChpc0RPTUNvbW1lbnQoY2hpbGQpIHx8IGlzRE9NRWxlbWVudChjaGlsZCkgJiYgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnKSB7XG4gICAgaWYgKHRyaWVkRm9yd2FyZCAmJiB0cmllZEJhY2t3YXJkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaSA+PSBjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgdHJpZWRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCAtIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnYmFja3dhcmQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0cmllZEJhY2t3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCArIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkTm9kZXNbaV07XG4gICAgaW5kZXggPSBpO1xuICAgIGkgKz0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyAxIDogLTE7XG4gIH1cblxuICByZXR1cm4gW2NoaWxkLCBpbmRleF07XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgbmVhcmVzdCBlZGl0YWJsZSBjaGlsZCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcclxuICogYGRpcmVjdGlvbmAuXHJcbiAqL1xuXG52YXIgZ2V0RWRpdGFibGVDaGlsZCA9IChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pID0+IHtcbiAgdmFyIFtjaGlsZF0gPSBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgocGFyZW50LCBpbmRleCwgZGlyZWN0aW9uKTtcbiAgcmV0dXJuIGNoaWxkO1xufTtcbi8qKlxyXG4gKiBHZXQgYSBwbGFpbnRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbnRlbnQgb2YgYSBub2RlLCBhY2NvdW50aW5nIGZvciBibG9ja1xyXG4gKiBlbGVtZW50cyB3aGljaCBnZXQgYSBuZXdsaW5lIGFwcGVuZGVkLlxyXG4gKlxyXG4gKiBUaGUgZG9tTm9kZSBtdXN0IGJlIGF0dGFjaGVkIHRvIHRoZSBET00uXHJcbiAqL1xuXG52YXIgZ2V0UGxhaW5UZXh0ID0gZG9tTm9kZSA9PiB7XG4gIHZhciB0ZXh0ID0gJyc7XG5cbiAgaWYgKGlzRE9NVGV4dChkb21Ob2RlKSAmJiBkb21Ob2RlLm5vZGVWYWx1ZSkge1xuICAgIHJldHVybiBkb21Ob2RlLm5vZGVWYWx1ZTtcbiAgfVxuXG4gIGlmIChpc0RPTUVsZW1lbnQoZG9tTm9kZSkpIHtcbiAgICBmb3IgKHZhciBjaGlsZE5vZGUgb2YgQXJyYXkuZnJvbShkb21Ob2RlLmNoaWxkTm9kZXMpKSB7XG4gICAgICB0ZXh0ICs9IGdldFBsYWluVGV4dChjaGlsZE5vZGUpO1xuICAgIH1cblxuICAgIHZhciBkaXNwbGF5ID0gZ2V0Q29tcHV0ZWRTdHlsZShkb21Ob2RlKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5Jyk7XG5cbiAgICBpZiAoZGlzcGxheSA9PT0gJ2Jsb2NrJyB8fCBkaXNwbGF5ID09PSAnbGlzdCcgfHwgZG9tTm9kZS50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICB0ZXh0ICs9ICdcXG4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0ZXh0O1xufTtcbi8qKlxyXG4gKiBHZXQgeC1zbGF0ZS1mcmFnbWVudCBhdHRyaWJ1dGUgZnJvbSBkYXRhLXNsYXRlLWZyYWdtZW50XHJcbiAqL1xuXG52YXIgY2F0Y2hTbGF0ZUZyYWdtZW50ID0gL2RhdGEtc2xhdGUtZnJhZ21lbnQ9XCIoLis/KVwiL207XG52YXIgZ2V0U2xhdGVGcmFnbWVudEF0dHJpYnV0ZSA9IGRhdGFUcmFuc2ZlciA9PiB7XG4gIHZhciBodG1sRGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcbiAgdmFyIFssIGZyYWdtZW50XSA9IGh0bWxEYXRhLm1hdGNoKGNhdGNoU2xhdGVGcmFnbWVudCkgfHwgW107XG4gIHJldHVybiBmcmFnbWVudDtcbn07XG4vKipcclxuICogQ2hlY2sgd2hldGhlciBhIG11dGF0aW9uIG9yaWdpbmF0ZXMgZnJvbSBhIGVkaXRhYmxlIGVsZW1lbnQgaW5zaWRlIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgaXNUcmFja2VkTXV0YXRpb24gPSAoZWRpdG9yLCBtdXRhdGlvbiwgYmF0Y2gpID0+IHtcbiAgdmFyIHtcbiAgICB0YXJnZXRcbiAgfSA9IG11dGF0aW9uO1xuXG4gIGlmIChpc0RPTUVsZW1lbnQodGFyZ2V0KSAmJiB0YXJnZXQubWF0Y2hlcygnW2NvbnRlbnRFZGl0YWJsZT1cImZhbHNlXCJdJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIge1xuICAgIGRvY3VtZW50XG4gIH0gPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcblxuICBpZiAoZG9jdW1lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgIHJldHVybiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0LCB7XG4gICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHBhcmVudE11dGF0aW9uID0gYmF0Y2guZmluZChfcmVmID0+IHtcbiAgICB2YXIge1xuICAgICAgYWRkZWROb2RlcyxcbiAgICAgIHJlbW92ZWROb2Rlc1xuICAgIH0gPSBfcmVmO1xuXG4gICAgZm9yICh2YXIgbm9kZSBvZiBhZGRlZE5vZGVzKSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGFyZ2V0IHx8IG5vZGUuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbm9kZSBvZiByZW1vdmVkTm9kZXMpIHtcbiAgICAgIGlmIChfbm9kZSA9PT0gdGFyZ2V0IHx8IF9ub2RlLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoIXBhcmVudE11dGF0aW9uIHx8IHBhcmVudE11dGF0aW9uID09PSBtdXRhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUYXJnZXQgYWRkL3JlbW92ZSBpcyB0cmFja2VkLiBUcmFjayB0aGUgbXV0YXRpb24gaWYgd2UgdHJhY2sgdGhlIHBhcmVudCBtdXRhdGlvbi5cblxuXG4gIHJldHVybiBpc1RyYWNrZWRNdXRhdGlvbihlZGl0b3IsIHBhcmVudE11dGF0aW9uLCBiYXRjaCk7XG59O1xuXG52YXIgSVNfUkVBQ1RfVkVSU0lPTl8xN19PUl9BQk9WRSA9IHBhcnNlSW50KFJlYWN0LnZlcnNpb24uc3BsaXQoJy4nKVswXSwgMTApID49IDE3O1xudmFyIElTX0lPUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG52YXIgSVNfQVBQTEUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvTWFjIE9TIFgvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQU5EUk9JRCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BbmRyb2lkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0ZJUkVGT1ggPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfU0FGQVJJID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1ZlcnNpb25cXC9bXFxkXFwuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gXCJtb2Rlcm5cIiBFZGdlIHdhcyByZWxlYXNlZCBhdCA3OS54XG5cbnZhciBJU19FREdFX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9FZGdlP1xcLyg/OlswLTZdWzAtOV18WzAtN11bMC04XSkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19DSFJPTUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gTmF0aXZlIGBiZWZvcmVJbnB1dGAgZXZlbnRzIGRvbid0IHdvcmsgd2VsbCB3aXRoIHJlYWN0IG9uIENocm9tZSA3NVxuLy8gYW5kIG9sZGVyLCBDaHJvbWUgNzYrIGNhbiB1c2UgYGJlZm9yZUlucHV0YCB0aG91Z2guXG5cbnZhciBJU19DSFJPTUVfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0Nocm9tZT9cXC8oPzpbMC03XVswLTVdfFswLTZdWzAtOV0pKD86XFwuKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQU5EUk9JRF9DSFJPTUVfTEVHQUNZID0gSVNfQU5EUk9JRCAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lP1xcLyg/OlswLTVdP1xcZCkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gRmlyZWZveCBkaWQgbm90IHN1cHBvcnQgYGJlZm9yZUlucHV0YCB1bnRpbCBgdjg3YC5cblxudmFyIElTX0ZJUkVGT1hfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3hcXC8oPzpbMC03XVswLTldfFswLThdWzAtNl0pKD86XFwuKSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIFVDIG1vYmlsZSBicm93c2VyXG5cbnZhciBJU19VQ19NT0JJTEUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLipVQ0Jyb3dzZXIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIFdlY2hhdCBicm93c2VyXG5cbnZhciBJU19XRUNIQVRCUk9XU0VSID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgLy4qV2VjaGF0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBDaGVjayBpZiBET00gaXMgYXZhaWxhYmxlIGFzIFJlYWN0IGRvZXMgaW50ZXJuYWxseS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcblxudmFyIENBTl9VU0VfRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7IC8vIENPTVBBVDogRmlyZWZveC9FZGdlIExlZ2FjeSBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50XG4vLyBDaHJvbWUgTGVnYWN5IGRvZXNuJ3Qgc3VwcG9ydCBgYmVmb3JlaW5wdXRgIGNvcnJlY3RseVxuXG52YXIgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUID0gKCFJU19DSFJPTUVfTEVHQUNZIHx8ICFJU19BTkRST0lEX0NIUk9NRV9MRUdBQ1kpICYmICFJU19FREdFX0xFR0FDWSAmJiAvLyBnbG9iYWxUaGlzIGlzIHVuZGVmaW5lZCBpbiBvbGRlciBicm93c2Vyc1xudHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuSW5wdXRFdmVudCAmJiAvLyBAdHMtaWdub3JlIFRoZSBgZ2V0VGFyZ2V0UmFuZ2VzYCBwcm9wZXJ0eSBpc24ndCByZWNvZ25pemVkLlxudHlwZW9mIGdsb2JhbFRoaXMuSW5wdXRFdmVudC5wcm90b3R5cGUuZ2V0VGFyZ2V0UmFuZ2VzID09PSAnZnVuY3Rpb24nO1xuXG52YXIgUmVhY3RFZGl0b3IgPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBjb21wb3NpbmcgaW5zaWRlIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGlzQ29tcG9zaW5nKGVkaXRvcikge1xuICAgIHJldHVybiAhIUlTX0NPTVBPU0lORy5nZXQoZWRpdG9yKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGhvc3Qgd2luZG93IG9mIHRoZSBjdXJyZW50IGVkaXRvci5cclxuICAgKi9cbiAgZ2V0V2luZG93KGVkaXRvcikge1xuICAgIHZhciB3aW5kb3cgPSBFRElUT1JfVE9fV0lORE9XLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCF3aW5kb3cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgYSBob3N0IHdpbmRvdyBlbGVtZW50IGZvciB0aGlzIGVkaXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiB3aW5kb3c7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCBhIGtleSBmb3IgYSBTbGF0ZSBub2RlLlxyXG4gICAqL1xuICBmaW5kS2V5KGVkaXRvciwgbm9kZSkge1xuICAgIHZhciBrZXkgPSBOT0RFX1RPX0tFWS5nZXQobm9kZSk7XG5cbiAgICBpZiAoIWtleSkge1xuICAgICAga2V5ID0gbmV3IEtleSgpO1xuICAgICAgTk9ERV9UT19LRVkuc2V0KG5vZGUsIGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleTtcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIHRoZSBwYXRoIG9mIFNsYXRlIG5vZGUuXHJcbiAgICovXG4gIGZpbmRQYXRoKGVkaXRvciwgbm9kZSkge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIGNoaWxkID0gbm9kZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgcGFyZW50ID0gTk9ERV9UT19QQVJFTlQuZ2V0KGNoaWxkKTtcblxuICAgICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChFZGl0b3IuaXNFZGl0b3IoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSBOT0RFX1RPX0lOREVYLmdldChjaGlsZCk7XG5cbiAgICAgIGlmIChpID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBhdGgudW5zaGlmdChpKTtcbiAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRoZSBwYXRoIGZvciBTbGF0ZSBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCB0aGUgRE9NIG5vZGUgdGhhdCBpbXBsZW1lbnRzIERvY3VtZW50T3JTaGFkb3dSb290IGZvciB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBmaW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKSB7XG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IGVsLmdldFJvb3ROb2RlKCk7XG5cbiAgICBpZiAoKHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudCB8fCByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCkgJiYgcm9vdC5nZXRTZWxlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsLm93bmVyRG9jdW1lbnQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBmb2N1c2VkLlxyXG4gICAqL1xuICBpc0ZvY3VzZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuICEhSVNfRk9DVVNFRC5nZXQoZWRpdG9yKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgZWRpdG9yIGlzIGluIHJlYWQtb25seSBtb2RlLlxyXG4gICAqL1xuICBpc1JlYWRPbmx5KGVkaXRvcikge1xuICAgIHJldHVybiAhIUlTX1JFQURfT05MWS5nZXQoZWRpdG9yKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBCbHVyIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGJsdXIoZWRpdG9yKSB7XG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgZmFsc2UpO1xuXG4gICAgaWYgKHJvb3QuYWN0aXZlRWxlbWVudCA9PT0gZWwpIHtcbiAgICAgIGVsLmJsdXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRm9jdXMgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgZm9jdXMoZWRpdG9yKSB7XG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgdHJ1ZSk7XG5cbiAgICBpZiAocm9vdC5hY3RpdmVFbGVtZW50ICE9PSBlbCkge1xuICAgICAgZWwuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRGVzZWxlY3QgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgZGVzZWxlY3QoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChkb21TZWxlY3Rpb24gJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIHdpdGhpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBoYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBlZGl0YWJsZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGVkaXRvckVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgdGFyZ2V0RWw7IC8vIENPTVBBVDogSW4gRmlyZWZveCwgcmVhZGluZyBgdGFyZ2V0Lm5vZGVUeXBlYCB3aWxsIHRocm93IGFuIGVycm9yIGlmXG4gICAgLy8gdGFyZ2V0IGlzIG9yaWdpbmF0aW5nIGZyb20gYW4gaW50ZXJuYWwgXCJyZXN0cmljdGVkXCIgZWxlbWVudCAoZS5nLiBhXG4gICAgLy8gc3RlcHBlciBhcnJvdyBvbiBhIG51bWJlciBpbnB1dCkuICgyMDE4LzA1LzA0KVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9pc3N1ZXMvMTgxOVxuXG4gICAgdHJ5IHtcbiAgICAgIHRhcmdldEVsID0gaXNET01FbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ1Blcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyBwcm9wZXJ0eSBcIm5vZGVUeXBlXCInKSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRFbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRFbC5jbG9zZXN0KFwiW2RhdGEtc2xhdGUtZWRpdG9yXVwiKSA9PT0gZWRpdG9yRWwgJiYgKCFlZGl0YWJsZSB8fCB0YXJnZXRFbC5pc0NvbnRlbnRFZGl0YWJsZSA/IHRydWUgOiB0eXBlb2YgdGFyZ2V0RWwuaXNDb250ZW50RWRpdGFibGUgPT09ICdib29sZWFuJyAmJiAvLyBpc0NvbnRlbnRFZGl0YWJsZSBleGlzdHMgb25seSBvbiBIVE1MRWxlbWVudCwgYW5kIG9uIG90aGVyIG5vZGVzIGl0IHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgLy8gdGhpcyBpcyB0aGUgY29yZSBsb2dpYyB0aGF0IGxldHMgeW91IGtub3cgeW91IGdvdCB0aGUgcmlnaHQgZWRpdG9yLnNlbGVjdGlvbiBpbnN0ZWFkIG9mIG51bGwgd2hlbiBlZGl0b3IgaXMgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIihyZWFkT25seSlcbiAgICB0YXJnZXRFbC5jbG9zZXN0KCdbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0nKSA9PT0gZWRpdG9yRWwgfHwgISF0YXJnZXRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgZGF0YSBmcm9tIGEgYERhdGFUcmFuc2ZlcmAgaW50byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnREYXRhKGVkaXRvciwgZGF0YSkge1xuICAgIGVkaXRvci5pbnNlcnREYXRhKGRhdGEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBmcmFnbWVudCBkYXRhIGZyb20gYSBgRGF0YVRyYW5zZmVyYCBpbnRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGluc2VydEZyYWdtZW50RGF0YShlZGl0b3IsIGRhdGEpIHtcbiAgICByZXR1cm4gZWRpdG9yLmluc2VydEZyYWdtZW50RGF0YShkYXRhKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgdGV4dCBkYXRhIGZyb20gYSBgRGF0YVRyYW5zZmVyYCBpbnRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGluc2VydFRleHREYXRhKGVkaXRvciwgZGF0YSkge1xuICAgIHJldHVybiBlZGl0b3IuaW5zZXJ0VGV4dERhdGEoZGF0YSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2V0cyBkYXRhIGZyb20gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmcmFnbWVudCBvbiBhIGBEYXRhVHJhbnNmZXJgLlxyXG4gICAqL1xuICBzZXRGcmFnbWVudERhdGEoZWRpdG9yLCBkYXRhLCBvcmlnaW5FdmVudCkge1xuICAgIGVkaXRvci5zZXRGcmFnbWVudERhdGEoZGF0YSwgb3JpZ2luRXZlbnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIG5hdGl2ZSBET00gZWxlbWVudCBmcm9tIGEgU2xhdGUgbm9kZS5cclxuICAgKi9cbiAgdG9ET01Ob2RlKGVkaXRvciwgbm9kZSkge1xuICAgIHZhciBLRVlfVE9fRUxFTUVOVCA9IEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICB2YXIgZG9tTm9kZSA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/IEVESVRPUl9UT19FTEVNRU5ULmdldChlZGl0b3IpIDogS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULmdldChSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgbm9kZSkpO1xuXG4gICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIERPTSBub2RlIGZyb20gU2xhdGUgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBkb21Ob2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgYSBuYXRpdmUgRE9NIHNlbGVjdGlvbiBwb2ludCBmcm9tIGEgU2xhdGUgcG9pbnQuXHJcbiAgICovXG4gIHRvRE9NUG9pbnQoZWRpdG9yLCBwb2ludCkge1xuICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBvaW50LnBhdGgpO1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIG5vZGUpO1xuICAgIHZhciBkb21Qb2ludDsgLy8gSWYgd2UncmUgaW5zaWRlIGEgdm9pZCBub2RlLCBmb3JjZSB0aGUgb2Zmc2V0IHRvIDAsIG90aGVyd2lzZSB0aGUgemVyb1xuICAgIC8vIHdpZHRoIHNwYWNpbmcgY2hhcmFjdGVyIHdpbGwgcmVzdWx0IGluIGFuIGluY29ycmVjdCBvZmZzZXQgb2YgMVxuXG4gICAgaWYgKEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IHBvaW50XG4gICAgfSkpIHtcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH07XG4gICAgfSAvLyBGb3IgZWFjaCBsZWFmLCB3ZSBuZWVkIHRvIGlzb2xhdGUgaXRzIGNvbnRlbnQsIHdoaWNoIG1lYW5zIGZpbHRlcmluZ1xuICAgIC8vIHRvIGl0cyBkaXJlY3QgdGV4dCBhbmQgemVyby13aWR0aCBzcGFucy4gKFdlIGhhdmUgdG8gZmlsdGVyIG91dCBhbnlcbiAgICAvLyBvdGhlciBzaWJsaW5ncyB0aGF0IG1heSBoYXZlIGJlZW4gcmVuZGVyZWQgYWxvbmdzaWRlIHRoZW0uKVxuXG5cbiAgICB2YXIgc2VsZWN0b3IgPSBcIltkYXRhLXNsYXRlLXN0cmluZ10sIFtkYXRhLXNsYXRlLXplcm8td2lkdGhdXCI7XG4gICAgdmFyIHRleHRzID0gQXJyYXkuZnJvbShlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0ZXh0ID0gdGV4dHNbaV07XG4gICAgICB2YXIgZG9tTm9kZSA9IHRleHQuY2hpbGROb2Rlc1swXTtcblxuICAgICAgaWYgKGRvbU5vZGUgPT0gbnVsbCB8fCBkb21Ob2RlLnRleHRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSA9IGRvbU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICB2YXIgYXR0ciA9IHRleHQuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLWxlbmd0aCcpO1xuICAgICAgdmFyIHRydWVMZW5ndGggPSBhdHRyID09IG51bGwgPyBsZW5ndGggOiBwYXJzZUludChhdHRyLCAxMCk7XG4gICAgICB2YXIgZW5kID0gc3RhcnQgKyB0cnVlTGVuZ3RoOyAvLyBQcmVmZXIgcHV0dGluZyB0aGUgc2VsZWN0aW9uIGluc2lkZSB0aGUgbWFyayBwbGFjZWhvbGRlciB0byBlbnN1cmVcbiAgICAgIC8vIGNvbXBvc2VkIHRleHQgaXMgZGlzcGxheWVkIHdpdGggdGhlIGNvcnJlY3QgbWFya3MuXG5cbiAgICAgIHZhciBuZXh0VGV4dCA9IHRleHRzW2kgKyAxXTtcblxuICAgICAgaWYgKHBvaW50Lm9mZnNldCA9PT0gZW5kICYmIG5leHRUZXh0ICE9PSBudWxsICYmIG5leHRUZXh0ICE9PSB2b2lkIDAgJiYgbmV4dFRleHQuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW1hcmstcGxhY2Vob2xkZXInKSkge1xuICAgICAgICB2YXIgX25leHRUZXh0JHRleHRDb250ZW50O1xuXG4gICAgICAgIHZhciBkb21UZXh0ID0gbmV4dFRleHQuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgZG9tUG9pbnQgPSBbLy8gQ09NUEFUOiBJZiB3ZSBkb24ndCBleHBsaWNpdHkgc2V0IHRoZSBkb20gcG9pbnQgdG8gYmUgb24gdGhlIGFjdHVhbFxuICAgICAgICAvLyBkb20gdGV4dCBlbGVtZW50LCBjaHJvbWUgd2lsbCBwdXQgdGhlIHNlbGVjdGlvbiBiZWhpbmQgdGhlIGFjdHVhbCBkb21cbiAgICAgICAgLy8gdGV4dCBlbGVtZW50LCBjYXVzaW5nIGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGNhbGxzIG9uIGEgY29sbGFwc2VkXG4gICAgICAgIC8vIHNlbGVjdGlvbiB0byByZXR1cm4gaW5jb3JyZWN0IHplcm8gdmFsdWVzIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00MzU0MzgpXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzIHdoZW4gc2Nyb2xsaW5nIHRvIGl0LlxuICAgICAgICBkb21UZXh0IGluc3RhbmNlb2YgRE9NVGV4dCA/IGRvbVRleHQgOiBuZXh0VGV4dCwgKF9uZXh0VGV4dCR0ZXh0Q29udGVudCA9IG5leHRUZXh0LnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQgIT09IHZvaWQgMCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQuc3RhcnRzV2l0aCgnXFx1RkVGRicpID8gMSA6IDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8PSBlbmQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IE1hdGgubWluKGxlbmd0aCwgTWF0aC5tYXgoMCwgcG9pbnQub2Zmc2V0IC0gc3RhcnQpKTtcbiAgICAgICAgZG9tUG9pbnQgPSBbZG9tTm9kZSwgb2Zmc2V0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgIH1cblxuICAgIGlmICghZG9tUG9pbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgRE9NIHBvaW50IGZyb20gU2xhdGUgcG9pbnQ6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocG9pbnQpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbVBvaW50O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgYSBuYXRpdmUgRE9NIHJhbmdlIGZyb20gYSBTbGF0ZSBgcmFuZ2VgLlxyXG4gICAqXHJcbiAgICogTm90aWNlOiB0aGUgcmV0dXJuZWQgcmFuZ2Ugd2lsbCBhbHdheXMgYmUgb3JkaW5hbCByZWdhcmRsZXNzIG9mIHRoZSBkaXJlY3Rpb24gb2YgU2xhdGUgYHJhbmdlYCBkdWUgdG8gRE9NIEFQSSBsaW1pdC5cclxuICAgKlxyXG4gICAqIHRoZXJlIGlzIG5vIHdheSB0byBjcmVhdGUgYSByZXZlcnNlIERPTSBSYW5nZSB1c2luZyBSYW5nZS5zZXRTdGFydC9zZXRFbmRcclxuICAgKiBhY2NvcmRpbmcgdG8gaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJhbmdlLWJwLXNldC5cclxuICAgKi9cbiAgdG9ET01SYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHZhciBpc0JhY2t3YXJkID0gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gICAgdmFyIGRvbUFuY2hvciA9IFJlYWN0RWRpdG9yLnRvRE9NUG9pbnQoZWRpdG9yLCBhbmNob3IpO1xuICAgIHZhciBkb21Gb2N1cyA9IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSA/IGRvbUFuY2hvciA6IFJlYWN0RWRpdG9yLnRvRE9NUG9pbnQoZWRpdG9yLCBmb2N1cyk7XG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHZhciBkb21SYW5nZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHZhciBbc3RhcnROb2RlLCBzdGFydE9mZnNldF0gPSBpc0JhY2t3YXJkID8gZG9tRm9jdXMgOiBkb21BbmNob3I7XG4gICAgdmFyIFtlbmROb2RlLCBlbmRPZmZzZXRdID0gaXNCYWNrd2FyZCA/IGRvbUFuY2hvciA6IGRvbUZvY3VzOyAvLyBBIHNsYXRlIFBvaW50IGF0IHplcm8td2lkdGggTGVhZiBhbHdheXMgaGFzIGFuIG9mZnNldCBvZiAwIGJ1dCBhIG5hdGl2ZSBET00gc2VsZWN0aW9uIGF0XG4gICAgLy8gemVyby13aWR0aCBub2RlIGhhcyBhbiBvZmZzZXQgb2YgMSBzbyB3ZSBoYXZlIHRvIGNoZWNrIGlmIHdlIGFyZSBpbiBhIHplcm8td2lkdGggbm9kZSBhbmRcbiAgICAvLyBhZGp1c3QgdGhlIG9mZnNldCBhY2NvcmRpbmdseS5cblxuICAgIHZhciBzdGFydEVsID0gaXNET01FbGVtZW50KHN0YXJ0Tm9kZSkgPyBzdGFydE5vZGUgOiBzdGFydE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB2YXIgaXNTdGFydEF0WmVyb1dpZHRoID0gISFzdGFydEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJyk7XG4gICAgdmFyIGVuZEVsID0gaXNET01FbGVtZW50KGVuZE5vZGUpID8gZW5kTm9kZSA6IGVuZE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB2YXIgaXNFbmRBdFplcm9XaWR0aCA9ICEhZW5kRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKTtcbiAgICBkb21SYW5nZS5zZXRTdGFydChzdGFydE5vZGUsIGlzU3RhcnRBdFplcm9XaWR0aCA/IDEgOiBzdGFydE9mZnNldCk7XG4gICAgZG9tUmFuZ2Uuc2V0RW5kKGVuZE5vZGUsIGlzRW5kQXRaZXJvV2lkdGggPyAxIDogZW5kT2Zmc2V0KTtcbiAgICByZXR1cm4gZG9tUmFuZ2U7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCBhIFNsYXRlIG5vZGUgZnJvbSBhIG5hdGl2ZSBET00gYGVsZW1lbnRgLlxyXG4gICAqL1xuICB0b1NsYXRlTm9kZShlZGl0b3IsIGRvbU5vZGUpIHtcbiAgICB2YXIgZG9tRWwgPSBpc0RPTUVsZW1lbnQoZG9tTm9kZSkgPyBkb21Ob2RlIDogZG9tTm9kZS5wYXJlbnRFbGVtZW50O1xuXG4gICAgaWYgKGRvbUVsICYmICFkb21FbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbm9kZScpKSB7XG4gICAgICBkb21FbCA9IGRvbUVsLmNsb3Nlc3QoXCJbZGF0YS1zbGF0ZS1ub2RlXVwiKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGRvbUVsID8gRUxFTUVOVF9UT19OT0RFLmdldChkb21FbCkgOiBudWxsO1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIG5vZGUgZnJvbSBET00gbm9kZTogXCIuY29uY2F0KGRvbUVsKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSBhIERPTSBgZXZlbnRgLlxyXG4gICAqL1xuICBmaW5kRXZlbnRSYW5nZShlZGl0b3IsIGV2ZW50KSB7XG4gICAgaWYgKCduYXRpdmVFdmVudCcgaW4gZXZlbnQpIHtcbiAgICAgIGV2ZW50ID0gZXZlbnQubmF0aXZlRXZlbnQ7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGNsaWVudFg6IHgsXG4gICAgICBjbGllbnRZOiB5LFxuICAgICAgdGFyZ2V0XG4gICAgfSA9IGV2ZW50O1xuXG4gICAgaWYgKHggPT0gbnVsbCB8fCB5ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSBhIERPTSBldmVudDogXCIuY29uY2F0KGV2ZW50KSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpOyAvLyBJZiB0aGUgZHJvcCB0YXJnZXQgaXMgaW5zaWRlIGEgdm9pZCBub2RlLCBtb3ZlIGl0IGludG8gZWl0aGVyIHRoZVxuICAgIC8vIG5leHQgb3IgcHJldmlvdXMgbm9kZSwgZGVwZW5kaW5nIG9uIHdoaWNoIHNpZGUgdGhlIGB4YCBhbmQgYHlgXG4gICAgLy8gY29vcmRpbmF0ZXMgYXJlIGNsb3Nlc3QgdG8uXG5cbiAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgIHZhciByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGlzUHJldiA9IGVkaXRvci5pc0lubGluZShub2RlKSA/IHggLSByZWN0LmxlZnQgPCByZWN0LmxlZnQgKyByZWN0LndpZHRoIC0geCA6IHkgLSByZWN0LnRvcCA8IHJlY3QudG9wICsgcmVjdC5oZWlnaHQgLSB5O1xuICAgICAgdmFyIGVkZ2UgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBwYXRoLCB7XG4gICAgICAgIGVkZ2U6IGlzUHJldiA/ICdzdGFydCcgOiAnZW5kJ1xuICAgICAgfSk7XG4gICAgICB2YXIgcG9pbnQgPSBpc1ByZXYgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgZWRnZSkgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBlZGdlKTtcblxuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIHZhciBfcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb2ludCk7XG5cbiAgICAgICAgcmV0dXJuIF9yYW5nZTtcbiAgICAgIH1cbiAgICB9IC8vIEVsc2UgcmVzb2x2ZSBhIHJhbmdlIGZyb20gdGhlIGNhcmV0IHBvc2l0aW9uIHdoZXJlIHRoZSBkcm9wIG9jY3VyZWQuXG5cblxuICAgIHZhciBkb21SYW5nZTtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnRcbiAgICB9ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7IC8vIENPTVBBVDogSW4gRmlyZWZveCwgYGNhcmV0UmFuZ2VGcm9tUG9pbnRgIGRvZXNuJ3QgZXhpc3QuICgyMDE2LzA3LzI1KVxuXG4gICAgaWYgKGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgIGRvbVJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvc2l0aW9uID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcblxuICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgIGRvbVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgZG9tUmFuZ2Uuc2V0U3RhcnQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgICAgZG9tUmFuZ2Uuc2V0RW5kKHBvc2l0aW9uLm9mZnNldE5vZGUsIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkb21SYW5nZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIGEgRE9NIGV2ZW50OiBcIi5jb25jYXQoZXZlbnQpKTtcbiAgICB9IC8vIFJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIHRoZSBET00gcmFuZ2UuXG5cblxuICAgIHZhciByYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVJhbmdlLCB7XG4gICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzVGhyb3c6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgYSBTbGF0ZSBwb2ludCBmcm9tIGEgRE9NIHNlbGVjdGlvbidzIGBkb21Ob2RlYCBhbmQgYGRvbU9mZnNldGAuXHJcbiAgICovXG4gIHRvU2xhdGVQb2ludChlZGl0b3IsIGRvbVBvaW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHtcbiAgICAgIGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIFtuZWFyZXN0Tm9kZSwgbmVhcmVzdE9mZnNldF0gPSBleGFjdE1hdGNoID8gZG9tUG9pbnQgOiBub3JtYWxpemVET01Qb2ludChkb21Qb2ludCk7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBuZWFyZXN0Tm9kZS5wYXJlbnROb2RlO1xuICAgIHZhciB0ZXh0Tm9kZSA9IG51bGw7XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgdmFyIF9kb21Ob2RlJHRleHRDb250ZW50LCBfZG9tTm9kZSR0ZXh0Q29udGVudDI7XG5cbiAgICAgIHZhciBlZGl0b3JFbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICB2YXIgcG90ZW50aWFsVm9pZE5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLXZvaWQ9XCJ0cnVlXCJdJyk7IC8vIE5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGNsb3Nlc3Qgdm9pZCBub2RlIGlzIGFjdHVhbGx5IGEgdm9pZCBub2RlXG4gICAgICAvLyB3aXRoaW4gdGhpcyBlZGl0b3IsIGFuZCBub3QgYSB2b2lkIG5vZGUgd2l0aGluIHNvbWUgcGFyZW50IGVkaXRvci4gVGhpcyBjYW4gaGFwcGVuXG4gICAgICAvLyBpZiB0aGlzIGVkaXRvciBpcyB3aXRoaW4gYSB2b2lkIG5vZGUgb2YgYW5vdGhlciBlZGl0b3IgKFwibmVzdGVkIGVkaXRvcnNcIiwgbGlrZSBpblxuICAgICAgLy8gdGhlIFwiRWRpdGFibGUgVm9pZHNcIiBleGFtcGxlIG9uIHRoZSBkb2NzIHNpdGUpLlxuXG4gICAgICB2YXIgdm9pZE5vZGUgPSBwb3RlbnRpYWxWb2lkTm9kZSAmJiBlZGl0b3JFbC5jb250YWlucyhwb3RlbnRpYWxWb2lkTm9kZSkgPyBwb3RlbnRpYWxWb2lkTm9kZSA6IG51bGw7XG4gICAgICB2YXIgbGVhZk5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG4gICAgICB2YXIgZG9tTm9kZSA9IG51bGw7IC8vIENhbGN1bGF0ZSBob3cgZmFyIGludG8gdGhlIHRleHQgbm9kZSB0aGUgYG5lYXJlc3ROb2RlYCBpcywgc28gdGhhdCB3ZVxuICAgICAgLy8gY2FuIGRldGVybWluZSB3aGF0IHRoZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHRleHQgbm9kZSBpcy5cblxuICAgICAgaWYgKGxlYWZOb2RlKSB7XG4gICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcblxuICAgICAgICBpZiAodGV4dE5vZGUpIHtcbiAgICAgICAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgICAgICAgdmFyIHJhbmdlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGUsIDApO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChuZWFyZXN0Tm9kZSwgbmVhcmVzdE9mZnNldCk7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gcmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgICAgIHZhciByZW1vdmFscyA9IFsuLi5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpKSwgLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2NvbnRlbnRlZGl0YWJsZT1mYWxzZV0nKSldO1xuICAgICAgICAgIHJlbW92YWxzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgLy8gQ09NUEFUOiBXaGlsZSBjb21wb3NpbmcgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlLCBzb21lIGtleWJvYXJkcyBwdXRcbiAgICAgICAgICAgIC8vIHRoZSB0ZXh0IGNvbnRlbnQgaW5zaWRlIHRoZSB6ZXJvIHdpZHRoIHNwYWNlLlxuICAgICAgICAgICAgaWYgKElTX0FORFJPSUQgJiYgIWV4YWN0TWF0Y2ggJiYgZWwuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSAmJiBlbC50ZXh0Q29udGVudC5sZW5ndGggPiAwICYmIGVsLnRleHRDb250ZXh0ICE9PSAnXFx1RkVGRicpIHtcbiAgICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50LnN0YXJ0c1dpdGgoJ1xcdUZFRkYnKSkge1xuICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gZWwudGV4dENvbnRlbnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgIH0pOyAvLyBDT01QQVQ6IEVkZ2UgaGFzIGEgYnVnIHdoZXJlIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZygpIHdpbGxcbiAgICAgICAgICAvLyBjb252ZXJ0IFxcbiBpbnRvIFxcclxcbi4gVGhlIGJ1ZyBjYXVzZXMgYSBsb29wIHdoZW4gc2xhdGUtcmVhY3RcbiAgICAgICAgICAvLyBhdHRlbXB0cyB0byByZXBvc2l0aW9uIGl0cyBjdXJzb3IgdG8gbWF0Y2ggdGhlIG5hdGl2ZSBwb3NpdGlvbi4gVXNlXG4gICAgICAgICAgLy8gdGV4dENvbnRlbnQubGVuZ3RoIGluc3RlYWQuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAyOTExMTYvXG5cbiAgICAgICAgICBvZmZzZXQgPSBjb250ZW50cy50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgZG9tTm9kZSA9IHRleHROb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZvaWROb2RlKSB7XG4gICAgICAgIC8vIEZvciB2b2lkIG5vZGVzLCB0aGUgZWxlbWVudCB3aXRoIHRoZSBvZmZzZXQga2V5IHdpbGwgYmUgYSBjb3VzaW4sIG5vdCBhblxuICAgICAgICAvLyBhbmNlc3Rvciwgc28gZmluZCBpdCBieSBnb2luZyBkb3duIGZyb20gdGhlIG5lYXJlc3Qgdm9pZCBwYXJlbnQgYW5kIHRha2luZyB0aGVcbiAgICAgICAgLy8gZmlyc3Qgb25lIHRoYXQgaXNuJ3QgaW5zaWRlIGEgbmVzdGVkIGVkaXRvci5cbiAgICAgICAgdmFyIGxlYWZOb2RlcyA9IHZvaWROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlYWZOb2Rlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGxlYWZOb2Rlc1tpbmRleF07XG5cbiAgICAgICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBsZWFmTm9kZSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ09NUEFUOiBJbiByZWFkLW9ubHkgZWRpdG9ycyB0aGUgbGVhZiBpcyBub3QgcmVuZGVyZWQuXG5cblxuICAgICAgICBpZiAoIWxlYWZOb2RlKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9IGxlYWZOb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGU9XCJ0ZXh0XCJdJyk7XG4gICAgICAgICAgZG9tTm9kZSA9IGxlYWZOb2RlO1xuICAgICAgICAgIG9mZnNldCA9IGRvbU5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIGRvbU5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBlbC50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRvbU5vZGUgJiYgb2Zmc2V0ID09PSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aCAmJiAvLyBDT01QQVQ6IEFuZHJvaWQgSU1FcyBtaWdodCByZW1vdmUgdGhlIHplcm8gd2lkdGggc3BhY2Ugd2hpbGUgY29tcG9zaW5nLFxuICAgICAgLy8gYW5kIHdlIGRvbid0IGFkZCBpdCBmb3IgbGluZS1icmVha3MuXG4gICAgICBJU19BTkRST0lEICYmIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSA9PT0gJ3onICYmIChfZG9tTm9kZSR0ZXh0Q29udGVudCA9IGRvbU5vZGUudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9kb21Ob2RlJHRleHRDb250ZW50ICE9PSB2b2lkIDAgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQuc3RhcnRzV2l0aCgnXFx1RkVGRicpICYmIChwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgfHwgSVNfRklSRUZPWCAmJiAoX2RvbU5vZGUkdGV4dENvbnRlbnQyID0gZG9tTm9kZS50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQyICE9PSB2b2lkIDAgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQyLmVuZHNXaXRoKCdcXG5cXG4nKSkpIHtcbiAgICAgICAgb2Zmc2V0LS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKElTX0FORFJPSUQgJiYgIXRleHROb2RlICYmICFleGFjdE1hdGNoKSB7XG4gICAgICB2YXIgbm9kZSA9IHBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW5vZGUnKSA/IHBhcmVudE5vZGUgOiBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGVdJyk7XG5cbiAgICAgIGlmIChub2RlICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCBub2RlLCB7XG4gICAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgX3NsYXRlTm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgbm9kZSk7XG5cbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXRcbiAgICAgICAgfSA9IEVkaXRvci5zdGFydChlZGl0b3IsIFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgX3NsYXRlTm9kZSkpO1xuXG4gICAgICAgIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zbGF0ZS1sZWFmXScpKSB7XG4gICAgICAgICAgX29mZnNldCA9IG5lYXJlc3RPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldDogX29mZnNldFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGV4dE5vZGUpIHtcbiAgICAgIGlmIChzdXBwcmVzc1Rocm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHBvaW50IGZyb20gRE9NIHBvaW50OiBcIi5jb25jYXQoZG9tUG9pbnQpKTtcbiAgICB9IC8vIENPTVBBVDogSWYgc29tZW9uZSBpcyBjbGlja2luZyBmcm9tIG9uZSBTbGF0ZSBlZGl0b3IgaW50byBhbm90aGVyLFxuICAgIC8vIHRoZSBzZWxlY3QgZXZlbnQgZmlyZXMgdHdpY2UsIG9uY2UgZm9yIHRoZSBvbGQgZWRpdG9yJ3MgYGVsZW1lbnRgXG4gICAgLy8gZmlyc3QsIGFuZCB0aGVuIGFmdGVyd2FyZHMgZm9yIHRoZSBjb3JyZWN0IGBlbGVtZW50YC4gKDIwMTcvMDMvMDMpXG5cblxuICAgIHZhciBzbGF0ZU5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIHRleHROb2RlKTtcbiAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgc2xhdGVOb2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gcmFuZ2Ugb3Igc2VsZWN0aW9uLlxyXG4gICAqL1xuICB0b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21SYW5nZSwgb3B0aW9ucykge1xuICAgIHZhciB7XG4gICAgICBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvd1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBlbCA9IGlzRE9NU2VsZWN0aW9uKGRvbVJhbmdlKSA/IGRvbVJhbmdlLmFuY2hvck5vZGUgOiBkb21SYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICB2YXIgYW5jaG9yTm9kZTtcbiAgICB2YXIgYW5jaG9yT2Zmc2V0O1xuICAgIHZhciBmb2N1c05vZGU7XG4gICAgdmFyIGZvY3VzT2Zmc2V0O1xuICAgIHZhciBpc0NvbGxhcHNlZDtcblxuICAgIGlmIChlbCkge1xuICAgICAgaWYgKGlzRE9NU2VsZWN0aW9uKGRvbVJhbmdlKSkge1xuICAgICAgICBhbmNob3JOb2RlID0gZG9tUmFuZ2UuYW5jaG9yTm9kZTtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2UuYW5jaG9yT2Zmc2V0O1xuICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5mb2N1c05vZGU7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gZG9tUmFuZ2UuZm9jdXNPZmZzZXQ7IC8vIENPTVBBVDogVGhlcmUncyBhIGJ1ZyBpbiBjaHJvbWUgdGhhdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICAgIC8vIGBpc0NvbGxhcHNlZGAgZm9yIGEgU2VsZWN0aW9uIHRoYXQgY29tZXMgZnJvbSBhIFNoYWRvd1Jvb3QuXG4gICAgICAgIC8vICgyMDIwLzA4LzA4KVxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc1MjNcblxuICAgICAgICBpZiAoSVNfQ0hST01FICYmIGhhc1NoYWRvd1Jvb3QoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmFuY2hvck5vZGUgPT09IGRvbVJhbmdlLmZvY3VzTm9kZSAmJiBkb21SYW5nZS5hbmNob3JPZmZzZXQgPT09IGRvbVJhbmdlLmZvY3VzT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuaXNDb2xsYXBzZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuY29sbGFwc2VkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbmNob3JOb2RlID09IG51bGwgfHwgZm9jdXNOb2RlID09IG51bGwgfHwgYW5jaG9yT2Zmc2V0ID09IG51bGwgfHwgZm9jdXNPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIERPTSByYW5nZTogXCIuY29uY2F0KGRvbVJhbmdlKSk7XG4gICAgfSAvLyBDT01QQVQ6IFRyaXBsZS1jbGlja2luZyBhIHdvcmQgaW4gY2hyb21lIHdpbGwgc29tZXRpbWVzIHBsYWNlIHRoZSBmb2N1c1xuICAgIC8vIGluc2lkZSBhIGBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiYCBET00gbm9kZSBmb2xsb3dpbmcgdGhlIHdvcmQsIHdoaWNoXG4gICAgLy8gd2lsbCBjYXVzZSBgdG9TbGF0ZVBvaW50YCB0byB0aHJvdyBhbiBlcnJvci4gKDIwMjMvMDMvMDcpXG5cblxuICAgIGlmICgnZ2V0QXR0cmlidXRlJyBpbiBmb2N1c05vZGUgJiYgZm9jdXNOb2RlLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScpIHtcbiAgICAgIHZhciBfYW5jaG9yTm9kZSR0ZXh0Q29udGU7XG5cbiAgICAgIGZvY3VzTm9kZSA9IGFuY2hvck5vZGU7XG4gICAgICBmb2N1c09mZnNldCA9ICgoX2FuY2hvck5vZGUkdGV4dENvbnRlID0gYW5jaG9yTm9kZS50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgX2FuY2hvck5vZGUkdGV4dENvbnRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYW5jaG9yTm9kZSR0ZXh0Q29udGUubGVuZ3RoKSB8fCAwO1xuICAgIH1cblxuICAgIHZhciBhbmNob3IgPSBSZWFjdEVkaXRvci50b1NsYXRlUG9pbnQoZWRpdG9yLCBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XSwge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9KTtcblxuICAgIGlmICghYW5jaG9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFuY2hvciA6IFJlYWN0RWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSwge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9KTtcblxuICAgIGlmICghZm9jdXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIHN1cHBvc2Ugd2UgaGF2ZSB0aGlzIGRvY3VtZW50OlxyXG4gICAgICpcclxuICAgICAqIHsgdHlwZTogJ3BhcmFncmFwaCcsXHJcbiAgICAgKiAgIGNoaWxkcmVuOiBbXHJcbiAgICAgKiAgICAgeyB0ZXh0OiAnZm9vICcgfSxcclxuICAgICAqICAgICB7IHRleHQ6ICdiYXInIH0sXHJcbiAgICAgKiAgICAgeyB0ZXh0OiAnIGJheicgfVxyXG4gICAgICogICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogYSBkb3VibGUgY2xpY2sgb24gXCJiYXJcIiBvbiBjaHJvbWUgd2lsbCBjcmVhdGUgdGhpcyByYW5nZTpcclxuICAgICAqXHJcbiAgICAgKiBhbmNob3IgLT4gWzAsMV0gb2Zmc2V0IDBcclxuICAgICAqIGZvY3VzICAtPiBbMCwxXSBvZmZzZXQgM1xyXG4gICAgICpcclxuICAgICAqIHdoaWxlIG9uIGZpcmVmb3ggd2lsbCBjcmVhdGUgdGhpcyByYW5nZTpcclxuICAgICAqXHJcbiAgICAgKiBhbmNob3IgLT4gWzAsMF0gb2Zmc2V0IDRcclxuICAgICAqIGZvY3VzICAtPiBbMCwyXSBvZmZzZXQgMFxyXG4gICAgICpcclxuICAgICAqIGxldCdzIHRyeSB0byBmaXggaXQuLi5cclxuICAgICAqL1xuXG5cbiAgICBpZiAoSVNfRklSRUZPWCAmJiAhaXNDb2xsYXBzZWQgJiYgYW5jaG9yTm9kZSAhPT0gZm9jdXNOb2RlKSB7XG4gICAgICB2YXIgaXNFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhbmNob3IsIGFuY2hvci5wYXRoKTtcbiAgICAgIHZhciBpc1N0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBmb2N1cywgZm9jdXMucGF0aCk7XG5cbiAgICAgIGlmIChpc0VuZCkge1xuICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhbmNob3IpOyAvLyBFZGl0b3IuYWZ0ZXIoKSBtaWdodCByZXR1cm4gdW5kZWZpbmVkXG5cbiAgICAgICAgYW5jaG9yID0gYWZ0ZXIgfHwgYW5jaG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdGFydCkge1xuICAgICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGZvY3VzKTtcbiAgICAgICAgZm9jdXMgPSBiZWZvcmUgfHwgZm9jdXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJhbmdlID0ge1xuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBmb2N1czogZm9jdXNcbiAgICB9OyAvLyBpZiB0aGUgc2VsZWN0aW9uIGlzIGEgaGFuZ2luZyByYW5nZSB0aGF0IGVuZHMgaW4gYSB2b2lkXG4gICAgLy8gYW5kIHRoZSBET00gZm9jdXMgaXMgYW4gRWxlbWVudFxuICAgIC8vIChtZWFuaW5nIHRoYXQgdGhlIHNlbGVjdGlvbiBlbmRzIGJlZm9yZSB0aGUgZWxlbWVudClcbiAgICAvLyB1bmhhbmcgdGhlIHJhbmdlIHRvIGF2b2lkIG1pc3Rha2VubHkgaW5jbHVkaW5nIHRoZSB2b2lkXG5cbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChyYW5nZSkgJiYgUmFuZ2UuaXNGb3J3YXJkKHJhbmdlKSAmJiBpc0RPTUVsZW1lbnQoZm9jdXNOb2RlKSAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZS5mb2N1cyxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pKSB7XG4gICAgICByYW5nZSA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlLCB7XG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH0sXG5cbiAgaGFzUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBhbmNob3IucGF0aCkgJiYgRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBmb2N1cy5wYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGluIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGhhc1RhcmdldChlZGl0b3IsIHRhcmdldCkge1xuICAgIHJldHVybiBpc0RPTU5vZGUodGFyZ2V0KSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGVkaXRhYmxlIGFuZCBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBoYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIHRhcmdldCkge1xuICAgIHJldHVybiBpc0RPTU5vZGUodGFyZ2V0KSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0LCB7XG4gICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSB0YXJnZXQgY2FuIGJlIHNlbGVjdGFibGVcclxuICAgKi9cbiAgaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIHRhcmdldCkge1xuICAgIHJldHVybiBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIHRhcmdldCkgfHwgUmVhY3RFZGl0b3IuaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQoZWRpdG9yLCB0YXJnZXQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSB0YXJnZXQgaXMgaW5zaWRlIHZvaWQgYW5kIGluIGFuIG5vbi1yZWFkb25seSBlZGl0b3IuXHJcbiAgICovXG4gIGlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkKGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgaWYgKElTX1JFQURfT05MWS5nZXQoZWRpdG9yKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzbGF0ZU5vZGUgPSBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCB0YXJnZXQpICYmIFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgdGFyZ2V0KTtcbiAgICByZXR1cm4gRWxlbWVudCQxLmlzRWxlbWVudChzbGF0ZU5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEV4cGVyaW1lbnRhbCBhbmQgYW5kcm9pZCBzcGVjaWZpYzogRmx1c2ggYWxsIHBlbmRpbmcgZGlmZnMgYW5kIGNhbmNlbCBjb21wb3NpdGlvbiBhdCB0aGUgbmV4dCBwb3NzaWJsZSB0aW1lLlxyXG4gICAqL1xuICBhbmRyb2lkU2NoZWR1bGVGbHVzaChlZGl0b3IpIHtcbiAgICB2YXIgX0VESVRPUl9UT19TQ0hFRFVMRV9GO1xuXG4gICAgKF9FRElUT1JfVE9fU0NIRURVTEVfRiA9IEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1NDSEVEVUxFX0YoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBFeHBlcmltZW50YWwgYW5kIGFuZHJvaWQgc3BlY2lmaWM6IEdldCBwZW5kaW5nIGRpZmZzXHJcbiAgICovXG4gIGFuZHJvaWRQZW5kaW5nRGlmZnMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdLFxuICAgIF9leGNsdWRlZDIkMSA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xudmFyIHNoYWxsb3dDb21wYXJlID0gKG9iajEsIG9iajIpID0+IE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoICYmIE9iamVjdC5rZXlzKG9iajEpLmV2ZXJ5KGtleSA9PiBvYmoyLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqMVtrZXldID09PSBvYmoyW2tleV0pO1xuXG52YXIgaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbCA9IChyYW5nZSwgb3RoZXIpID0+IHtcbiAgdmFyIHJhbmdlT3duUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmFuZ2UsIF9leGNsdWRlZCQzKTtcblxuICB2YXIgb3RoZXJPd25Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvdGhlciwgX2V4Y2x1ZGVkMiQxKTtcblxuICByZXR1cm4gcmFuZ2VbUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gb3RoZXJbUExBQ0VIT0xERVJfU1lNQk9MXSAmJiBzaGFsbG93Q29tcGFyZShyYW5nZU93blByb3BzLCBvdGhlck93blByb3BzKTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBsaXN0IG9mIGRlY29yYXRvciByYW5nZXMgYXJlIGVxdWFsIHRvIGFub3RoZXIuXHJcbiAqXHJcbiAqIFBFUkY6IHRoaXMgcmVxdWlyZXMgdGhlIHR3byBsaXN0cyB0byBhbHNvIGhhdmUgdGhlIHJhbmdlcyBpbnNpZGUgdGhlbSBpbiB0aGVcclxuICogc2FtZSBvcmRlciwgYnV0IHRoaXMgaXMgYW4gb2theSBjb25zdHJhaW50IGZvciB1cyBzaW5jZSBkZWNvcmF0aW9ucyBhcmVcclxuICoga2VwdCBpbiBvcmRlciwgYW5kIHRoZSBvZGQgY2FzZSB3aGVyZSB0aGV5IGFyZW4ndCBpcyBva2F5IHRvIHJlLXJlbmRlciBmb3IuXHJcbiAqL1xuXG5cbnZhciBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsID0gKGxpc3QsIGFub3RoZXIpID0+IHtcbiAgaWYgKGxpc3QubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByYW5nZSA9IGxpc3RbaV07XG4gICAgdmFyIG90aGVyID0gYW5vdGhlcltpXTtcblxuICAgIGlmICghUmFuZ2UuZXF1YWxzKHJhbmdlLCBvdGhlcikgfHwgIWlzRGVjb3JhdGlvbkZsYWdzRXF1YWwocmFuZ2UsIG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGxpc3Qgb2YgZGVjb3JhdG9yIHJhbmdlcyBhcmUgZXF1YWwgdG8gYW5vdGhlci5cclxuICpcclxuICogUEVSRjogdGhpcyByZXF1aXJlcyB0aGUgdHdvIGxpc3RzIHRvIGFsc28gaGF2ZSB0aGUgcmFuZ2VzIGluc2lkZSB0aGVtIGluIHRoZVxyXG4gKiBzYW1lIG9yZGVyLCBidXQgdGhpcyBpcyBhbiBva2F5IGNvbnN0cmFpbnQgZm9yIHVzIHNpbmNlIGRlY29yYXRpb25zIGFyZVxyXG4gKiBrZXB0IGluIG9yZGVyLCBhbmQgdGhlIG9kZCBjYXNlIHdoZXJlIHRoZXkgYXJlbid0IGlzIG9rYXkgdG8gcmUtcmVuZGVyIGZvci5cclxuICovXG5cbnZhciBpc1RleHREZWNvcmF0aW9uc0VxdWFsID0gKGxpc3QsIGFub3RoZXIpID0+IHtcbiAgaWYgKGxpc3QubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByYW5nZSA9IGxpc3RbaV07XG4gICAgdmFyIG90aGVyID0gYW5vdGhlcltpXTsgLy8gY29tcGFyZSBvbmx5IG9mZnNldHMgYmVjYXVzZSBwYXRocyBkb2Vzbid0IG1hdHRlciBmb3IgdGV4dFxuXG4gICAgaWYgKHJhbmdlLmFuY2hvci5vZmZzZXQgIT09IG90aGVyLmFuY2hvci5vZmZzZXQgfHwgcmFuZ2UuZm9jdXMub2Zmc2V0ICE9PSBvdGhlci5mb2N1cy5vZmZzZXQgfHwgIWlzRGVjb3JhdGlvbkZsYWdzRXF1YWwocmFuZ2UsIG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXHJcbiAqIFByZXZlbnQgd2FybmluZyBvbiBTU1IgYnkgZmFsbGluZyBiYWNrIHRvIHVzZUVmZmVjdCB3aGVuIERPTSBpc24ndCBhdmFpbGFibGVcclxuICovXG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxyXG4gKiBMZWFmIGNvbnRlbnQgc3RyaW5ncy5cclxuICovXG5cbnZhciBTdHJpbmcgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgaXNMYXN0LFxuICAgIGxlYWYsXG4gICAgcGFyZW50LFxuICAgIHRleHRcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIHRleHQpO1xuICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KHBhdGgpO1xuICB2YXIgaXNNYXJrUGxhY2Vob2xkZXIgPSBsZWFmW01BUktfUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gdHJ1ZTsgLy8gQ09NUEFUOiBSZW5kZXIgdGV4dCBpbnNpZGUgdm9pZCBub2RlcyB3aXRoIGEgemVyby13aWR0aCBzcGFjZS5cbiAgLy8gU28gdGhlIG5vZGUgY2FuIGNvbnRhaW4gc2VsZWN0aW9uIGJ1dCB0aGUgdGV4dCBpcyBub3QgdmlzaWJsZS5cblxuICBpZiAoZWRpdG9yLmlzVm9pZChwYXJlbnQpKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFplcm9XaWR0aFN0cmluZywge1xuICAgICAgbGVuZ3RoOiBOb2RlLnN0cmluZyhwYXJlbnQpLmxlbmd0aFxuICAgIH0pO1xuICB9IC8vIENPTVBBVDogSWYgdGhpcyBpcyB0aGUgbGFzdCB0ZXh0IG5vZGUgaW4gYW4gZW1wdHkgYmxvY2ssIHJlbmRlciBhIHplcm8tXG4gIC8vIHdpZHRoIHNwYWNlIHRoYXQgd2lsbCBjb252ZXJ0IGludG8gYSBsaW5lIGJyZWFrIHdoZW4gY29weWluZyBhbmQgcGFzdGluZ1xuICAvLyB0byBzdXBwb3J0IGV4cGVjdGVkIHBsYWluIHRleHQuXG5cblxuICBpZiAobGVhZi50ZXh0ID09PSAnJyAmJiBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdID09PSB0ZXh0ICYmICFlZGl0b3IuaXNJbmxpbmUocGFyZW50KSAmJiBFZGl0b3Iuc3RyaW5nKGVkaXRvciwgcGFyZW50UGF0aCkgPT09ICcnKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFplcm9XaWR0aFN0cmluZywge1xuICAgICAgaXNMaW5lQnJlYWs6IHRydWUsXG4gICAgICBpc01hcmtQbGFjZWhvbGRlcjogaXNNYXJrUGxhY2Vob2xkZXJcbiAgICB9KTtcbiAgfSAvLyBDT01QQVQ6IElmIHRoZSB0ZXh0IGlzIGVtcHR5LCBpdCdzIGJlY2F1c2UgaXQncyBvbiB0aGUgZWRnZSBvZiBhbiBpbmxpbmVcbiAgLy8gbm9kZSwgc28gd2UgcmVuZGVyIGEgemVyby13aWR0aCBzcGFjZSBzbyB0aGF0IHRoZSBzZWxlY3Rpb24gY2FuIGJlXG4gIC8vIGluc2VydGVkIG5leHQgdG8gaXQgc3RpbGwuXG5cblxuICBpZiAobGVhZi50ZXh0ID09PSAnJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGlzTWFya1BsYWNlaG9sZGVyOiBpc01hcmtQbGFjZWhvbGRlclxuICAgIH0pO1xuICB9IC8vIENPTVBBVDogQnJvd3NlcnMgd2lsbCBjb2xsYXBzZSB0cmFpbGluZyBuZXcgbGluZXMgYXQgdGhlIGVuZCBvZiBibG9ja3MsXG4gIC8vIHNvIHdlIG5lZWQgdG8gYWRkIGFuIGV4dHJhIHRyYWlsaW5nIG5ldyBsaW5lcyB0byBwcmV2ZW50IHRoYXQuXG5cblxuICBpZiAoaXNMYXN0ICYmIGxlYWYudGV4dC5zbGljZSgtMSkgPT09ICdcXG4nKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRleHRTdHJpbmcsIHtcbiAgICAgIGlzVHJhaWxpbmc6IHRydWUsXG4gICAgICB0ZXh0OiBsZWFmLnRleHRcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0U3RyaW5nLCB7XG4gICAgdGV4dDogbGVhZi50ZXh0XG4gIH0pO1xufTtcbi8qKlxyXG4gKiBMZWFmIHN0cmluZ3Mgd2l0aCB0ZXh0IGluIHRoZW0uXHJcbiAqL1xuXG5cbnZhciBUZXh0U3RyaW5nID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIHRleHQsXG4gICAgaXNUcmFpbGluZyA9IGZhbHNlXG4gIH0gPSBwcm9wcztcbiAgdmFyIHJlZiA9IHVzZVJlZihudWxsKTtcblxuICB2YXIgZ2V0VGV4dENvbnRlbnQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHRleHQgIT09IG51bGwgJiYgdGV4dCAhPT0gdm9pZCAwID8gdGV4dCA6ICcnKS5jb25jYXQoaXNUcmFpbGluZyA/ICdcXG4nIDogJycpO1xuICB9O1xuXG4gIHZhciBbaW5pdGlhbFRleHRdID0gdXNlU3RhdGUoZ2V0VGV4dENvbnRlbnQpOyAvLyBUaGlzIGlzIHRoZSBhY3R1YWwgdGV4dCByZW5kZXJpbmcgYm91bmRhcnkgd2hlcmUgd2UgaW50ZXJmYWNlIHdpdGggdGhlIERPTVxuICAvLyBUaGUgdGV4dCBpcyBub3QgcmVuZGVyZWQgYXMgcGFydCBvZiB0aGUgdmlydHVhbCBET00sIGFzIHNpbmNlIHdlIGhhbmRsZSBiYXNpYyBjaGFyYWN0ZXIgaW5zZXJ0aW9ucyBuYXRpdmVseSxcbiAgLy8gdXBkYXRpbmcgdGhlIERPTSBpcyBub3QgYSBvbmUgd2F5IGRhdGFmbG93IGFueW1vcmUuIFdoYXQgd2UgbmVlZCBoZXJlIGlzIG5vdCByZWNvbmNpbGlhdGlvbiBhbmQgZGlmZmluZ1xuICAvLyB3aXRoIHByZXZpb3VzIHZlcnNpb24gb2YgdGhlIHZpcnR1YWwgRE9NLCBidXQgcmF0aGVyIGRpZmZpbmcgd2l0aCB0aGUgYWN0dWFsIERPTSBlbGVtZW50LCBhbmQgcmVwbGFjZSB0aGUgRE9NIDxzcGFuPiBjb250ZW50XG4gIC8vIGV4YWN0bHkgaWYgYW5kIG9ubHkgaWYgaXRzIGN1cnJlbnQgY29udGVudCBkb2VzIG5vdCBtYXRjaCBvdXIgY3VycmVudCB2aXJ0dWFsIERPTS5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBET00gVGV4dE5vZGUgd291bGQgYWx3YXlzIGJlIHJlcGxhY2VkIGJ5IFJlYWN0IGFzIHRoZSB1c2VyIHR5cGVzLCB3aGljaCBpbnRlcmZlcmVzIHdpdGggbmF0aXZlIHRleHQgZmVhdHVyZXMsXG4gIC8vIGVnIG1ha2VzIG5hdGl2ZSBzcGVsbGNoZWNrIG9wdCBvdXQgZnJvbSBjaGVja2luZyB0aGUgdGV4dCBub2RlLlxuICAvLyB1c2VMYXlvdXRFZmZlY3Q6IHVwZGF0aW5nIG91ciBzcGFuIGJlZm9yZSBicm93c2VyIHBhaW50XG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgLy8gbnVsbCBjb2FsZXNjaW5nIHRleHQgdG8gbWFrZSBzdXJlIHdlJ3JlIG5vdCBvdXRwdXRpbmcgXCJudWxsXCIgYXMgYSBzdHJpbmcgaW4gdGhlIGV4dHJlbWUgY2FzZSBpdCBpcyBudWxsaXNoIGF0IHJ1bnRpbWVcbiAgICB2YXIgdGV4dFdpdGhUcmFpbGluZyA9IGdldFRleHRDb250ZW50KCk7XG5cbiAgICBpZiAocmVmLmN1cnJlbnQgJiYgcmVmLmN1cnJlbnQudGV4dENvbnRlbnQgIT09IHRleHRXaXRoVHJhaWxpbmcpIHtcbiAgICAgIHJlZi5jdXJyZW50LnRleHRDb250ZW50ID0gdGV4dFdpdGhUcmFpbGluZztcbiAgICB9IC8vIGludGVudGlvbmFsbHkgbm90IHNwZWNpZnlpbmcgZGVwZW5kZW5jaWVzLCBzbyB0aGF0IHRoaXMgZWZmZWN0IHJ1bnMgb24gZXZlcnkgcmVuZGVyXG4gICAgLy8gYXMgdGhpcyBlZmZlY3RpdmVseSByZXBsYWNlcyBcInNwZWNpZnlpbmcgdGhlIHRleHQgaW4gdGhlIHZpcnR1YWwgRE9NIHVuZGVyIHRoZSA8c3Bhbj4gYmVsb3dcIiBvbiBlYWNoIHJlbmRlclxuXG4gIH0pOyAvLyBXZSBpbnRlbnRpb25hbGx5IHJlbmRlciBhIG1lbW9pemVkIDxzcGFuPiB0aGF0IG9ubHkgcmVjZWl2ZXMgdGhlIGluaXRpYWwgdGV4dCBjb250ZW50IHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAvLyBXZSBkZWZlciB0byB0aGUgbGF5b3V0IGVmZmVjdCBhYm92ZSB0byB1cGRhdGUgdGhlIGB0ZXh0Q29udGVudGAgb2YgdGhlIHNwYW4gZWxlbWVudCB3aGVuIG5lZWRlZC5cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0JDEsIHtcbiAgICByZWY6IHJlZlxuICB9LCBpbml0aWFsVGV4dCk7XG59O1xuXG52YXIgTWVtb2l6ZWRUZXh0JDEgPSAvKiNfX1BVUkVfXyovbWVtbyggLyojX19QVVJFX18qL2ZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJkYXRhLXNsYXRlLXN0cmluZ1wiOiB0cnVlLFxuICAgIHJlZjogcmVmXG4gIH0sIHByb3BzLmNoaWxkcmVuKTtcbn0pKTtcbi8qKlxyXG4gKiBMZWFmIHN0cmluZ3Mgd2l0aG91dCB0ZXh0LCByZW5kZXIgYXMgemVyby13aWR0aCBzdHJpbmdzLlxyXG4gKi9cblxudmFyIFplcm9XaWR0aFN0cmluZyA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBsZW5ndGggPSAwLFxuICAgIGlzTGluZUJyZWFrID0gZmFsc2UsXG4gICAgaXNNYXJrUGxhY2Vob2xkZXIgPSBmYWxzZVxuICB9ID0gcHJvcHM7XG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICdkYXRhLXNsYXRlLXplcm8td2lkdGgnOiBpc0xpbmVCcmVhayA/ICduJyA6ICd6JyxcbiAgICAnZGF0YS1zbGF0ZS1sZW5ndGgnOiBsZW5ndGhcbiAgfTtcblxuICBpZiAoaXNNYXJrUGxhY2Vob2xkZXIpIHtcbiAgICBhdHRyaWJ1dGVzWydkYXRhLXNsYXRlLW1hcmstcGxhY2Vob2xkZXInXSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCAhSVNfQU5EUk9JRCB8fCAhaXNMaW5lQnJlYWsgPyAnXFx1RkVGRicgOiBudWxsLCBpc0xpbmVCcmVhayA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnJcIiwgbnVsbCkgOiBudWxsKTtcbn07XG5cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGVkaXRvciBvYmplY3QuXHJcbiAqL1xuXG52YXIgRWRpdG9yQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBlZGl0b3Igb2JqZWN0IGZyb20gdGhlIFJlYWN0IGNvbnRleHQuXHJcbiAqL1xuXG52YXIgdXNlU2xhdGVTdGF0aWMgPSAoKSA9PiB7XG4gIHZhciBlZGl0b3IgPSB1c2VDb250ZXh0KEVkaXRvckNvbnRleHQpO1xuXG4gIGlmICghZWRpdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VTbGF0ZVN0YXRpY2AgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbi8qKlxyXG4gKiBJbmRpdmlkdWFsIGxlYXZlcyBpbiBhIHRleHQgbm9kZSB3aXRoIHVuaXF1ZSBmb3JtYXR0aW5nLlxyXG4gKi9cblxudmFyIExlYWYgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgbGVhZixcbiAgICBpc0xhc3QsXG4gICAgdGV4dCxcbiAgICBwYXJlbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZiA9IHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRMZWFmLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpXG4gIH0gPSBwcm9wcztcbiAgdmFyIGxhc3RQbGFjZWhvbGRlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHBsYWNlaG9sZGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIgPSB1c2VSZWYobnVsbCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQpIHtcbiAgICAgICAgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIHBsYWNlaG9sZGVyRWwgPSBwbGFjZWhvbGRlclJlZiA9PT0gbnVsbCB8fCBwbGFjZWhvbGRlclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGxhY2Vob2xkZXJSZWYuY3VycmVudDtcblxuICAgIGlmIChwbGFjZWhvbGRlckVsKSB7XG4gICAgICBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVC5zZXQoZWRpdG9yLCBwbGFjZWhvbGRlckVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudCkge1xuICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIG9ic2VydmVyLlxuICAgICAgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgIGlmIChwbGFjZWhvbGRlckVsKSBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQub2JzZXJ2ZShwbGFjZWhvbGRlckVsKTtcbiAgICB9IGVsc2UgaWYgKHBsYWNlaG9sZGVyRWwpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBvYnNlcnZlciBhbmQgb2JzZXJ2ZSB0aGUgcGxhY2Vob2xkZXIgZWxlbWVudC5cbiAgICAgIHZhciBSZXNpemVPYnNlcnZlciQxID0gd2luZG93LlJlc2l6ZU9ic2VydmVyIHx8IFJlc2l6ZU9ic2VydmVyO1xuICAgICAgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyJDEoKCkgPT4ge1xuICAgICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlciBvZiB0aGUgZWRpdG9yIHNvIGl0cyBtaW4taGVpZ2h0IGNhbiBiZSB1cGRhdGVkXG4gICAgICAgIC8vIHRvIHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgdmFyIGZvcmNlUmVuZGVyID0gRURJVE9SX1RPX0ZPUkNFX1JFTkRFUi5nZXQoZWRpdG9yKTtcbiAgICAgICAgZm9yY2VSZW5kZXIgPT09IG51bGwgfHwgZm9yY2VSZW5kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcmNlUmVuZGVyKCk7XG4gICAgICB9KTtcbiAgICAgIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudC5vYnNlcnZlKHBsYWNlaG9sZGVyRWwpO1xuICAgIH1cblxuICAgIGlmICghcGxhY2Vob2xkZXJFbCAmJiBsYXN0UGxhY2Vob2xkZXJSZWYuY3VycmVudCkge1xuICAgICAgLy8gTm8gcGxhY2Vob2xkZXIgZWxlbWVudCwgc28gbm8gbmVlZCBmb3IgYSByZXNpemUgb2JzZXJ2ZXIuXG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlciBvZiB0aGUgZWRpdG9yIHNvIGl0cyBtaW4taGVpZ2h0IGNhbiBiZSByZXNldC5cbiAgICAgIHZhciBmb3JjZVJlbmRlciA9IEVESVRPUl9UT19GT1JDRV9SRU5ERVIuZ2V0KGVkaXRvcik7XG4gICAgICBmb3JjZVJlbmRlciA9PT0gbnVsbCB8fCBmb3JjZVJlbmRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9yY2VSZW5kZXIoKTtcbiAgICB9XG5cbiAgICBsYXN0UGxhY2Vob2xkZXJSZWYuY3VycmVudCA9IHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQ7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgIH07XG4gIH0sIFtwbGFjZWhvbGRlclJlZiwgbGVhZl0pO1xuICB2YXIgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTdHJpbmcsIHtcbiAgICBpc0xhc3Q6IGlzTGFzdCxcbiAgICBsZWFmOiBsZWFmLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHRleHQ6IHRleHRcbiAgfSk7XG5cbiAgaWYgKGxlYWZbUExBQ0VIT0xERVJfU1lNQk9MXSkge1xuICAgIHZhciBwbGFjZWhvbGRlclByb3BzID0ge1xuICAgICAgY2hpbGRyZW46IGxlYWYucGxhY2Vob2xkZXIsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICdkYXRhLXNsYXRlLXBsYWNlaG9sZGVyJzogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgb3BhY2l0eTogJzAuMzMzJyxcbiAgICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgICAgdGV4dERlY29yYXRpb246ICdub25lJ1xuICAgICAgICB9LFxuICAgICAgICBjb250ZW50RWRpdGFibGU6IGZhbHNlLFxuICAgICAgICByZWY6IHBsYWNlaG9sZGVyUmVmXG4gICAgICB9XG4gICAgfTtcbiAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZW5kZXJQbGFjZWhvbGRlcihwbGFjZWhvbGRlclByb3BzKSwgY2hpbGRyZW4pO1xuICB9IC8vIENPTVBBVDogSGF2aW5nIHRoZSBgZGF0YS1gIGF0dHJpYnV0ZXMgb24gdGhlc2UgbGVhZiBlbGVtZW50cyBlbnN1cmVzIHRoYXRcbiAgLy8gaW4gY2VydGFpbiBtaXNiZWhhdmluZyBicm93c2VycyB0aGV5IGFyZW4ndCB3ZWlyZGx5IGNsb25lZC9kZXN0cm95ZWQgYnlcbiAgLy8gY29udGVudGVkaXRhYmxlIGJlaGF2aW9ycy4gKDIwMTkvMDUvMDgpXG5cblxuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS1sZWFmJzogdHJ1ZVxuICB9O1xuICByZXR1cm4gcmVuZGVyTGVhZih7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbixcbiAgICBsZWFmLFxuICAgIHRleHRcbiAgfSk7XG59O1xuXG52YXIgTWVtb2l6ZWRMZWFmID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oTGVhZiwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIG5leHQucGFyZW50ID09PSBwcmV2LnBhcmVudCAmJiBuZXh0LmlzTGFzdCA9PT0gcHJldi5pc0xhc3QgJiYgbmV4dC5yZW5kZXJMZWFmID09PSBwcmV2LnJlbmRlckxlYWYgJiYgbmV4dC5yZW5kZXJQbGFjZWhvbGRlciA9PT0gcHJldi5yZW5kZXJQbGFjZWhvbGRlciAmJiBuZXh0LnRleHQgPT09IHByZXYudGV4dCAmJiBUZXh0JDEuZXF1YWxzKG5leHQubGVhZiwgcHJldi5sZWFmKSAmJiBuZXh0LmxlYWZbUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gcHJldi5sZWFmW1BMQUNFSE9MREVSX1NZTUJPTF07XG59KTtcbnZhciBEZWZhdWx0TGVhZiA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgY2hpbGRyZW4pO1xufTtcblxuLyoqXHJcbiAqIFRleHQuXHJcbiAqL1xuXG52YXIgVGV4dCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBpc0xhc3QsXG4gICAgcGFyZW50LFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYsXG4gICAgdGV4dFxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgbGVhdmVzID0gVGV4dCQxLmRlY29yYXRpb25zKHRleHQsIGRlY29yYXRpb25zKTtcbiAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCB0ZXh0KTtcbiAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGVhZiA9IGxlYXZlc1tpXTtcbiAgICBjaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZExlYWYsIHtcbiAgICAgIGlzTGFzdDogaXNMYXN0ICYmIGkgPT09IGxlYXZlcy5sZW5ndGggLSAxLFxuICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXkuaWQsIFwiLVwiKS5jb25jYXQoaSksXG4gICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICBsZWFmOiBsZWFmLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZlxuICAgIH0pKTtcbiAgfSAvLyBVcGRhdGUgZWxlbWVudC1yZWxhdGVkIHdlYWsgbWFwcyB3aXRoIHRoZSBET00gZWxlbWVudCByZWYuXG5cblxuICB2YXIgY2FsbGJhY2tSZWYgPSB1c2VDYWxsYmFjayhzcGFuID0+IHtcbiAgICB2YXIgS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoc3Bhbikge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULnNldChrZXksIHNwYW4pO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldCh0ZXh0LCBzcGFuKTtcbiAgICAgIEVMRU1FTlRfVE9fTk9ERS5zZXQoc3BhbiwgdGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVC5kZWxldGUoa2V5KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUodGV4dCk7XG5cbiAgICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgICBFTEVNRU5UX1RPX05PREUuZGVsZXRlKHJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWYuY3VycmVudCA9IHNwYW47XG4gIH0sIFtyZWYsIGVkaXRvciwga2V5LCB0ZXh0XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIFwiZGF0YS1zbGF0ZS1ub2RlXCI6IFwidGV4dFwiLFxuICAgIHJlZjogY2FsbGJhY2tSZWZcbiAgfSwgY2hpbGRyZW4pO1xufTtcblxudmFyIE1lbW9pemVkVGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKFRleHQsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBuZXh0LnBhcmVudCA9PT0gcHJldi5wYXJlbnQgJiYgbmV4dC5pc0xhc3QgPT09IHByZXYuaXNMYXN0ICYmIG5leHQucmVuZGVyTGVhZiA9PT0gcHJldi5yZW5kZXJMZWFmICYmIG5leHQucmVuZGVyUGxhY2Vob2xkZXIgPT09IHByZXYucmVuZGVyUGxhY2Vob2xkZXIgJiYgbmV4dC50ZXh0ID09PSBwcmV2LnRleHQgJiYgaXNUZXh0RGVjb3JhdGlvbnNFcXVhbChuZXh0LmRlY29yYXRpb25zLCBwcmV2LmRlY29yYXRpb25zKTtcbn0pO1xuXG4vKipcclxuICogRWxlbWVudC5cclxuICovXG5cbnZhciBFbGVtZW50ID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGRlY29yYXRpb25zLFxuICAgIGVsZW1lbnQsXG4gICAgcmVuZGVyRWxlbWVudCA9IHAgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdEVsZW1lbnQsIE9iamVjdC5hc3NpZ24oe30sIHApKSxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmLFxuICAgIHNlbGVjdGlvblxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcmVhZE9ubHkgPSB1c2VSZWFkT25seSgpO1xuICB2YXIgaXNJbmxpbmUgPSBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCk7XG4gIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgZWxlbWVudCk7XG4gIHZhciByZWYgPSB1c2VDYWxsYmFjayhyZWYgPT4ge1xuICAgIC8vIFVwZGF0ZSBlbGVtZW50LXJlbGF0ZWQgd2VhayBtYXBzIHdpdGggdGhlIERPTSBlbGVtZW50IHJlZi5cbiAgICB2YXIgS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAocmVmKSB7XG4gICAgICBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogS0VZX1RPX0VMRU1FTlQuc2V0KGtleSwgcmVmKTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5zZXQoZWxlbWVudCwgcmVmKTtcbiAgICAgIEVMRU1FTlRfVE9fTk9ERS5zZXQocmVmLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULmRlbGV0ZShrZXkpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZShlbGVtZW50KTtcbiAgICB9XG4gIH0sIFtlZGl0b3IsIGtleSwgZWxlbWVudF0pO1xuICB2YXIgY2hpbGRyZW4gPSB1c2VDaGlsZHJlbih7XG4gICAgZGVjb3JhdGlvbnMsXG4gICAgbm9kZTogZWxlbWVudCxcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uXG4gIH0pOyAvLyBBdHRyaWJ1dGVzIHRoYXQgdGhlIGRldmVsb3BlciBtdXN0IG1peCBpbnRvIHRoZSBlbGVtZW50IGluIHRoZWlyXG4gIC8vIGN1c3RvbSBub2RlIHJlbmRlcmVyIGNvbXBvbmVudC5cblxuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS1ub2RlJzogJ2VsZW1lbnQnLFxuICAgIHJlZlxuICB9O1xuXG4gIGlmIChpc0lubGluZSkge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtaW5saW5lJ10gPSB0cnVlO1xuICB9IC8vIElmIGl0J3MgYSBibG9jayBub2RlIHdpdGggaW5saW5lIGNoaWxkcmVuLCBhZGQgdGhlIHByb3BlciBgZGlyYCBhdHRyaWJ1dGVcbiAgLy8gZm9yIHRleHQgZGlyZWN0aW9uLlxuXG5cbiAgaWYgKCFpc0lubGluZSAmJiBFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpKSB7XG4gICAgdmFyIHRleHQgPSBOb2RlLnN0cmluZyhlbGVtZW50KTtcbiAgICB2YXIgZGlyID0gZ2V0RGlyZWN0aW9uKHRleHQpO1xuXG4gICAgaWYgKGRpciA9PT0gJ3J0bCcpIHtcbiAgICAgIGF0dHJpYnV0ZXMuZGlyID0gZGlyO1xuICAgIH1cbiAgfSAvLyBJZiBpdCdzIGEgdm9pZCBub2RlLCB3cmFwIHRoZSBjaGlsZHJlbiBpbiBleHRyYSB2b2lkLXNwZWNpZmljIGVsZW1lbnRzLlxuXG5cbiAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBlbGVtZW50KSkge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtdm9pZCddID0gdHJ1ZTtcblxuICAgIGlmICghcmVhZE9ubHkgJiYgaXNJbmxpbmUpIHtcbiAgICAgIGF0dHJpYnV0ZXMuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIFRhZyA9IGlzSW5saW5lID8gJ3NwYW4nIDogJ2Rpdic7XG4gICAgdmFyIFtbX3RleHRdXSA9IE5vZGUudGV4dHMoZWxlbWVudCk7XG4gICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICAgIFwiZGF0YS1zbGF0ZS1zcGFjZXJcIjogdHJ1ZSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGhlaWdodDogJzAnLFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgfVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkVGV4dCwge1xuICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgZGVjb3JhdGlvbnM6IFtdLFxuICAgICAgaXNMYXN0OiBmYWxzZSxcbiAgICAgIHBhcmVudDogZWxlbWVudCxcbiAgICAgIHRleHQ6IF90ZXh0XG4gICAgfSkpO1xuICAgIE5PREVfVE9fSU5ERVguc2V0KF90ZXh0LCAwKTtcbiAgICBOT0RFX1RPX1BBUkVOVC5zZXQoX3RleHQsIGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlckVsZW1lbnQoe1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgZWxlbWVudFxuICB9KTtcbn07XG5cbnZhciBNZW1vaXplZEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhFbGVtZW50LCAocHJldiwgbmV4dCkgPT4ge1xuICByZXR1cm4gcHJldi5lbGVtZW50ID09PSBuZXh0LmVsZW1lbnQgJiYgcHJldi5yZW5kZXJFbGVtZW50ID09PSBuZXh0LnJlbmRlckVsZW1lbnQgJiYgcHJldi5yZW5kZXJMZWFmID09PSBuZXh0LnJlbmRlckxlYWYgJiYgcHJldi5yZW5kZXJQbGFjZWhvbGRlciA9PT0gbmV4dC5yZW5kZXJQbGFjZWhvbGRlciAmJiBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsKHByZXYuZGVjb3JhdGlvbnMsIG5leHQuZGVjb3JhdGlvbnMpICYmIChwcmV2LnNlbGVjdGlvbiA9PT0gbmV4dC5zZWxlY3Rpb24gfHwgISFwcmV2LnNlbGVjdGlvbiAmJiAhIW5leHQuc2VsZWN0aW9uICYmIFJhbmdlLmVxdWFscyhwcmV2LnNlbGVjdGlvbiwgbmV4dC5zZWxlY3Rpb24pKTtcbn0pO1xuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGVsZW1lbnQgcmVuZGVyZXIuXHJcbiAqL1xuXG52YXIgRGVmYXVsdEVsZW1lbnQgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50XG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBUYWcgPSBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkgPyAnc3BhbicgOiAnZGl2JztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRhZywgT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcywge1xuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH1cbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGBkZWNvcmF0ZWAgcHJvcCBvZiB0aGUgZWRpdGFibGUuXHJcbiAqL1xuXG52YXIgRGVjb3JhdGVDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoKCkgPT4gW10pO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgZGVjb3JhdGVgIHByb3Agb2YgdGhlIGVkaXRhYmxlLlxyXG4gKi9cblxudmFyIHVzZURlY29yYXRlID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChEZWNvcmF0ZUNvbnRleHQpO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYHNlbGVjdGVkYCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gKi9cblxudmFyIFNlbGVjdGVkQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgYHNlbGVjdGVkYCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gKi9cblxudmFyIHVzZVNlbGVjdGVkID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChTZWxlY3RlZENvbnRleHQpO1xufTtcblxuLyoqXHJcbiAqIENoaWxkcmVuLlxyXG4gKi9cblxudmFyIHVzZUNoaWxkcmVuID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGRlY29yYXRpb25zLFxuICAgIG5vZGUsXG4gICAgcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmLFxuICAgIHNlbGVjdGlvblxuICB9ID0gcHJvcHM7XG4gIHZhciBkZWNvcmF0ZSA9IHVzZURlY29yYXRlKCk7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuICB2YXIgaXNMZWFmQmxvY2sgPSBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNJbmxpbmUobm9kZSkgJiYgRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBub2RlKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHBhdGguY29uY2F0KGkpO1xuICAgIHZhciBuID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIG4pO1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHApO1xuICAgIHZhciBzZWwgPSBzZWxlY3Rpb24gJiYgUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBzZWxlY3Rpb24pO1xuICAgIHZhciBkcyA9IGRlY29yYXRlKFtuLCBwXSk7XG5cbiAgICBmb3IgKHZhciBkZWMgb2YgZGVjb3JhdGlvbnMpIHtcbiAgICAgIHZhciBkID0gUmFuZ2UuaW50ZXJzZWN0aW9uKGRlYywgcmFuZ2UpO1xuXG4gICAgICBpZiAoZCkge1xuICAgICAgICBkcy5wdXNoKGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KG4pKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTZWxlY3RlZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAga2V5OiBcInByb3ZpZGVyLVwiLmNvbmNhdChrZXkuaWQpLFxuICAgICAgICB2YWx1ZTogISFzZWxcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkRWxlbWVudCwge1xuICAgICAgICBkZWNvcmF0aW9uczogZHMsXG4gICAgICAgIGVsZW1lbnQ6IG4sXG4gICAgICAgIGtleToga2V5LmlkLFxuICAgICAgICByZW5kZXJFbGVtZW50OiByZW5kZXJFbGVtZW50LFxuICAgICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgICAgIHNlbGVjdGlvbjogc2VsXG4gICAgICB9KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZFRleHQsIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IGRzLFxuICAgICAgICBrZXk6IGtleS5pZCxcbiAgICAgICAgaXNMYXN0OiBpc0xlYWZCbG9jayAmJiBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEsXG4gICAgICAgIHBhcmVudDogbm9kZSxcbiAgICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmLFxuICAgICAgICB0ZXh0OiBuXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgTk9ERV9UT19JTkRFWC5zZXQobiwgaSk7XG4gICAgTk9ERV9UT19QQVJFTlQuc2V0KG4sIG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYHJlYWRPbmx5YCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxyXG4gKi9cblxudmFyIFJlYWRPbmx5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgYHJlYWRPbmx5YCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxyXG4gKi9cblxudmFyIHVzZVJlYWRPbmx5ID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChSZWFkT25seUNvbnRleHQpO1xufTtcblxudmFyIFNsYXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBlZGl0b3Igb2JqZWN0IGZyb20gdGhlIFJlYWN0IGNvbnRleHQuXHJcbiAqL1xuXG52YXIgdXNlU2xhdGUgPSAoKSA9PiB7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChTbGF0ZUNvbnRleHQpO1xuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHZhciB7XG4gICAgZWRpdG9yXG4gIH0gPSBjb250ZXh0O1xuICByZXR1cm4gZWRpdG9yO1xufTtcbnZhciB1c2VTbGF0ZVdpdGhWID0gKCkgPT4ge1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoU2xhdGVDb250ZXh0KTtcblxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbnZhciBUUklQTEVfQ0xJQ0sgPSAzO1xuXG4vKipcclxuICogSG90a2V5IG1hcHBpbmdzIGZvciBlYWNoIHBsYXRmb3JtLlxyXG4gKi9cblxudmFyIEhPVEtFWVMgPSB7XG4gIGJvbGQ6ICdtb2QrYicsXG4gIGNvbXBvc2U6IFsnZG93bicsICdsZWZ0JywgJ3JpZ2h0JywgJ3VwJywgJ2JhY2tzcGFjZScsICdlbnRlciddLFxuICBtb3ZlQmFja3dhcmQ6ICdsZWZ0JyxcbiAgbW92ZUZvcndhcmQ6ICdyaWdodCcsXG4gIG1vdmVXb3JkQmFja3dhcmQ6ICdjdHJsK2xlZnQnLFxuICBtb3ZlV29yZEZvcndhcmQ6ICdjdHJsK3JpZ2h0JyxcbiAgZGVsZXRlQmFja3dhcmQ6ICdzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlRm9yd2FyZDogJ3NoaWZ0PytkZWxldGUnLFxuICBleHRlbmRCYWNrd2FyZDogJ3NoaWZ0K2xlZnQnLFxuICBleHRlbmRGb3J3YXJkOiAnc2hpZnQrcmlnaHQnLFxuICBpdGFsaWM6ICdtb2QraScsXG4gIGluc2VydFNvZnRCcmVhazogJ3NoaWZ0K2VudGVyJyxcbiAgc3BsaXRCbG9jazogJ2VudGVyJyxcbiAgdW5kbzogJ21vZCt6J1xufTtcbnZhciBBUFBMRV9IT1RLRVlTID0ge1xuICBtb3ZlTGluZUJhY2t3YXJkOiAnb3B0K3VwJyxcbiAgbW92ZUxpbmVGb3J3YXJkOiAnb3B0K2Rvd24nLFxuICBtb3ZlV29yZEJhY2t3YXJkOiAnb3B0K2xlZnQnLFxuICBtb3ZlV29yZEZvcndhcmQ6ICdvcHQrcmlnaHQnLFxuICBkZWxldGVCYWNrd2FyZDogWydjdHJsK2JhY2tzcGFjZScsICdjdHJsK2gnXSxcbiAgZGVsZXRlRm9yd2FyZDogWydjdHJsK2RlbGV0ZScsICdjdHJsK2QnXSxcbiAgZGVsZXRlTGluZUJhY2t3YXJkOiAnY21kK3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVMaW5lRm9yd2FyZDogWydjbWQrc2hpZnQ/K2RlbGV0ZScsICdjdHJsK2snXSxcbiAgZGVsZXRlV29yZEJhY2t3YXJkOiAnb3B0K3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVXb3JkRm9yd2FyZDogJ29wdCtzaGlmdD8rZGVsZXRlJyxcbiAgZXh0ZW5kTGluZUJhY2t3YXJkOiAnb3B0K3NoaWZ0K3VwJyxcbiAgZXh0ZW5kTGluZUZvcndhcmQ6ICdvcHQrc2hpZnQrZG93bicsXG4gIHJlZG86ICdjbWQrc2hpZnQreicsXG4gIHRyYW5zcG9zZUNoYXJhY3RlcjogJ2N0cmwrdCdcbn07XG52YXIgV0lORE9XU19IT1RLRVlTID0ge1xuICBkZWxldGVXb3JkQmFja3dhcmQ6ICdjdHJsK3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVXb3JkRm9yd2FyZDogJ2N0cmwrc2hpZnQ/K2RlbGV0ZScsXG4gIHJlZG86IFsnY3RybCt5JywgJ2N0cmwrc2hpZnQreiddXG59O1xuLyoqXHJcbiAqIENyZWF0ZSBhIHBsYXRmb3JtLWF3YXJlIGhvdGtleSBjaGVja2VyLlxyXG4gKi9cblxudmFyIGNyZWF0ZSA9IGtleSA9PiB7XG4gIHZhciBnZW5lcmljID0gSE9US0VZU1trZXldO1xuICB2YXIgYXBwbGUgPSBBUFBMRV9IT1RLRVlTW2tleV07XG4gIHZhciB3aW5kb3dzID0gV0lORE9XU19IT1RLRVlTW2tleV07XG4gIHZhciBpc0dlbmVyaWMgPSBnZW5lcmljICYmIGlzS2V5SG90a2V5KGdlbmVyaWMpO1xuICB2YXIgaXNBcHBsZSA9IGFwcGxlICYmIGlzS2V5SG90a2V5KGFwcGxlKTtcbiAgdmFyIGlzV2luZG93cyA9IHdpbmRvd3MgJiYgaXNLZXlIb3RrZXkod2luZG93cyk7XG4gIHJldHVybiBldmVudCA9PiB7XG4gICAgaWYgKGlzR2VuZXJpYyAmJiBpc0dlbmVyaWMoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoSVNfQVBQTEUgJiYgaXNBcHBsZSAmJiBpc0FwcGxlKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFJU19BUFBMRSAmJiBpc1dpbmRvd3MgJiYgaXNXaW5kb3dzKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufTtcbi8qKlxyXG4gKiBIb3RrZXlzLlxyXG4gKi9cblxuXG52YXIgSG90a2V5cyA9IHtcbiAgaXNCb2xkOiBjcmVhdGUoJ2JvbGQnKSxcbiAgaXNDb21wb3NlOiBjcmVhdGUoJ2NvbXBvc2UnKSxcbiAgaXNNb3ZlQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZUJhY2t3YXJkJyksXG4gIGlzTW92ZUZvcndhcmQ6IGNyZWF0ZSgnbW92ZUZvcndhcmQnKSxcbiAgaXNEZWxldGVCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZUZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlRm9yd2FyZCcpLFxuICBpc0RlbGV0ZUxpbmVCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVMaW5lQmFja3dhcmQnKSxcbiAgaXNEZWxldGVMaW5lRm9yd2FyZDogY3JlYXRlKCdkZWxldGVMaW5lRm9yd2FyZCcpLFxuICBpc0RlbGV0ZVdvcmRCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVXb3JkQmFja3dhcmQnKSxcbiAgaXNEZWxldGVXb3JkRm9yd2FyZDogY3JlYXRlKCdkZWxldGVXb3JkRm9yd2FyZCcpLFxuICBpc0V4dGVuZEJhY2t3YXJkOiBjcmVhdGUoJ2V4dGVuZEJhY2t3YXJkJyksXG4gIGlzRXh0ZW5kRm9yd2FyZDogY3JlYXRlKCdleHRlbmRGb3J3YXJkJyksXG4gIGlzRXh0ZW5kTGluZUJhY2t3YXJkOiBjcmVhdGUoJ2V4dGVuZExpbmVCYWNrd2FyZCcpLFxuICBpc0V4dGVuZExpbmVGb3J3YXJkOiBjcmVhdGUoJ2V4dGVuZExpbmVGb3J3YXJkJyksXG4gIGlzSXRhbGljOiBjcmVhdGUoJ2l0YWxpYycpLFxuICBpc01vdmVMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZUxpbmVCYWNrd2FyZCcpLFxuICBpc01vdmVMaW5lRm9yd2FyZDogY3JlYXRlKCdtb3ZlTGluZUZvcndhcmQnKSxcbiAgaXNNb3ZlV29yZEJhY2t3YXJkOiBjcmVhdGUoJ21vdmVXb3JkQmFja3dhcmQnKSxcbiAgaXNNb3ZlV29yZEZvcndhcmQ6IGNyZWF0ZSgnbW92ZVdvcmRGb3J3YXJkJyksXG4gIGlzUmVkbzogY3JlYXRlKCdyZWRvJyksXG4gIGlzU29mdEJyZWFrOiBjcmVhdGUoJ2luc2VydFNvZnRCcmVhaycpLFxuICBpc1NwbGl0QmxvY2s6IGNyZWF0ZSgnc3BsaXRCbG9jaycpLFxuICBpc1RyYW5zcG9zZUNoYXJhY3RlcjogY3JlYXRlKCd0cmFuc3Bvc2VDaGFyYWN0ZXInKSxcbiAgaXNVbmRvOiBjcmVhdGUoJ3VuZG8nKVxufTtcblxudmFyIGNyZWF0ZVJlc3RvcmVEb21NYW5hZ2VyID0gKGVkaXRvciwgcmVjZWl2ZWRVc2VySW5wdXQpID0+IHtcbiAgdmFyIGJ1ZmZlcmVkTXV0YXRpb25zID0gW107XG5cbiAgdmFyIGNsZWFyID0gKCkgPT4ge1xuICAgIGJ1ZmZlcmVkTXV0YXRpb25zID0gW107XG4gIH07XG5cbiAgdmFyIHJlZ2lzdGVyTXV0YXRpb25zID0gbXV0YXRpb25zID0+IHtcbiAgICBpZiAoIXJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tlZE11dGF0aW9ucyA9IG11dGF0aW9ucy5maWx0ZXIobXV0YXRpb24gPT4gaXNUcmFja2VkTXV0YXRpb24oZWRpdG9yLCBtdXRhdGlvbiwgbXV0YXRpb25zKSk7XG4gICAgYnVmZmVyZWRNdXRhdGlvbnMucHVzaCguLi50cmFja2VkTXV0YXRpb25zKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXN0b3JlRE9NKCkge1xuICAgIGlmIChidWZmZXJlZE11dGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBidWZmZXJlZE11dGF0aW9ucy5yZXZlcnNlKCkuZm9yRWFjaChtdXRhdGlvbiA9PiB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hhcmFjdGVyRGF0YScpIHtcbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJlc3RvcmUgdGhlIERPTSBmb3IgY2hhcmFjdGVyRGF0YSBtdXRhdGlvbnNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMgaW50ZXJydXB0cyB0aGUgY29tcG9zaXRpb24uXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24udGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBtdXRhdGlvbi5uZXh0U2libGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBtdXRhdGlvbi5hZGRlZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24udGFyZ2V0LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBDbGVhciBidWZmZXJlZCBtdXRhdGlvbnMgdG8gZW5zdXJlIHdlIGRvbid0IHVuZG8gdGhlbSB0d2ljZVxuXG4gICAgICBjbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVnaXN0ZXJNdXRhdGlvbnMsXG4gICAgcmVzdG9yZURPTSxcbiAgICBjbGVhclxuICB9O1xufTtcblxudmFyIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyQxID0ge1xuICBzdWJ0cmVlOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZVxufTsgLy8gV2UgaGF2ZSB0byB1c2UgYSBjbGFzcyBjb21wb25lbnQgaGVyZSBzaW5jZSB3ZSByZWx5IG9uIGBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZWAgd2hpY2ggaGFzIG5vIEZDIGVxdWl2YWxlbnRcbi8vIHRvIHJ1biBjb2RlIHN5bmNocm9ub3VzbHkgaW1tZWRpYXRlbHkgYmVmb3JlIHJlYWN0IGNvbW1pdHMgdGhlIGNvbXBvbmVudCB1cGRhdGUgdG8gdGhlIERPTS5cblxuY2xhc3MgUmVzdG9yZURPTUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IG51bGw7XG4gIH1cblxuICBvYnNlcnZlKCkge1xuICAgIHZhciBfdGhpcyRtdXRhdGlvbk9ic2VydmU7XG5cbiAgICB2YXIge1xuICAgICAgbm9kZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKCFub2RlLmN1cnJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGF0dGFjaCBNdXRhdGlvbk9ic2VydmVyLCBgbm9kZWAgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgKF90aGlzJG11dGF0aW9uT2JzZXJ2ZSA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtdXRhdGlvbk9ic2VydmUub2JzZXJ2ZShub2RlLmN1cnJlbnQsIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyQxKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciB7XG4gICAgICByZWNlaXZlZFVzZXJJbnB1dFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHZhciBlZGl0b3IgPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5tYW5hZ2VyID0gY3JlYXRlUmVzdG9yZURvbU1hbmFnZXIoZWRpdG9yLCByZWNlaXZlZFVzZXJJbnB1dCk7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5tYW5hZ2VyLnJlZ2lzdGVyTXV0YXRpb25zKTtcbiAgICB0aGlzLm9ic2VydmUoKTtcbiAgfVxuXG4gIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkge1xuICAgIHZhciBfdGhpcyRtdXRhdGlvbk9ic2VydmUyLCBfdGhpcyRtdXRhdGlvbk9ic2VydmUzLCBfdGhpcyRtYW5hZ2VyMjtcblxuICAgIHZhciBwZW5kaW5nTXV0YXRpb25zID0gKF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIudGFrZVJlY29yZHMoKTtcblxuICAgIGlmIChwZW5kaW5nTXV0YXRpb25zICE9PSBudWxsICYmIHBlbmRpbmdNdXRhdGlvbnMgIT09IHZvaWQgMCAmJiBwZW5kaW5nTXV0YXRpb25zLmxlbmd0aCkge1xuICAgICAgdmFyIF90aGlzJG1hbmFnZXI7XG5cbiAgICAgIChfdGhpcyRtYW5hZ2VyID0gdGhpcy5tYW5hZ2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRtYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtYW5hZ2VyLnJlZ2lzdGVyTXV0YXRpb25zKHBlbmRpbmdNdXRhdGlvbnMpO1xuICAgIH1cblxuICAgIChfdGhpcyRtdXRhdGlvbk9ic2VydmUzID0gdGhpcy5tdXRhdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtdXRhdGlvbk9ic2VydmUzLmRpc2Nvbm5lY3QoKTtcbiAgICAoX3RoaXMkbWFuYWdlcjIgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtYW5hZ2VyMi5yZXN0b3JlRE9NKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdmFyIF90aGlzJG1hbmFnZXIzO1xuXG4gICAgKF90aGlzJG1hbmFnZXIzID0gdGhpcy5tYW5hZ2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRtYW5hZ2VyMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbWFuYWdlcjMuY2xlYXIoKTtcbiAgICB0aGlzLm9ic2VydmUoKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHZhciBfdGhpcyRtdXRhdGlvbk9ic2VydmU0O1xuXG4gICAgKF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG5cbn1cblxuUmVzdG9yZURPTUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG52YXIgUmVzdG9yZURPTSA9IElTX0FORFJPSUQgPyBSZXN0b3JlRE9NQ29tcG9uZW50IDogX3JlZiA9PiB7XG4gIHZhciB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufTtcblxuLyoqXHJcbiAqIENoZWNrIHdoZXRoZXIgYSB0ZXh0IGRpZmYgd2FzIGFwcGxpZWQgaW4gYSB3YXkgd2UgY2FuIHBlcmZvcm0gdGhlIHBlbmRpbmcgYWN0aW9uIG9uIC9cclxuICogcmVjb3ZlciB0aGUgcGVuZGluZyBzZWxlY3Rpb24uXHJcbiAqL1xuXG5mdW5jdGlvbiB2ZXJpZnlEaWZmU3RhdGUoZWRpdG9yLCB0ZXh0RGlmZikge1xuICB2YXIge1xuICAgIHBhdGgsXG4gICAgZGlmZlxuICB9ID0gdGV4dERpZmY7XG5cbiAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuXG4gIGlmICghVGV4dCQxLmlzVGV4dChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChkaWZmLnN0YXJ0ICE9PSBub2RlLnRleHQubGVuZ3RoIHx8IGRpZmYudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbm9kZS50ZXh0LnNsaWNlKGRpZmYuc3RhcnQsIGRpZmYuc3RhcnQgKyBkaWZmLnRleHQubGVuZ3RoKSA9PT0gZGlmZi50ZXh0O1xuICB9XG5cbiAgdmFyIG5leHRQYXRoID0gUGF0aC5uZXh0KHBhdGgpO1xuXG4gIGlmICghRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBuZXh0UGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbmV4dE5vZGUgPSBOb2RlLmdldChlZGl0b3IsIG5leHRQYXRoKTtcbiAgcmV0dXJuIFRleHQkMS5pc1RleHQobmV4dE5vZGUpICYmIG5leHROb2RlLnRleHQuc3RhcnRzV2l0aChkaWZmLnRleHQpO1xufVxuZnVuY3Rpb24gYXBwbHlTdHJpbmdEaWZmKHRleHQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRpZmZzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBkaWZmc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlmZnMucmVkdWNlKCh0ZXh0LCBkaWZmKSA9PiB0ZXh0LnNsaWNlKDAsIGRpZmYuc3RhcnQpICsgZGlmZi50ZXh0ICsgdGV4dC5zbGljZShkaWZmLmVuZCksIHRleHQpO1xufVxuXG5mdW5jdGlvbiBsb25nZXN0Q29tbW9uUHJlZml4TGVuZ3RoKHN0ciwgYW5vdGhlcikge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyLmNoYXJBdChpKSAhPT0gYW5vdGhlci5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGxvbmdlc3RDb21tb25TdWZmaXhMZW5ndGgoc3RyLCBhbm90aGVyLCBtYXgpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGFub3RoZXIubGVuZ3RoLCBtYXgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gaSAtIDEpICE9PSBhbm90aGVyLmNoYXJBdChhbm90aGVyLmxlbmd0aCAtIGkgLSAxKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxyXG4gKiBSZW1vdmUgcmVkdW5kYW50IGNoYW5nZXMgZnJvbSB0aGUgZGlmZiBzbyB0aGF0IGl0IHNwYW5zIHRoZSBtaW5pbWFsIHBvc3NpYmxlIHJhbmdlXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwgZGlmZikge1xuICB2YXIge1xuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICB0ZXh0XG4gIH0gPSBkaWZmO1xuICB2YXIgcmVtb3ZlZFRleHQgPSB0YXJnZXRUZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcHJlZml4TGVuZ3RoID0gbG9uZ2VzdENvbW1vblByZWZpeExlbmd0aChyZW1vdmVkVGV4dCwgdGV4dCk7XG4gIHZhciBtYXggPSBNYXRoLm1pbihyZW1vdmVkVGV4dC5sZW5ndGggLSBwcmVmaXhMZW5ndGgsIHRleHQubGVuZ3RoIC0gcHJlZml4TGVuZ3RoKTtcbiAgdmFyIHN1ZmZpeExlbmd0aCA9IGxvbmdlc3RDb21tb25TdWZmaXhMZW5ndGgocmVtb3ZlZFRleHQsIHRleHQsIG1heCk7XG4gIHZhciBub3JtYWxpemVkID0ge1xuICAgIHN0YXJ0OiBzdGFydCArIHByZWZpeExlbmd0aCxcbiAgICBlbmQ6IGVuZCAtIHN1ZmZpeExlbmd0aCxcbiAgICB0ZXh0OiB0ZXh0LnNsaWNlKHByZWZpeExlbmd0aCwgdGV4dC5sZW5ndGggLSBzdWZmaXhMZW5ndGgpXG4gIH07XG5cbiAgaWYgKG5vcm1hbGl6ZWQuc3RhcnQgPT09IG5vcm1hbGl6ZWQuZW5kICYmIG5vcm1hbGl6ZWQudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuLyoqXHJcbiAqIFJldHVybiBhIHN0cmluZyBkaWZmIHRoYXQgaXMgZXF1aXZhbGVudCB0byBhcHBseWluZyBiIGFmdGVyIGEgc3Bhbm5pbmcgdGhlIHJhbmdlIG9mXHJcbiAqIGJvdGggY2hhbmdlc1xyXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VTdHJpbmdEaWZmcyh0YXJnZXRUZXh0LCBhLCBiKSB7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKGEuc3RhcnQsIGIuc3RhcnQpO1xuICB2YXIgb3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoLCBiLmVuZCkgLSBiLnN0YXJ0KTtcbiAgdmFyIGFwcGxpZWQgPSBhcHBseVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwgYSwgYik7XG4gIHZhciBzbGljZUVuZCA9IE1hdGgubWF4KGIuc3RhcnQgKyBiLnRleHQubGVuZ3RoLCBhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCArIChhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCA+IGIuc3RhcnQgPyBiLnRleHQubGVuZ3RoIDogMCkgLSBvdmVybGFwKTtcbiAgdmFyIHRleHQgPSBhcHBsaWVkLnNsaWNlKHN0YXJ0LCBzbGljZUVuZCk7XG4gIHZhciBlbmQgPSBNYXRoLm1heChhLmVuZCwgYi5lbmQgLSBhLnRleHQubGVuZ3RoICsgKGEuZW5kIC0gYS5zdGFydCkpO1xuICByZXR1cm4gbm9ybWFsaXplU3RyaW5nRGlmZih0YXJnZXRUZXh0LCB7XG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIHRleHRcbiAgfSk7XG59XG4vKipcclxuICogR2V0IHRoZSBzbGF0ZSByYW5nZSB0aGUgdGV4dCBkaWZmIHNwYW5zLlxyXG4gKi9cblxuZnVuY3Rpb24gdGFyZ2V0UmFuZ2UodGV4dERpZmYpIHtcbiAgdmFyIHtcbiAgICBwYXRoLFxuICAgIGRpZmZcbiAgfSA9IHRleHREaWZmO1xuICByZXR1cm4ge1xuICAgIGFuY2hvcjoge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5zdGFydFxuICAgIH0sXG4gICAgZm9jdXM6IHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXQ6IGRpZmYuZW5kXG4gICAgfVxuICB9O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhICdwZW5kaW5nIHBvaW50JyBhLmsuYSBhIHBvaW50IGJhc2VkIG9uIHRoZSBkb20gc3RhdGUgYmVmb3JlIGFwcGx5aW5nXHJcbiAqIHRoZSBwZW5kaW5nIGRpZmZzLiBTaW5jZSB0aGUgcGVuZGluZyBkaWZmcyBtaWdodCBoYXZlIGJlZW4gaW5zZXJ0ZWQgd2l0aCBkaWZmZXJlbnRcclxuICogbWFya3Mgd2UgaGF2ZSB0byAnd2FsaycgdGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydGluZyBwb3NpdGlvbiB0byBlbnN1cmUgd2Ugc3RpbGxcclxuICogaGF2ZSBhIHZhbGlkIHBvaW50IGluc2lkZSB0aGUgZG9jdW1lbnRcclxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcG9pbnQpIHtcbiAgdmFyIHtcbiAgICBwYXRoLFxuICAgIG9mZnNldFxuICB9ID0gcG9pbnQ7XG5cbiAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGVhZiA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG5cbiAgaWYgKCFUZXh0JDEuaXNUZXh0KGxlYWYpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFyZW50QmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IG4gPT4gRWxlbWVudCQxLmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgIGF0OiBwYXRoXG4gIH0pO1xuXG4gIGlmICghcGFyZW50QmxvY2spIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHdoaWxlIChvZmZzZXQgPiBsZWFmLnRleHQubGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5leHQoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIG1hdGNoOiBUZXh0JDEuaXNUZXh0XG4gICAgfSk7XG5cbiAgICBpZiAoIWVudHJ5IHx8ICFQYXRoLmlzRGVzY2VuZGFudChlbnRyeVsxXSwgcGFyZW50QmxvY2tbMV0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBvZmZzZXQgLT0gbGVhZi50ZXh0Lmxlbmd0aDtcbiAgICBsZWFmID0gZW50cnlbMF07XG4gICAgcGF0aCA9IGVudHJ5WzFdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIG9mZnNldFxuICB9O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhICdwZW5kaW5nIHNlbGVjdGlvbicgdG8gZW5zdXJlIGl0J3MgdmFsaWQgaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQgc3RhdGUuXHJcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIHZhciBhbmNob3IgPSBub3JtYWxpemVQb2ludChlZGl0b3IsIHJhbmdlLmFuY2hvcik7XG5cbiAgaWYgKCFhbmNob3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXM6IGFuY2hvclxuICAgIH07XG4gIH1cblxuICB2YXIgZm9jdXMgPSBub3JtYWxpemVQb2ludChlZGl0b3IsIHJhbmdlLmZvY3VzKTtcblxuICBpZiAoIWZvY3VzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcG9pbnQsIG9wKSB7XG4gIHZhciBwZW5kaW5nRGlmZnMgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKTtcbiAgdmFyIHRleHREaWZmID0gcGVuZGluZ0RpZmZzID09PSBudWxsIHx8IHBlbmRpbmdEaWZmcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ0RpZmZzLmZpbmQoX3JlZiA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMocGF0aCwgcG9pbnQucGF0aCk7XG4gIH0pO1xuXG4gIGlmICghdGV4dERpZmYgfHwgcG9pbnQub2Zmc2V0IDw9IHRleHREaWZmLmRpZmYuc3RhcnQpIHtcbiAgICByZXR1cm4gUG9pbnQudHJhbnNmb3JtKHBvaW50LCBvcCwge1xuICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB7XG4gICAgZGlmZlxuICB9ID0gdGV4dERpZmY7IC8vIFBvaW50IHJlZmVyZW5jZXMgbG9jYXRpb24gaW5zaWRlIHRoZSBkaWZmID0+IHRyYW5zZm9ybSB0aGUgcG9pbnQgYmFzZWQgb24gdGhlIGxvY2F0aW9uXG4gIC8vIHRoZSBkaWZmIHdpbGwgYmUgYXBwbGllZCB0byBhbmQgYWRkIHRoZSBvZmZzZXQgaW5zaWRlIHRoZSBkaWZmLlxuXG4gIGlmIChwb2ludC5vZmZzZXQgPD0gZGlmZi5zdGFydCArIGRpZmYudGV4dC5sZW5ndGgpIHtcbiAgICB2YXIgX2FuY2hvciA9IHtcbiAgICAgIHBhdGg6IHBvaW50LnBhdGgsXG4gICAgICBvZmZzZXQ6IGRpZmYuc3RhcnRcbiAgICB9O1xuXG4gICAgdmFyIF90cmFuc2Zvcm1lZCA9IFBvaW50LnRyYW5zZm9ybShfYW5jaG9yLCBvcCwge1xuICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICB9KTtcblxuICAgIGlmICghX3RyYW5zZm9ybWVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogX3RyYW5zZm9ybWVkLnBhdGgsXG4gICAgICBvZmZzZXQ6IF90cmFuc2Zvcm1lZC5vZmZzZXQgKyBwb2ludC5vZmZzZXQgLSBkaWZmLnN0YXJ0XG4gICAgfTtcbiAgfSAvLyBQb2ludCByZWZlcmVuY2VzIGxvY2F0aW9uIGFmdGVyIHRoZSBkaWZmXG5cblxuICB2YXIgYW5jaG9yID0ge1xuICAgIHBhdGg6IHBvaW50LnBhdGgsXG4gICAgb2Zmc2V0OiBwb2ludC5vZmZzZXQgLSBkaWZmLnRleHQubGVuZ3RoICsgZGlmZi5lbmQgLSBkaWZmLnN0YXJ0XG4gIH07XG4gIHZhciB0cmFuc2Zvcm1lZCA9IFBvaW50LnRyYW5zZm9ybShhbmNob3IsIG9wLCB7XG4gICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgfSk7XG5cbiAgaWYgKCF0cmFuc2Zvcm1lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG9wLnR5cGUgPT09ICdzcGxpdF9ub2RlJyAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwb2ludC5wYXRoKSAmJiBhbmNob3Iub2Zmc2V0IDwgb3AucG9zaXRpb24gJiYgZGlmZi5zdGFydCA8IG9wLnBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiB0cmFuc2Zvcm1lZC5wYXRoLFxuICAgIG9mZnNldDogdHJhbnNmb3JtZWQub2Zmc2V0ICsgZGlmZi50ZXh0Lmxlbmd0aCAtIGRpZmYuZW5kICsgZGlmZi5zdGFydFxuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtUGVuZGluZ1JhbmdlKGVkaXRvciwgcmFuZ2UsIG9wKSB7XG4gIHZhciBhbmNob3IgPSB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZWRpdG9yLCByYW5nZS5hbmNob3IsIG9wKTtcblxuICBpZiAoIWFuY2hvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1czogYW5jaG9yXG4gICAgfTtcbiAgfVxuXG4gIHZhciBmb2N1cyA9IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlZGl0b3IsIHJhbmdlLmZvY3VzLCBvcCk7XG5cbiAgaWYgKCFmb2N1cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVRleHREaWZmKHRleHREaWZmLCBvcCkge1xuICB2YXIge1xuICAgIHBhdGgsXG4gICAgZGlmZixcbiAgICBpZFxuICB9ID0gdGV4dERpZmY7XG5cbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLm9mZnNldCA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0RGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcC5vZmZzZXQgPD0gZGlmZi5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBvcC50ZXh0Lmxlbmd0aCArIGRpZmYuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogb3AudGV4dC5sZW5ndGggKyBkaWZmLmVuZCxcbiAgICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kICsgb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhdGhcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBvcC5vZmZzZXQgPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dERpZmY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3Aub2Zmc2V0ICsgb3AudGV4dC5sZW5ndGggPD0gZGlmZi5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0IC0gb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kIC0gb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhdGhcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLnBvc2l0aW9uID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCB7XG4gICAgICAgICAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3AucG9zaXRpb24gPiBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogTWF0aC5taW4ob3AucG9zaXRpb24sIGRpZmYuZW5kKSxcbiAgICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgLSBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgLSBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIHtcbiAgICAgICAgICAgIGFmZmluaXR5OiAnZm9yd2FyZCdcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgKyBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgKyBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApXG4gICAgICAgIH07XG4gICAgICB9XG4gIH1cblxuICB2YXIgbmV3UGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcblxuICBpZiAoIW5ld1BhdGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGlmZixcbiAgICBwYXRoOiBuZXdQYXRoLFxuICAgIGlkXG4gIH07XG59XG5cbmZ1bmN0aW9uIG93bktleXMkMyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuLy8gV2hlbiB1c2luZyBrZXlib2FyZCBFbmdsaXNoIGFzc29jaWF0aW9uIGZ1bmN0aW9uLCBjb25wb3NpdGlvbkVuZCB0cmlnZ2VyZWQgdG9vIGZhc3QsIHJlc3VsdGluZyBpbiBhZnRlciBgaW5zZXJ0VGV4dGAgc3RpbGwgbWFpbnRhaW4gYXNzb2NpYXRpb24gc3RhdGUuXG5cbnZhciBSRVNPTFZFX0RFTEFZID0gMjU7IC8vIFRpbWUgd2l0aCBubyB1c2VyIGludGVyYWN0aW9uIGJlZm9yZSB0aGUgY3VycmVudCB1c2VyIGFjdGlvbiBpcyBjb25zaWRlcmVkIGFzIGRvbmUuXG5cbnZhciBGTFVTSF9ERUxBWSA9IDIwMDsgLy8gUmVwbGFjZSB3aXRoIGBjb25zdCBkZWJ1ZyA9IGNvbnNvbGUubG9nYCB0byBkZWJ1Z1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9OyAvLyBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgYSBEYXRhVHJhbnNmZXJcblxuXG52YXIgaXNEYXRhVHJhbnNmZXIgPSB2YWx1ZSA9PiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpID09PSAnRGF0YVRyYW5zZmVyJztcblxuZnVuY3Rpb24gY3JlYXRlQW5kcm9pZElucHV0TWFuYWdlcihfcmVmKSB7XG4gIHZhciB7XG4gICAgZWRpdG9yLFxuICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UsXG4gICAgb25ET01TZWxlY3Rpb25DaGFuZ2VcbiAgfSA9IF9yZWY7XG4gIHZhciBmbHVzaGluZyA9IGZhbHNlO1xuICB2YXIgY29tcG9zaXRpb25FbmRUaW1lb3V0SWQgPSBudWxsO1xuICB2YXIgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICB2YXIgYWN0aW9uVGltZW91dElkID0gbnVsbDtcbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIHZhciBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcblxuICB2YXIgYXBwbHlQZW5kaW5nU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgIHZhciBwZW5kaW5nU2VsZWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmdldChlZGl0b3IpO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcblxuICAgIGlmIChwZW5kaW5nU2VsZWN0aW9uKSB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG4gICAgICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVJhbmdlKGVkaXRvciwgcGVuZGluZ1NlbGVjdGlvbik7XG5cbiAgICAgIGlmIChub3JtYWxpemVkICYmICghc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMobm9ybWFsaXplZCwgc2VsZWN0aW9uKSkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBub3JtYWxpemVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlcmZvcm1BY3Rpb24gPSAoKSA9PiB7XG4gICAgdmFyIGFjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZWRpdG9yKTtcbiAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZGVsZXRlKGVkaXRvcik7XG5cbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24uYXQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBQb2ludC5pc1BvaW50KGFjdGlvbi5hdCkgPyBub3JtYWxpemVQb2ludChlZGl0b3IsIGFjdGlvbi5hdCkgOiBub3JtYWxpemVSYW5nZShlZGl0b3IsIGFjdGlvbi5hdCk7XG5cbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF90YXJnZXRSYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHRhcmdldCk7XG5cbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKGVkaXRvci5zZWxlY3Rpb24sIF90YXJnZXRSYW5nZSkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFjdGlvbi5ydW4oKTtcbiAgfTtcblxuICB2YXIgZmx1c2ggPSAoKSA9PiB7XG4gICAgaWYgKGZsdXNoVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZmx1c2hUaW1lb3V0SWQpO1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChhY3Rpb25UaW1lb3V0SWQpO1xuICAgICAgYWN0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1BlbmRpbmdEaWZmcygpICYmICFoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGFwcGx5UGVuZGluZ1NlbGVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gZmx1c2hpbmcgPSBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgZmx1c2hpbmcgPSAnYWN0aW9uJztcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0aW9uUmVmID0gZWRpdG9yLnNlbGVjdGlvbiAmJiBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLCB7XG4gICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgfSk7XG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1Muc2V0KGVkaXRvciwgZWRpdG9yLm1hcmtzKTtcbiAgICBkZWJ1ZygnZmx1c2gnLCBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGVkaXRvciksIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKTtcbiAgICB2YXIgc2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UgPSBoYXNQZW5kaW5nRGlmZnMoKTtcbiAgICB2YXIgZGlmZjtcblxuICAgIHdoaWxlIChkaWZmID0gKF9FRElUT1JfVE9fUEVORElOR19ESSA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1BFTkRJTkdfREkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fUEVORElOR19ESVswXSkge1xuICAgICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESSwgX0VESVRPUl9UT19QRU5ESU5HX0RJMjtcblxuICAgICAgdmFyIHBlbmRpbmdNYXJrcyA9IEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZWRpdG9yKTtcblxuICAgICAgaWYgKHBlbmRpbmdNYXJrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0gcGVuZGluZ01hcmtzO1xuICAgICAgfVxuXG4gICAgICBpZiAocGVuZGluZ01hcmtzICYmIGluc2VydFBvc2l0aW9uSGludCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlID0gdGFyZ2V0UmFuZ2UoZGlmZik7XG5cbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKGVkaXRvci5zZWxlY3Rpb24sIHJhbmdlKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZmYuZGlmZi50ZXh0KSB7XG4gICAgICAgIEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgZGlmZi5kaWZmLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICB9IC8vIFJlbW92ZSBkaWZmIG9ubHkgYWZ0ZXIgd2UgaGF2ZSBhcHBsaWVkIGl0IHRvIGFjY291bnQgZm9yIGl0IHdoZW4gdHJhbnNmb3JtaW5nXG4gICAgICAvLyBwZW5kaW5nIHJhbmdlcy5cblxuXG4gICAgICBFRElUT1JfVE9fUEVORElOR19ESUZGUy5zZXQoZWRpdG9yLCAoX0VESVRPUl9UT19QRU5ESU5HX0RJMiA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1BFTkRJTkdfREkyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1BFTkRJTkdfREkyLmZpbHRlcihfcmVmMiA9PiB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gaWQgIT09IGRpZmYuaWQ7XG4gICAgICB9KSk7XG5cbiAgICAgIGlmICghdmVyaWZ5RGlmZlN0YXRlKGVkaXRvciwgZGlmZikpIHtcbiAgICAgICAgc2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcbiAgICAgICAgZmx1c2hpbmcgPSAnYWN0aW9uJzsgLy8gRW5zdXJlIHdlIGRvbid0IHJlc3RvcmUgdGhlIHBlbmRpbmcgdXNlciAoZG9tKSBzZWxlY3Rpb25cbiAgICAgICAgLy8gc2luY2UgdGhlIGRvY3VtZW50IGFuZCBkb20gc3RhdGUgZG8gbm90IG1hdGNoLlxuXG4gICAgICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICAgICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICAgICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgICAgIHNlbGVjdGlvblJlZiA9PT0gbnVsbCB8fCBzZWxlY3Rpb25SZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvblJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzZWxlY3Rpb24gPSBzZWxlY3Rpb25SZWYgPT09IG51bGwgfHwgc2VsZWN0aW9uUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3Rpb25SZWYudW5yZWYoKTtcblxuICAgIGlmIChzZWxlY3Rpb24gJiYgIUVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5nZXQoZWRpdG9yKSAmJiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhzZWxlY3Rpb24sIGVkaXRvci5zZWxlY3Rpb24pKSkge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIHBlcmZvcm1BY3Rpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENPTVBBVDogVGhlIHNlbGVjdGlvbkNoYW5nZSBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgYWN0aW9uIGlzIHBlcmZvcm1lZCxcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIG1hbnVhbGx5IHNjaGVkdWxlIGl0IHRvIGVuc3VyZSB3ZSBkb24ndCAndGhyb3cgYXdheScgdGhlIHNlbGVjdGlvblxuICAgIC8vIHdoaWxlIHJlbmRlcmluZyBpZiB3ZSBoYXZlIHBlbmRpbmcgY2hhbmdlcy5cblxuXG4gICAgaWYgKHNjaGVkdWxlU2VsZWN0aW9uQ2hhbmdlKSB7XG4gICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5mbHVzaCgpO1xuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgYXBwbHlQZW5kaW5nU2VsZWN0aW9uKCk7XG4gICAgdmFyIHVzZXJNYXJrcyA9IEVESVRPUl9UT19VU0VSX01BUktTLmdldChlZGl0b3IpO1xuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuXG4gICAgaWYgKHVzZXJNYXJrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlZGl0b3IubWFya3MgPSB1c2VyTWFya3M7XG4gICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNvbXBvc2l0aW9uRW5kID0gX2V2ZW50ID0+IHtcbiAgICBpZiAoY29tcG9zaXRpb25FbmRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCk7XG4gICAgfVxuXG4gICAgY29tcG9zaXRpb25FbmRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICBmbHVzaCgpO1xuICAgIH0sIFJFU09MVkVfREVMQVkpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVDb21wb3NpdGlvblN0YXJ0ID0gX2V2ZW50ID0+IHtcbiAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG5cbiAgICBpZiAoY29tcG9zaXRpb25FbmRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCk7XG4gICAgICBjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHZhciB1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkgPSBmdW5jdGlvbiB1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkoKSB7XG4gICAgdmFyIGZvcmNlSGlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIHBsYWNlaG9sZGVyRWxlbWVudCA9IEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCFwbGFjZWhvbGRlckVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaGFzUGVuZGluZ0RpZmZzKCkgfHwgZm9yY2VIaWRlKSB7XG4gICAgICBwbGFjZWhvbGRlckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwbGFjZWhvbGRlckVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2Rpc3BsYXknKTtcbiAgfTtcblxuICB2YXIgc3RvcmVEaWZmID0gKHBhdGgsIGRpZmYpID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19QRU5ESU5HX0RJMztcbiAgICB2YXIgcGVuZGluZ0RpZmZzID0gKF9FRElUT1JfVE9fUEVORElOR19ESTMgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJMyAhPT0gdm9pZCAwID8gX0VESVRPUl9UT19QRU5ESU5HX0RJMyA6IFtdO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLnNldChlZGl0b3IsIHBlbmRpbmdEaWZmcyk7XG4gICAgdmFyIHRhcmdldCA9IE5vZGUubGVhZihlZGl0b3IsIHBhdGgpO1xuICAgIHZhciBpZHggPSBwZW5kaW5nRGlmZnMuZmluZEluZGV4KGNoYW5nZSA9PiBQYXRoLmVxdWFscyhjaGFuZ2UucGF0aCwgcGF0aCkpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplU3RyaW5nRGlmZih0YXJnZXQudGV4dCwgZGlmZik7XG5cbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHBlbmRpbmdEaWZmcy5wdXNoKHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgaWQ6IGlkQ291bnRlcisrXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VkID0gbWVyZ2VTdHJpbmdEaWZmcyh0YXJnZXQudGV4dCwgcGVuZGluZ0RpZmZzW2lkeF0uZGlmZiwgZGlmZik7XG5cbiAgICBpZiAoIW1lcmdlZCkge1xuICAgICAgcGVuZGluZ0RpZmZzLnNwbGljZShpZHgsIDEpO1xuICAgICAgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGVuZGluZ0RpZmZzW2lkeF0gPSBfb2JqZWN0U3ByZWFkJDMoX29iamVjdFNwcmVhZCQzKHt9LCBwZW5kaW5nRGlmZnNbaWR4XSksIHt9LCB7XG4gICAgICBkaWZmOiBtZXJnZWRcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgc2NoZWR1bGVBY3Rpb24gPSBmdW5jdGlvbiBzY2hlZHVsZUFjdGlvbihydW4pIHtcbiAgICB2YXIge1xuICAgICAgYXRcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcblxuICAgIGlmIChoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGZsdXNoKCk7XG4gICAgfVxuXG4gICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLnNldChlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgcnVuXG4gICAgfSk7IC8vIENPTVBBVDogV2hlbiBkZWxldGluZyBiZWZvcmUgYSBub24tY29udGVudGVkaXRhYmxlIGVsZW1lbnQgY2hyb21lIG9ubHkgZmlyZXMgYSBiZWZvcmVpbnB1dCxcbiAgICAvLyAobm8gaW5wdXQpIGFuZCBkb2Vzbid0IHBlcmZvcm0gYW55IGRvbSBtdXRhdGlvbnMuIFdpdGhvdXQgYSBmbHVzaCB0aW1lb3V0IHdlIHdvdWxkIG5ldmVyIGZsdXNoXG4gICAgLy8gaW4gdGhpcyBjYXNlIGFuZCB0aHVzIG5ldmVyIGFjdHVhbGx5IHBlcmZvcm0gdGhlIGFjdGlvbi5cblxuICAgIGFjdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZmx1c2gpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVET01CZWZvcmVJbnB1dCA9IGV2ZW50ID0+IHtcbiAgICB2YXIgX3RhcmdldFJhbmdlMjtcblxuICAgIGlmIChmbHVzaFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoVGltZW91dElkKTtcbiAgICAgIGZsdXNoVGltZW91dElkID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgaW5wdXRUeXBlOiB0eXBlXG4gICAgfSA9IGV2ZW50O1xuICAgIHZhciB0YXJnZXRSYW5nZSA9IG51bGw7XG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXIgfHwgZXZlbnQuZGF0YSB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaW5zZXJ0UG9zaXRpb25IaW50ICE9PSBmYWxzZSAmJiB0eXBlICE9PSAnaW5zZXJ0VGV4dCcgJiYgdHlwZSAhPT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcpIHtcbiAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBbbmF0aXZlVGFyZ2V0UmFuZ2VdID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG5cbiAgICBpZiAobmF0aXZlVGFyZ2V0UmFuZ2UpIHtcbiAgICAgIHRhcmdldFJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgbmF0aXZlVGFyZ2V0UmFuZ2UsIHtcbiAgICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gLy8gQ09NUEFUOiBTZWxlY3Rpb25DaGFuZ2UgZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgdGhlIGFjdGlvbiBpcyBwZXJmb3JtZWQsIHNvIHdlXG4gICAgLy8gaGF2ZSB0byBtYW51YWxseSBnZXQgdGhlIHNlbGVjdGlvbiBoZXJlIHRvIGVuc3VyZSBpdCdzIHVwLXRvLWRhdGUuXG5cblxuICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCF0YXJnZXRSYW5nZSAmJiBkb21TZWxlY3Rpb24pIHtcbiAgICAgIG5hdGl2ZVRhcmdldFJhbmdlID0gZG9tU2VsZWN0aW9uO1xuICAgICAgdGFyZ2V0UmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21TZWxlY3Rpb24sIHtcbiAgICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRhcmdldFJhbmdlID0gKF90YXJnZXRSYW5nZTIgPSB0YXJnZXRSYW5nZSkgIT09IG51bGwgJiYgX3RhcmdldFJhbmdlMiAhPT0gdm9pZCAwID8gX3RhcmdldFJhbmdlMiA6IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICBpZiAoIXRhcmdldFJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBCeSBkZWZhdWx0LCB0aGUgaW5wdXQgbWFuYWdlciB0cmllcyB0byBzdG9yZSB0ZXh0IGRpZmZzIHNvIHRoYXQgd2UgY2FuXG4gICAgLy8gZGVmZXIgZmx1c2hpbmcgdGhlbSBhdCBhIGxhdGVyIHBvaW50IGluIHRpbWUuIFdlIGRvbid0IHdhbnQgdG8gZmx1c2hcbiAgICAvLyBmb3IgZXZlcnkgaW5wdXQgZXZlbnQgYXMgdGhpcyBjYW4gYmUgZXhwZW5zaXZlLiBIb3dldmVyLCB0aGVyZSBhcmUgc29tZVxuICAgIC8vIHNjZW5hcmlvcyB3aGVyZSB3ZSBjYW5ub3Qgc2FmZWx5IHN0b3JlIHRoZSB0ZXh0IGRpZmYgYW5kIG11c3QgaW5zdGVhZFxuICAgIC8vIHNjaGVkdWxlIGFuIGFjdGlvbiB0byBsZXQgU2xhdGUgbm9ybWFsaXplIHRoZSBlZGl0b3Igc3RhdGUuXG5cblxuICAgIHZhciBjYW5TdG9yZURpZmYgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlJykpIHtcbiAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHRhcmdldFJhbmdlKSkge1xuICAgICAgICB2YXIgW19zdGFydCwgX2VuZF0gPSBSYW5nZS5lZGdlcyh0YXJnZXRSYW5nZSk7XG5cbiAgICAgICAgdmFyIF9sZWFmID0gTm9kZS5sZWFmKGVkaXRvciwgX3N0YXJ0LnBhdGgpO1xuXG4gICAgICAgIGlmIChfbGVhZi50ZXh0Lmxlbmd0aCA9PT0gX3N0YXJ0Lm9mZnNldCAmJiBfZW5kLm9mZnNldCA9PT0gMCkge1xuICAgICAgICAgIHZhciBuZXh0ID0gRWRpdG9yLm5leHQoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogX3N0YXJ0LnBhdGgsXG4gICAgICAgICAgICBtYXRjaDogVGV4dCQxLmlzVGV4dFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKG5leHQgJiYgUGF0aC5lcXVhbHMobmV4dFsxXSwgX2VuZC5wYXRoKSkge1xuICAgICAgICAgICAgdGFyZ2V0UmFuZ2UgPSB7XG4gICAgICAgICAgICAgIGFuY2hvcjogX2VuZCxcbiAgICAgICAgICAgICAgZm9jdXM6IF9lbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSB0eXBlLmVuZHNXaXRoKCdCYWNrd2FyZCcpID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJztcbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyh0YXJnZXRSYW5nZSk7XG4gICAgICB2YXIgW2xlYWYsIHBhdGhdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBzdGFydC5wYXRoKTtcbiAgICAgIHZhciBkaWZmID0ge1xuICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0Lm9mZnNldCxcbiAgICAgICAgZW5kOiBlbmQub2Zmc2V0XG4gICAgICB9O1xuICAgICAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICAgICAgdmFyIHJlbGV2YW50UGVuZGluZ0RpZmZzID0gcGVuZGluZ0RpZmZzID09PSBudWxsIHx8IHBlbmRpbmdEaWZmcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ0RpZmZzLmZpbmQoY2hhbmdlID0+IFBhdGguZXF1YWxzKGNoYW5nZS5wYXRoLCBwYXRoKSk7XG4gICAgICB2YXIgZGlmZnMgPSByZWxldmFudFBlbmRpbmdEaWZmcyA/IFtyZWxldmFudFBlbmRpbmdEaWZmcy5kaWZmLCBkaWZmXSA6IFtkaWZmXTtcbiAgICAgIHZhciB0ZXh0ID0gYXBwbHlTdHJpbmdEaWZmKGxlYWYudGV4dCwgLi4uZGlmZnMpO1xuXG4gICAgICBpZiAodGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gVGV4dCBsZWFmIHdpbGwgYmUgcmVtb3ZlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSBhblxuICAgICAgICAvLyBhY3Rpb24gdG8gcmVtb3ZlIGl0IHNvIHRoYXQgU2xhdGUgY2FuIG5vcm1hbGl6ZSBpbnN0ZWFkXG4gICAgICAgIC8vIG9mIHN0b3JpbmcgYXMgYSBkaWZmXG4gICAgICAgIGNhblN0b3JlRGlmZiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZCh0YXJnZXRSYW5nZSkpIHtcbiAgICAgICAgaWYgKGNhblN0b3JlRGlmZiAmJiBQYXRoLmVxdWFscyh0YXJnZXRSYW5nZS5hbmNob3IucGF0aCwgdGFyZ2V0UmFuZ2UuZm9jdXMucGF0aCkpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgICBwYXRoOiB0YXJnZXRSYW5nZS5hbmNob3IucGF0aCxcbiAgICAgICAgICAgIG9mZnNldDogc3RhcnQub2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb2ludCwgcG9pbnQpO1xuICAgICAgICAgIGhhbmRsZVVzZXJTZWxlY3QocmFuZ2UpO1xuICAgICAgICAgIHJldHVybiBzdG9yZURpZmYodGFyZ2V0UmFuZ2UuYW5jaG9yLnBhdGgsIHtcbiAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgZW5kOiBlbmQub2Zmc2V0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0Lm9mZnNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICBkaXJlY3Rpb25cbiAgICAgICAgfSksIHtcbiAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdkZWxldGVCeUNvbXBvc2l0aW9uJzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q3V0JzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5RHJhZyc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnQnOlxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIGFuY2hvclxuICAgICAgICAgIH0gPSB0YXJnZXRSYW5nZTtcblxuICAgICAgICAgIGlmIChjYW5TdG9yZURpZmYgJiYgUmFuZ2UuaXNDb2xsYXBzZWQodGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIGFuY2hvci5wYXRoKTtcblxuICAgICAgICAgICAgaWYgKGFuY2hvci5vZmZzZXQgPCB0YXJnZXROb2RlLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdG9yZURpZmYoYW5jaG9yLnBhdGgsIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICBzdGFydDogYW5jaG9yLm9mZnNldCxcbiAgICAgICAgICAgICAgICBlbmQ6IGFuY2hvci5vZmZzZXQgKyAxXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVDb250ZW50QmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9uYXRpdmVUYXJnZXRSYW5nZTtcblxuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBhbmNob3I6IF9hbmNob3JcbiAgICAgICAgICB9ID0gdGFyZ2V0UmFuZ2U7IC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBuYXRpdmUgYW5kIHNsYXRlIHNlbGVjdGlvbiBiZWluZyBjb2xsYXBzZWRcbiAgICAgICAgICAvLyB3ZSBhcmUgbW9zdCBsaWtlbHkgZGVsZXRpbmcgYSB6ZXJvLXdpZHRoIHBsYWNlaG9sZGVyIGFuZCB0aHVzIHNob3VsZCBwZXJmb3JtIGl0XG4gICAgICAgICAgLy8gYXMgYW4gYWN0aW9uIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yIChtb3N0bHkgaGFwcGVucyB3aXRoIG1hcmsgcGxhY2Vob2xkZXJzKVxuXG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbGxhcHNlZCA9IGlzRE9NU2VsZWN0aW9uKG5hdGl2ZVRhcmdldFJhbmdlKSA/IG5hdGl2ZVRhcmdldFJhbmdlLmlzQ29sbGFwc2VkIDogISEoKF9uYXRpdmVUYXJnZXRSYW5nZSA9IG5hdGl2ZVRhcmdldFJhbmdlKSAhPT0gbnVsbCAmJiBfbmF0aXZlVGFyZ2V0UmFuZ2UgIT09IHZvaWQgMCAmJiBfbmF0aXZlVGFyZ2V0UmFuZ2UuY29sbGFwc2VkKTtcblxuICAgICAgICAgIGlmIChjYW5TdG9yZURpZmYgJiYgbmF0aXZlQ29sbGFwc2VkICYmIFJhbmdlLmlzQ29sbGFwc2VkKHRhcmdldFJhbmdlKSAmJiBfYW5jaG9yLm9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZURpZmYoX2FuY2hvci5wYXRoLCB7XG4gICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICBzdGFydDogX2FuY2hvci5vZmZzZXQgLSAxLFxuICAgICAgICAgICAgICBlbmQ6IF9hbmNob3Iub2Zmc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUVudGlyZVNvZnRMaW5lJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRMaW5lQnJlYWsnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0UGFyYWdyYXBoJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuaW5zZXJ0QnJlYWsoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0JzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbXBvc2l0aW9uVGV4dCc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbURyb3AnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlJzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21ZYW5rJzpcbiAgICAgIGNhc2UgJ2luc2VydFJlcGxhY2VtZW50VGV4dCc6XG4gICAgICBjYXNlICdpbnNlcnRUZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChpc0RhdGFUcmFuc2ZlcihkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBkYXRhKSwge1xuICAgICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfdGV4dCA9IGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdm9pZCAwID8gZGF0YSA6ICcnOyAvLyBDT01QQVQ6IElmIHdlIGFyZSB3cml0aW5nIGluc2lkZSBhIHBsYWNlaG9sZGVyLCB0aGUgaW1lIGluc2VydHMgdGhlIHRleHQgaW5zaWRlXG4gICAgICAgICAgLy8gdGhlIHBsYWNlaG9sZGVyIGl0c2VsZiBhbmQgdGh1cyBpbmNsdWRlcyB0aGUgemVyby13aWR0aCBzcGFjZSBpbnNpZGUgZWRpdCBldmVudHMuXG5cblxuICAgICAgICAgIGlmIChFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgICAgIF90ZXh0ID0gX3RleHQucmVwbGFjZSgnXFx1RkVGRicsICcnKTtcbiAgICAgICAgICB9IC8vIFBhc3RlcyBmcm9tIHRoZSBBbmRyb2lkIGNsaXBib2FyZCB3aWxsIGdlbmVyYXRlIGBpbnNlcnRUZXh0YCBldmVudHMuXG4gICAgICAgICAgLy8gSWYgdGhlIGNvcGllZCB0ZXh0IGNvbnRhaW5zIGFueSBuZXdsaW5lcywgQW5kcm9pZCB3aWxsIGFwcGVuZCBhblxuICAgICAgICAgIC8vIGV4dHJhIG5ld2xpbmUgdG8gdGhlIGVuZCBvZiB0aGUgY29waWVkIHRleHQuXG5cblxuICAgICAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0VGV4dCcgJiYgLy4qXFxuLipcXG4kLy50ZXN0KF90ZXh0KSkge1xuICAgICAgICAgICAgX3RleHQgPSBfdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgfSAvLyBJZiB0aGUgdGV4dCBpbmNsdWRlcyBhIG5ld2xpbmUsIHNwbGl0IGl0IGF0IG5ld2xpbmVzIGFuZCBwYXN0ZSBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHN0cmluZywgd2l0aCBzb2Z0IGJyZWFrcyBpbiBiZXR3ZWVuIGVhY2guXG5cblxuICAgICAgICAgIGlmIChfdGV4dC5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IF90ZXh0LnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKChsaW5lLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgIEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgbGluZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIEVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyh0YXJnZXRSYW5nZS5hbmNob3IucGF0aCwgdGFyZ2V0UmFuZ2UuZm9jdXMucGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBbX3N0YXJ0MiwgX2VuZDJdID0gUmFuZ2UuZWRnZXModGFyZ2V0UmFuZ2UpO1xuICAgICAgICAgICAgdmFyIF9kaWZmID0ge1xuICAgICAgICAgICAgICBzdGFydDogX3N0YXJ0Mi5vZmZzZXQsXG4gICAgICAgICAgICAgIGVuZDogX2VuZDIub2Zmc2V0LFxuICAgICAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICAgICAgfTsgLy8gQ09NUEFUOiBTd2lmdGtleSBoYXMgYSB3ZWlyZCBidWcgd2hlcmUgdGhlIHRhcmdldCByYW5nZSBvZiB0aGUgMm5kIHdvcmRcbiAgICAgICAgICAgIC8vIGluc2VydGVkIGFmdGVyIGEgbWFyayBwbGFjZWhvbGRlciBpcyBpbnNlcnRlZCB3aXRoIGFuIGFuY2hvciBvZmZzZXQgb2ZmIGJ5IDEuXG4gICAgICAgICAgICAvLyBTbyB3cml0aW5nICdzb21lIHRleHQnIHdpbGwgcmVzdWx0IGluICdzb21lIHR0ZXh0Jy4gTHVja2lseSBhbGwgJ25vcm1hbCcgaW5zZXJ0XG4gICAgICAgICAgICAvLyB0ZXh0IGV2ZW50cyBhcmUgZmlyZWQgd2l0aCB0aGUgY29ycmVjdCB0YXJnZXQgcmFuZ2VzLCBvbmx5IHRoZSBmaW5hbCAnaW5zZXJ0Q29tcG9zaXRpb24nXG4gICAgICAgICAgICAvLyBpc24ndCwgc28gd2UgY2FuIGFkanVzdCB0aGUgdGFyZ2V0IHJhbmdlIHN0YXJ0IG9mZnNldCBpZiB3ZSBhcmUgY29uZmlkZW50IHRoaXMgaXMgdGhlXG4gICAgICAgICAgICAvLyBzd2lmdGtleSBpbnNlcnQgY2F1c2luZyB0aGUgaXNzdWUuXG5cbiAgICAgICAgICAgIGlmIChfdGV4dCAmJiBpbnNlcnRQb3NpdGlvbkhpbnQgJiYgdHlwZSA9PT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcpIHtcbiAgICAgICAgICAgICAgdmFyIGhpbnRQb3NpdGlvbiA9IGluc2VydFBvc2l0aW9uSGludC5zdGFydCArIGluc2VydFBvc2l0aW9uSGludC50ZXh0LnNlYXJjaCgvXFxTfCQvKTtcblxuICAgICAgICAgICAgICB2YXIgZGlmZlBvc2l0aW9uID0gX2RpZmYuc3RhcnQgKyBfZGlmZi50ZXh0LnNlYXJjaCgvXFxTfCQvKTtcblxuICAgICAgICAgICAgICBpZiAoZGlmZlBvc2l0aW9uID09PSBoaW50UG9zaXRpb24gKyAxICYmIF9kaWZmLmVuZCA9PT0gaW5zZXJ0UG9zaXRpb25IaW50LnN0YXJ0ICsgaW5zZXJ0UG9zaXRpb25IaW50LnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgX2RpZmYuc3RhcnQgLT0gMTtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaW5zZXJ0VGV4dCcpIHtcbiAgICAgICAgICAgICAgaWYgKGluc2VydFBvc2l0aW9uSGludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IF9kaWZmO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluc2VydFBvc2l0aW9uSGludCAmJiBSYW5nZS5pc0NvbGxhcHNlZCh0YXJnZXRSYW5nZSkgJiYgaW5zZXJ0UG9zaXRpb25IaW50LmVuZCArIGluc2VydFBvc2l0aW9uSGludC50ZXh0Lmxlbmd0aCA9PT0gX3N0YXJ0Mi5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBfb2JqZWN0U3ByZWFkJDMoX29iamVjdFNwcmVhZCQzKHt9LCBpbnNlcnRQb3NpdGlvbkhpbnQpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgdGV4dDogaW5zZXJ0UG9zaXRpb25IaW50LnRleHQgKyBfdGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhblN0b3JlRGlmZikge1xuICAgICAgICAgICAgICBzdG9yZURpZmYoX3N0YXJ0Mi5wYXRoLCBfZGlmZik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBfdGV4dCksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYXNQZW5kaW5nQWN0aW9uID0gKCkgPT4ge1xuICAgIHJldHVybiAhIUVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZWRpdG9yKTtcbiAgfTtcblxuICB2YXIgaGFzUGVuZGluZ0RpZmZzID0gKCkgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREk0O1xuXG4gICAgcmV0dXJuICEhKChfRURJVE9SX1RPX1BFTkRJTkdfREk0ID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTQgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREk0Lmxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGhhc1BlbmRpbmdDaGFuZ2VzID0gKCkgPT4ge1xuICAgIHJldHVybiBoYXNQZW5kaW5nQWN0aW9uKCkgfHwgaGFzUGVuZGluZ0RpZmZzKCk7XG4gIH07XG5cbiAgdmFyIGlzRmx1c2hpbmcgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGZsdXNoaW5nO1xuICB9O1xuXG4gIHZhciBoYW5kbGVVc2VyU2VsZWN0ID0gcmFuZ2UgPT4ge1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5zZXQoZWRpdG9yLCByYW5nZSk7XG5cbiAgICBpZiAoZmx1c2hUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFRpbWVvdXRJZCk7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG5cbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGhDaGFuZ2VkID0gIXNlbGVjdGlvbiB8fCAhUGF0aC5lcXVhbHMoc2VsZWN0aW9uLmFuY2hvci5wYXRoLCByYW5nZS5hbmNob3IucGF0aCk7XG4gICAgdmFyIHBhcmVudFBhdGhDaGFuZ2VkID0gIXNlbGVjdGlvbiB8fCAhUGF0aC5lcXVhbHMoc2VsZWN0aW9uLmFuY2hvci5wYXRoLnNsaWNlKDAsIC0xKSwgcmFuZ2UuYW5jaG9yLnBhdGguc2xpY2UoMCwgLTEpKTtcblxuICAgIGlmIChwYXRoQ2hhbmdlZCAmJiBpbnNlcnRQb3NpdGlvbkhpbnQgfHwgcGFyZW50UGF0aENoYW5nZWQpIHtcbiAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwYXRoQ2hhbmdlZCB8fCBoYXNQZW5kaW5nRGlmZnMoKSkge1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZsdXNoLCBGTFVTSF9ERUxBWSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVJbnB1dCA9ICgpID0+IHtcbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpIHx8ICFoYXNQZW5kaW5nRGlmZnMoKSkge1xuICAgICAgZmx1c2goKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUtleURvd24gPSBfID0+IHtcbiAgICAvLyBDT01QQVQ6IFN3aWZ0a2V5IGNsb3NlcyB0aGUga2V5Ym9hcmQgd2hlbiB0eXBpbmcgaW5zaWRlIGEgZW1wdHkgbm9kZVxuICAgIC8vIGRpcmVjdGx5IG5leHQgdG8gYSBub24tY29udGVudGVkaXRhYmxlIGVsZW1lbnQgKD0gdGhlIHBsYWNlaG9sZGVyKS5cbiAgICAvLyBUaGUgb25seSBldmVudCBmaXJlZCBzb29uIGVub3VnaCBmb3IgdXMgdG8gYWxsb3cgaGlkaW5nIHRoZSBwbGFjZWhvbGRlclxuICAgIC8vIHdpdGhvdXQgc3dpZnRrZXkgcGlja2luZyBpdCB1cCBpcyB0aGUga2V5ZG93biBldmVudCwgc28gd2UgaGF2ZSB0byBoaWRlIGl0XG4gICAgLy8gaGVyZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9wdWxsLzQ5ODgjaXNzdWVjb21tZW50LTEyMDEwNTA1MzVcbiAgICBpZiAoIWhhc1BlbmRpbmdEaWZmcygpKSB7XG4gICAgICB1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkodHJ1ZSk7XG4gICAgICBzZXRUaW1lb3V0KHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzY2hlZHVsZUZsdXNoID0gKCkgPT4ge1xuICAgIGlmICghaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBhY3Rpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZsdXNoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZURvbU11dGF0aW9ucyA9IG11dGF0aW9ucyA9PiB7XG4gICAgaWYgKGhhc1BlbmRpbmdEaWZmcygpIHx8IGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtdXRhdGlvbnMuc29tZShtdXRhdGlvbiA9PiBpc1RyYWNrZWRNdXRhdGlvbihlZGl0b3IsIG11dGF0aW9uLCBtdXRhdGlvbnMpKSkge1xuICAgICAgdmFyIF9FRElUT1JfVE9fRk9SQ0VfUkVORDtcblxuICAgICAgLy8gQ2F1c2UgYSByZS1yZW5kZXIgdG8gcmVzdG9yZSB0aGUgZG9tIHN0YXRlIGlmIHdlIGVuY291bnRlciB0cmFja2VkIG11dGF0aW9ucyB3aXRob3V0XG4gICAgICAvLyBhIGNvcnJlc3BvbmRpbmcgcGVuZGluZyBhY3Rpb24uXG4gICAgICAoX0VESVRPUl9UT19GT1JDRV9SRU5EID0gRURJVE9SX1RPX0ZPUkNFX1JFTkRFUi5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19GT1JDRV9SRU5EID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX0ZPUkNFX1JFTkQoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBmbHVzaCxcbiAgICBzY2hlZHVsZUZsdXNoLFxuICAgIGhhc1BlbmRpbmdEaWZmcyxcbiAgICBoYXNQZW5kaW5nQWN0aW9uLFxuICAgIGhhc1BlbmRpbmdDaGFuZ2VzLFxuICAgIGlzRmx1c2hpbmcsXG4gICAgaGFuZGxlVXNlclNlbGVjdCxcbiAgICBoYW5kbGVDb21wb3NpdGlvbkVuZCxcbiAgICBoYW5kbGVDb21wb3NpdGlvblN0YXJ0LFxuICAgIGhhbmRsZURPTUJlZm9yZUlucHV0LFxuICAgIGhhbmRsZUtleURvd24sXG4gICAgaGFuZGxlRG9tTXV0YXRpb25zLFxuICAgIGhhbmRsZUlucHV0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUlzTW91bnRlZCgpIHtcbiAgdmFyIGlzTW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlzTW91bnRlZFJlZi5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKG5vZGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBbbXV0YXRpb25PYnNlcnZlcl0gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAvLyBEaXNjYXJkIG11dGF0aW9ucyBjYXVzZWQgZHVyaW5nIHJlbmRlciBwaGFzZS4gVGhpcyB3b3JrcyBkdWUgdG8gcmVhY3QgY2FsbGluZ1xuICAgIC8vIHVzZUxheW91dEVmZmVjdCBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSByZW5kZXIgcGhhc2UgYmVmb3JlIHRoZSBuZXh0IHRpY2suXG4gICAgbXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW5vZGUuY3VycmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXR0YWNoIE11dGF0aW9uT2JzZXJ2ZXIsIGBub2RlYCBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUobm9kZS5jdXJyZW50LCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFtdKTtcbn1cblxudmFyIF9leGNsdWRlZCQyID0gW1wibm9kZVwiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHID0ge1xuICBzdWJ0cmVlOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWVcbn07XG5mdW5jdGlvbiB1c2VBbmRyb2lkSW5wdXRNYW5hZ2VyKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBub2RlXG4gIH0gPSBfcmVmLFxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQkMik7XG5cbiAgaWYgKCFJU19BTkRST0lEKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIGlzTW91bnRlZCA9IHVzZUlzTW91bnRlZCgpO1xuICB2YXIgW2lucHV0TWFuYWdlcl0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVBbmRyb2lkSW5wdXRNYW5hZ2VyKF9vYmplY3RTcHJlYWQkMih7XG4gICAgZWRpdG9yXG4gIH0sIG9wdGlvbnMpKSk7XG4gIHVzZU11dGF0aW9uT2JzZXJ2ZXIobm9kZSwgaW5wdXRNYW5hZ2VyLmhhbmRsZURvbU11dGF0aW9ucywgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHKTtcbiAgRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILnNldChlZGl0b3IsIGlucHV0TWFuYWdlci5zY2hlZHVsZUZsdXNoKTtcblxuICBpZiAoaXNNb3VudGVkKSB7XG4gICAgaW5wdXRNYW5hZ2VyLmZsdXNoKCk7XG4gIH1cblxuICByZXR1cm4gaW5wdXRNYW5hZ2VyO1xufVxuXG5mdW5jdGlvbiB1c2VUcmFja1VzZXJJbnB1dCgpIHtcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciByZWNlaXZlZFVzZXJJbnB1dCA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciBhbmltYXRpb25GcmFtZUlkUmVmID0gdXNlUmVmKDApO1xuICB2YXIgb25Vc2VySW5wdXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWNlaXZlZFVzZXJJbnB1dC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWRSZWYuY3VycmVudCk7XG4gICAgYW5pbWF0aW9uRnJhbWVJZFJlZi5jdXJyZW50ID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICByZWNlaXZlZFVzZXJJbnB1dC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+ICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWRSZWYuY3VycmVudCksIFtdKTtcbiAgcmV0dXJuIHtcbiAgICByZWNlaXZlZFVzZXJJbnB1dCxcbiAgICBvblVzZXJJbnB1dFxuICB9O1xufVxuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJhdXRvRm9jdXNcIiwgXCJkZWNvcmF0ZVwiLCBcIm9uRE9NQmVmb3JlSW5wdXRcIiwgXCJwbGFjZWhvbGRlclwiLCBcInJlYWRPbmx5XCIsIFwicmVuZGVyRWxlbWVudFwiLCBcInJlbmRlckxlYWZcIiwgXCJyZW5kZXJQbGFjZWhvbGRlclwiLCBcInNjcm9sbFNlbGVjdGlvbkludG9WaWV3XCIsIFwic3R5bGVcIiwgXCJhc1wiLCBcImRpc2FibGVEZWZhdWx0U3R5bGVzXCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJ0ZXh0XCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIENoaWxkcmVuID0gcHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHVzZUNoaWxkcmVuKHByb3BzKSk7XG4vKipcclxuICogRWRpdGFibGUuXHJcbiAqL1xuXG5cbnZhciBFZGl0YWJsZSA9IHByb3BzID0+IHtcbiAgdmFyIF9FRElUT1JfVE9fUExBQ0VIT0xERSwgX0VESVRPUl9UT19QTEFDRUhPTERFMjtcblxuICB2YXIgZGVmYXVsdFJlbmRlclBsYWNlaG9sZGVyID0gdXNlQ2FsbGJhY2socHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdFBsYWNlaG9sZGVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpLCBbXSk7XG5cbiAgdmFyIHtcbiAgICBhdXRvRm9jdXMsXG4gICAgZGVjb3JhdGUgPSBkZWZhdWx0RGVjb3JhdGUsXG4gICAgb25ET01CZWZvcmVJbnB1dDogcHJvcHNPbkRPTUJlZm9yZUlucHV0LFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIHJlYWRPbmx5ID0gZmFsc2UsXG4gICAgcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJMZWFmLFxuICAgIHJlbmRlclBsYWNlaG9sZGVyID0gZGVmYXVsdFJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID0gZGVmYXVsdFNjcm9sbFNlbGVjdGlvbkludG9WaWV3LFxuICAgIHN0eWxlOiB1c2VyU3R5bGUgPSB7fSxcbiAgICBhczogQ29tcG9uZW50ID0gJ2RpdicsXG4gICAgZGlzYWJsZURlZmF1bHRTdHlsZXMgPSBmYWxzZVxuICB9ID0gcHJvcHMsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQkMSk7XG5cbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlKCk7IC8vIFJlcmVuZGVyIGVkaXRvciB3aGVuIGNvbXBvc2l0aW9uIHN0YXR1cyBjaGFuZ2VkXG5cbiAgdmFyIFtpc0NvbXBvc2luZywgc2V0SXNDb21wb3NpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgZGVmZXJyZWRPcGVyYXRpb25zID0gdXNlUmVmKFtdKTtcbiAgdmFyIHtcbiAgICBvblVzZXJJbnB1dCxcbiAgICByZWNlaXZlZFVzZXJJbnB1dFxuICB9ID0gdXNlVHJhY2tVc2VySW5wdXQoKTtcbiAgdmFyIFssIGZvcmNlUmVuZGVyXSA9IHVzZVJlZHVjZXIocyA9PiBzICsgMSwgMCk7XG4gIEVESVRPUl9UT19GT1JDRV9SRU5ERVIuc2V0KGVkaXRvciwgZm9yY2VSZW5kZXIpOyAvLyBVcGRhdGUgaW50ZXJuYWwgc3RhdGUgb24gZWFjaCByZW5kZXIuXG5cbiAgSVNfUkVBRF9PTkxZLnNldChlZGl0b3IsIHJlYWRPbmx5KTsgLy8gS2VlcCB0cmFjayBvZiBzb21lIHN0YXRlIGZvciB0aGUgZXZlbnQgaGFuZGxlciBsb2dpYy5cblxuICB2YXIgc3RhdGUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaXNEcmFnZ2luZ0ludGVybmFsbHk6IGZhbHNlLFxuICAgIGlzVXBkYXRpbmdTZWxlY3Rpb246IGZhbHNlLFxuICAgIGxhdGVzdEVsZW1lbnQ6IG51bGwsXG4gICAgaGFzTWFya1BsYWNlaG9sZGVyOiBmYWxzZVxuICB9KSwgW10pOyAvLyBUaGUgYXV0b0ZvY3VzIFRleHRhcmVhSFRNTEF0dHJpYnV0ZSBkb2Vzbid0IGRvIGFueXRoaW5nIG9uIGEgZGl2LCBzbyBpdFxuICAvLyBuZWVkcyB0byBiZSBtYW51YWxseSBmb2N1c2VkLlxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50ICYmIGF1dG9Gb2N1cykge1xuICAgICAgcmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICB9XG4gIH0sIFthdXRvRm9jdXNdKTsgLy8gTGlzdGVuIG9uIHRoZSBuYXRpdmUgYHNlbGVjdGlvbmNoYW5nZWAgZXZlbnQgdG8gYmUgYWJsZSB0byB1cGRhdGUgYW55IHRpbWVcbiAgLy8gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgUmVhY3QncyBgb25TZWxlY3RgIGlzIGxlYWt5XG4gIC8vIGFuZCBub24tc3RhbmRhcmQgc28gaXQgZG9lc24ndCBmaXJlIHVudGlsIGFmdGVyIGEgc2VsZWN0aW9uIGhhcyBiZWVuXG4gIC8vIHJlbGVhc2VkLiBUaGlzIGNhdXNlcyBpc3N1ZXMgaW4gc2l0dWF0aW9ucyB3aGVyZSBhbm90aGVyIGNoYW5nZSBoYXBwZW5zXG4gIC8vIHdoaWxlIGEgc2VsZWN0aW9uIGlzIGJlaW5nIGRyYWdnZWQuXG5cbiAgdmFyIG9uRE9NU2VsZWN0aW9uQ2hhbmdlID0gdXNlQ2FsbGJhY2sodGhyb3R0bGUoKCkgPT4ge1xuICAgIGlmICgoSVNfQU5EUk9JRCB8fCAhUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkgJiYgKCFzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uIHx8IGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IG51bGwgJiYgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gdm9pZCAwICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIuaXNGbHVzaGluZygpKSAmJiAhc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkpIHtcbiAgICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgICB2YXIge1xuICAgICAgICBhY3RpdmVFbGVtZW50XG4gICAgICB9ID0gcm9vdDtcbiAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICB2YXIgZG9tU2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XG4gICAgICAgIHN0YXRlLmxhdGVzdEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50O1xuICAgICAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSVNfRk9DVVNFRC5kZWxldGUoZWRpdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkb21TZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgYW5jaG9yTm9kZSxcbiAgICAgICAgZm9jdXNOb2RlXG4gICAgICB9ID0gZG9tU2VsZWN0aW9uO1xuICAgICAgdmFyIGFuY2hvck5vZGVTZWxlY3RhYmxlID0gUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBhbmNob3JOb2RlKSB8fCBSZWFjdEVkaXRvci5pc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIGFuY2hvck5vZGUpO1xuICAgICAgdmFyIGZvY3VzTm9kZVNlbGVjdGFibGUgPSBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGZvY3VzTm9kZSkgfHwgUmVhY3RFZGl0b3IuaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQoZWRpdG9yLCBmb2N1c05vZGUpO1xuXG4gICAgICBpZiAoYW5jaG9yTm9kZVNlbGVjdGFibGUgJiYgZm9jdXNOb2RlU2VsZWN0YWJsZSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21TZWxlY3Rpb24sIHtcbiAgICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSAmJiAhKGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IG51bGwgJiYgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gdm9pZCAwICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIuaGFzUGVuZGluZ0NoYW5nZXMoKSkgJiYgIShhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSBudWxsICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IHZvaWQgMCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmlzRmx1c2hpbmcoKSkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSBudWxsIHx8IGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuZHJvaWRJbnB1dE1hbmFnZXIuaGFuZGxlVXNlclNlbGVjdChyYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIERlc2VsZWN0IHRoZSBlZGl0b3IgaWYgdGhlIGRvbSBzZWxlY3Rpb24gaXMgbm90IHNlbGVjdGFibGUgaW4gcmVhZG9ubHkgbW9kZVxuXG5cbiAgICAgIGlmIChyZWFkT25seSAmJiAoIWFuY2hvck5vZGVTZWxlY3RhYmxlIHx8ICFmb2N1c05vZGVTZWxlY3RhYmxlKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCAxMDApLCBbcmVhZE9ubHldKTtcbiAgdmFyIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UgPSB1c2VNZW1vKCgpID0+IGRlYm91bmNlKG9uRE9NU2VsZWN0aW9uQ2hhbmdlLCAwKSwgW29uRE9NU2VsZWN0aW9uQ2hhbmdlXSk7XG4gIHZhciBhbmRyb2lkSW5wdXRNYW5hZ2VyID0gdXNlQW5kcm9pZElucHV0TWFuYWdlcih7XG4gICAgbm9kZTogcmVmLFxuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLFxuICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2VcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFVwZGF0ZSBlbGVtZW50LXJlbGF0ZWQgd2VhayBtYXBzIHdpdGggdGhlIERPTSBlbGVtZW50IHJlZi5cbiAgICB2YXIgd2luZG93O1xuXG4gICAgaWYgKHJlZi5jdXJyZW50ICYmICh3aW5kb3cgPSBnZXREZWZhdWx0VmlldyhyZWYuY3VycmVudCkpKSB7XG4gICAgICBFRElUT1JfVE9fV0lORE9XLnNldChlZGl0b3IsIHdpbmRvdyk7XG4gICAgICBFRElUT1JfVE9fRUxFTUVOVC5zZXQoZWRpdG9yLCByZWYuY3VycmVudCk7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuc2V0KGVkaXRvciwgcmVmLmN1cnJlbnQpO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChyZWYuY3VycmVudCwgZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBET00gc2VsZWN0aW9uIHN0YXRlIGlzIGluIHN5bmMuXG5cblxuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgdmFyIGRvbVNlbGVjdGlvbiA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWRvbVNlbGVjdGlvbiB8fCAhUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikgfHwgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gbnVsbCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSB2b2lkIDAgJiYgYW5kcm9pZElucHV0TWFuYWdlci5oYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2V0RG9tU2VsZWN0aW9uID0gZm9yY2VDaGFuZ2UgPT4ge1xuICAgICAgdmFyIGhhc0RvbVNlbGVjdGlvbiA9IGRvbVNlbGVjdGlvbi50eXBlICE9PSAnTm9uZSc7IC8vIElmIHRoZSBET00gc2VsZWN0aW9uIGlzIHByb3Blcmx5IHVuc2V0LCB3ZSdyZSBkb25lLlxuXG4gICAgICBpZiAoIXNlbGVjdGlvbiAmJiAhaGFzRG9tU2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gdmVyaWZ5IHRoYXQgdGhlIGRvbSBzZWxlY3Rpb24gaXMgaW4gdGhlIGVkaXRvclxuXG5cbiAgICAgIHZhciBlZGl0b3JFbGVtZW50ID0gRURJVE9SX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgICB2YXIgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgPSBmYWxzZTtcblxuICAgICAgaWYgKGVkaXRvckVsZW1lbnQuY29udGFpbnMoZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUpICYmIGVkaXRvckVsZW1lbnQuY29udGFpbnMoZG9tU2VsZWN0aW9uLmZvY3VzTm9kZSkpIHtcbiAgICAgICAgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgPSB0cnVlO1xuICAgICAgfSAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBpcyBpbiB0aGUgZWRpdG9yIGFuZCB0aGUgZWRpdG9yIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGNvcnJlY3QsIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKGhhc0RvbVNlbGVjdGlvbiAmJiBoYXNEb21TZWxlY3Rpb25JbkVkaXRvciAmJiBzZWxlY3Rpb24gJiYgIWZvcmNlQ2hhbmdlKSB7XG4gICAgICAgIHZhciBzbGF0ZVJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgICAgZXhhY3RNYXRjaDogdHJ1ZSxcbiAgICAgICAgICAvLyBkb21TZWxlY3Rpb24gaXMgbm90IG5lY2Vzc2FyaWx5IGEgdmFsaWQgU2xhdGUgcmFuZ2VcbiAgICAgICAgICAvLyAoZS5nLiB3aGVuIGNsaWNraW5nIG9uIGNvbnRlbnRFZGl0YWJsZTpmYWxzZSBlbGVtZW50KVxuICAgICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNsYXRlUmFuZ2UgJiYgUmFuZ2UuZXF1YWxzKHNsYXRlUmFuZ2UsIHNlbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgX2FuY2hvck5vZGUkcGFyZW50RWxlO1xuXG4gICAgICAgICAgaWYgKCFzdGF0ZS5oYXNNYXJrUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIEVuc3VyZSBzZWxlY3Rpb24gaXMgaW5zaWRlIHRoZSBtYXJrIHBsYWNlaG9sZGVyXG5cblxuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBhbmNob3JOb2RlXG4gICAgICAgICAgfSA9IGRvbVNlbGVjdGlvbjtcblxuICAgICAgICAgIGlmIChhbmNob3JOb2RlICE9PSBudWxsICYmIGFuY2hvck5vZGUgIT09IHZvaWQgMCAmJiAoX2FuY2hvck5vZGUkcGFyZW50RWxlID0gYW5jaG9yTm9kZS5wYXJlbnRFbGVtZW50KSAhPT0gbnVsbCAmJiBfYW5jaG9yTm9kZSRwYXJlbnRFbGUgIT09IHZvaWQgMCAmJiBfYW5jaG9yTm9kZSRwYXJlbnRFbGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW1hcmstcGxhY2Vob2xkZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyB3aGVuIDxFZGl0YWJsZS8+IGlzIGJlaW5nIGNvbnRyb2xsZWQgdGhyb3VnaCBleHRlcm5hbCB2YWx1ZVxuICAgICAgLy8gdGhlbiBpdHMgY2hpbGRyZW4gbWlnaHQganVzdCBjaGFuZ2UgLSBET00gcmVzcG9uZHMgdG8gaXQgb24gaXRzIG93blxuICAgICAgLy8gYnV0IFNsYXRlJ3MgdmFsdWUgaXMgbm90IGJlaW5nIHVwZGF0ZWQgdGhyb3VnaCBhbnkgb3BlcmF0aW9uXG4gICAgICAvLyBhbmQgdGh1cyBpdCBkb2Vzbid0IHRyYW5zZm9ybSBzZWxlY3Rpb24gb24gaXRzIG93blxuXG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgIVJlYWN0RWRpdG9yLmhhc1JhbmdlKGVkaXRvciwgc2VsZWN0aW9uKSkge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBPdGhlcndpc2UgdGhlIERPTSBzZWxlY3Rpb24gaXMgb3V0IG9mIHN5bmMsIHNvIHVwZGF0ZSBpdC5cblxuXG4gICAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBuZXdEb21SYW5nZSA9IHNlbGVjdGlvbiAmJiBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgc2VsZWN0aW9uKTtcblxuICAgICAgaWYgKG5ld0RvbVJhbmdlKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBkb21TZWxlY3Rpb24uc2V0QmFzZUFuZEV4dGVudChuZXdEb21SYW5nZS5lbmRDb250YWluZXIsIG5ld0RvbVJhbmdlLmVuZE9mZnNldCwgbmV3RG9tUmFuZ2Uuc3RhcnRDb250YWluZXIsIG5ld0RvbVJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21TZWxlY3Rpb24uc2V0QmFzZUFuZEV4dGVudChuZXdEb21SYW5nZS5zdGFydENvbnRhaW5lciwgbmV3RG9tUmFuZ2Uuc3RhcnRPZmZzZXQsIG5ld0RvbVJhbmdlLmVuZENvbnRhaW5lciwgbmV3RG9tUmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3KGVkaXRvciwgbmV3RG9tUmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3RG9tUmFuZ2U7XG4gICAgfTtcblxuICAgIHZhciBuZXdEb21SYW5nZSA9IHNldERvbVNlbGVjdGlvbigpO1xuICAgIHZhciBlbnN1cmVTZWxlY3Rpb24gPSAoYW5kcm9pZElucHV0TWFuYWdlciA9PT0gbnVsbCB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmlzRmx1c2hpbmcoKSkgPT09ICdhY3Rpb24nO1xuXG4gICAgaWYgKCFJU19BTkRST0lEIHx8ICFlbnN1cmVTZWxlY3Rpb24pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIGl0J3Mgbm90IGVub3VnaCB0byBjcmVhdGUgYSByYW5nZSwgeW91IGFsc28gbmVlZFxuICAgICAgICAvLyB0byBmb2N1cyB0aGUgY29udGVudGVkaXRhYmxlIGVsZW1lbnQgdG9vLiAoMjAxNi8xMS8xNilcbiAgICAgICAgaWYgKG5ld0RvbVJhbmdlICYmIElTX0ZJUkVGT1gpIHtcbiAgICAgICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGltZW91dElkID0gbnVsbDtcbiAgICB2YXIgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoZW5zdXJlU2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBlbnN1cmVEb21TZWxlY3Rpb24gPSBmb3JjZUNoYW5nZSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICAgICAgc2V0RG9tU2VsZWN0aW9uKGZvcmNlQ2hhbmdlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7Ly8gSWdub3JlLCBkb20gYW5kIHN0YXRlIG1pZ2h0IGJlIG91dCBvZiBzeW5jXG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBDb21wYXQ6IEFuZHJvaWQgSU1FcyB0cnkgdG8gZm9yY2UgdGhlaXIgc2VsZWN0aW9uIGJ5IG1hbnVhbGx5IHJlLWFwcGx5aW5nIGl0IGV2ZW4gYWZ0ZXIgd2Ugc2V0IGl0LlxuICAgICAgICAvLyBUaGlzIGVzc2VudGlhbGx5IHdvdWxkIG1ha2Ugc2V0dGluZyB0aGUgc2xhdGUgc2VsZWN0aW9uIGR1cmluZyBhbiB1cGRhdGUgbWVhbmluZ2xlc3MsIHNvIHdlIGZvcmNlIGl0XG4gICAgICAgIC8vIGFnYWluIGhlcmUuIFdlIGNhbid0IG9ubHkgZG8gaXQgaW4gdGhlIHNldFRpbWVvdXQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBmcmFtZSBzaW5jZSB0aGF0IHdvdWxkIGNhdXNlIGFcbiAgICAgICAgLy8gdmlzaWJsZSBmbGlja2VyLlxuXG5cbiAgICAgICAgZW5zdXJlRG9tU2VsZWN0aW9uKCk7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIC8vIENPTVBBVDogV2hpbGUgc2V0dGluZyB0aGUgc2VsZWN0aW9uIGluIGFuIGFuaW1hdGlvbiBmcmFtZSB2aXN1YWxseSBjb3JyZWN0bHkgc2V0cyB0aGUgc2VsZWN0aW9uLFxuICAgICAgICAgIC8vIGl0IGRvZXNuJ3QgdXBkYXRlIEdCb2FyZHMgc3BlbGxjaGVja2VyIHN0YXRlLiBXZSBoYXZlIHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBzZWxlY3Rpb24gY2hhbmdlIGFmdGVyXG4gICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBmcmFtZSB0byBlbnN1cmUgaXQgZGlzcGxheXMgdGhlIGNvcnJlY3Qgc3RhdGUuXG4gICAgICAgICAgZW5zdXJlRG9tU2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgIHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xuXG4gICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pOyAvLyBMaXN0ZW4gb24gdGhlIG5hdGl2ZSBgYmVmb3JlaW5wdXRgIGV2ZW50IHRvIGdldCByZWFsIFwiTGV2ZWwgMlwiIGV2ZW50cy4gVGhpc1xuICAvLyBpcyByZXF1aXJlZCBiZWNhdXNlIFJlYWN0J3MgYGJlZm9yZWlucHV0YCBpcyBmYWtlIGFuZCBuZXZlciByZWFsbHkgYXR0YWNoZXNcbiAgLy8gdG8gdGhlIHJlYWwgZXZlbnQgc2FkbHkuICgyMDE5LzExLzAxKVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExMjExXG5cbiAgdmFyIG9uRE9NQmVmb3JlSW5wdXQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgb25Vc2VySW5wdXQoKTtcblxuICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0RPTUV2ZW50SGFuZGxlZChldmVudCwgcHJvcHNPbkRPTUJlZm9yZUlucHV0KSkge1xuICAgICAgdmFyIF9FRElUT1JfVE9fVVNFUl9TRUxFQztcblxuICAgICAgLy8gQ09NUEFUOiBCZWZvcmVJbnB1dCBldmVudHMgYXJlbid0IGNhbmNlbGFibGUgb24gYW5kcm9pZCwgc28gd2UgaGF2ZSB0byBoYW5kbGUgdGhlbSBkaWZmZXJlbnRseSB1c2luZyB0aGUgYW5kcm9pZCBpbnB1dCBtYW5hZ2VyLlxuICAgICAgaWYgKGFuZHJvaWRJbnB1dE1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIGFuZHJvaWRJbnB1dE1hbmFnZXIuaGFuZGxlRE9NQmVmb3JlSW5wdXQoZXZlbnQpO1xuICAgICAgfSAvLyBTb21lIElNRXMvQ2hyb21lIGV4dGVuc2lvbnMgbGlrZSBlLmcuIEdyYW1tYXJseSBzZXQgdGhlIHNlbGVjdGlvbiBpbW1lZGlhdGVseSBiZWZvcmVcbiAgICAgIC8vIHRyaWdnZXJpbmcgYSBgYmVmb3JlaW5wdXRgIGV4cGVjdGluZyB0aGUgY2hhbmdlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGltbWVkaWF0ZWx5IGJlZm9yZVxuICAgICAgLy8gc2V0IHNlbGVjdGlvbi5cblxuXG4gICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5mbHVzaCgpO1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuICAgICAgdmFyIHtcbiAgICAgICAgaW5wdXRUeXBlOiB0eXBlXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFUcmFuc2ZlciB8fCBldmVudC5kYXRhIHx8IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpc0NvbXBvc2l0aW9uQ2hhbmdlID0gdHlwZSA9PT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcgfHwgdHlwZSA9PT0gJ2RlbGV0ZUNvbXBvc2l0aW9uVGV4dCc7IC8vIENPTVBBVDogdXNlIGNvbXBvc2l0aW9uIGNoYW5nZSBldmVudHMgYXMgYSBoaW50IHRvIHdoZXJlIHdlIHNob3VsZCBpbnNlcnRcbiAgICAgIC8vIGNvbXBvc2l0aW9uIHRleHQgaWYgd2UgYXJlbid0IGNvbXBvc2luZyB0byB3b3JrIGFyb3VuZCBodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvaXNzdWVzLzUwMzhcblxuICAgICAgaWYgKGlzQ29tcG9zaXRpb25DaGFuZ2UgJiYgUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuYXRpdmUgPSBmYWxzZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdpbnNlcnRUZXh0JyAmJiBzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSAmJiAvLyBPbmx5IHVzZSBuYXRpdmUgY2hhcmFjdGVyIGluc2VydGlvbiBmb3Igc2luZ2xlIGNoYXJhY3RlcnMgYS16IG9yIHNwYWNlIGZvciBub3cuXG4gICAgICAvLyBMb25nLXByZXNzIGV2ZW50cyAoaG9sZCBhICsgcHJlc3MgNCA9IMOkKSB0byBjaG9vc2UgYSBzcGVjaWFsIGNoYXJhY3RlciBvdGhlcndpc2VcbiAgICAgIC8vIGNhdXNlcyBkdXBsaWNhdGUgaW5zZXJ0cy5cbiAgICAgIGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5sZW5ndGggPT09IDEgJiYgL1thLXogXS9pLnRlc3QoZXZlbnQuZGF0YSkgJiYgLy8gQ2hyb21lIGhhcyBpc3N1ZXMgY29ycmVjdGx5IGVkaXRpbmcgdGhlIHN0YXJ0IG9mIG5vZGVzOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjQ5NDA1XG4gICAgICAvLyBXaGVuIHRoZXJlIGlzIGFuIGlubGluZSBlbGVtZW50LCBlLmcuIGEgbGluaywgYW5kIHlvdSBzZWxlY3RcbiAgICAgIC8vIHJpZ2h0IGFmdGVyIGl0ICh0aGUgc3RhcnQgb2YgdGhlIG5leHQgbm9kZSkuXG4gICAgICBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCAhPT0gMCkge1xuICAgICAgICB2YXIgX25vZGUkcGFyZW50RWxlbWVudCwgX3dpbmRvdyRnZXRDb21wdXRlZFN0O1xuXG4gICAgICAgIG5hdGl2ZSA9IHRydWU7IC8vIFNraXAgbmF0aXZlIGlmIHRoZXJlIGFyZSBtYXJrcywgYXNcbiAgICAgICAgLy8gYGluc2VydFRleHRgIHdpbGwgaW5zZXJ0IGEgbm9kZSwgbm90IGp1c3QgdGV4dC5cblxuICAgICAgICBpZiAoZWRpdG9yLm1hcmtzKSB7XG4gICAgICAgICAgbmF0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gLy8gQ2hyb21lIGFsc28gaGFzIGlzc3VlcyBjb3JyZWN0bHkgZWRpdGluZyB0aGUgZW5kIG9mIGFuY2hvciBlbGVtZW50czogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTI1OTEwMFxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgZG9uJ3QgYWxsb3cgbmF0aXZlIGV2ZW50cyB0byBpbnNlcnQgdGV4dCBhdCB0aGUgZW5kIG9mIGFuY2hvciBub2Rlcy5cblxuXG4gICAgICAgIHZhciB7XG4gICAgICAgICAgYW5jaG9yXG4gICAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIHZhciBbbm9kZSwgb2Zmc2V0XSA9IFJlYWN0RWRpdG9yLnRvRE9NUG9pbnQoZWRpdG9yLCBhbmNob3IpO1xuICAgICAgICB2YXIgYW5jaG9yTm9kZSA9IChfbm9kZSRwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfbm9kZSRwYXJlbnRFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRwYXJlbnRFbGVtZW50LmNsb3Nlc3QoJ2EnKTtcbiAgICAgICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuXG4gICAgICAgIGlmIChuYXRpdmUgJiYgYW5jaG9yTm9kZSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICB2YXIgX2xhc3RUZXh0JHRleHRDb250ZW50O1xuXG4gICAgICAgICAgLy8gRmluZCB0aGUgbGFzdCB0ZXh0IG5vZGUgaW5zaWRlIHRoZSBhbmNob3IuXG4gICAgICAgICAgdmFyIGxhc3RUZXh0ID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoYW5jaG9yTm9kZSwgTm9kZUZpbHRlci5TSE9XX1RFWFQpLmxhc3RDaGlsZCgpO1xuXG4gICAgICAgICAgaWYgKGxhc3RUZXh0ID09PSBub2RlICYmICgoX2xhc3RUZXh0JHRleHRDb250ZW50ID0gbGFzdFRleHQudGV4dENvbnRlbnQpID09PSBudWxsIHx8IF9sYXN0VGV4dCR0ZXh0Q29udGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xhc3RUZXh0JHRleHRDb250ZW50Lmxlbmd0aCkgPT09IG9mZnNldCkge1xuICAgICAgICAgICAgbmF0aXZlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENocm9tZSBoYXMgaXNzdWVzIHdpdGggdGhlIHByZXNlbmNlIG9mIHRhYiBjaGFyYWN0ZXJzIGluc2lkZSBlbGVtZW50cyB3aXRoIHdoaXRlU3BhY2UgPSAncHJlJ1xuICAgICAgICAvLyBjYXVzaW5nIGFibm9ybWFsIGluc2VydCBiZWhhdmlvcjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTIxOTEzOVxuXG5cbiAgICAgICAgaWYgKG5hdGl2ZSAmJiBub2RlLnBhcmVudEVsZW1lbnQgJiYgKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfd2luZG93JGdldENvbXB1dGVkU3QgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLnBhcmVudEVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfd2luZG93JGdldENvbXB1dGVkU3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3ckZ2V0Q29tcHV0ZWRTdC53aGl0ZVNwYWNlKSA9PT0gJ3ByZScpIHtcbiAgICAgICAgICB2YXIgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogYW5jaG9yLnBhdGgsXG4gICAgICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50JDEuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbilcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChibG9jayAmJiBOb2RlLnN0cmluZyhibG9ja1swXSkuaW5jbHVkZXMoJ1xcdCcpKSB7XG4gICAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ09NUEFUOiBGb3IgdGhlIGRlbGV0aW5nIGZvcndhcmQvYmFja3dhcmQgaW5wdXQgdHlwZXMgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gY2hhbmdlIHRoZSBzZWxlY3Rpb24gYmVjYXVzZSBpdCBpcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIGJlIGRlbGV0ZWQsXG4gICAgICAvLyBhbmQgdGhvc2UgY29tbWFuZHMgZGV0ZXJtaW5lIHRoYXQgZm9yIHRoZW1zZWx2ZXMuXG5cblxuICAgICAgaWYgKCF0eXBlLnN0YXJ0c1dpdGgoJ2RlbGV0ZScpIHx8IHR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlQnknKSkge1xuICAgICAgICB2YXIgW3RhcmdldFJhbmdlXSA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpO1xuXG4gICAgICAgIGlmICh0YXJnZXRSYW5nZSkge1xuICAgICAgICAgIHZhciByYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIHRhcmdldFJhbmdlLCB7XG4gICAgICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIHN1cHByZXNzVGhyb3c6IGZhbHNlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKHNlbGVjdGlvbiwgcmFuZ2UpKSB7XG4gICAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SZWYgPSAhaXNDb21wb3NpdGlvbkNoYW5nZSAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25SZWYpIHtcbiAgICAgICAgICAgICAgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLnNldChlZGl0b3IsIHNlbGVjdGlvblJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENvbXBvc2l0aW9uIGNoYW5nZSB0eXBlcyBvY2N1ciB3aGlsZSBhIHVzZXIgaXMgY29tcG9zaW5nIHRleHQgYW5kIGNhbid0IGJlXG4gICAgICAvLyBjYW5jZWxsZWQuIExldCB0aGVtIHRocm91Z2ggYW5kIHdhaXQgZm9yIHRoZSBjb21wb3NpdGlvbiB0byBlbmQuXG5cblxuICAgICAgaWYgKGlzQ29tcG9zaXRpb25DaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW5hdGl2ZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSAvLyBDT01QQVQ6IElmIHRoZSBzZWxlY3Rpb24gaXMgZXhwYW5kZWQsIGV2ZW4gaWYgdGhlIGNvbW1hbmQgc2VlbXMgbGlrZVxuICAgICAgLy8gYSBkZWxldGUgZm9yd2FyZC9iYWNrd2FyZCBjb21tYW5kIGl0IHNob3VsZCBkZWxldGUgdGhlIHNlbGVjdGlvbi5cblxuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSAmJiB0eXBlLnN0YXJ0c1dpdGgoJ2RlbGV0ZScpKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0eXBlLmVuZHNXaXRoKCdCYWNrd2FyZCcpID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJztcbiAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgIGRpcmVjdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZGVsZXRlQnlDb21wb3NpdGlvbic6XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q3V0JzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQnlEcmFnJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50JzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVFbnRpcmVTb2Z0TGluZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVXb3JkQmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVXb3JkRm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0TGluZUJyZWFrJzpcbiAgICAgICAgICBFZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0UGFyYWdyYXBoJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuaW5zZXJ0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nOlxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tRHJvcCc6XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21QYXN0ZSc6XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21ZYW5rJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0UmVwbGFjZW1lbnRUZXh0JzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0VGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgIC8vIENPTVBBVDogaW4gU2FmYXJpLCBgY29tcG9zaXRpb25lbmRgIGlzIGRpc3BhdGNoZWQgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgIC8vIGBiZWZvcmVpbnB1dGAgZm9yIFwiaW5zZXJ0RnJvbUNvbXBvc2l0aW9uXCIuIEJ1dCBpZiB3ZSB3YWl0IGZvciBpdFxuICAgICAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgYWJvcnQgYmVjYXVzZSB3ZSdyZSBzdGlsbCBjb21wb3NpbmcgYW5kIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgLy8gd29uJ3QgYmUgdXBkYXRlZCBwcm9wZXJseS5cbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2lucHV0LWV2ZW50cy0yL1xuICAgICAgICAgICAgICBpZiAoUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICAgICAgICAgIHNldElzQ29tcG9zaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIHVzZSBhIHdlYWsgY29tcGFyaXNvbiBpbnN0ZWFkIG9mICdpbnN0YW5jZW9mJyB0byBhbGxvd1xuICAgICAgICAgICAgLy8gcHJvZ3JhbW1hdGljIGFjY2VzcyBvZiBwYXN0ZSBldmVudHMgY29taW5nIGZyb20gZXh0ZXJuYWwgd2luZG93c1xuICAgICAgICAgICAgLy8gbGlrZSBjeXByZXNzIHdoZXJlIGN5LndpbmRvdyBkb2VzIG5vdCB3b3JrIHJlYWxpYmx5XG5cblxuICAgICAgICAgICAgaWYgKChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuY29uc3RydWN0b3IubmFtZSkgPT09ICdEYXRhVHJhbnNmZXInKSB7XG4gICAgICAgICAgICAgIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgaW5zZXJ0VGV4dCBvcGVyYXRpb25zIHVzZSB0aGUgbmF0aXZlIGZ1bmN0aW9uYWxpdHksIGZvciBub3cuXG4gICAgICAgICAgICAgIC8vIFBvdGVudGlhbGx5IGV4cGFuZCB0byBzaW5nbGUgY2hhcmFjdGVyIGRlbGV0ZXMsIGFzIHdlbGwuXG4gICAgICAgICAgICAgIGlmIChuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbnMuY3VycmVudC5wdXNoKCgpID0+IEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgZGF0YSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfSAvLyBSZXN0b3JlIHRoZSBhY3R1YWwgdXNlciBzZWN0aW9uIGlmIG5vdGhpbmcgbWFudWFsbHkgc2V0IGl0LlxuXG5cbiAgICAgIHZhciB0b1Jlc3RvcmUgPSAoX0VESVRPUl9UT19VU0VSX1NFTEVDID0gRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1VTRVJfU0VMRUMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fVVNFUl9TRUxFQy51bnJlZigpO1xuICAgICAgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuXG4gICAgICBpZiAodG9SZXN0b3JlICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKGVkaXRvci5zZWxlY3Rpb24sIHRvUmVzdG9yZSkpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgdG9SZXN0b3JlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtyZWFkT25seSwgcHJvcHNPbkRPTUJlZm9yZUlucHV0XSk7XG4gIHZhciBjYWxsYmFja1JlZiA9IHVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICAgIEVESVRPUl9UT19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuXG4gICAgICBpZiAocmVmLmN1cnJlbnQgJiYgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgVGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQgaXNuJ3QgcmVjb2duaXplZC5cbiAgICAgICAgcmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCBvbkRPTUJlZm9yZUlucHV0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXR0YWNoIGEgbmF0aXZlIERPTSBldmVudCBoYW5kbGVyIGZvciBgYmVmb3JlaW5wdXRgIGV2ZW50cywgYmVjYXVzZSBSZWFjdCdzXG4gICAgICAvLyBidWlsdC1pbiBgb25CZWZvcmVJbnB1dGAgaXMgYWN0dWFsbHkgYSBsZWFreSBwb2x5ZmlsbCB0aGF0IGRvZXNuJ3QgZXhwb3NlXG4gICAgICAvLyByZWFsIGBiZWZvcmVpbnB1dGAgZXZlbnRzIHNhZGx5Li4uICgyMDE5LzExLzA0KVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTIxMVxuICAgICAgaWYgKEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlIFRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50IGlzbid0IHJlY29nbml6ZWQuXG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCBvbkRPTUJlZm9yZUlucHV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gIH0sIFtyZWYsIG9uRE9NQmVmb3JlSW5wdXQsIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLCBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlXSk7IC8vIEF0dGFjaCBhIG5hdGl2ZSBET00gZXZlbnQgaGFuZGxlciBmb3IgYHNlbGVjdGlvbmNoYW5nZWAsIGJlY2F1c2UgUmVhY3Qnc1xuICAvLyBidWlsdC1pbiBgb25TZWxlY3RgIGhhbmRsZXIgZG9lc24ndCBmaXJlIGZvciBhbGwgc2VsZWN0aW9uIGNoYW5nZXMuIEl0J3MgYVxuICAvLyBsZWFreSBwb2x5ZmlsbCB0aGF0IG9ubHkgZmlyZXMgb24ga2V5cHJlc3NlcyBvciBjbGlja3MuIEluc3RlYWQsIHdlIHdhbnQgdG9cbiAgLy8gZmlyZSBmb3IgYW55IGNoYW5nZSB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSB0aGUgZWRpdG9yLiAoMjAxOS8xMS8wNClcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy81Nzg1XG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlXSk7XG4gIHZhciBkZWNvcmF0aW9ucyA9IGRlY29yYXRlKFtlZGl0b3IsIFtdXSk7XG5cbiAgaWYgKHBsYWNlaG9sZGVyICYmIGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgQXJyYXkuZnJvbShOb2RlLnRleHRzKGVkaXRvcikpLmxlbmd0aCA9PT0gMSAmJiBOb2RlLnN0cmluZyhlZGl0b3IpID09PSAnJyAmJiAhaXNDb21wb3NpbmcpIHtcbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgZGVjb3JhdGlvbnMucHVzaCh7XG4gICAgICBbUExBQ0VIT0xERVJfU1lNQk9MXTogdHJ1ZSxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgIGZvY3VzOiBzdGFydFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHtcbiAgICBtYXJrc1xuICB9ID0gZWRpdG9yO1xuICBzdGF0ZS5oYXNNYXJrUGxhY2Vob2xkZXIgPSBmYWxzZTtcblxuICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSAmJiBtYXJrcykge1xuICAgIHZhciB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB2YXIgbGVhZiA9IE5vZGUubGVhZihlZGl0b3IsIGFuY2hvci5wYXRoKTtcblxuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGxlYWYsIF9leGNsdWRlZDIpOyAvLyBXaGlsZSBtYXJrcyBpc24ndCBhICdjb21wbGV0ZScgdGV4dCwgd2UgY2FuIHN0aWxsIHVzZSBsb29zZSBUZXh0LmVxdWFsc1xuICAgIC8vIGhlcmUgd2hpY2ggb25seSBjb21wYXJlcyBtYXJrcyBhbnl3YXkuXG5cblxuICAgIGlmICghVGV4dCQxLmVxdWFscyhsZWFmLCBtYXJrcywge1xuICAgICAgbG9vc2U6IHRydWVcbiAgICB9KSkge1xuICAgICAgc3RhdGUuaGFzTWFya1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHZhciB1bnNldCA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhyZXN0KS5tYXAobWFyayA9PiBbbWFyaywgbnVsbF0pKTtcbiAgICAgIGRlY29yYXRpb25zLnB1c2goX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe1xuICAgICAgICBbTUFSS19QTEFDRUhPTERFUl9TWU1CT0xdOiB0cnVlXG4gICAgICB9LCB1bnNldCksIG1hcmtzKSwge30sIHtcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBmb2N1czogYW5jaG9yXG4gICAgICB9KSk7XG4gICAgfVxuICB9IC8vIFVwZGF0ZSBFRElUT1JfVE9fTUFSS19QTEFDRUhPTERFUl9NQVJLUyBpbiBzZXRUaW1lb3V0IHVzZUVmZmVjdCB0byBlbnN1cmUgd2UgZG9uJ3Qgc2V0IGl0XG4gIC8vIGJlZm9yZSB3ZSByZWNlaXZlIHRoZSBjb21wb3NpdGlvbiBlbmQgZXZlbnQuXG5cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgYW5jaG9yOiBfYW5jaG9yXG4gICAgICAgIH0gPSBzZWxlY3Rpb247XG5cbiAgICAgICAgdmFyIF90ZXh0ID0gTm9kZS5sZWFmKGVkaXRvciwgX2FuY2hvci5wYXRoKTsgLy8gV2hpbGUgbWFya3MgaXNuJ3QgYSAnY29tcGxldGUnIHRleHQsIHdlIGNhbiBzdGlsbCB1c2UgbG9vc2UgVGV4dC5lcXVhbHNcbiAgICAgICAgLy8gaGVyZSB3aGljaCBvbmx5IGNvbXBhcmVzIG1hcmtzIGFueXdheS5cblxuXG4gICAgICAgIGlmIChtYXJrcyAmJiAhVGV4dCQxLmVxdWFscyhfdGV4dCwgbWFya3MsIHtcbiAgICAgICAgICBsb29zZTogdHJ1ZVxuICAgICAgICB9KSkge1xuICAgICAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZWRpdG9yLCBtYXJrcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHZhciBwbGFjZWhvbGRlckhlaWdodCA9IChfRURJVE9SX1RPX1BMQUNFSE9MREUgPSBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVC5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19QTEFDRUhPTERFID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX0VESVRPUl9UT19QTEFDRUhPTERFMiA9IF9FRElUT1JfVE9fUExBQ0VIT0xERS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19QTEFDRUhPTERFMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19QTEFDRUhPTERFMi5oZWlnaHQ7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFkT25seUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcmVhZE9ubHlcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVjb3JhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRlY29yYXRlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlc3RvcmVET00sIHtcbiAgICBub2RlOiByZWYsXG4gICAgcmVjZWl2ZWRVc2VySW5wdXQ6IHJlY2VpdmVkVXNlcklucHV0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7XG4gICAgcm9sZTogcmVhZE9ubHkgPyB1bmRlZmluZWQgOiAndGV4dGJveCcsXG4gICAgXCJhcmlhLW11bHRpbGluZVwiOiByZWFkT25seSA/IHVuZGVmaW5lZCA6IHRydWVcbiAgfSwgYXR0cmlidXRlcywge1xuICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZSdkXG4gICAgLy8gaGF2ZSB0byB1c2UgaGFja3MgdG8gbWFrZSB0aGVzZSByZXBsYWNlbWVudC1iYXNlZCBmZWF0dXJlcyB3b3JrLlxuICAgIC8vIEZvciBTU1Igc2l0dWF0aW9ucyBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgaXMgZmFsc2UgYW5kIHJlc3VsdHMgaW4gcHJvcFxuICAgIC8vIG1pc21hdGNoIHdhcm5pbmcgYXBwIG1vdmVzIHRvIGJyb3dzZXIuIFBhc3MtdGhyb3VnaCBjb25zdW1lciBwcm9wcyB3aGVuXG4gICAgLy8gbm90IENBTl9VU0VfRE9NIChTU1IpIGFuZCBkZWZhdWx0IHRvIGZhbHN5IHZhbHVlXG4gICAgc3BlbGxDaGVjazogSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8ICFDQU5fVVNFX0RPTSA/IGF0dHJpYnV0ZXMuc3BlbGxDaGVjayA6IGZhbHNlLFxuICAgIGF1dG9Db3JyZWN0OiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgIUNBTl9VU0VfRE9NID8gYXR0cmlidXRlcy5hdXRvQ29ycmVjdCA6ICdmYWxzZScsXG4gICAgYXV0b0NhcGl0YWxpemU6IEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCAhQ0FOX1VTRV9ET00gPyBhdHRyaWJ1dGVzLmF1dG9DYXBpdGFsaXplIDogJ2ZhbHNlJyxcbiAgICBcImRhdGEtc2xhdGUtZWRpdG9yXCI6IHRydWUsXG4gICAgXCJkYXRhLXNsYXRlLW5vZGVcIjogXCJ2YWx1ZVwiLFxuICAgIC8vIGV4cGxpY2l0bHkgc2V0IHRoaXNcbiAgICBjb250ZW50RWRpdGFibGU6ICFyZWFkT25seSxcbiAgICAvLyBpbiBzb21lIGNhc2VzLCBhIGRlY29yYXRpb24gbmVlZHMgYWNjZXNzIHRvIHRoZSByYW5nZSAvIHNlbGVjdGlvbiB0byBkZWNvcmF0ZSBhIHRleHQgbm9kZSxcbiAgICAvLyB0aGVuIHlvdSB3aWxsIHNlbGVjdCB0aGUgd2hvbGUgdGV4dCBub2RlIHdoZW4geW91IHNlbGVjdCBwYXJ0IHRoZSBvZiB0ZXh0XG4gICAgLy8gdGhpcyBtYWdpYyB6SW5kZXg9XCItMVwiIHdpbGwgZml4IGl0XG4gICAgemluZGV4OiAtMSxcbiAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gICAgcmVmOiBjYWxsYmFja1JlZixcbiAgICBzdHlsZTogX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgZGlzYWJsZURlZmF1bHRTdHlsZXMgPyB7fSA6IF9vYmplY3RTcHJlYWQkMSh7XG4gICAgICAvLyBBbGxvdyBwb3NpdGlvbmluZyByZWxhdGl2ZSB0byB0aGUgZWRpdGFibGUgZWxlbWVudC5cbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBvdXRsaW5lIHN0eWxlcy5cbiAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgIC8vIFByZXNlcnZlIGFkamFjZW50IHdoaXRlc3BhY2UgYW5kIG5ldyBsaW5lcy5cbiAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXG4gICAgICAvLyBBbGxvdyB3b3JkcyB0byBicmVhayBpZiB0aGV5IGFyZSB0b28gbG9uZy5cbiAgICAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCdcbiAgICB9LCBwbGFjZWhvbGRlckhlaWdodCA/IHtcbiAgICAgIG1pbkhlaWdodDogcGxhY2Vob2xkZXJIZWlnaHRcbiAgICB9IDoge30pKSwgdXNlclN0eWxlKSxcbiAgICBvbkJlZm9yZUlucHV0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgIC8vIGZhbGwgYmFjayB0byBSZWFjdCdzIGxlYWt5IHBvbHlmaWxsIGluc3RlYWQganVzdCBmb3IgaXQuIEl0XG4gICAgICAvLyBvbmx5IHdvcmtzIGZvciB0aGUgYGluc2VydFRleHRgIGlucHV0IHR5cGUuXG4gICAgICBpZiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCAmJiAhcmVhZE9ubHkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQmVmb3JlSW5wdXQpICYmIFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgdmFyIF90ZXh0MiA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBfdGV4dDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5XSksXG4gICAgb25JbnB1dDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uSW5wdXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuZHJvaWRJbnB1dE1hbmFnZXIpIHtcbiAgICAgICAgYW5kcm9pZElucHV0TWFuYWdlci5oYW5kbGVJbnB1dCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEZsdXNoIG5hdGl2ZSBvcGVyYXRpb25zLCBhcyBuYXRpdmUgZXZlbnRzIHdpbGwgaGF2ZSBwcm9wb2dhdGVkXG4gICAgICAvLyBhbmQgd2UgY2FuIGNvcnJlY3RseSBjb21wYXJlIERPTSB0ZXh0IHZhbHVlcyBpbiBjb21wb25lbnRzXG4gICAgICAvLyB0byBzdG9wIHJlbmRlcmluZywgc28gdGhhdCBicm93c2VyIGZ1bmN0aW9ucyBsaWtlIGF1dG9jb3JyZWN0XG4gICAgICAvLyBhbmQgc3BlbGxjaGVjayB3b3JrIGFzIGV4cGVjdGVkLlxuXG5cbiAgICAgIGZvciAodmFyIG9wIG9mIGRlZmVycmVkT3BlcmF0aW9ucy5jdXJyZW50KSB7XG4gICAgICAgIG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGRlZmVycmVkT3BlcmF0aW9ucy5jdXJyZW50ID0gW107XG4gICAgfSwgW10pLFxuICAgIG9uQmx1cjogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKHJlYWRPbmx5IHx8IHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gfHwgIVJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpIHx8IGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQmx1cikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBDT01QQVQ6IElmIHRoZSBjdXJyZW50IGBhY3RpdmVFbGVtZW50YCBpcyBzdGlsbCB0aGUgcHJldmlvdXNcbiAgICAgIC8vIG9uZSwgdGhpcyBpcyBkdWUgdG8gdGhlIHdpbmRvdyBiZWluZyBibHVycmVkIHdoZW4gdGhlIHRhYlxuICAgICAgLy8gaXRzZWxmIGJlY29tZXMgdW5mb2N1c2VkLCBzbyB3ZSB3YW50IHRvIGFib3J0IGVhcmx5IHRvIGFsbG93IHRvXG4gICAgICAvLyBlZGl0b3IgdG8gc3RheSBmb2N1c2VkIHdoZW4gdGhlIHRhYiBiZWNvbWVzIGZvY3VzZWQgYWdhaW4uXG5cblxuICAgICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcblxuICAgICAgaWYgKHN0YXRlLmxhdGVzdEVsZW1lbnQgPT09IHJvb3QuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7IC8vIENPTVBBVDogVGhlIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkIGlmIHRoZSBmb2N1cyBpcyByZXR1cm5pbmdcbiAgICAgIC8vIHRvIHRoZSBlZGl0b3IgZnJvbSBhbiBlbWJlZGRlZCBlZGl0YWJsZSBlbGVtZW50IChlZy4gYW4gPGlucHV0PlxuICAgICAgLy8gZWxlbWVudCBpbnNpZGUgYSB2b2lkIG5vZGUpLlxuXG4gICAgICBpZiAocmVsYXRlZFRhcmdldCA9PT0gZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBDT01QQVQ6IFRoZSBldmVudCBzaG91bGQgYmUgaWdub3JlZCBpZiB0aGUgZm9jdXMgaXMgbW92aW5nIGZyb21cbiAgICAgIC8vIHRoZSBlZGl0b3IgdG8gaW5zaWRlIGEgdm9pZCBub2RlJ3Mgc3BhY2VyIGVsZW1lbnQuXG5cblxuICAgICAgaWYgKGlzRE9NRWxlbWVudChyZWxhdGVkVGFyZ2V0KSAmJiByZWxhdGVkVGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1zcGFjZXInKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENPTVBBVDogVGhlIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkIGlmIHRoZSBmb2N1cyBpcyBtb3ZpbmcgdG8gYVxuICAgICAgLy8gbm9uLSBlZGl0YWJsZSBzZWN0aW9uIG9mIGFuIGVsZW1lbnQgdGhhdCBpc24ndCBhIHZvaWQgbm9kZSAoZWcuXG4gICAgICAvLyBhIGxpc3QgaXRlbSBvZiB0aGUgY2hlY2sgbGlzdCBleGFtcGxlKS5cblxuXG4gICAgICBpZiAocmVsYXRlZFRhcmdldCAhPSBudWxsICYmIGlzRE9NTm9kZShyZWxhdGVkVGFyZ2V0KSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgcmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIHJlbGF0ZWRUYXJnZXQpO1xuXG4gICAgICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNWb2lkKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIENPTVBBVDogU2FmYXJpIGRvZXNuJ3QgYWx3YXlzIHJlbW92ZSB0aGUgc2VsZWN0aW9uIGV2ZW4gaWYgdGhlIGNvbnRlbnQtXG4gICAgICAvLyBlZGl0YWJsZSBlbGVtZW50IG5vIGxvbmdlciBoYXMgZm9jdXMuIFJlZmVyIHRvOlxuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTIzNTMyNDcvZm9yY2UtY29udGVudGVkaXRhYmxlLWRpdi10by1zdG9wLWFjY2VwdGluZy1pbnB1dC1hZnRlci1pdC1sb3Nlcy1mb2N1cy11bmRlci13ZWJcblxuXG4gICAgICBpZiAoSVNfU0FGQVJJKSB7XG4gICAgICAgIHZhciBkb21TZWxlY3Rpb24gPSByb290LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG5cbiAgICAgIElTX0ZPQ1VTRUQuZGVsZXRlKGVkaXRvcik7XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uQmx1cl0pLFxuICAgIG9uQ2xpY2s6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNsaWNrKSAmJiBpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpOyAvLyBBdCB0aGlzIHRpbWUsIHRoZSBTbGF0ZSBkb2N1bWVudCBtYXkgYmUgYXJiaXRyYXJpbHkgZGlmZmVyZW50LFxuICAgICAgICAvLyBiZWNhdXNlIG9uQ2xpY2sgaGFuZGxlcnMgY2FuIGNoYW5nZSB0aGUgZG9jdW1lbnQgYmVmb3JlIHdlIGdldCBoZXJlLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbXVzdCBjaGVjayB0aGF0IHRoaXMgcGF0aCBhY3R1YWxseSBleGlzdHMsXG4gICAgICAgIC8vIGFuZCB0aGF0IGl0IHN0aWxsIHJlZmVycyB0byB0aGUgc2FtZSBub2RlLlxuXG4gICAgICAgIGlmICghRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBwYXRoKSB8fCBOb2RlLmdldChlZGl0b3IsIHBhdGgpICE9PSBub2RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmRldGFpbCA9PT0gVFJJUExFX0NMSUNLICYmIHBhdGgubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICB2YXIgYmxvY2tQYXRoID0gcGF0aDtcblxuICAgICAgICAgIGlmICghKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBub2RlKSkpIHtcbiAgICAgICAgICAgIHZhciBfYmxvY2skO1xuXG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmxvY2tQYXRoID0gKF9ibG9jayQgPSBibG9jayA9PT0gbnVsbCB8fCBibG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvY2tbMV0pICE9PSBudWxsICYmIF9ibG9jayQgIT09IHZvaWQgMCA/IF9ibG9jayQgOiBwYXRoLnNsaWNlKDAsIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGJsb2NrUGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlYWRPbmx5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBzdGFydFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogX3N0YXJ0XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZW5kVm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0Vm9pZCAmJiBlbmRWb2lkICYmIFBhdGguZXF1YWxzKHN0YXJ0Vm9pZFsxXSwgZW5kVm9pZFsxXSkpIHtcbiAgICAgICAgICB2YXIgX3JhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgX3N0YXJ0KTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3JhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vbkNsaWNrXSksXG4gICAgb25Db21wb3NpdGlvbkVuZDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGlmIChSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSBudWxsIHx8IGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuZHJvaWRJbnB1dE1hbmFnZXIuaGFuZGxlQ29tcG9zaXRpb25FbmQoZXZlbnQpO1xuXG4gICAgICAgIGlmIChpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uRW5kKSB8fCBJU19BTkRST0lEKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIENPTVBBVDogSW4gQ2hyb21lLCBgYmVmb3JlaW5wdXRgIGV2ZW50cyBmb3IgY29tcG9zaXRpb25zXG4gICAgICAgIC8vIGFyZW4ndCBjb3JyZWN0IGFuZCBuZXZlciBmaXJlIHRoZSBcImluc2VydEZyb21Db21wb3NpdGlvblwiXG4gICAgICAgIC8vIHR5cGUgdGhhdCB3ZSBuZWVkLiBTbyBpbnN0ZWFkLCBpbnNlcnQgd2hlbmV2ZXIgYSBjb21wb3NpdGlvblxuICAgICAgICAvLyBlbmRzIHNpbmNlIGl0IHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gY29tbWl0dGVkIHRvIHRoZSBET00uXG5cblxuICAgICAgICBpZiAoIUlTX1NBRkFSSSAmJiAhSVNfRklSRUZPWF9MRUdBQ1kgJiYgIUlTX0lPUyAmJiAhSVNfV0VDSEFUQlJPV1NFUiAmJiAhSVNfVUNfTU9CSUxFICYmIGV2ZW50LmRhdGEpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJNYXJrcyA9IEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZWRpdG9yKTtcbiAgICAgICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZGVsZXRlKGVkaXRvcik7IC8vIEVuc3VyZSB3ZSBpbnNlcnQgdGV4dCB3aXRoIHRoZSBtYXJrcyB0aGUgdXNlciB3YXMgYWN0dWFsbHkgc2VlaW5nXG5cbiAgICAgICAgICBpZiAocGxhY2Vob2xkZXJNYXJrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5zZXQoZWRpdG9yLCBlZGl0b3IubWFya3MpO1xuICAgICAgICAgICAgZWRpdG9yLm1hcmtzID0gcGxhY2Vob2xkZXJNYXJrcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGV2ZW50LmRhdGEpO1xuICAgICAgICAgIHZhciB1c2VyTWFya3MgPSBFRElUT1JfVE9fVVNFUl9NQVJLUy5nZXQoZWRpdG9yKTtcbiAgICAgICAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcblxuICAgICAgICAgIGlmICh1c2VyTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdG9yLm1hcmtzID0gdXNlck1hcmtzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25FbmRdKSxcbiAgICBvbkNvbXBvc2l0aW9uVXBkYXRlOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25VcGRhdGUpKSB7XG4gICAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICAgIHNldElzQ29tcG9zaW5nKHRydWUpO1xuICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25VcGRhdGVdKSxcbiAgICBvbkNvbXBvc2l0aW9uU3RhcnQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSBudWxsIHx8IGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuZHJvaWRJbnB1dE1hbmFnZXIuaGFuZGxlQ29tcG9zaXRpb25TdGFydChldmVudCk7XG5cbiAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25TdGFydCkgfHwgSVNfQU5EUk9JRCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldElzQ29tcG9zaW5nKHRydWUpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5saW5lID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudCQxLmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGlubGluZSkge1xuICAgICAgICAgICAgdmFyIFssIGlubGluZVBhdGhdID0gaW5saW5lO1xuXG4gICAgICAgICAgICBpZiAoRWRpdG9yLmlzRW5kKGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvciwgaW5saW5lUGF0aCkpIHtcbiAgICAgICAgICAgICAgdmFyIHBvaW50ID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgaW5saW5lUGF0aCk7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGFuY2hvcjogcG9pbnQsXG4gICAgICAgICAgICAgICAgZm9jdXM6IHBvaW50XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25TdGFydF0pLFxuICAgIG9uQ29weTogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvcHkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEsICdjb3B5Jyk7XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db3B5XSksXG4gICAgb25DdXQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ3V0KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBSZWFjdEVkaXRvci5zZXRGcmFnbWVudERhdGEoZWRpdG9yLCBldmVudC5jbGlwYm9hcmREYXRhLCAnY3V0Jyk7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IE5vZGUucGFyZW50KGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvci5wYXRoKTtcblxuICAgICAgICAgICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vbkN1dF0pLFxuICAgIG9uRHJhZ092ZXI6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkRyYWdPdmVyKSkge1xuICAgICAgICAvLyBPbmx5IHdoZW4gdGhlIHRhcmdldCBpcyB2b2lkLCBjYWxsIGBwcmV2ZW50RGVmYXVsdGAgdG8gc2lnbmFsXG4gICAgICAgIC8vIHRoYXQgZHJvcHMgYXJlIGFsbG93ZWQuIEVkaXRhYmxlIGNvbnRlbnQgaXMgZHJvcHBhYmxlIGJ5XG4gICAgICAgIC8vIGRlZmF1bHQsIGFuZCBjYWxsaW5nIGBwcmV2ZW50RGVmYXVsdGAgaGlkZXMgdGhlIGN1cnNvci5cbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG5cbiAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uRHJhZ092ZXJdKSxcbiAgICBvbkRyYWdTdGFydDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkRyYWdTdGFydCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgICAgICAgdmFyIHZvaWRNYXRjaCA9IEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgIH0pOyAvLyBJZiBzdGFydGluZyBhIGRyYWcgb24gYSB2b2lkIG5vZGUsIG1ha2Ugc3VyZSBpdCBpcyBzZWxlY3RlZFxuICAgICAgICAvLyBzbyB0aGF0IGl0IHNob3dzIHVwIGluIHRoZSBzZWxlY3Rpb24ncyBmcmFnbWVudC5cblxuICAgICAgICBpZiAodm9pZE1hdGNoKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSA9IHRydWU7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmRhdGFUcmFuc2ZlciwgJ2RyYWcnKTtcbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25EcmFnU3RhcnRdKSxcbiAgICBvbkRyb3A6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Ecm9wKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBkcmFnZ2VkIHJhbmdlIGJlZm9yZSB1cGRhdGluZyBzZWxlY3Rpb25cblxuICAgICAgICB2YXIgZHJhZ2dlZFJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbjsgLy8gRmluZCB0aGUgcmFuZ2Ugd2hlcmUgdGhlIGRyb3AgaGFwcGVuZWRcblxuICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci5maW5kRXZlbnRSYW5nZShlZGl0b3IsIGV2ZW50KTtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXI7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSkge1xuICAgICAgICAgIGlmIChkcmFnZ2VkUmFuZ2UgJiYgIVJhbmdlLmVxdWFscyhkcmFnZ2VkUmFuZ2UsIHJhbmdlKSAmJiAhRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IGRyYWdnZWRSYW5nZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpOyAvLyBXaGVuIGRyYWdnaW5nIGZyb20gYW5vdGhlciBzb3VyY2UgaW50byB0aGUgZWRpdG9yLCBpdCdzIHBvc3NpYmxlXG4gICAgICAgIC8vIHRoYXQgdGhlIGN1cnJlbnQgZWRpdG9yIGRvZXMgbm90IGhhdmUgZm9jdXMuXG5cbiAgICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSkge1xuICAgICAgICAgIFJlYWN0RWRpdG9yLmZvY3VzKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSBmYWxzZTtcbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25Ecm9wXSksXG4gICAgb25EcmFnRW5kOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ICYmIGF0dHJpYnV0ZXMub25EcmFnRW5kICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgYXR0cmlidXRlcy5vbkRyYWdFbmQoZXZlbnQpO1xuICAgICAgfSAvLyBXaGVuIGRyb3BwaW5nIG9uIGEgZGlmZmVyZW50IGRyb3BwYWJsZSBlbGVtZW50IHRoYW4gdGhlIGN1cnJlbnQgZWRpdG9yLFxuICAgICAgLy8gYG9uRHJvcGAgaXMgbm90IGNhbGxlZC4gU28gd2UgbmVlZCB0byBjbGVhbiB1cCBpbiBgb25EcmFnRW5kYCBpbnN0ZWFkLlxuICAgICAgLy8gTm90ZTogYG9uRHJhZ0VuZGAgaXMgb25seSBjYWxsZWQgd2hlbiBgb25Ecm9wYCBpcyBub3QgY2FsbGVkXG5cblxuICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSBmYWxzZTtcbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25EcmFnRW5kXSksXG4gICAgb25Gb2N1czogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiAhc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiAmJiBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRm9jdXMpKSB7XG4gICAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgICAgIHN0YXRlLmxhdGVzdEVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7IC8vIENPTVBBVDogSWYgdGhlIGVkaXRvciBoYXMgbmVzdGVkIGVkaXRhYmxlIGVsZW1lbnRzLCB0aGUgZm9jdXNcbiAgICAgICAgLy8gY2FuIGdvIHRvIHRoZW0uIEluIEZpcmVmb3gsIHRoaXMgbXVzdCBiZSBwcmV2ZW50ZWQgYmVjYXVzZSBpdFxuICAgICAgICAvLyByZXN1bHRzIGluIGlzc3VlcyB3aXRoIGtleWJvYXJkIG5hdmlnYXRpb24uICgyMDE3LzAzLzMwKVxuXG4gICAgICAgIGlmIChJU19GSVJFRk9YICYmIGV2ZW50LnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uRm9jdXNdKSxcbiAgICBvbktleURvd246IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IG51bGwgfHwgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5kcm9pZElucHV0TWFuYWdlci5oYW5kbGVLZXlEb3duKGV2ZW50KTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICB9ID0gZXZlbnQ7IC8vIENPTVBBVDogVGhlIGNvbXBvc2l0aW9uIGVuZCBldmVudCBpc24ndCBmaXJlZCByZWxpYWJseSBpbiBhbGwgYnJvd3NlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNvbWV0aW1lcyBtaWdodCBlbmQgdXAgc3R1Y2sgaW4gYSBjb21wb3NpdGlvbiBzdGF0ZSBldmVuIHRob3VnaCB3ZVxuICAgICAgICAvLyBhcmVuJ3QgY29tcG9zaW5nIGFueSBtb3JlLlxuXG4gICAgICAgIGlmIChSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpICYmIG5hdGl2ZUV2ZW50LmlzQ29tcG9zaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uS2V5RG93bikgfHwgUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3I7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZWRpdG9yLmNoaWxkcmVuW3NlbGVjdGlvbiAhPT0gbnVsbCA/IHNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdIDogMF07XG4gICAgICAgIHZhciBpc1JUTCA9IGdldERpcmVjdGlvbihOb2RlLnN0cmluZyhlbGVtZW50KSkgPT09ICdydGwnOyAvLyBDT01QQVQ6IFNpbmNlIHdlIHByZXZlbnQgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb25cbiAgICAgICAgLy8gYGJlZm9yZWlucHV0YCBldmVudHMsIHRoZSBicm93c2VyIGRvZXNuJ3QgdGhpbmsgdGhlcmUncyBldmVyXG4gICAgICAgIC8vIGFueSBoaXN0b3J5IHN0YWNrIHRvIHVuZG8gb3IgcmVkbywgc28gd2UgaGF2ZSB0byBtYW5hZ2UgdGhlc2VcbiAgICAgICAgLy8gaG90a2V5cyBvdXJzZWx2ZXMuICgyMDE5LzExLzA2KVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzUmVkbyhuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHZhciBtYXliZUhpc3RvcnlFZGl0b3IgPSBlZGl0b3I7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG1heWJlSGlzdG9yeUVkaXRvci5yZWRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZUhpc3RvcnlFZGl0b3IucmVkbygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzVW5kbyhuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHZhciBfbWF5YmVIaXN0b3J5RWRpdG9yID0gZWRpdG9yO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBfbWF5YmVIaXN0b3J5RWRpdG9yLnVuZG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9tYXliZUhpc3RvcnlFZGl0b3IudW5kbygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3QgaGFuZGxlIHRoZSBzZWxlY3Rpb24gdXBkYXRlc1xuICAgICAgICAvLyBwcm9wZXJseS4gSW4gQ2hyb21lLCB0aGUgc2VsZWN0aW9uIGlzbid0IHByb3Blcmx5IGV4dGVuZGVkLlxuICAgICAgICAvLyBBbmQgaW4gRmlyZWZveCwgdGhlIHNlbGVjdGlvbiBpc24ndCBwcm9wZXJseSBjb2xsYXBzZWQuXG4gICAgICAgIC8vICgyMDE3LzEwLzE3KVxuXG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnLFxuICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUxpbmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNFeHRlbmRMaW5lQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZScsXG4gICAgICAgICAgICBlZGdlOiAnZm9jdXMnLFxuICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzRXh0ZW5kTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZScsXG4gICAgICAgICAgICBlZGdlOiAnZm9jdXMnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIENPTVBBVDogSWYgYSB2b2lkIG5vZGUgaXMgc2VsZWN0ZWQsIG9yIGEgemVyby13aWR0aCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYWRqYWNlbnQgdG8gYW4gaW5saW5lIGlzIHNlbGVjdGVkLCB3ZSBuZWVkIHRvIGhhbmRsZSB0aGVzZVxuICAgICAgICAvLyBob3RrZXlzIG1hbnVhbGx5IGJlY2F1c2UgYnJvd3NlcnMgd29uJ3QgYmUgYWJsZSB0byBza2lwIG92ZXJcbiAgICAgICAgLy8gdGhlIHZvaWQgbm9kZSB3aXRoIHRoZSB6ZXJvLXdpZHRoIHNwYWNlIG5vdCBiZWluZyBhbiBlbXB0eVxuICAgICAgICAvLyBzdHJpbmcuXG5cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHJldmVyc2U6ICFpc1JUTFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuY29sbGFwc2UoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgICByZXZlcnNlOiBpc1JUTFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuY29sbGFwc2UoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGVkZ2U6ICdlbmQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVXb3JkQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiAnZm9jdXMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnd29yZCcsXG4gICAgICAgICAgICByZXZlcnNlOiAhaXNSVExcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVXb3JkRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuY29sbGFwc2UoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGVkZ2U6ICdmb2N1cydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJyxcbiAgICAgICAgICAgIHJldmVyc2U6IGlzUlRMXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZVxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZ3Vlc3NpbmcgYXQgdGhlIGlucHV0IGludGVudGlvbiBmb3IgaG90a2V5cy5cbiAgICAgICAgLy8gQ09NUEFUOiBJbiBpT1MsIHNvbWUgb2YgdGhlc2UgaG90a2V5cyBhcmUgaGFuZGxlZCBpbiB0aGVcblxuXG4gICAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUKSB7XG4gICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhIGNvcmUgYmVoYXZpb3IgZm9yIHRoZXNlLCBidXQgdGhleSBjaGFuZ2UgdGhlXG4gICAgICAgICAgLy8gRE9NIGlmIHdlIGRvbid0IHByZXZlbnQgdGhlbSwgc28gd2UgaGF2ZSB0by5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0JvbGQobmF0aXZlRXZlbnQpIHx8IEhvdGtleXMuaXNJdGFsaWMobmF0aXZlRXZlbnQpIHx8IEhvdGtleXMuaXNUcmFuc3Bvc2VDaGFyYWN0ZXIobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzU29mdEJyZWFrKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIEVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc1NwbGl0QmxvY2sobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUxpbmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVMaW5lRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlV29yZEJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZVdvcmRGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChJU19DSFJPTUUgfHwgSVNfU0FGQVJJKSB7XG4gICAgICAgICAgICAvLyBDT01QQVQ6IENocm9tZSBhbmQgU2FmYXJpIHN1cHBvcnQgYGJlZm9yZWlucHV0YCBldmVudCBidXQgZG8gbm90IGZpcmVcbiAgICAgICAgICAgIC8vIGFuIGV2ZW50IHdoZW4gZGVsZXRpbmcgYmFja3dhcmRzIGluIGEgc2VsZWN0ZWQgdm9pZCBpbmxpbmUgbm9kZVxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiAoSG90a2V5cy5pc0RlbGV0ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzRGVsZXRlRm9yd2FyZChuYXRpdmVFdmVudCkpICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLnBhdGgpO1xuXG4gICAgICAgICAgICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgY3VycmVudE5vZGUpICYmIChFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBjdXJyZW50Tm9kZSkgfHwgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBjdXJyZW50Tm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uS2V5RG93bl0pLFxuICAgIG9uUGFzdGU6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vblBhc3RlKSkge1xuICAgICAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIFJlYWN0J3MgYG9uUGFzdGVgIGhlcmUgaW5zdGVhZC5cbiAgICAgICAgLy8gQ09NUEFUOiBGaXJlZm94LCBDaHJvbWUgYW5kIFNhZmFyaSBkb24ndCBlbWl0IGBiZWZvcmVpbnB1dGAgZXZlbnRzXG4gICAgICAgIC8vIHdoZW4gXCJwYXN0ZSB3aXRob3V0IGZvcm1hdHRpbmdcIiBpcyB1c2VkLCBzbyBmYWxsYmFjay4gKDIwMjAvMDIvMjApXG4gICAgICAgIC8vIENPTVBBVDogU2FmYXJpIElucHV0RXZlbnRzIGdlbmVyYXRlZCBieSBwYXN0aW5nIHdvbid0IGluY2x1ZGVcbiAgICAgICAgLy8gYXBwbGljYXRpb24veC1zbGF0ZS1mcmFnbWVudCBpdGVtcywgc28gdXNlIHRoZVxuICAgICAgICAvLyBDbGlwYm9hcmRFdmVudCBoZXJlLiAoMjAyMy8wMy8xNSlcbiAgICAgICAgaWYgKCFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgaXNQbGFpblRleHRPbmx5UGFzdGUoZXZlbnQubmF0aXZlRXZlbnQpIHx8IElTX1NBRkFSSSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uUGFzdGVdKVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hpbGRyZW4sIHtcbiAgICBkZWNvcmF0aW9uczogZGVjb3JhdGlvbnMsXG4gICAgbm9kZTogZWRpdG9yLFxuICAgIHJlbmRlckVsZW1lbnQ6IHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uOiBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0pKSkpKTtcbn07XG4vKipcclxuICogVGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgZWxlbWVudFxyXG4gKi9cblxudmFyIERlZmF1bHRQbGFjZWhvbGRlciA9IF9yZWYgPT4ge1xuICB2YXIge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIC8vIENPTVBBVDogQXJ0aWZpY2lhbGx5IGFkZCBhIGxpbmUtYnJlYWsgdG8gdGhlIGVuZCBvbiB0aGUgcGxhY2Vob2xkZXIgZWxlbWVudFxuICAgIC8vIHRvIHByZXZlbnQgQW5kcm9pZCBJTUVzIHRvIHBpY2sgdXAgaXRzIGNvbnRlbnQgaW4gYXV0b2NvcnJlY3QgYW5kIHRvIGF1dG8tY2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyksIGNoaWxkcmVuLCBJU19BTkRST0lEICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnJcIiwgbnVsbCkpXG4gICk7XG59O1xuLyoqXHJcbiAqIEEgZGVmYXVsdCBtZW1vaXplZCBkZWNvcmF0ZSBmdW5jdGlvbi5cclxuICovXG5cbnZhciBkZWZhdWx0RGVjb3JhdGUgPSAoKSA9PiBbXTtcbi8qKlxyXG4gKiBBIGRlZmF1bHQgaW1wbGVtZW50IHRvIHNjcm9sbCBkb20gcmFuZ2UgaW50byB2aWV3LlxyXG4gKi9cblxudmFyIGRlZmF1bHRTY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9IChlZGl0b3IsIGRvbVJhbmdlKSA9PiB7XG4gIC8vIFRoaXMgd2FzIGFmZmVjdGluZyB0aGUgc2VsZWN0aW9uIG9mIG11bHRpcGxlIGJsb2NrcyBhbmQgZHJhZ2dpbmcgYmVoYXZpb3IsXG4gIC8vIHNvIGVuYWJsZWQgb25seSBpZiB0aGUgc2VsZWN0aW9uIGhhcyBiZWVuIGNvbGxhcHNlZC5cbiAgaWYgKGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSkpIHtcbiAgICB2YXIgbGVhZkVsID0gZG9tUmFuZ2Uuc3RhcnRDb250YWluZXIucGFyZW50RWxlbWVudDtcbiAgICBsZWFmRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmJpbmQoZG9tUmFuZ2UpO1xuICAgIHNjcm9sbEludG9WaWV3KGxlYWZFbCwge1xuICAgICAgc2Nyb2xsTW9kZTogJ2lmLW5lZWRlZCdcbiAgICB9KTsgLy8gQHRzLWV4cGVjdC1lcnJvciBhbiB1bm9ydGhvZG94IGRlbGV0ZSBEOlxuXG4gICAgZGVsZXRlIGxlYWZFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3Q7XG4gIH1cbn07XG4vKipcclxuICogQ2hlY2sgaWYgYW4gZXZlbnQgaXMgb3ZlcnJpZGVkIGJ5IGEgaGFuZGxlci5cclxuICovXG5cblxudmFyIGlzRXZlbnRIYW5kbGVkID0gKGV2ZW50LCBoYW5kbGVyKSA9PiB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUaGUgY3VzdG9tIGV2ZW50IGhhbmRsZXIgbWF5IHJldHVybiBhIGJvb2xlYW4gdG8gc3BlY2lmeSB3aGV0aGVyIHRoZSBldmVudFxuICAvLyBzaGFsbCBiZSB0cmVhdGVkIGFzIGJlaW5nIGhhbmRsZWQgb3Igbm90LlxuXG5cbiAgdmFyIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQgPSBoYW5kbGVyKGV2ZW50KTtcblxuICBpZiAoc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQ7XG4gIH1cblxuICByZXR1cm4gZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gZXZlbnQgaXMgb3ZlcnJpZGVkIGJ5IGEgaGFuZGxlci5cclxuICovXG5cbnZhciBpc0RPTUV2ZW50SGFuZGxlZCA9IChldmVudCwgaGFuZGxlcikgPT4ge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGhlIGN1c3RvbSBldmVudCBoYW5kbGVyIG1heSByZXR1cm4gYSBib29sZWFuIHRvIHNwZWNpZnkgd2hldGhlciB0aGUgZXZlbnRcbiAgLy8gc2hhbGwgYmUgdHJlYXRlZCBhcyBiZWluZyBoYW5kbGVkIG9yIG5vdC5cblxuXG4gIHZhciBzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkID0gaGFuZGxlcihldmVudCk7XG5cbiAgaWYgKHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQgIT0gbnVsbCkge1xuICAgIHJldHVybiBzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgZm9jdXNlZGAgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciBGb2N1c2VkQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgYGZvY3VzZWRgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgdXNlRm9jdXNlZCA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoRm9jdXNlZENvbnRleHQpO1xufTtcblxuZnVuY3Rpb24gaXNFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGVkaXRvciBzZWxlY3RvciBjb250ZXh0IGluIGEgd2F5IHRvIGNvbnRyb2wgcmVyZW5kZXJzXHJcbiAqL1xuXG5cbnZhciBTbGF0ZVNlbGVjdG9yQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHt9KTtcblxudmFyIHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG4vKipcclxuICogdXNlIHJlZHV4IHN0eWxlIHNlbGVjdG9ycyB0byBwcmV2ZW50IHJlcmVuZGVyaW5nIG9uIGV2ZXJ5IGtleXN0cm9rZS5cclxuICogQmVhciBpbiBtaW5kIHJlcmVuZGVyaW5nIGNhbiBvbmx5IHByZXZlbnRlZCBpZiB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgYSB2YWx1ZSB0eXBlIG9yIGZvciByZWZlcmVuY2UgdHlwZXMgKGUuZy4gb2JqZWN0cyBhbmQgYXJyYXlzKSBhZGQgYSBjdXN0b20gZXF1YWxpdHkgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEV4YW1wbGU6XHJcbiAqIGBgYFxyXG4gKiAgY29uc3QgaXNTZWxlY3Rpb25BY3RpdmUgPSB1c2VTbGF0ZVNlbGVjdG9yKGVkaXRvciA9PiBCb29sZWFuKGVkaXRvci5zZWxlY3Rpb24pKTtcclxuICogYGBgXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZVNsYXRlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdmFyIGVxdWFsaXR5Rm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHJlZkVxdWFsaXR5O1xuICB2YXIgWywgZm9yY2VSZW5kZXJdID0gdXNlUmVkdWNlcihzID0+IHMgKyAxLCAwKTtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFNsYXRlU2VsZWN0b3JDb250ZXh0KTtcblxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlU2VsZWN0b3JgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHZhciB7XG4gICAgZ2V0U2xhdGUsXG4gICAgYWRkRXZlbnRMaXN0ZW5lclxuICB9ID0gY29udGV4dDtcbiAgdmFyIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IgPSB1c2VSZWYoKTtcbiAgdmFyIGxhdGVzdFNlbGVjdG9yID0gdXNlUmVmKCgpID0+IG51bGwpO1xuICB2YXIgbGF0ZXN0U2VsZWN0ZWRTdGF0ZSA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHNlbGVjdGVkU3RhdGU7XG5cbiAgdHJ5IHtcbiAgICBpZiAoc2VsZWN0b3IgIT09IGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgfHwgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICBzZWxlY3RlZFN0YXRlID0gc2VsZWN0b3IoZ2V0U2xhdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkU3RhdGUgPSBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQ7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ICYmIGlzRXJyb3IoZXJyKSkge1xuICAgICAgZXJyLm1lc3NhZ2UgKz0gXCJcXG5UaGUgZXJyb3IgbWF5IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGlzIHByZXZpb3VzIGVycm9yOlxcblwiLmNvbmNhdChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2ssIFwiXFxuXFxuXCIpO1xuICAgIH1cblxuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgICBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQgPSBzZWxlY3RlZFN0YXRlO1xuICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGNoZWNrRm9yVXBkYXRlcygpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3RlZFN0YXRlID0gbGF0ZXN0U2VsZWN0b3IuY3VycmVudChnZXRTbGF0ZSgpKTtcblxuICAgICAgICBpZiAoZXF1YWxpdHlGbihuZXdTZWxlY3RlZFN0YXRlLCBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50ID0gbmV3U2VsZWN0ZWRTdGF0ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyB3ZSBpZ25vcmUgYWxsIGVycm9ycyBoZXJlLCBzaW5jZSB3aGVuIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaXMgcmUtcmVuZGVyZWQsIHRoZSBzZWxlY3RvcnMgYXJlIGNhbGxlZCBhZ2FpbiwgYW5kXG4gICAgICAgIC8vIHdpbGwgdGhyb3cgYWdhaW4sIGlmIG5laXRoZXIgcHJvcHMgbm9yIHN0b3JlIHN0YXRlXG4gICAgICAgIC8vIGNoYW5nZWRcbiAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gZXJyO1xuICAgICAgfVxuXG4gICAgICBmb3JjZVJlbmRlcigpO1xuICAgIH1cblxuICAgIHZhciB1bnN1YnNjcmliZSA9IGFkZEV2ZW50TGlzdGVuZXIoY2hlY2tGb3JVcGRhdGVzKTtcbiAgICBjaGVja0ZvclVwZGF0ZXMoKTtcbiAgICByZXR1cm4gKCkgPT4gdW5zdWJzY3JpYmUoKTtcbiAgfSwgLy8gZG9uJ3QgcmVyZW5kZXIgb24gZXF1YWxpdHlGbiBjaGFuZ2Ugc2luY2Ugd2Ugd2FudCB0byBiZSBhYmxlIHRvIGRlZmluZSBpdCBpbmxpbmVcbiAgW2FkZEV2ZW50TGlzdGVuZXIsIGdldFNsYXRlXSk7XG4gIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBzZWxlY3RvciBjb250ZXh0IHdpdGggZWRpdG9yIHVwZGF0aW5nIG9uIGV2ZXJ5IGVkaXRvciBjaGFuZ2VcclxuICovXG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yQ29udGV4dChlZGl0b3IpIHtcbiAgdmFyIGV2ZW50TGlzdGVuZXJzID0gdXNlUmVmKFtdKS5jdXJyZW50O1xuICB2YXIgc2xhdGVSZWYgPSB1c2VSZWYoe1xuICAgIGVkaXRvclxuICB9KS5jdXJyZW50O1xuICB2YXIgb25DaGFuZ2UgPSB1c2VDYWxsYmFjayhlZGl0b3IgPT4ge1xuICAgIHNsYXRlUmVmLmVkaXRvciA9IGVkaXRvcjtcbiAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGVkaXRvcikpO1xuICB9LCBbXSk7XG4gIHZhciBzZWxlY3RvckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U2xhdGU6ICgpID0+IHNsYXRlUmVmLmVkaXRvcixcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGNhbGxiYWNrID0+IHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGV2ZW50TGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZXZlbnRMaXN0ZW5lcnMsIHNsYXRlUmVmXSk7XG4gIHJldHVybiB7XG4gICAgc2VsZWN0b3JDb250ZXh0LFxuICAgIG9uQ2hhbmdlXG4gIH07XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJlZGl0b3JcIiwgXCJjaGlsZHJlblwiLCBcIm9uQ2hhbmdlXCIsIFwidmFsdWVcIl07XG4vKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgcHJvdmlkZXIgdG8gaGFuZGxlIGBvbkNoYW5nZWAgZXZlbnRzLCBiZWNhdXNlIHRoZSBlZGl0b3JcclxuICogaXMgYSBtdXRhYmxlIHNpbmdsZXRvbiBzbyBpdCB3b24ndCBldmVyIHJlZ2lzdGVyIGFzIFwiY2hhbmdlZFwiIG90aGVyd2lzZS5cclxuICovXG5cbnZhciBTbGF0ZSA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBlZGl0b3IsXG4gICAgY2hpbGRyZW4sXG4gICAgb25DaGFuZ2UsXG4gICAgdmFsdWVcbiAgfSA9IHByb3BzLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkKTtcblxuICB2YXIgdW5tb3VudFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciBbY29udGV4dCwgc2V0Q29udGV4dF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgaWYgKCFOb2RlLmlzTm9kZUxpc3QodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbU2xhdGVdIHZhbHVlIGlzIGludmFsaWQhIEV4cGVjdGVkIGEgbGlzdCBvZiBlbGVtZW50cyBidXQgZ290OiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHZhbHVlKSkpO1xuICAgIH1cblxuICAgIGlmICghRWRpdG9yLmlzRWRpdG9yKGVkaXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltTbGF0ZV0gZWRpdG9yIGlzIGludmFsaWQhIFlvdSBwYXNzZWQ6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoZWRpdG9yKSkpO1xuICAgIH1cblxuICAgIGVkaXRvci5jaGlsZHJlbiA9IHZhbHVlO1xuICAgIE9iamVjdC5hc3NpZ24oZWRpdG9yLCByZXN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdjogMCxcbiAgICAgIGVkaXRvclxuICAgIH07XG4gIH0pO1xuICB2YXIge1xuICAgIHNlbGVjdG9yQ29udGV4dCxcbiAgICBvbkNoYW5nZTogaGFuZGxlU2VsZWN0b3JDaGFuZ2VcbiAgfSA9IGdldFNlbGVjdG9yQ29udGV4dChlZGl0b3IpO1xuICB2YXIgb25Db250ZXh0Q2hhbmdlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgb25DaGFuZ2UoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBzZXRDb250ZXh0KHByZXZDb250ZXh0ID0+ICh7XG4gICAgICB2OiBwcmV2Q29udGV4dC52ICsgMSxcbiAgICAgIGVkaXRvclxuICAgIH0pKTtcbiAgICBoYW5kbGVTZWxlY3RvckNoYW5nZShlZGl0b3IpO1xuICB9LCBbb25DaGFuZ2VdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBFRElUT1JfVE9fT05fQ0hBTkdFLnNldChlZGl0b3IsIG9uQ29udGV4dENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIEVESVRPUl9UT19PTl9DSEFOR0Uuc2V0KGVkaXRvciwgKCkgPT4ge30pO1xuICAgICAgdW5tb3VudFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbb25Db250ZXh0Q2hhbmdlXSk7XG4gIHZhciBbaXNGb2N1c2VkLCBzZXRJc0ZvY3VzZWRdID0gdXNlU3RhdGUoUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldElzRm9jdXNlZChSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSk7XG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB2YXIgZm4gPSAoKSA9PiBzZXRJc0ZvY3VzZWQoUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpO1xuXG4gICAgaWYgKElTX1JFQUNUX1ZFUlNJT05fMTdfT1JfQUJPVkUpIHtcbiAgICAgIC8vIEluIFJlYWN0ID49IDE3IG9uRm9jdXMgYW5kIG9uQmx1ciBsaXN0ZW4gdG8gdGhlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0IGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsaW5nIHBoYXNlLlxuICAgICAgLy8gVGhlcmVmb3JlIGluIG9yZGVyIGZvciA8RWRpdGFibGUgLz4ncyBoYW5kbGVycyB0byBydW4gZmlyc3QsIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcilcbiAgICAgIC8vIHRvIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSwgd2UgaGF2ZSB0byBsaXN0ZW4gdG8gdGhlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0IGV2ZW50cyB3aXRob3V0IHVzZUNhcHR1cmUgaGVyZS5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmbik7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGZuKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmbik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmbiwgdHJ1ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZm4sIHRydWUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmbiwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmbiwgdHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2xhdGVTZWxlY3RvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2VsZWN0b3JDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNsYXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dC5lZGl0b3JcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNlZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogaXNGb2N1c2VkXG4gIH0sIGNoaWxkcmVuKSkpKTtcbn07XG5cbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIG9iamVjdCBmcm9tIHRoZSBSZWFjdCBjb250ZXh0LlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgdXNlU2xhdGVTdGF0aWMgaW5zdGVhZC5cclxuICovXG5cbnZhciB1c2VFZGl0b3IgPSAoKSA9PiB7XG4gIHZhciBlZGl0b3IgPSB1c2VDb250ZXh0KEVkaXRvckNvbnRleHQpO1xuXG4gIGlmICghZWRpdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VFZGl0b3JgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IHNsYXRlIHNlbGVjdGlvbi5cclxuICogT25seSB0cmlnZ2VycyBhIHJlcmVuZGVyIHdoZW4gdGhlIHNlbGVjdGlvbiBhY3R1YWxseSBjaGFuZ2VzXHJcbiAqL1xuXG52YXIgdXNlU2xhdGVTZWxlY3Rpb24gPSAoKSA9PiB7XG4gIHJldHVybiB1c2VTbGF0ZVNlbGVjdG9yKGVkaXRvciA9PiBlZGl0b3Iuc2VsZWN0aW9uLCBpc1NlbGVjdGlvbkVxdWFsKTtcbn07XG5cbnZhciBpc1NlbGVjdGlvbkVxdWFsID0gKGEsIGIpID0+IHtcbiAgaWYgKCFhICYmICFiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCFhIHx8ICFiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBSYW5nZS5lcXVhbHMoYSwgYik7XG59O1xuXG4vKipcclxuICogVXRpbGl0aWVzIGZvciBzaW5nbGUtbGluZSBkZWxldGlvblxyXG4gKi9cblxudmFyIGRvUmVjdHNJbnRlcnNlY3QgPSAocmVjdCwgY29tcGFyZVJlY3QpID0+IHtcbiAgdmFyIG1pZGRsZSA9IChjb21wYXJlUmVjdC50b3AgKyBjb21wYXJlUmVjdC5ib3R0b20pIC8gMjtcbiAgcmV0dXJuIHJlY3QudG9wIDw9IG1pZGRsZSAmJiByZWN0LmJvdHRvbSA+PSBtaWRkbGU7XG59O1xuXG52YXIgYXJlUmFuZ2VzU2FtZUxpbmUgPSAoZWRpdG9yLCByYW5nZTEsIHJhbmdlMikgPT4ge1xuICB2YXIgcmVjdDEgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHJlY3QyID0gUmVhY3RFZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHJhbmdlMikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBkb1JlY3RzSW50ZXJzZWN0KHJlY3QxLCByZWN0MikgJiYgZG9SZWN0c0ludGVyc2VjdChyZWN0MiwgcmVjdDEpO1xufTtcbi8qKlxyXG4gKiBBIGhlbHBlciB1dGlsaXR5IHRoYXQgcmV0dXJucyB0aGUgZW5kIHBvcnRpb24gb2YgYSBgUmFuZ2VgXHJcbiAqIHdoaWNoIGlzIGxvY2F0ZWQgb24gYSBzaW5nbGUgbGluZS5cclxuICpcclxuICogQHBhcmFtIHtFZGl0b3J9IGVkaXRvciBUaGUgZWRpdG9yIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3RcclxuICogQHBhcmFtIHtSYW5nZX0gcGFyZW50UmFuZ2UgVGhlIHBhcmVudCByYW5nZSB0byBjb21wYXJlIGFnYWluc3RcclxuICogQHJldHVybnMge1JhbmdlfSBBIHZhbGlkIHBvcnRpb24gb2YgdGhlIHBhcmVudFJhbmdlIHdoaWNoIGlzIG9uZSBhIHNpbmdsZSBsaW5lXHJcbiAqL1xuXG5cbnZhciBmaW5kQ3VycmVudExpbmVSYW5nZSA9IChlZGl0b3IsIHBhcmVudFJhbmdlKSA9PiB7XG4gIHZhciBwYXJlbnRSYW5nZUJvdW5kYXJ5ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgUmFuZ2UuZW5kKHBhcmVudFJhbmdlKSk7XG4gIHZhciBwb3NpdGlvbnMgPSBBcnJheS5mcm9tKEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCB7XG4gICAgYXQ6IHBhcmVudFJhbmdlXG4gIH0pKTtcbiAgdmFyIGxlZnQgPSAwO1xuICB2YXIgcmlnaHQgPSBwb3NpdGlvbnMubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihyaWdodCAvIDIpO1xuXG4gIGlmIChhcmVSYW5nZXNTYW1lTGluZShlZGl0b3IsIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSksIHBhcmVudFJhbmdlQm91bmRhcnkpKSB7XG4gICAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG4gIH1cblxuICBpZiAocG9zaXRpb25zLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG4gIH1cblxuICB3aGlsZSAobWlkZGxlICE9PSBwb3NpdGlvbnMubGVuZ3RoICYmIG1pZGRsZSAhPT0gbGVmdCkge1xuICAgIGlmIChhcmVSYW5nZXNTYW1lTGluZShlZGl0b3IsIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1ttaWRkbGVdKSwgcGFyZW50UmFuZ2VCb3VuZGFyeSkpIHtcbiAgICAgIHJpZ2h0ID0gbWlkZGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gbWlkZGxlO1xuICAgIH1cblxuICAgIG1pZGRsZSA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgfVxuXG4gIHJldHVybiBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbcmlnaHRdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBgd2l0aFJlYWN0YCBhZGRzIFJlYWN0IGFuZCBET00gc3BlY2lmaWMgYmVoYXZpb3JzIHRvIHRoZSBlZGl0b3IuXHJcbiAqXHJcbiAqIElmIHlvdSBhcmUgdXNpbmcgVHlwZVNjcmlwdCwgeW91IG11c3QgZXh0ZW5kIFNsYXRlJ3MgQ3VzdG9tVHlwZXMgdG8gdXNlXHJcbiAqIHRoaXMgcGx1Z2luLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLnNsYXRlanMub3JnL2NvbmNlcHRzLzExLXR5cGVzY3JpcHQgdG8gbGVhcm4gaG93LlxyXG4gKi9cblxudmFyIHdpdGhSZWFjdCA9IGZ1bmN0aW9uIHdpdGhSZWFjdChlZGl0b3IpIHtcbiAgdmFyIGNsaXBib2FyZEZvcm1hdEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3gtc2xhdGUtZnJhZ21lbnQnO1xuICB2YXIgZSA9IGVkaXRvcjtcbiAgdmFyIHtcbiAgICBhcHBseSxcbiAgICBvbkNoYW5nZSxcbiAgICBkZWxldGVCYWNrd2FyZCxcbiAgICBhZGRNYXJrLFxuICAgIHJlbW92ZU1hcmtcbiAgfSA9IGU7IC8vIFRoZSBXZWFrTWFwIHdoaWNoIG1hcHMgYSBrZXkgdG8gYSBzcGVjaWZpYyBIVE1MRWxlbWVudCBtdXN0IGJlIHNjb3BlZCB0byB0aGUgZWRpdG9yIGluc3RhbmNlIHRvXG4gIC8vIGF2b2lkIGNvbGxpc2lvbnMgYmV0d2VlbiBlZGl0b3JzIGluIHRoZSBET00gdGhhdCBzaGFyZSB0aGUgc2FtZSB2YWx1ZS5cblxuICBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuc2V0KGUsIG5ldyBXZWFrTWFwKCkpO1xuXG4gIGUuYWRkTWFyayA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fU0NIRURVTEVfRiwgX0VESVRPUl9UT19QRU5ESU5HX0RJO1xuXG4gICAgKF9FRElUT1JfVE9fU0NIRURVTEVfRiA9IEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5nZXQoZSkpID09PSBudWxsIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19TQ0hFRFVMRV9GKCk7XG5cbiAgICBpZiAoIUVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZSkgJiYgKF9FRElUT1JfVE9fUEVORElOR19ESSA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJICE9PSB2b2lkIDAgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJLmxlbmd0aCkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBjdXJyZW50IHBlbmRpbmcgZGlmZnMgb3JpZ2luYXRpbmcgZnJvbSBjaGFuZ2VzIGJlZm9yZSB0aGUgYWRkTWFya1xuICAgICAgLy8gYXJlIGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCBmb3JtYXR0aW5nXG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1Muc2V0KGUsIG51bGwpO1xuICAgIH1cblxuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlKTtcbiAgICBhZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9O1xuXG4gIGUucmVtb3ZlTWFyayA9IGtleSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTI7XG5cbiAgICBpZiAoIUVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZSkgJiYgKF9FRElUT1JfVE9fUEVORElOR19ESTIgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZSkpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTIgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkyLmxlbmd0aCkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBjdXJyZW50IHBlbmRpbmcgZGlmZnMgb3JpZ2luYXRpbmcgZnJvbSBjaGFuZ2VzIGJlZm9yZSB0aGUgYWRkTWFya1xuICAgICAgLy8gYXJlIGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCBmb3JtYXR0aW5nXG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1Muc2V0KGUsIG51bGwpO1xuICAgIH1cblxuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlKTtcbiAgICByZW1vdmVNYXJrKGtleSk7XG4gIH07XG5cbiAgZS5kZWxldGVCYWNrd2FyZCA9IHVuaXQgPT4ge1xuICAgIGlmICh1bml0ICE9PSAnbGluZScpIHtcbiAgICAgIHJldHVybiBkZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgICB9XG5cbiAgICBpZiAoZS5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZS5zZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgcGFyZW50QmxvY2tFbnRyeSA9IEVkaXRvci5hYm92ZShlLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZSwgbiksXG4gICAgICAgIGF0OiBlLnNlbGVjdGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwYXJlbnRCbG9ja0VudHJ5KSB7XG4gICAgICAgIHZhciBbLCBwYXJlbnRCbG9ja1BhdGhdID0gcGFyZW50QmxvY2tFbnRyeTtcbiAgICAgICAgdmFyIHBhcmVudEVsZW1lbnRSYW5nZSA9IEVkaXRvci5yYW5nZShlLCBwYXJlbnRCbG9ja1BhdGgsIGUuc2VsZWN0aW9uLmFuY2hvcik7XG4gICAgICAgIHZhciBjdXJyZW50TGluZVJhbmdlID0gZmluZEN1cnJlbnRMaW5lUmFuZ2UoZSwgcGFyZW50RWxlbWVudFJhbmdlKTtcblxuICAgICAgICBpZiAoIVJhbmdlLmlzQ29sbGFwc2VkKGN1cnJlbnRMaW5lUmFuZ2UpKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZSwge1xuICAgICAgICAgICAgYXQ6IGN1cnJlbnRMaW5lUmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gVGhpcyBhdHRlbXB0cyB0byByZXNldCB0aGUgTk9ERV9UT19LRVkgZW50cnkgdG8gdGhlIGNvcnJlY3QgdmFsdWVcbiAgLy8gYXMgYXBwbHkoKSBjaGFuZ2VzIHRoZSBvYmplY3QgcmVmZXJlbmNlIGFuZCBoZW5jZSBpbnZhbGlkYXRlcyB0aGUgTk9ERV9UT19LRVkgZW50cnlcblxuXG4gIGUuYXBwbHkgPSBvcCA9PiB7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgcGVuZGluZ0RpZmZzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGUpO1xuXG4gICAgaWYgKHBlbmRpbmdEaWZmcyAhPT0gbnVsbCAmJiBwZW5kaW5nRGlmZnMgIT09IHZvaWQgMCAmJiBwZW5kaW5nRGlmZnMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZWQgPSBwZW5kaW5nRGlmZnMubWFwKHRleHREaWZmID0+IHRyYW5zZm9ybVRleHREaWZmKHRleHREaWZmLCBvcCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLnNldChlLCB0cmFuc2Zvcm1lZCk7XG4gICAgfVxuXG4gICAgdmFyIHBlbmRpbmdTZWxlY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZ2V0KGUpO1xuXG4gICAgaWYgKHBlbmRpbmdTZWxlY3Rpb24pIHtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5zZXQoZSwgdHJhbnNmb3JtUGVuZGluZ1JhbmdlKGUsIHBlbmRpbmdTZWxlY3Rpb24sIG9wKSk7XG4gICAgfVxuXG4gICAgdmFyIHBlbmRpbmdBY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGUpO1xuXG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gIT09IG51bGwgJiYgcGVuZGluZ0FjdGlvbiAhPT0gdm9pZCAwICYmIHBlbmRpbmdBY3Rpb24uYXQpIHtcbiAgICAgIHZhciBhdCA9IFBvaW50LmlzUG9pbnQocGVuZGluZ0FjdGlvbiA9PT0gbnVsbCB8fCBwZW5kaW5nQWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nQWN0aW9uLmF0KSA/IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlLCBwZW5kaW5nQWN0aW9uLmF0LCBvcCkgOiB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZSwgcGVuZGluZ0FjdGlvbi5hdCwgb3ApO1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLnNldChlLCBhdCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGVuZGluZ0FjdGlvbiksIHt9LCB7XG4gICAgICAgIGF0XG4gICAgICB9KSA6IG51bGwpO1xuICAgIH1cblxuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBvcC5wYXRoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX0VESVRPUl9UT19VU0VSX1NFTEVDO1xuXG4gICAgICAgICAgLy8gU2VsZWN0aW9uIHdhcyBtYW51YWxseSBzZXQsIGRvbid0IHJlc3RvcmUgdGhlIHVzZXIgc2VsZWN0aW9uIGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgICAgICAgKF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9IEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5nZXQoZSkpID09PSBudWxsIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19VU0VSX1NFTEVDLnVucmVmKCk7XG4gICAgICAgICAgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmRlbGV0ZShlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBQYXRoLnBhcmVudChvcC5wYXRoKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhvcC5wYXRoKTtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBwcmV2UGF0aCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguY29tbW9uKFBhdGgucGFyZW50KG9wLnBhdGgpLCBQYXRoLnBhcmVudChvcC5uZXdQYXRoKSk7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgY29tbW9uUGF0aCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXBwbHkob3ApO1xuXG4gICAgZm9yICh2YXIgW3BhdGgsIGtleV0gb2YgbWF0Y2hlcykge1xuICAgICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGUsIHBhdGgpO1xuICAgICAgTk9ERV9UT19LRVkuc2V0KG5vZGUsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGUuc2V0RnJhZ21lbnREYXRhID0gZGF0YSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICB2YXIgc3RhcnRWb2lkID0gRWRpdG9yLnZvaWQoZSwge1xuICAgICAgYXQ6IHN0YXJ0LnBhdGhcbiAgICB9KTtcbiAgICB2YXIgZW5kVm9pZCA9IEVkaXRvci52b2lkKGUsIHtcbiAgICAgIGF0OiBlbmQucGF0aFxuICAgIH0pO1xuXG4gICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgJiYgIXN0YXJ0Vm9pZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ3JlYXRlIGEgZmFrZSBzZWxlY3Rpb24gc28gdGhhdCB3ZSBjYW4gYWRkIGEgQmFzZTY0LWVuY29kZWQgY29weSBvZiB0aGVcbiAgICAvLyBmcmFnbWVudCB0byB0aGUgSFRNTCwgdG8gZGVjb2RlIG9uIGZ1dHVyZSBwYXN0ZXMuXG5cblxuICAgIHZhciBkb21SYW5nZSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZSwgc2VsZWN0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBkb21SYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgdmFyIGF0dGFjaCA9IGNvbnRlbnRzLmNoaWxkTm9kZXNbMF07IC8vIE1ha2Ugc3VyZSBhdHRhY2ggaXMgbm9uLWVtcHR5LCBzaW5jZSBlbXB0eSBub2RlcyB3aWxsIG5vdCBnZXQgY29waWVkLlxuXG4gICAgY29udGVudHMuY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaWYgKG5vZGUudGV4dENvbnRlbnQgJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgIT09ICcnKSB7XG4gICAgICAgIGF0dGFjaCA9IG5vZGU7XG4gICAgICB9XG4gICAgfSk7IC8vIENPTVBBVDogSWYgdGhlIGVuZCBub2RlIGlzIGEgdm9pZCBub2RlLCB3ZSBuZWVkIHRvIG1vdmUgdGhlIGVuZCBvZiB0aGVcbiAgICAvLyByYW5nZSBmcm9tIHRoZSB2b2lkIG5vZGUncyBzcGFjZXIgc3BhbiwgdG8gdGhlIGVuZCBvZiB0aGUgdm9pZCBub2RlJ3NcbiAgICAvLyBjb250ZW50LCBzaW5jZSB0aGUgc3BhY2VyIGlzIGJlZm9yZSB2b2lkJ3MgY29udGVudCBpbiB0aGUgRE9NLlxuXG4gICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgIHZhciBbdm9pZE5vZGVdID0gZW5kVm9pZDtcbiAgICAgIHZhciByID0gZG9tUmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgdmFyIGRvbU5vZGUgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZSwgdm9pZE5vZGUpO1xuICAgICAgci5zZXRFbmRBZnRlcihkb21Ob2RlKTtcbiAgICAgIGNvbnRlbnRzID0gci5jbG9uZUNvbnRlbnRzKCk7XG4gICAgfSAvLyBDT01QQVQ6IElmIHRoZSBzdGFydCBub2RlIGlzIGEgdm9pZCBub2RlLCB3ZSBuZWVkIHRvIGF0dGFjaCB0aGUgZW5jb2RlZFxuICAgIC8vIGZyYWdtZW50IHRvIHRoZSB2b2lkIG5vZGUncyBjb250ZW50IG5vZGUgaW5zdGVhZCBvZiB0aGUgc3BhY2VyLCBiZWNhdXNlXG4gICAgLy8gYXR0YWNoaW5nIGl0IHRvIGVtcHR5IGA8ZGl2Pi88c3Bhbj5gIG5vZGVzIHdpbGwgZW5kIHVwIGhhdmluZyBpdCBlcmFzZWQgYnlcbiAgICAvLyBtb3N0IGJyb3dzZXJzLiAoMjAxOC8wNC8yNylcblxuXG4gICAgaWYgKHN0YXJ0Vm9pZCkge1xuICAgICAgYXR0YWNoID0gY29udGVudHMucXVlcnlTZWxlY3RvcignW2RhdGEtc2xhdGUtc3BhY2VyXScpO1xuICAgIH0gLy8gUmVtb3ZlIGFueSB6ZXJvLXdpZHRoIHNwYWNlIHNwYW5zIGZyb20gdGhlIGNsb25lZCBET00gc28gdGhhdCB0aGV5IGRvbid0XG4gICAgLy8gc2hvdyB1cCBlbHNld2hlcmUgd2hlbiBwYXN0ZWQuXG5cblxuICAgIEFycmF5LmZyb20oY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKSkuZm9yRWFjaCh6dyA9PiB7XG4gICAgICB2YXIgaXNOZXdsaW5lID0gencuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSA9PT0gJ24nO1xuICAgICAgencudGV4dENvbnRlbnQgPSBpc05ld2xpbmUgPyAnXFxuJyA6ICcnO1xuICAgIH0pOyAvLyBTZXQgYSBgZGF0YS1zbGF0ZS1mcmFnbWVudGAgYXR0cmlidXRlIG9uIGEgbm9uLWVtcHR5IG5vZGUsIHNvIGl0IHNob3dzIHVwXG4gICAgLy8gaW4gdGhlIEhUTUwsIGFuZCBjYW4gYmUgdXNlZCBmb3IgaW50cmEtU2xhdGUgcGFzdGluZy4gSWYgaXQncyBhIHRleHRcbiAgICAvLyBub2RlLCB3cmFwIGl0IGluIGEgYDxzcGFuPmAgc28gd2UgaGF2ZSBzb21ldGhpbmcgdG8gc2V0IGFuIGF0dHJpYnV0ZSBvbi5cblxuICAgIGlmIChpc0RPTVRleHQoYXR0YWNoKSkge1xuICAgICAgdmFyIHNwYW4gPSBhdHRhY2gub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7IC8vIENPTVBBVDogSW4gQ2hyb21lIGFuZCBTYWZhcmksIGlmIHdlIGRvbid0IGFkZCB0aGUgYHdoaXRlLXNwYWNlYCBzdHlsZVxuICAgICAgLy8gdGhlbiBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXMgd2lsbCBiZSBpZ25vcmVkLiAoMjAxNy8wOS8yMSlcblxuICAgICAgc3Bhbi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZSc7XG4gICAgICBzcGFuLmFwcGVuZENoaWxkKGF0dGFjaCk7XG4gICAgICBjb250ZW50cy5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgIGF0dGFjaCA9IHNwYW47XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50ID0gZS5nZXRGcmFnbWVudCgpO1xuICAgIHZhciBzdHJpbmcgPSBKU09OLnN0cmluZ2lmeShmcmFnbWVudCk7XG4gICAgdmFyIGVuY29kZWQgPSB3aW5kb3cuYnRvYShlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKSk7XG4gICAgYXR0YWNoLnNldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1mcmFnbWVudCcsIGVuY29kZWQpO1xuICAgIGRhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL1wiLmNvbmNhdChjbGlwYm9hcmRGb3JtYXRLZXkpLCBlbmNvZGVkKTsgLy8gQWRkIHRoZSBjb250ZW50IHRvIGEgPGRpdj4gc28gdGhhdCB3ZSBjYW4gZ2V0IGl0cyBpbm5lciBIVE1MLlxuXG4gICAgdmFyIGRpdiA9IGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGNvbnRlbnRzKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAndHJ1ZScpO1xuICAgIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIGRhdGEuc2V0RGF0YSgndGV4dC9odG1sJywgZGl2LmlubmVySFRNTCk7XG4gICAgZGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgZ2V0UGxhaW5UZXh0KGRpdikpO1xuICAgIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIGUuaW5zZXJ0RGF0YSA9IGRhdGEgPT4ge1xuICAgIGlmICghZS5pbnNlcnRGcmFnbWVudERhdGEoZGF0YSkpIHtcbiAgICAgIGUuaW5zZXJ0VGV4dERhdGEoZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIGUuaW5zZXJ0RnJhZ21lbnREYXRhID0gZGF0YSA9PiB7XG4gICAgLyoqXHJcbiAgICAgKiBDaGVja2luZyBjb3BpZWQgZnJhZ21lbnQgZnJvbSBhcHBsaWNhdGlvbi94LXNsYXRlLWZyYWdtZW50IG9yIGRhdGEtc2xhdGUtZnJhZ21lbnRcclxuICAgICAqL1xuICAgIHZhciBmcmFnbWVudCA9IGRhdGEuZ2V0RGF0YShcImFwcGxpY2F0aW9uL1wiLmNvbmNhdChjbGlwYm9hcmRGb3JtYXRLZXkpKSB8fCBnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlKGRhdGEpO1xuXG4gICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICB2YXIgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cuYXRvYihmcmFnbWVudCkpO1xuICAgICAgdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgICBlLmluc2VydEZyYWdtZW50KHBhcnNlZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgZS5pbnNlcnRUZXh0RGF0YSA9IGRhdGEgPT4ge1xuICAgIHZhciB0ZXh0ID0gZGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcbiAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlLCB7XG4gICAgICAgICAgICBhbHdheXM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUuaW5zZXJ0VGV4dChsaW5lKTtcbiAgICAgICAgc3BsaXQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgZS5vbkNoYW5nZSA9IG9wdGlvbnMgPT4ge1xuICAgIC8vIENPTVBBVDogUmVhY3QgZG9lc24ndCBiYXRjaCBgc2V0U3RhdGVgIGhvb2sgY2FsbHMsIHdoaWNoIG1lYW5zIHRoYXQgdGhlXG4gICAgLy8gY2hpbGRyZW4gYW5kIHNlbGVjdGlvbiBjYW4gZ2V0IG91dCBvZiBzeW5jIGZvciBvbmUgcmVuZGVyIHBhc3MuIFNvIHdlXG4gICAgLy8gaGF2ZSB0byB1c2UgdGhpcyB1bnN0YWJsZSBBUEkgdG8gZW5zdXJlIGl0IGJhdGNoZXMgdGhlbS4gKDIwMTkvMTIvMDMpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDI1OSNpc3N1ZWNvbW1lbnQtNDM5NzAyMzY3XG4gICAgUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgdmFyIG9uQ29udGV4dENoYW5nZSA9IEVESVRPUl9UT19PTl9DSEFOR0UuZ2V0KGUpO1xuXG4gICAgICBpZiAob25Db250ZXh0Q2hhbmdlKSB7XG4gICAgICAgIG9uQ29udGV4dENoYW5nZSgpO1xuICAgICAgfVxuXG4gICAgICBvbkNoYW5nZShvcHRpb25zKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gZTtcbn07XG5cbnZhciBnZXRNYXRjaGVzID0gKGUsIHBhdGgpID0+IHtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICBmb3IgKHZhciBbbiwgcF0gb2YgRWRpdG9yLmxldmVscyhlLCB7XG4gICAgYXQ6IHBhdGhcbiAgfSkpIHtcbiAgICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlLCBuKTtcbiAgICBtYXRjaGVzLnB1c2goW3AsIGtleV0pO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59O1xuXG5leHBvcnQgeyBEZWZhdWx0RWxlbWVudCwgRGVmYXVsdExlYWYsIERlZmF1bHRQbGFjZWhvbGRlciwgRWRpdGFibGUsIFJlYWN0RWRpdG9yLCBTbGF0ZSwgdXNlRWRpdG9yLCB1c2VGb2N1c2VkLCB1c2VSZWFkT25seSwgdXNlU2VsZWN0ZWQsIHVzZVNsYXRlLCB1c2VTbGF0ZVNlbGVjdGlvbiwgdXNlU2xhdGVTZWxlY3RvciwgdXNlU2xhdGVTdGF0aWMsIHVzZVNsYXRlV2l0aFYsIHdpdGhSZWFjdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0RGlyZWN0aW9uIiwiZGVib3VuY2UiLCJ0aHJvdHRsZSIsIlJlYWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJtZW1vIiwiZm9yd2FyZFJlZiIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlQ2FsbGJhY2siLCJDb21wb25lbnQiLCJ1c2VSZWR1Y2VyIiwidXNlTWVtbyIsInNjcm9sbEludG9WaWV3IiwiRWRpdG9yIiwiU2NydWJiZXIiLCJUcmFuc2Zvcm1zIiwiUmFuZ2UiLCJFbGVtZW50IiwiRWxlbWVudCQxIiwiUGF0aCIsIk5vZGUiLCJUZXh0IiwiVGV4dCQxIiwiUG9pbnQiLCJSZXNpemVPYnNlcnZlciIsImlzS2V5SG90a2V5IiwiUmVhY3RET00iLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsInNvdXJjZUtleXMiLCJrZXlzIiwiaSIsImxlbmd0aCIsImluZGV4T2YiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwicHJvdG90eXBlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJjYWxsIiwibiIsIktleSIsImNvbnN0cnVjdG9yIiwiaWQiLCJjb25jYXQiLCJOT0RFX1RPX0lOREVYIiwiV2Vha01hcCIsIk5PREVfVE9fUEFSRU5UIiwiRURJVE9SX1RPX1dJTkRPVyIsIkVESVRPUl9UT19FTEVNRU5UIiwiRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQiLCJFTEVNRU5UX1RPX05PREUiLCJOT0RFX1RPX0VMRU1FTlQiLCJOT0RFX1RPX0tFWSIsIkVESVRPUl9UT19LRVlfVE9fRUxFTUVOVCIsIklTX1JFQURfT05MWSIsIklTX0ZPQ1VTRUQiLCJJU19DT01QT1NJTkciLCJFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04iLCJFRElUT1JfVE9fT05fQ0hBTkdFIiwiRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNIIiwiRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTIiwiRURJVE9SX1RPX1VTRVJfTUFSS1MiLCJFRElUT1JfVE9fUEVORElOR19ESUZGUyIsIkVESVRPUl9UT19QRU5ESU5HX0FDVElPTiIsIkVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTiIsIkVESVRPUl9UT19GT1JDRV9SRU5ERVIiLCJQTEFDRUhPTERFUl9TWU1CT0wiLCJTeW1ib2wiLCJNQVJLX1BMQUNFSE9MREVSX1NZTUJPTCIsIkRPTVRleHQiLCJnbG9iYWxUaGlzIiwiZ2V0RGVmYXVsdFZpZXciLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0RPTUNvbW1lbnQiLCJpc0RPTU5vZGUiLCJub2RlVHlwZSIsImlzRE9NRWxlbWVudCIsIndpbmRvdyIsImlzRE9NU2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsIlNlbGVjdGlvbiIsImlzRE9NVGV4dCIsImlzUGxhaW5UZXh0T25seVBhc3RlIiwiZXZlbnQiLCJjbGlwYm9hcmREYXRhIiwiZ2V0RGF0YSIsInR5cGVzIiwibm9ybWFsaXplRE9NUG9pbnQiLCJkb21Qb2ludCIsIm5vZGUiLCJvZmZzZXQiLCJjaGlsZE5vZGVzIiwiaXNMYXN0IiwiaW5kZXgiLCJnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgiLCJnZXRFZGl0YWJsZUNoaWxkIiwidGV4dENvbnRlbnQiLCJoYXNTaGFkb3dSb290IiwicGFyZW50IiwicGFyZW50Tm9kZSIsInRvU3RyaW5nIiwiZGlyZWN0aW9uIiwiY2hpbGQiLCJ0cmllZEZvcndhcmQiLCJ0cmllZEJhY2t3YXJkIiwiZ2V0QXR0cmlidXRlIiwiZ2V0UGxhaW5UZXh0IiwiZG9tTm9kZSIsInRleHQiLCJub2RlVmFsdWUiLCJjaGlsZE5vZGUiLCJBcnJheSIsImZyb20iLCJkaXNwbGF5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJ0YWdOYW1lIiwiY2F0Y2hTbGF0ZUZyYWdtZW50IiwiZ2V0U2xhdGVGcmFnbWVudEF0dHJpYnV0ZSIsImRhdGFUcmFuc2ZlciIsImh0bWxEYXRhIiwiZnJhZ21lbnQiLCJtYXRjaCIsImlzVHJhY2tlZE11dGF0aW9uIiwiZWRpdG9yIiwibXV0YXRpb24iLCJiYXRjaCIsIm1hdGNoZXMiLCJkb2N1bWVudCIsIlJlYWN0RWRpdG9yIiwiZ2V0V2luZG93IiwiY29udGFpbnMiLCJoYXNET01Ob2RlIiwiZWRpdGFibGUiLCJwYXJlbnRNdXRhdGlvbiIsImZpbmQiLCJfcmVmIiwiYWRkZWROb2RlcyIsInJlbW92ZWROb2RlcyIsIl9ub2RlIiwiSVNfUkVBQ1RfVkVSU0lPTl8xN19PUl9BQk9WRSIsInBhcnNlSW50IiwidmVyc2lvbiIsInNwbGl0IiwiSVNfSU9TIiwibmF2aWdhdG9yIiwidGVzdCIsInVzZXJBZ2VudCIsIk1TU3RyZWFtIiwiSVNfQVBQTEUiLCJJU19BTkRST0lEIiwiSVNfRklSRUZPWCIsIklTX1NBRkFSSSIsIklTX0VER0VfTEVHQUNZIiwiSVNfQ0hST01FIiwiSVNfQ0hST01FX0xFR0FDWSIsIklTX0FORFJPSURfQ0hST01FX0xFR0FDWSIsIklTX0ZJUkVGT1hfTEVHQUNZIiwiSVNfVUNfTU9CSUxFIiwiSVNfV0VDSEFUQlJPV1NFUiIsIkNBTl9VU0VfRE9NIiwiY3JlYXRlRWxlbWVudCIsIkhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCIsIklucHV0RXZlbnQiLCJnZXRUYXJnZXRSYW5nZXMiLCJpc0NvbXBvc2luZyIsImdldCIsIkVycm9yIiwiZmluZEtleSIsInNldCIsImZpbmRQYXRoIiwicGF0aCIsImlzRWRpdG9yIiwidW5zaGlmdCIsInN0cmluZ2lmeSIsImZpbmREb2N1bWVudE9yU2hhZG93Um9vdCIsImVsIiwidG9ET01Ob2RlIiwicm9vdCIsImdldFJvb3ROb2RlIiwiRG9jdW1lbnQiLCJTaGFkb3dSb290IiwiZ2V0U2VsZWN0aW9uIiwiaXNGb2N1c2VkIiwiaXNSZWFkT25seSIsImJsdXIiLCJhY3RpdmVFbGVtZW50IiwiZm9jdXMiLCJwcmV2ZW50U2Nyb2xsIiwiZGVzZWxlY3QiLCJzZWxlY3Rpb24iLCJkb21TZWxlY3Rpb24iLCJyYW5nZUNvdW50IiwicmVtb3ZlQWxsUmFuZ2VzIiwib3B0aW9ucyIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsImVkaXRvckVsIiwidGFyZ2V0RWwiLCJwYXJlbnRFbGVtZW50IiwiZXJyIiwibWVzc2FnZSIsImluY2x1ZGVzIiwiY2xvc2VzdCIsImlzQ29udGVudEVkaXRhYmxlIiwiaW5zZXJ0RGF0YSIsImRhdGEiLCJpbnNlcnRGcmFnbWVudERhdGEiLCJpbnNlcnRUZXh0RGF0YSIsInNldEZyYWdtZW50RGF0YSIsIm9yaWdpbkV2ZW50IiwiS0VZX1RPX0VMRU1FTlQiLCJ0b0RPTVBvaW50IiwicG9pbnQiLCJ2b2lkIiwiYXQiLCJzZWxlY3RvciIsInRleHRzIiwicXVlcnlTZWxlY3RvckFsbCIsInN0YXJ0IiwiYXR0ciIsInRydWVMZW5ndGgiLCJlbmQiLCJuZXh0VGV4dCIsImhhc0F0dHJpYnV0ZSIsIl9uZXh0VGV4dCR0ZXh0Q29udGVudCIsImRvbVRleHQiLCJzdGFydHNXaXRoIiwiTWF0aCIsIm1pbiIsIm1heCIsInRvRE9NUmFuZ2UiLCJyYW5nZSIsImFuY2hvciIsImlzQmFja3dhcmQiLCJkb21BbmNob3IiLCJkb21Gb2N1cyIsImlzQ29sbGFwc2VkIiwiZG9tUmFuZ2UiLCJjcmVhdGVSYW5nZSIsInN0YXJ0Tm9kZSIsInN0YXJ0T2Zmc2V0IiwiZW5kTm9kZSIsImVuZE9mZnNldCIsInN0YXJ0RWwiLCJpc1N0YXJ0QXRaZXJvV2lkdGgiLCJlbmRFbCIsImlzRW5kQXRaZXJvV2lkdGgiLCJzZXRTdGFydCIsInNldEVuZCIsInRvU2xhdGVOb2RlIiwiZG9tRWwiLCJmaW5kRXZlbnRSYW5nZSIsIm5hdGl2ZUV2ZW50IiwiY2xpZW50WCIsIngiLCJjbGllbnRZIiwieSIsImlzRWxlbWVudCIsImlzVm9pZCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpc1ByZXYiLCJpc0lubGluZSIsImxlZnQiLCJ3aWR0aCIsInRvcCIsImhlaWdodCIsImVkZ2UiLCJiZWZvcmUiLCJhZnRlciIsIl9yYW5nZSIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJwb3NpdGlvbiIsImNhcmV0UG9zaXRpb25Gcm9tUG9pbnQiLCJvZmZzZXROb2RlIiwidG9TbGF0ZVJhbmdlIiwiZXhhY3RNYXRjaCIsInN1cHByZXNzVGhyb3ciLCJ0b1NsYXRlUG9pbnQiLCJuZWFyZXN0Tm9kZSIsIm5lYXJlc3RPZmZzZXQiLCJ0ZXh0Tm9kZSIsIl9kb21Ob2RlJHRleHRDb250ZW50IiwiX2RvbU5vZGUkdGV4dENvbnRlbnQyIiwicG90ZW50aWFsVm9pZE5vZGUiLCJ2b2lkTm9kZSIsImxlYWZOb2RlIiwiY29udGVudHMiLCJjbG9uZUNvbnRlbnRzIiwicmVtb3ZhbHMiLCJzbGljZSIsImZvckVhY2giLCJ0ZXh0Q29udGV4dCIsInJlbW92ZUNoaWxkIiwibGVhZk5vZGVzIiwiY3VycmVudCIsImVuZHNXaXRoIiwiX3NsYXRlTm9kZSIsIl9wYXRoIiwiX29mZnNldCIsInF1ZXJ5U2VsZWN0b3IiLCJzbGF0ZU5vZGUiLCJzdGFydENvbnRhaW5lciIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiZW5kQ29udGFpbmVyIiwiY29sbGFwc2VkIiwiX2FuY2hvck5vZGUkdGV4dENvbnRlIiwiaXNFbmQiLCJpc1N0YXJ0IiwiaXNFeHBhbmRlZCIsImlzRm9yd2FyZCIsIm1vZGUiLCJ1bmhhbmdSYW5nZSIsInZvaWRzIiwiaGFzUmFuZ2UiLCJoYXNQYXRoIiwiaGFzVGFyZ2V0IiwiaGFzRWRpdGFibGVUYXJnZXQiLCJoYXNTZWxlY3RhYmxlVGFyZ2V0IiwiaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQiLCJhbmRyb2lkU2NoZWR1bGVGbHVzaCIsIl9FRElUT1JfVE9fU0NIRURVTEVfRiIsImFuZHJvaWRQZW5kaW5nRGlmZnMiLCJfZXhjbHVkZWQkMyIsIl9leGNsdWRlZDIkMSIsInNoYWxsb3dDb21wYXJlIiwib2JqMSIsIm9iajIiLCJldmVyeSIsImhhc093blByb3BlcnR5IiwiaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbCIsIm90aGVyIiwicmFuZ2VPd25Qcm9wcyIsIm90aGVyT3duUHJvcHMiLCJpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsIiwibGlzdCIsImFub3RoZXIiLCJlcXVhbHMiLCJpc1RleHREZWNvcmF0aW9uc0VxdWFsIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIlN0cmluZyIsInByb3BzIiwibGVhZiIsInVzZVNsYXRlU3RhdGljIiwicGFyZW50UGF0aCIsImlzTWFya1BsYWNlaG9sZGVyIiwiWmVyb1dpZHRoU3RyaW5nIiwic3RyaW5nIiwiY2hpbGRyZW4iLCJpc0xpbmVCcmVhayIsIlRleHRTdHJpbmciLCJpc1RyYWlsaW5nIiwicmVmIiwiZ2V0VGV4dENvbnRlbnQiLCJpbml0aWFsVGV4dCIsInRleHRXaXRoVHJhaWxpbmciLCJNZW1vaXplZFRleHQkMSIsImF0dHJpYnV0ZXMiLCJhc3NpZ24iLCJFZGl0b3JDb250ZXh0IiwiTGVhZiIsInJlbmRlclBsYWNlaG9sZGVyIiwicmVuZGVyTGVhZiIsIkRlZmF1bHRMZWFmIiwibGFzdFBsYWNlaG9sZGVyUmVmIiwicGxhY2Vob2xkZXJSZWYiLCJwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyIiwiZGlzY29ubmVjdCIsInBsYWNlaG9sZGVyRWwiLCJkZWxldGUiLCJvYnNlcnZlIiwiUmVzaXplT2JzZXJ2ZXIkMSIsImZvcmNlUmVuZGVyIiwicGxhY2Vob2xkZXJQcm9wcyIsInBsYWNlaG9sZGVyIiwic3R5bGUiLCJwb2ludGVyRXZlbnRzIiwibWF4V2lkdGgiLCJvcGFjaXR5IiwidXNlclNlbGVjdCIsInRleHREZWNvcmF0aW9uIiwiY29udGVudEVkaXRhYmxlIiwiRnJhZ21lbnQiLCJNZW1vaXplZExlYWYiLCJwcmV2IiwibmV4dCIsImRlY29yYXRpb25zIiwibGVhdmVzIiwicHVzaCIsImNhbGxiYWNrUmVmIiwic3BhbiIsIk1lbW9pemVkVGV4dCIsImVsZW1lbnQiLCJyZW5kZXJFbGVtZW50IiwicCIsIkRlZmF1bHRFbGVtZW50IiwicmVhZE9ubHkiLCJ1c2VSZWFkT25seSIsInVzZUNoaWxkcmVuIiwiaGFzSW5saW5lcyIsImRpciIsIlRhZyIsIl90ZXh0IiwiY29sb3IiLCJvdXRsaW5lIiwiTWVtb2l6ZWRFbGVtZW50IiwiRGVjb3JhdGVDb250ZXh0IiwidXNlRGVjb3JhdGUiLCJTZWxlY3RlZENvbnRleHQiLCJ1c2VTZWxlY3RlZCIsImRlY29yYXRlIiwiaXNMZWFmQmxvY2siLCJzZWwiLCJpbnRlcnNlY3Rpb24iLCJkcyIsImRlYyIsImQiLCJQcm92aWRlciIsIlJlYWRPbmx5Q29udGV4dCIsIlNsYXRlQ29udGV4dCIsInVzZVNsYXRlIiwiY29udGV4dCIsInVzZVNsYXRlV2l0aFYiLCJUUklQTEVfQ0xJQ0siLCJIT1RLRVlTIiwiYm9sZCIsImNvbXBvc2UiLCJtb3ZlQmFja3dhcmQiLCJtb3ZlRm9yd2FyZCIsIm1vdmVXb3JkQmFja3dhcmQiLCJtb3ZlV29yZEZvcndhcmQiLCJkZWxldGVCYWNrd2FyZCIsImRlbGV0ZUZvcndhcmQiLCJleHRlbmRCYWNrd2FyZCIsImV4dGVuZEZvcndhcmQiLCJpdGFsaWMiLCJpbnNlcnRTb2Z0QnJlYWsiLCJzcGxpdEJsb2NrIiwidW5kbyIsIkFQUExFX0hPVEtFWVMiLCJtb3ZlTGluZUJhY2t3YXJkIiwibW92ZUxpbmVGb3J3YXJkIiwiZGVsZXRlTGluZUJhY2t3YXJkIiwiZGVsZXRlTGluZUZvcndhcmQiLCJkZWxldGVXb3JkQmFja3dhcmQiLCJkZWxldGVXb3JkRm9yd2FyZCIsImV4dGVuZExpbmVCYWNrd2FyZCIsImV4dGVuZExpbmVGb3J3YXJkIiwicmVkbyIsInRyYW5zcG9zZUNoYXJhY3RlciIsIldJTkRPV1NfSE9US0VZUyIsImNyZWF0ZSIsImdlbmVyaWMiLCJhcHBsZSIsIndpbmRvd3MiLCJpc0dlbmVyaWMiLCJpc0FwcGxlIiwiaXNXaW5kb3dzIiwiSG90a2V5cyIsImlzQm9sZCIsImlzQ29tcG9zZSIsImlzTW92ZUJhY2t3YXJkIiwiaXNNb3ZlRm9yd2FyZCIsImlzRGVsZXRlQmFja3dhcmQiLCJpc0RlbGV0ZUZvcndhcmQiLCJpc0RlbGV0ZUxpbmVCYWNrd2FyZCIsImlzRGVsZXRlTGluZUZvcndhcmQiLCJpc0RlbGV0ZVdvcmRCYWNrd2FyZCIsImlzRGVsZXRlV29yZEZvcndhcmQiLCJpc0V4dGVuZEJhY2t3YXJkIiwiaXNFeHRlbmRGb3J3YXJkIiwiaXNFeHRlbmRMaW5lQmFja3dhcmQiLCJpc0V4dGVuZExpbmVGb3J3YXJkIiwiaXNJdGFsaWMiLCJpc01vdmVMaW5lQmFja3dhcmQiLCJpc01vdmVMaW5lRm9yd2FyZCIsImlzTW92ZVdvcmRCYWNrd2FyZCIsImlzTW92ZVdvcmRGb3J3YXJkIiwiaXNSZWRvIiwiaXNTb2Z0QnJlYWsiLCJpc1NwbGl0QmxvY2siLCJpc1RyYW5zcG9zZUNoYXJhY3RlciIsImlzVW5kbyIsImNyZWF0ZVJlc3RvcmVEb21NYW5hZ2VyIiwicmVjZWl2ZWRVc2VySW5wdXQiLCJidWZmZXJlZE11dGF0aW9ucyIsImNsZWFyIiwicmVnaXN0ZXJNdXRhdGlvbnMiLCJtdXRhdGlvbnMiLCJ0cmFja2VkTXV0YXRpb25zIiwiZmlsdGVyIiwicmVzdG9yZURPTSIsInJldmVyc2UiLCJ0eXBlIiwiaW5zZXJ0QmVmb3JlIiwibmV4dFNpYmxpbmciLCJNVVRBVElPTl9PQlNFUlZFUl9DT05GSUckMSIsInN1YnRyZWUiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwiUmVzdG9yZURPTUNvbXBvbmVudCIsIm1hbmFnZXIiLCJtdXRhdGlvbk9ic2VydmVyIiwiX3RoaXMkbXV0YXRpb25PYnNlcnZlIiwiY29tcG9uZW50RGlkTW91bnQiLCJNdXRhdGlvbk9ic2VydmVyIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJfdGhpcyRtdXRhdGlvbk9ic2VydmUyIiwiX3RoaXMkbXV0YXRpb25PYnNlcnZlMyIsIl90aGlzJG1hbmFnZXIyIiwicGVuZGluZ011dGF0aW9ucyIsInRha2VSZWNvcmRzIiwiX3RoaXMkbWFuYWdlciIsImNvbXBvbmVudERpZFVwZGF0ZSIsIl90aGlzJG1hbmFnZXIzIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJfdGhpcyRtdXRhdGlvbk9ic2VydmU0IiwicmVuZGVyIiwiY29udGV4dFR5cGUiLCJSZXN0b3JlRE9NIiwidmVyaWZ5RGlmZlN0YXRlIiwidGV4dERpZmYiLCJkaWZmIiwiaXNUZXh0IiwibmV4dFBhdGgiLCJuZXh0Tm9kZSIsImFwcGx5U3RyaW5nRGlmZiIsIl9sZW4iLCJkaWZmcyIsIl9rZXkiLCJyZWR1Y2UiLCJsb25nZXN0Q29tbW9uUHJlZml4TGVuZ3RoIiwic3RyIiwiY2hhckF0IiwibG9uZ2VzdENvbW1vblN1ZmZpeExlbmd0aCIsIm5vcm1hbGl6ZVN0cmluZ0RpZmYiLCJ0YXJnZXRUZXh0IiwicmVtb3ZlZFRleHQiLCJwcmVmaXhMZW5ndGgiLCJzdWZmaXhMZW5ndGgiLCJub3JtYWxpemVkIiwibWVyZ2VTdHJpbmdEaWZmcyIsImEiLCJiIiwib3ZlcmxhcCIsImFwcGxpZWQiLCJzbGljZUVuZCIsInRhcmdldFJhbmdlIiwibm9ybWFsaXplUG9pbnQiLCJwYXJlbnRCbG9jayIsImFib3ZlIiwiaXNCbG9jayIsImVudHJ5IiwiaXNEZXNjZW5kYW50Iiwibm9ybWFsaXplUmFuZ2UiLCJ0cmFuc2Zvcm1QZW5kaW5nUG9pbnQiLCJvcCIsInBlbmRpbmdEaWZmcyIsInRyYW5zZm9ybSIsImFmZmluaXR5IiwiX2FuY2hvciIsIl90cmFuc2Zvcm1lZCIsInRyYW5zZm9ybWVkIiwidHJhbnNmb3JtUGVuZGluZ1JhbmdlIiwidHJhbnNmb3JtVGV4dERpZmYiLCJuZXdQYXRoIiwib3duS2V5cyQzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJzeW1ib2xzIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkJDMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIlJFU09MVkVfREVMQVkiLCJGTFVTSF9ERUxBWSIsImRlYnVnIiwiaXNEYXRhVHJhbnNmZXIiLCJuYW1lIiwiY3JlYXRlQW5kcm9pZElucHV0TWFuYWdlciIsInNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UiLCJvbkRPTVNlbGVjdGlvbkNoYW5nZSIsImZsdXNoaW5nIiwiY29tcG9zaXRpb25FbmRUaW1lb3V0SWQiLCJmbHVzaFRpbWVvdXRJZCIsImFjdGlvblRpbWVvdXRJZCIsImlkQ291bnRlciIsImluc2VydFBvc2l0aW9uSGludCIsImFwcGx5UGVuZGluZ1NlbGVjdGlvbiIsInBlbmRpbmdTZWxlY3Rpb24iLCJzZWxlY3QiLCJwZXJmb3JtQWN0aW9uIiwiYWN0aW9uIiwiaXNQb2ludCIsIl90YXJnZXRSYW5nZSIsInJ1biIsImZsdXNoIiwiY2xlYXJUaW1lb3V0IiwiaGFzUGVuZGluZ0RpZmZzIiwiaGFzUGVuZGluZ0FjdGlvbiIsInNldFRpbWVvdXQiLCJzZWxlY3Rpb25SZWYiLCJyYW5nZVJlZiIsIm1hcmtzIiwic2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UiLCJfRURJVE9SX1RPX1BFTkRJTkdfREkiLCJfRURJVE9SX1RPX1BFTkRJTkdfREkyIiwicGVuZGluZ01hcmtzIiwiaW5zZXJ0VGV4dCIsImRlbGV0ZUZyYWdtZW50IiwiX3JlZjIiLCJjYW5jZWwiLCJ1bnJlZiIsInVzZXJNYXJrcyIsIm9uQ2hhbmdlIiwiaGFuZGxlQ29tcG9zaXRpb25FbmQiLCJfZXZlbnQiLCJoYW5kbGVDb21wb3NpdGlvblN0YXJ0IiwidXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5IiwiZm9yY2VIaWRlIiwicGxhY2Vob2xkZXJFbGVtZW50IiwicmVtb3ZlUHJvcGVydHkiLCJzdG9yZURpZmYiLCJfRURJVE9SX1RPX1BFTkRJTkdfREkzIiwiaWR4IiwiZmluZEluZGV4IiwiY2hhbmdlIiwibWVyZ2VkIiwic3BsaWNlIiwic2NoZWR1bGVBY3Rpb24iLCJoYW5kbGVET01CZWZvcmVJbnB1dCIsIl90YXJnZXRSYW5nZTIiLCJpbnB1dFR5cGUiLCJuYXRpdmVUYXJnZXRSYW5nZSIsImNhblN0b3JlRGlmZiIsIl9zdGFydCIsIl9lbmQiLCJlZGdlcyIsIl9sZWFmIiwicmVsZXZhbnRQZW5kaW5nRGlmZnMiLCJoYW5kbGVVc2VyU2VsZWN0IiwidGFyZ2V0Tm9kZSIsIl9uYXRpdmVUYXJnZXRSYW5nZSIsIm5hdGl2ZUNvbGxhcHNlZCIsInVuaXQiLCJpbnNlcnRCcmVhayIsInJlcGxhY2UiLCJwYXJ0cyIsImxpbmUiLCJfc3RhcnQyIiwiX2VuZDIiLCJfZGlmZiIsImhpbnRQb3NpdGlvbiIsInNlYXJjaCIsImRpZmZQb3NpdGlvbiIsInNjaGVkdWxlRmx1c2giLCJfRURJVE9SX1RPX1BFTkRJTkdfREk0IiwiaGFzUGVuZGluZ0NoYW5nZXMiLCJpc0ZsdXNoaW5nIiwicGF0aENoYW5nZWQiLCJwYXJlbnRQYXRoQ2hhbmdlZCIsImhhbmRsZUlucHV0IiwiaGFuZGxlS2V5RG93biIsIl8iLCJoYW5kbGVEb21NdXRhdGlvbnMiLCJzb21lIiwiX0VESVRPUl9UT19GT1JDRV9SRU5EIiwidXNlSXNNb3VudGVkIiwiaXNNb3VudGVkUmVmIiwidXNlTXV0YXRpb25PYnNlcnZlciIsImNhbGxiYWNrIiwiX2V4Y2x1ZGVkJDIiLCJvd25LZXlzJDIiLCJfb2JqZWN0U3ByZWFkJDIiLCJNVVRBVElPTl9PQlNFUlZFUl9DT05GSUciLCJ1c2VBbmRyb2lkSW5wdXRNYW5hZ2VyIiwiaXNNb3VudGVkIiwiaW5wdXRNYW5hZ2VyIiwidXNlVHJhY2tVc2VySW5wdXQiLCJhbmltYXRpb25GcmFtZUlkUmVmIiwib25Vc2VySW5wdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9leGNsdWRlZCQxIiwiX2V4Y2x1ZGVkMiIsIm93bktleXMkMSIsIl9vYmplY3RTcHJlYWQkMSIsIkNoaWxkcmVuIiwiRWRpdGFibGUiLCJfRURJVE9SX1RPX1BMQUNFSE9MREUiLCJfRURJVE9SX1RPX1BMQUNFSE9MREUyIiwiZGVmYXVsdFJlbmRlclBsYWNlaG9sZGVyIiwiRGVmYXVsdFBsYWNlaG9sZGVyIiwiYXV0b0ZvY3VzIiwiZGVmYXVsdERlY29yYXRlIiwib25ET01CZWZvcmVJbnB1dCIsInByb3BzT25ET01CZWZvcmVJbnB1dCIsInNjcm9sbFNlbGVjdGlvbkludG9WaWV3IiwiZGVmYXVsdFNjcm9sbFNlbGVjdGlvbkludG9WaWV3IiwidXNlclN0eWxlIiwiYXMiLCJkaXNhYmxlRGVmYXVsdFN0eWxlcyIsInNldElzQ29tcG9zaW5nIiwiZGVmZXJyZWRPcGVyYXRpb25zIiwicyIsInN0YXRlIiwiaXNEcmFnZ2luZ0ludGVybmFsbHkiLCJpc1VwZGF0aW5nU2VsZWN0aW9uIiwibGF0ZXN0RWxlbWVudCIsImhhc01hcmtQbGFjZWhvbGRlciIsImFuZHJvaWRJbnB1dE1hbmFnZXIiLCJhbmNob3JOb2RlU2VsZWN0YWJsZSIsImZvY3VzTm9kZVNlbGVjdGFibGUiLCJzZXREb21TZWxlY3Rpb24iLCJmb3JjZUNoYW5nZSIsImhhc0RvbVNlbGVjdGlvbiIsImVkaXRvckVsZW1lbnQiLCJoYXNEb21TZWxlY3Rpb25JbkVkaXRvciIsInNsYXRlUmFuZ2UiLCJfYW5jaG9yTm9kZSRwYXJlbnRFbGUiLCJuZXdEb21SYW5nZSIsInNldEJhc2VBbmRFeHRlbnQiLCJlbnN1cmVTZWxlY3Rpb24iLCJ0aW1lb3V0SWQiLCJhbmltYXRpb25GcmFtZUlkIiwiZW5zdXJlRG9tU2VsZWN0aW9uIiwiZSIsImlzRE9NRXZlbnRIYW5kbGVkIiwiX0VESVRPUl9UT19VU0VSX1NFTEVDIiwiaXNDb21wb3NpdGlvbkNoYW5nZSIsIm5hdGl2ZSIsIl9ub2RlJHBhcmVudEVsZW1lbnQiLCJfd2luZG93JGdldENvbXB1dGVkU3QiLCJfbGFzdFRleHQkdGV4dENvbnRlbnQiLCJsYXN0VGV4dCIsImNyZWF0ZVRyZWVXYWxrZXIiLCJOb2RlRmlsdGVyIiwiU0hPV19URVhUIiwibGFzdENoaWxkIiwid2hpdGVTcGFjZSIsImJsb2NrIiwicHJldmVudERlZmF1bHQiLCJ0b1Jlc3RvcmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlc3QiLCJsb29zZSIsInVuc2V0IiwiZnJvbUVudHJpZXMiLCJtYXAiLCJtYXJrIiwicGxhY2Vob2xkZXJIZWlnaHQiLCJyb2xlIiwic3BlbGxDaGVjayIsImF1dG9Db3JyZWN0IiwiYXV0b0NhcGl0YWxpemUiLCJ6aW5kZXgiLCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciLCJ3b3JkV3JhcCIsIm1pbkhlaWdodCIsIm9uQmVmb3JlSW5wdXQiLCJpc0V2ZW50SGFuZGxlZCIsIl90ZXh0MiIsIm9uSW5wdXQiLCJvbkJsdXIiLCJyZWxhdGVkVGFyZ2V0Iiwib25DbGljayIsImRldGFpbCIsImJsb2NrUGF0aCIsIl9ibG9jayQiLCJzdGFydFZvaWQiLCJlbmRWb2lkIiwib25Db21wb3NpdGlvbkVuZCIsInBsYWNlaG9sZGVyTWFya3MiLCJvbkNvbXBvc2l0aW9uVXBkYXRlIiwib25Db21wb3NpdGlvblN0YXJ0IiwiaW5saW5lIiwiaW5saW5lUGF0aCIsInNldFNlbGVjdGlvbiIsIm9uQ29weSIsIm9uQ3V0Iiwib25EcmFnT3ZlciIsIm9uRHJhZ1N0YXJ0Iiwidm9pZE1hdGNoIiwib25Ecm9wIiwiZHJhZ2dlZFJhbmdlIiwib25EcmFnRW5kIiwib25Gb2N1cyIsIm9uS2V5RG93biIsImlzUlRMIiwibWF5YmVIaXN0b3J5RWRpdG9yIiwiX21heWJlSGlzdG9yeUVkaXRvciIsIm1vdmUiLCJjb2xsYXBzZSIsImN1cnJlbnROb2RlIiwib25QYXN0ZSIsImxlYWZFbCIsImJpbmQiLCJzY3JvbGxNb2RlIiwiaGFuZGxlciIsInNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJGb2N1c2VkQ29udGV4dCIsInVzZUZvY3VzZWQiLCJpc0Vycm9yIiwiZXJyb3IiLCJTbGF0ZVNlbGVjdG9yQ29udGV4dCIsInJlZkVxdWFsaXR5IiwidXNlU2xhdGVTZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJnZXRTbGF0ZSIsImxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IiLCJsYXRlc3RTZWxlY3RvciIsImxhdGVzdFNlbGVjdGVkU3RhdGUiLCJzZWxlY3RlZFN0YXRlIiwic3RhY2siLCJjaGVja0ZvclVwZGF0ZXMiLCJuZXdTZWxlY3RlZFN0YXRlIiwidW5zdWJzY3JpYmUiLCJnZXRTZWxlY3RvckNvbnRleHQiLCJldmVudExpc3RlbmVycyIsInNsYXRlUmVmIiwibGlzdGVuZXIiLCJzZWxlY3RvckNvbnRleHQiLCJfZXhjbHVkZWQiLCJTbGF0ZSIsInVubW91bnRSZWYiLCJzZXRDb250ZXh0IiwiaXNOb2RlTGlzdCIsInYiLCJoYW5kbGVTZWxlY3RvckNoYW5nZSIsIm9uQ29udGV4dENoYW5nZSIsInByZXZDb250ZXh0Iiwic2V0SXNGb2N1c2VkIiwiZm4iLCJ1c2VFZGl0b3IiLCJ1c2VTbGF0ZVNlbGVjdGlvbiIsImlzU2VsZWN0aW9uRXF1YWwiLCJkb1JlY3RzSW50ZXJzZWN0IiwiY29tcGFyZVJlY3QiLCJtaWRkbGUiLCJib3R0b20iLCJhcmVSYW5nZXNTYW1lTGluZSIsInJhbmdlMSIsInJhbmdlMiIsInJlY3QxIiwicmVjdDIiLCJmaW5kQ3VycmVudExpbmVSYW5nZSIsInBhcmVudFJhbmdlIiwicGFyZW50UmFuZ2VCb3VuZGFyeSIsInBvc2l0aW9ucyIsInJpZ2h0IiwiZmxvb3IiLCJvd25LZXlzIiwiX29iamVjdFNwcmVhZCIsIndpdGhSZWFjdCIsImNsaXBib2FyZEZvcm1hdEtleSIsImFkZE1hcmsiLCJyZW1vdmVNYXJrIiwicGFyZW50QmxvY2tFbnRyeSIsInBhcmVudEJsb2NrUGF0aCIsInBhcmVudEVsZW1lbnRSYW5nZSIsImN1cnJlbnRMaW5lUmFuZ2UiLCJCb29sZWFuIiwicGVuZGluZ0FjdGlvbiIsImdldE1hdGNoZXMiLCJwcmV2UGF0aCIsInByZXZpb3VzIiwiY29tbW9uUGF0aCIsImNvbW1vbiIsImF0dGFjaCIsInRyaW0iLCJyIiwiY2xvbmVSYW5nZSIsInNldEVuZEFmdGVyIiwienciLCJpc05ld2xpbmUiLCJhcHBlbmRDaGlsZCIsImdldEZyYWdtZW50IiwiSlNPTiIsImVuY29kZWQiLCJidG9hIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2V0QXR0cmlidXRlIiwic2V0RGF0YSIsImRpdiIsImJvZHkiLCJpbm5lckhUTUwiLCJkZWNvZGVkIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiYXRvYiIsInBhcnNlZCIsInBhcnNlIiwiaW5zZXJ0RnJhZ21lbnQiLCJsaW5lcyIsInNwbGl0Tm9kZXMiLCJhbHdheXMiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsImxldmVscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-react/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/slate-react/node_modules/is-hotkey/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/slate-react/node_modules/is-hotkey/lib/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * Constants.\n */ var IS_MAC =  false && 0;\nvar MODIFIERS = {\n    alt: \"altKey\",\n    control: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n};\nvar ALIASES = {\n    add: \"+\",\n    break: \"pause\",\n    cmd: \"meta\",\n    command: \"meta\",\n    ctl: \"control\",\n    ctrl: \"control\",\n    del: \"delete\",\n    down: \"arrowdown\",\n    esc: \"escape\",\n    ins: \"insert\",\n    left: \"arrowleft\",\n    mod: IS_MAC ? \"meta\" : \"control\",\n    opt: \"alt\",\n    option: \"alt\",\n    return: \"enter\",\n    right: \"arrowright\",\n    space: \" \",\n    spacebar: \" \",\n    up: \"arrowup\",\n    win: \"meta\",\n    windows: \"meta\"\n};\nvar CODES = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    shift: 16,\n    control: 17,\n    alt: 18,\n    pause: 19,\n    capslock: 20,\n    escape: 27,\n    \" \": 32,\n    pageup: 33,\n    pagedown: 34,\n    end: 35,\n    home: 36,\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    insert: 45,\n    delete: 46,\n    meta: 91,\n    numlock: 144,\n    scrolllock: 145,\n    \";\": 186,\n    \"=\": 187,\n    \",\": 188,\n    \"-\": 189,\n    \".\": 190,\n    \"/\": 191,\n    \"`\": 192,\n    \"[\": 219,\n    \"\\\\\": 220,\n    \"]\": 221,\n    \"'\": 222\n};\nfor(var f = 1; f < 20; f++){\n    CODES[\"f\" + f] = 111 + f;\n}\n/**\n * Is hotkey?\n */ function isHotkey(hotkey, options, event) {\n    if (options && !(\"byKey\" in options)) {\n        event = options;\n        options = null;\n    }\n    if (!Array.isArray(hotkey)) {\n        hotkey = [\n            hotkey\n        ];\n    }\n    var array = hotkey.map(function(string) {\n        return parseHotkey(string, options);\n    });\n    var check = function check(e) {\n        return array.some(function(object) {\n            return compareHotkey(object, e);\n        });\n    };\n    var ret = event == null ? check : check(event);\n    return ret;\n}\nfunction isCodeHotkey(hotkey, event) {\n    return isHotkey(hotkey, event);\n}\nfunction isKeyHotkey(hotkey, event) {\n    return isHotkey(hotkey, {\n        byKey: true\n    }, event);\n}\n/**\n * Parse.\n */ function parseHotkey(hotkey, options) {\n    var byKey = options && options.byKey;\n    var ret = {};\n    // Special case to handle the `+` key since we use it as a separator.\n    hotkey = hotkey.replace(\"++\", \"+add\");\n    var values = hotkey.split(\"+\");\n    var length = values.length;\n    // Ensure that all the modifiers are set to false unless the hotkey has them.\n    for(var k in MODIFIERS){\n        ret[MODIFIERS[k]] = false;\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n        for(var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var value = _step.value;\n            var optional = value.endsWith(\"?\") && value.length > 1;\n            if (optional) {\n                value = value.slice(0, -1);\n            }\n            var name = toKeyName(value);\n            var modifier = MODIFIERS[name];\n            if (length === 1 || !modifier) {\n                if (byKey) {\n                    ret.key = name;\n                } else {\n                    ret.which = toKeyCode(value);\n                }\n            }\n            if (modifier) {\n                ret[modifier] = optional ? null : true;\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return ret;\n}\n/**\n * Compare.\n */ function compareHotkey(object, event) {\n    for(var key in object){\n        var expected = object[key];\n        var actual = void 0;\n        if (expected == null) {\n            continue;\n        }\n        if (key === \"key\" && event.key != null) {\n            actual = event.key.toLowerCase();\n        } else if (key === \"which\") {\n            actual = expected === 91 && event.which === 93 ? 91 : event.which;\n        } else {\n            actual = event[key];\n        }\n        if (actual == null && expected === false) {\n            continue;\n        }\n        if (actual !== expected) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Utils.\n */ function toKeyCode(name) {\n    name = toKeyName(name);\n    var code = CODES[name] || name.toUpperCase().charCodeAt(0);\n    return code;\n}\nfunction toKeyName(name) {\n    name = name.toLowerCase();\n    name = ALIASES[name] || name;\n    return name;\n}\n/**\n * Export.\n */ exports[\"default\"] = isHotkey;\nexports.isHotkey = isHotkey;\nexports.isCodeHotkey = isCodeHotkey;\nexports.isKeyHotkey = isKeyHotkey;\nexports.parseHotkey = parseHotkey;\nexports.compareHotkey = compareHotkey;\nexports.toKeyCode = toKeyCode;\nexports.toKeyName = toKeyName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3Qvbm9kZV9tb2R1bGVzL2lzLWhvdGtleS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBRUY7O0NBRUMsR0FFRCxJQUFJQyxTQUFTLE1BQWlCLElBQWUsQ0FBc0Q7QUFFbkcsSUFBSUssWUFBWTtJQUNkQyxLQUFLO0lBQ0xDLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxPQUFPO0FBQ1Q7QUFFQSxJQUFJQyxVQUFVO0lBQ1pDLEtBQUs7SUFDTEMsT0FBTztJQUNQQyxLQUFLO0lBQ0xDLFNBQVM7SUFDVEMsS0FBSztJQUNMQyxNQUFNO0lBQ05DLEtBQUs7SUFDTEMsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLEtBQUs7SUFDTEMsTUFBTTtJQUNOQyxLQUFLdEIsU0FBUyxTQUFTO0lBQ3ZCdUIsS0FBSztJQUNMQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkMsSUFBSTtJQUNKQyxLQUFLO0lBQ0xDLFNBQVM7QUFDWDtBQUVBLElBQUlDLFFBQVE7SUFDVkMsV0FBVztJQUNYQyxLQUFLO0lBQ0xDLE9BQU87SUFDUDFCLE9BQU87SUFDUEYsU0FBUztJQUNURCxLQUFLO0lBQ0w4QixPQUFPO0lBQ1BDLFVBQVU7SUFDVkMsUUFBUTtJQUNSLEtBQUs7SUFDTEMsUUFBUTtJQUNSQyxVQUFVO0lBQ1ZDLEtBQUs7SUFDTEMsTUFBTTtJQUNOQyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsWUFBWTtJQUNaQyxXQUFXO0lBQ1hDLFFBQVE7SUFDUkMsUUFBUTtJQUNSeEMsTUFBTTtJQUNOeUMsU0FBUztJQUNUQyxZQUFZO0lBQ1osS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxNQUFNO0lBQ04sS0FBSztJQUNM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cEUsaUJBQWlCLEdBQUdnRztBQUNwQmhHLGlCQUFpQixHQUFHNEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3Qvbm9kZV9tb2R1bGVzL2lzLWhvdGtleS9saWIvaW5kZXguanM/MWNmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogQ29uc3RhbnRzLlxuICovXG5cbnZhciBJU19NQUMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKTtcblxudmFyIE1PRElGSUVSUyA9IHtcbiAgYWx0OiAnYWx0S2V5JyxcbiAgY29udHJvbDogJ2N0cmxLZXknLFxuICBtZXRhOiAnbWV0YUtleScsXG4gIHNoaWZ0OiAnc2hpZnRLZXknXG59O1xuXG52YXIgQUxJQVNFUyA9IHtcbiAgYWRkOiAnKycsXG4gIGJyZWFrOiAncGF1c2UnLFxuICBjbWQ6ICdtZXRhJyxcbiAgY29tbWFuZDogJ21ldGEnLFxuICBjdGw6ICdjb250cm9sJyxcbiAgY3RybDogJ2NvbnRyb2wnLFxuICBkZWw6ICdkZWxldGUnLFxuICBkb3duOiAnYXJyb3dkb3duJyxcbiAgZXNjOiAnZXNjYXBlJyxcbiAgaW5zOiAnaW5zZXJ0JyxcbiAgbGVmdDogJ2Fycm93bGVmdCcsXG4gIG1vZDogSVNfTUFDID8gJ21ldGEnIDogJ2NvbnRyb2wnLFxuICBvcHQ6ICdhbHQnLFxuICBvcHRpb246ICdhbHQnLFxuICByZXR1cm46ICdlbnRlcicsXG4gIHJpZ2h0OiAnYXJyb3dyaWdodCcsXG4gIHNwYWNlOiAnICcsXG4gIHNwYWNlYmFyOiAnICcsXG4gIHVwOiAnYXJyb3d1cCcsXG4gIHdpbjogJ21ldGEnLFxuICB3aW5kb3dzOiAnbWV0YSdcbn07XG5cbnZhciBDT0RFUyA9IHtcbiAgYmFja3NwYWNlOiA4LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc2hpZnQ6IDE2LFxuICBjb250cm9sOiAxNyxcbiAgYWx0OiAxOCxcbiAgcGF1c2U6IDE5LFxuICBjYXBzbG9jazogMjAsXG4gIGVzY2FwZTogMjcsXG4gICcgJzogMzIsXG4gIHBhZ2V1cDogMzMsXG4gIHBhZ2Vkb3duOiAzNCxcbiAgZW5kOiAzNSxcbiAgaG9tZTogMzYsXG4gIGFycm93bGVmdDogMzcsXG4gIGFycm93dXA6IDM4LFxuICBhcnJvd3JpZ2h0OiAzOSxcbiAgYXJyb3dkb3duOiA0MCxcbiAgaW5zZXJ0OiA0NSxcbiAgZGVsZXRlOiA0NixcbiAgbWV0YTogOTEsXG4gIG51bWxvY2s6IDE0NCxcbiAgc2Nyb2xsbG9jazogMTQ1LFxuICAnOyc6IDE4NixcbiAgJz0nOiAxODcsXG4gICcsJzogMTg4LFxuICAnLSc6IDE4OSxcbiAgJy4nOiAxOTAsXG4gICcvJzogMTkxLFxuICAnYCc6IDE5MixcbiAgJ1snOiAyMTksXG4gICdcXFxcJzogMjIwLFxuICAnXSc6IDIyMSxcbiAgJ1xcJyc6IDIyMlxufTtcblxuZm9yICh2YXIgZiA9IDE7IGYgPCAyMDsgZisrKSB7XG4gIENPREVTWydmJyArIGZdID0gMTExICsgZjtcbn1cblxuLyoqXG4gKiBJcyBob3RrZXk/XG4gKi9cblxuZnVuY3Rpb24gaXNIb3RrZXkoaG90a2V5LCBvcHRpb25zLCBldmVudCkge1xuICBpZiAob3B0aW9ucyAmJiAhKCdieUtleScgaW4gb3B0aW9ucykpIHtcbiAgICBldmVudCA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoaG90a2V5KSkge1xuICAgIGhvdGtleSA9IFtob3RrZXldO1xuICB9XG5cbiAgdmFyIGFycmF5ID0gaG90a2V5Lm1hcChmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhcnNlSG90a2V5KHN0cmluZywgb3B0aW9ucyk7XG4gIH0pO1xuICB2YXIgY2hlY2sgPSBmdW5jdGlvbiBjaGVjayhlKSB7XG4gICAgcmV0dXJuIGFycmF5LnNvbWUoZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVIb3RrZXkob2JqZWN0LCBlKTtcbiAgICB9KTtcbiAgfTtcbiAgdmFyIHJldCA9IGV2ZW50ID09IG51bGwgPyBjaGVjayA6IGNoZWNrKGV2ZW50KTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaXNDb2RlSG90a2V5KGhvdGtleSwgZXZlbnQpIHtcbiAgcmV0dXJuIGlzSG90a2V5KGhvdGtleSwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBpc0tleUhvdGtleShob3RrZXksIGV2ZW50KSB7XG4gIHJldHVybiBpc0hvdGtleShob3RrZXksIHsgYnlLZXk6IHRydWUgfSwgZXZlbnQpO1xufVxuXG4vKipcbiAqIFBhcnNlLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSG90a2V5KGhvdGtleSwgb3B0aW9ucykge1xuICB2YXIgYnlLZXkgPSBvcHRpb25zICYmIG9wdGlvbnMuYnlLZXk7XG4gIHZhciByZXQgPSB7fTtcblxuICAvLyBTcGVjaWFsIGNhc2UgdG8gaGFuZGxlIHRoZSBgK2Aga2V5IHNpbmNlIHdlIHVzZSBpdCBhcyBhIHNlcGFyYXRvci5cbiAgaG90a2V5ID0gaG90a2V5LnJlcGxhY2UoJysrJywgJythZGQnKTtcbiAgdmFyIHZhbHVlcyA9IGhvdGtleS5zcGxpdCgnKycpO1xuICB2YXIgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAvLyBFbnN1cmUgdGhhdCBhbGwgdGhlIG1vZGlmaWVycyBhcmUgc2V0IHRvIGZhbHNlIHVubGVzcyB0aGUgaG90a2V5IGhhcyB0aGVtLlxuXG4gIGZvciAodmFyIGsgaW4gTU9ESUZJRVJTKSB7XG4gICAgcmV0W01PRElGSUVSU1trXV0gPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHZhbHVlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICB2YXIgb3B0aW9uYWwgPSB2YWx1ZS5lbmRzV2l0aCgnPycpICYmIHZhbHVlLmxlbmd0aCA+IDE7XG5cbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSB0b0tleU5hbWUodmFsdWUpO1xuICAgICAgdmFyIG1vZGlmaWVyID0gTU9ESUZJRVJTW25hbWVdO1xuXG4gICAgICBpZiAobGVuZ3RoID09PSAxIHx8ICFtb2RpZmllcikge1xuICAgICAgICBpZiAoYnlLZXkpIHtcbiAgICAgICAgICByZXQua2V5ID0gbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQud2hpY2ggPSB0b0tleUNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RpZmllcikge1xuICAgICAgICByZXRbbW9kaWZpZXJdID0gb3B0aW9uYWwgPyBudWxsIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb21wYXJlLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBhcmVIb3RrZXkob2JqZWN0LCBldmVudCkge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgdmFyIGV4cGVjdGVkID0gb2JqZWN0W2tleV07XG4gICAgdmFyIGFjdHVhbCA9IHZvaWQgMDtcblxuICAgIGlmIChleHBlY3RlZCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAna2V5JyAmJiBldmVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgYWN0dWFsID0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICd3aGljaCcpIHtcbiAgICAgIGFjdHVhbCA9IGV4cGVjdGVkID09PSA5MSAmJiBldmVudC53aGljaCA9PT0gOTMgPyA5MSA6IGV2ZW50LndoaWNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3R1YWwgPSBldmVudFtrZXldO1xuICAgIH1cblxuICAgIGlmIChhY3R1YWwgPT0gbnVsbCAmJiBleHBlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVXRpbHMuXG4gKi9cblxuZnVuY3Rpb24gdG9LZXlDb2RlKG5hbWUpIHtcbiAgbmFtZSA9IHRvS2V5TmFtZShuYW1lKTtcbiAgdmFyIGNvZGUgPSBDT0RFU1tuYW1lXSB8fCBuYW1lLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGNvZGU7XG59XG5cbmZ1bmN0aW9uIHRvS2V5TmFtZShuYW1lKSB7XG4gIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIG5hbWUgPSBBTElBU0VTW25hbWVdIHx8IG5hbWU7XG4gIHJldHVybiBuYW1lO1xufVxuXG4vKipcbiAqIEV4cG9ydC5cbiAqL1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc0hvdGtleTtcbmV4cG9ydHMuaXNIb3RrZXkgPSBpc0hvdGtleTtcbmV4cG9ydHMuaXNDb2RlSG90a2V5ID0gaXNDb2RlSG90a2V5O1xuZXhwb3J0cy5pc0tleUhvdGtleSA9IGlzS2V5SG90a2V5O1xuZXhwb3J0cy5wYXJzZUhvdGtleSA9IHBhcnNlSG90a2V5O1xuZXhwb3J0cy5jb21wYXJlSG90a2V5ID0gY29tcGFyZUhvdGtleTtcbmV4cG9ydHMudG9LZXlDb2RlID0gdG9LZXlDb2RlO1xuZXhwb3J0cy50b0tleU5hbWUgPSB0b0tleU5hbWU7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSVNfTUFDIiwidGVzdCIsIndpbmRvdyIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwiTU9ESUZJRVJTIiwiYWx0IiwiY29udHJvbCIsIm1ldGEiLCJzaGlmdCIsIkFMSUFTRVMiLCJhZGQiLCJicmVhayIsImNtZCIsImNvbW1hbmQiLCJjdGwiLCJjdHJsIiwiZGVsIiwiZG93biIsImVzYyIsImlucyIsImxlZnQiLCJtb2QiLCJvcHQiLCJvcHRpb24iLCJyZXR1cm4iLCJyaWdodCIsInNwYWNlIiwic3BhY2ViYXIiLCJ1cCIsIndpbiIsIndpbmRvd3MiLCJDT0RFUyIsImJhY2tzcGFjZSIsInRhYiIsImVudGVyIiwicGF1c2UiLCJjYXBzbG9jayIsImVzY2FwZSIsInBhZ2V1cCIsInBhZ2Vkb3duIiwiZW5kIiwiaG9tZSIsImFycm93bGVmdCIsImFycm93dXAiLCJhcnJvd3JpZ2h0IiwiYXJyb3dkb3duIiwiaW5zZXJ0IiwiZGVsZXRlIiwibnVtbG9jayIsInNjcm9sbGxvY2siLCJmIiwiaXNIb3RrZXkiLCJob3RrZXkiLCJvcHRpb25zIiwiZXZlbnQiLCJBcnJheSIsImlzQXJyYXkiLCJhcnJheSIsIm1hcCIsInN0cmluZyIsInBhcnNlSG90a2V5IiwiY2hlY2siLCJlIiwic29tZSIsIm9iamVjdCIsImNvbXBhcmVIb3RrZXkiLCJyZXQiLCJpc0NvZGVIb3RrZXkiLCJpc0tleUhvdGtleSIsImJ5S2V5IiwicmVwbGFjZSIsInZhbHVlcyIsInNwbGl0IiwibGVuZ3RoIiwiayIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24iLCJfZGlkSXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvckVycm9yIiwidW5kZWZpbmVkIiwiX2l0ZXJhdG9yIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfc3RlcCIsIm5leHQiLCJkb25lIiwib3B0aW9uYWwiLCJlbmRzV2l0aCIsInNsaWNlIiwibmFtZSIsInRvS2V5TmFtZSIsIm1vZGlmaWVyIiwia2V5Iiwid2hpY2giLCJ0b0tleUNvZGUiLCJlcnIiLCJleHBlY3RlZCIsImFjdHVhbCIsInRvTG93ZXJDYXNlIiwiY29kZSIsInRvVXBwZXJDYXNlIiwiY2hhckNvZGVBdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-react/node_modules/is-hotkey/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/slate-react/node_modules/scroll-into-view-if-needed/es/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/slate-react/node_modules/scroll-into-view-if-needed/es/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! compute-scroll-into-view */ \"(ssr)/./node_modules/slate-react/node_modules/compute-scroll-into-view/dist/index.mjs\");\n\nfunction isOptionsObject(options) {\n    return options === Object(options) && Object.keys(options).length !== 0;\n}\nfunction defaultBehavior(actions, behavior) {\n    if (behavior === void 0) {\n        behavior = \"auto\";\n    }\n    var canSmoothScroll = \"scrollBehavior\" in document.body.style;\n    actions.forEach(function(_ref) {\n        var el = _ref.el, top = _ref.top, left = _ref.left;\n        if (el.scroll && canSmoothScroll) {\n            el.scroll({\n                top: top,\n                left: left,\n                behavior: behavior\n            });\n        } else {\n            el.scrollTop = top;\n            el.scrollLeft = left;\n        }\n    });\n}\nfunction getOptions(options) {\n    if (options === false) {\n        return {\n            block: \"end\",\n            inline: \"nearest\"\n        };\n    }\n    if (isOptionsObject(options)) {\n        return options;\n    }\n    return {\n        block: \"start\",\n        inline: \"nearest\"\n    };\n}\nfunction scrollIntoView(target, options) {\n    var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);\n    if (isOptionsObject(options) && typeof options.behavior === \"function\") {\n        return options.behavior(isTargetAttached ? (0,compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, options) : []);\n    }\n    if (!isTargetAttached) {\n        return;\n    }\n    var computeOptions = getOptions(options);\n    return defaultBehavior((0,compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, computeOptions), computeOptions.behavior);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (scrollIntoView);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3Qvbm9kZV9tb2R1bGVzL3Njcm9sbC1pbnRvLXZpZXctaWYtbmVlZGVkL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStDO0FBQy9DLFNBQVNDLGdCQUFnQkMsT0FBTztJQUM5QixPQUFPQSxZQUFZQyxPQUFPRCxZQUFZQyxPQUFPQyxJQUFJLENBQUNGLFNBQVNHLE1BQU0sS0FBSztBQUN4RTtBQUNBLFNBQVNDLGdCQUFnQkMsT0FBTyxFQUFFQyxRQUFRO0lBQ3hDLElBQUlBLGFBQWEsS0FBSyxHQUFHO1FBQ3ZCQSxXQUFXO0lBQ2I7SUFDQSxJQUFJQyxrQkFBbUIsb0JBQW9CQyxTQUFTQyxJQUFJLENBQUNDLEtBQUs7SUFDOURMLFFBQVFNLE9BQU8sQ0FBQyxTQUFVQyxJQUFJO1FBQzVCLElBQUlDLEtBQUtELEtBQUtDLEVBQUUsRUFDZEMsTUFBTUYsS0FBS0UsR0FBRyxFQUNkQyxPQUFPSCxLQUFLRyxJQUFJO1FBQ2xCLElBQUlGLEdBQUdHLE1BQU0sSUFBSVQsaUJBQWlCO1lBQ2hDTSxHQUFHRyxNQUFNLENBQUM7Z0JBQ1JGLEtBQUtBO2dCQUNMQyxNQUFNQTtnQkFDTlQsVUFBVUE7WUFDWjtRQUNGLE9BQU87WUFDTE8sR0FBR0ksU0FBUyxHQUFHSDtZQUNmRCxHQUFHSyxVQUFVLEdBQUdIO1FBQ2xCO0lBQ0Y7QUFDRjtBQUNBLFNBQVNJLFdBQVduQixPQUFPO0lBQ3pCLElBQUlBLFlBQVksT0FBTztRQUNyQixPQUFPO1lBQ0xvQixPQUFPO1lBQ1BDLFFBQVE7UUFDVjtJQUNGO0lBQ0EsSUFBSXRCLGdCQUFnQkMsVUFBVTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsT0FBTztRQUNMb0IsT0FBTztRQUNQQyxRQUFRO0lBQ1Y7QUFDRjtBQUNBLFNBQVNDLGVBQWVDLE1BQU0sRUFBRXZCLE9BQU87SUFDckMsSUFBSXdCLG1CQUFtQkQsT0FBT0UsV0FBVyxJQUFJRixPQUFPRyxhQUFhLENBQUNDLGVBQWUsQ0FBQ0MsUUFBUSxDQUFDTDtJQUMzRixJQUFJeEIsZ0JBQWdCQyxZQUFZLE9BQU9BLFFBQVFNLFFBQVEsS0FBSyxZQUFZO1FBQ3RFLE9BQU9OLFFBQVFNLFFBQVEsQ0FBQ2tCLG1CQUFtQjFCLG9FQUFPQSxDQUFDeUIsUUFBUXZCLFdBQVcsRUFBRTtJQUMxRTtJQUNBLElBQUksQ0FBQ3dCLGtCQUFrQjtRQUNyQjtJQUNGO0lBQ0EsSUFBSUssaUJBQWlCVixXQUFXbkI7SUFDaEMsT0FBT0ksZ0JBQWdCTixvRUFBT0EsQ0FBQ3lCLFFBQVFNLGlCQUFpQkEsZUFBZXZCLFFBQVE7QUFDakY7QUFDQSxpRUFBZWdCLGNBQWNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3Qvbm9kZV9tb2R1bGVzL3Njcm9sbC1pbnRvLXZpZXctaWYtbmVlZGVkL2VzL2luZGV4LmpzPzFkMzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNvbXB1dGUgZnJvbSAnY29tcHV0ZS1zY3JvbGwtaW50by12aWV3JztcbmZ1bmN0aW9uIGlzT3B0aW9uc09iamVjdChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID09PSBPYmplY3Qob3B0aW9ucykgJiYgT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoICE9PSAwO1xufVxuZnVuY3Rpb24gZGVmYXVsdEJlaGF2aW9yKGFjdGlvbnMsIGJlaGF2aW9yKSB7XG4gIGlmIChiZWhhdmlvciA9PT0gdm9pZCAwKSB7XG4gICAgYmVoYXZpb3IgPSAnYXV0byc7XG4gIH1cbiAgdmFyIGNhblNtb290aFNjcm9sbCA9ICgnc2Nyb2xsQmVoYXZpb3InIGluIGRvY3VtZW50LmJvZHkuc3R5bGUpO1xuICBhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZWwgPSBfcmVmLmVsLFxuICAgICAgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0O1xuICAgIGlmIChlbC5zY3JvbGwgJiYgY2FuU21vb3RoU2Nyb2xsKSB7XG4gICAgICBlbC5zY3JvbGwoe1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2s6ICdlbmQnLFxuICAgICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgICB9O1xuICB9XG4gIGlmIChpc09wdGlvbnNPYmplY3Qob3B0aW9ucykpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICByZXR1cm4ge1xuICAgIGJsb2NrOiAnc3RhcnQnLFxuICAgIGlubGluZTogJ25lYXJlc3QnXG4gIH07XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIGlzVGFyZ2V0QXR0YWNoZWQgPSB0YXJnZXQuaXNDb25uZWN0ZWQgfHwgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRhcmdldCk7XG4gIGlmIChpc09wdGlvbnNPYmplY3Qob3B0aW9ucykgJiYgdHlwZW9mIG9wdGlvbnMuYmVoYXZpb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5iZWhhdmlvcihpc1RhcmdldEF0dGFjaGVkID8gY29tcHV0ZSh0YXJnZXQsIG9wdGlvbnMpIDogW10pO1xuICB9XG4gIGlmICghaXNUYXJnZXRBdHRhY2hlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY29tcHV0ZU9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICByZXR1cm4gZGVmYXVsdEJlaGF2aW9yKGNvbXB1dGUodGFyZ2V0LCBjb21wdXRlT3B0aW9ucyksIGNvbXB1dGVPcHRpb25zLmJlaGF2aW9yKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHNjcm9sbEludG9WaWV3OyJdLCJuYW1lcyI6WyJjb21wdXRlIiwiaXNPcHRpb25zT2JqZWN0Iiwib3B0aW9ucyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJkZWZhdWx0QmVoYXZpb3IiLCJhY3Rpb25zIiwiYmVoYXZpb3IiLCJjYW5TbW9vdGhTY3JvbGwiLCJkb2N1bWVudCIsImJvZHkiLCJzdHlsZSIsImZvckVhY2giLCJfcmVmIiwiZWwiLCJ0b3AiLCJsZWZ0Iiwic2Nyb2xsIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImdldE9wdGlvbnMiLCJibG9jayIsImlubGluZSIsInNjcm9sbEludG9WaWV3IiwidGFyZ2V0IiwiaXNUYXJnZXRBdHRhY2hlZCIsImlzQ29ubmVjdGVkIiwib3duZXJEb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNvbnRhaW5zIiwiY29tcHV0ZU9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-react/node_modules/scroll-into-view-if-needed/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/slate-react/node_modules/compute-scroll-into-view/dist/index.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/slate-react/node_modules/compute-scroll-into-view/dist/index.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ i)\n/* harmony export */ });\nfunction t(t) {\n    return \"object\" == typeof t && null != t && 1 === t.nodeType;\n}\nfunction e(t, e) {\n    return (!e || \"hidden\" !== t) && \"visible\" !== t && \"clip\" !== t;\n}\nfunction n(t, n) {\n    if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {\n        var r = getComputedStyle(t, null);\n        return e(r.overflowY, n) || e(r.overflowX, n) || function(t) {\n            var e = function(t) {\n                if (!t.ownerDocument || !t.ownerDocument.defaultView) return null;\n                try {\n                    return t.ownerDocument.defaultView.frameElement;\n                } catch (t) {\n                    return null;\n                }\n            }(t);\n            return !!e && (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth);\n        }(t);\n    }\n    return !1;\n}\nfunction r(t, e, n, r, i, o, l, d) {\n    return o < t && l > e || o > t && l < e ? 0 : o <= t && d <= n || l >= e && d >= n ? o - t - r : l > e && d < n || o < t && d > n ? l - e + i : 0;\n}\nvar i = function(e, i) {\n    var o = window, l = i.scrollMode, d = i.block, f = i.inline, h = i.boundary, u = i.skipOverflowHiddenElements, s = \"function\" == typeof h ? h : function(t) {\n        return t !== h;\n    };\n    if (!t(e)) throw new TypeError(\"Invalid target\");\n    for(var a, c, g = document.scrollingElement || document.documentElement, p = [], m = e; t(m) && s(m);){\n        if ((m = null == (c = (a = m).parentElement) ? a.getRootNode().host || null : c) === g) {\n            p.push(m);\n            break;\n        }\n        null != m && m === document.body && n(m) && !n(document.documentElement) || null != m && n(m, u) && p.push(m);\n    }\n    for(var w = o.visualViewport ? o.visualViewport.width : innerWidth, v = o.visualViewport ? o.visualViewport.height : innerHeight, W = window.scrollX || pageXOffset, H = window.scrollY || pageYOffset, b = e.getBoundingClientRect(), y = b.height, E = b.width, M = b.top, V = b.right, x = b.bottom, I = b.left, C = \"start\" === d || \"nearest\" === d ? M : \"end\" === d ? x : M + y / 2, R = \"center\" === f ? I + E / 2 : \"end\" === f ? V : I, T = [], k = 0; k < p.length; k++){\n        var B = p[k], D = B.getBoundingClientRect(), O = D.height, X = D.width, Y = D.top, L = D.right, S = D.bottom, j = D.left;\n        if (\"if-needed\" === l && M >= 0 && I >= 0 && x <= v && V <= w && M >= Y && x <= S && I >= j && V <= L) return T;\n        var N = getComputedStyle(B), q = parseInt(N.borderLeftWidth, 10), z = parseInt(N.borderTopWidth, 10), A = parseInt(N.borderRightWidth, 10), F = parseInt(N.borderBottomWidth, 10), G = 0, J = 0, K = \"offsetWidth\" in B ? B.offsetWidth - B.clientWidth - q - A : 0, P = \"offsetHeight\" in B ? B.offsetHeight - B.clientHeight - z - F : 0, Q = \"offsetWidth\" in B ? 0 === B.offsetWidth ? 0 : X / B.offsetWidth : 0, U = \"offsetHeight\" in B ? 0 === B.offsetHeight ? 0 : O / B.offsetHeight : 0;\n        if (g === B) G = \"start\" === d ? C : \"end\" === d ? C - v : \"nearest\" === d ? r(H, H + v, v, z, F, H + C, H + C + y, y) : C - v / 2, J = \"start\" === f ? R : \"center\" === f ? R - w / 2 : \"end\" === f ? R - w : r(W, W + w, w, q, A, W + R, W + R + E, E), G = Math.max(0, G + H), J = Math.max(0, J + W);\n        else {\n            G = \"start\" === d ? C - Y - z : \"end\" === d ? C - S + F + P : \"nearest\" === d ? r(Y, S, O, z, F + P, C, C + y, y) : C - (Y + O / 2) + P / 2, J = \"start\" === f ? R - j - q : \"center\" === f ? R - (j + X / 2) + K / 2 : \"end\" === f ? R - L + A + K : r(j, L, X, q, A + K, R, R + E, E);\n            var Z = B.scrollLeft, $ = B.scrollTop;\n            C += $ - (G = Math.max(0, Math.min($ + G / U, B.scrollHeight - O / U + P))), R += Z - (J = Math.max(0, Math.min(Z + J / Q, B.scrollWidth - X / Q + K)));\n        }\n        T.push({\n            el: B,\n            top: G,\n            left: J\n        });\n    }\n    return T;\n};\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3Qvbm9kZV9tb2R1bGVzL2NvbXB1dGUtc2Nyb2xsLWludG8tdmlldy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsRUFBRUEsQ0FBQztJQUFFLE9BQU0sWUFBVSxPQUFPQSxLQUFHLFFBQU1BLEtBQUcsTUFBSUEsRUFBRUMsUUFBUTtBQUFBO0FBQUMsU0FBU0MsRUFBRUYsQ0FBQyxFQUFDRSxDQUFDO0lBQUUsT0FBTSxDQUFDLENBQUNBLEtBQUcsYUFBV0YsQ0FBQUEsS0FBSSxjQUFZQSxLQUFHLFdBQVNBO0FBQUM7QUFBQyxTQUFTRyxFQUFFSCxDQUFDLEVBQUNHLENBQUM7SUFBRSxJQUFHSCxFQUFFSSxZQUFZLEdBQUNKLEVBQUVLLFlBQVksSUFBRUwsRUFBRU0sV0FBVyxHQUFDTixFQUFFTyxXQUFXLEVBQUM7UUFBQyxJQUFJQyxJQUFFQyxpQkFBaUJULEdBQUU7UUFBTSxPQUFPRSxFQUFFTSxFQUFFRSxTQUFTLEVBQUNQLE1BQUlELEVBQUVNLEVBQUVHLFNBQVMsRUFBQ1IsTUFBSSxTQUFTSCxDQUFDO1lBQUUsSUFBSUUsSUFBRSxTQUFTRixDQUFDO2dCQUFFLElBQUcsQ0FBQ0EsRUFBRVksYUFBYSxJQUFFLENBQUNaLEVBQUVZLGFBQWEsQ0FBQ0MsV0FBVyxFQUFDLE9BQU87Z0JBQUssSUFBRztvQkFBQyxPQUFPYixFQUFFWSxhQUFhLENBQUNDLFdBQVcsQ0FBQ0MsWUFBWTtnQkFBQSxFQUFDLE9BQU1kLEdBQUU7b0JBQUMsT0FBTztnQkFBSTtZQUFDLEVBQUVBO1lBQUcsT0FBTSxDQUFDLENBQUNFLEtBQUlBLENBQUFBLEVBQUVFLFlBQVksR0FBQ0osRUFBRUssWUFBWSxJQUFFSCxFQUFFSSxXQUFXLEdBQUNOLEVBQUVPLFdBQVc7UUFBQyxFQUFFUDtJQUFFO0lBQUMsT0FBTSxDQUFDO0FBQUM7QUFBQyxTQUFTUSxFQUFFUixDQUFDLEVBQUNFLENBQUMsRUFBQ0MsQ0FB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LENBQ3BtRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3Qvbm9kZV9tb2R1bGVzL2NvbXB1dGUtc2Nyb2xsLWludG8tdmlldy9kaXN0L2luZGV4Lm1qcz9jMjRmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHQodCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQmJm51bGwhPXQmJjE9PT10Lm5vZGVUeXBlfWZ1bmN0aW9uIGUodCxlKXtyZXR1cm4oIWV8fFwiaGlkZGVuXCIhPT10KSYmXCJ2aXNpYmxlXCIhPT10JiZcImNsaXBcIiE9PXR9ZnVuY3Rpb24gbih0LG4pe2lmKHQuY2xpZW50SGVpZ2h0PHQuc2Nyb2xsSGVpZ2h0fHx0LmNsaWVudFdpZHRoPHQuc2Nyb2xsV2lkdGgpe3ZhciByPWdldENvbXB1dGVkU3R5bGUodCxudWxsKTtyZXR1cm4gZShyLm92ZXJmbG93WSxuKXx8ZShyLm92ZXJmbG93WCxuKXx8ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24odCl7aWYoIXQub3duZXJEb2N1bWVudHx8IXQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldylyZXR1cm4gbnVsbDt0cnl7cmV0dXJuIHQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5mcmFtZUVsZW1lbnR9Y2F0Y2godCl7cmV0dXJuIG51bGx9fSh0KTtyZXR1cm4hIWUmJihlLmNsaWVudEhlaWdodDx0LnNjcm9sbEhlaWdodHx8ZS5jbGllbnRXaWR0aDx0LnNjcm9sbFdpZHRoKX0odCl9cmV0dXJuITF9ZnVuY3Rpb24gcih0LGUsbixyLGksbyxsLGQpe3JldHVybiBvPHQmJmw+ZXx8bz50JiZsPGU/MDpvPD10JiZkPD1ufHxsPj1lJiZkPj1uP28tdC1yOmw+ZSYmZDxufHxvPHQmJmQ+bj9sLWUraTowfXZhciBpPWZ1bmN0aW9uKGUsaSl7dmFyIG89d2luZG93LGw9aS5zY3JvbGxNb2RlLGQ9aS5ibG9jayxmPWkuaW5saW5lLGg9aS5ib3VuZGFyeSx1PWkuc2tpcE92ZXJmbG93SGlkZGVuRWxlbWVudHMscz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBoP2g6ZnVuY3Rpb24odCl7cmV0dXJuIHQhPT1ofTtpZighdChlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0YXJnZXRcIik7Zm9yKHZhciBhLGMsZz1kb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQscD1bXSxtPWU7dChtKSYmcyhtKTspe2lmKChtPW51bGw9PShjPShhPW0pLnBhcmVudEVsZW1lbnQpP2EuZ2V0Um9vdE5vZGUoKS5ob3N0fHxudWxsOmMpPT09Zyl7cC5wdXNoKG0pO2JyZWFrfW51bGwhPW0mJm09PT1kb2N1bWVudC5ib2R5JiZuKG0pJiYhbihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpfHxudWxsIT1tJiZuKG0sdSkmJnAucHVzaChtKX1mb3IodmFyIHc9by52aXN1YWxWaWV3cG9ydD9vLnZpc3VhbFZpZXdwb3J0LndpZHRoOmlubmVyV2lkdGgsdj1vLnZpc3VhbFZpZXdwb3J0P28udmlzdWFsVmlld3BvcnQuaGVpZ2h0OmlubmVySGVpZ2h0LFc9d2luZG93LnNjcm9sbFh8fHBhZ2VYT2Zmc2V0LEg9d2luZG93LnNjcm9sbFl8fHBhZ2VZT2Zmc2V0LGI9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx5PWIuaGVpZ2h0LEU9Yi53aWR0aCxNPWIudG9wLFY9Yi5yaWdodCx4PWIuYm90dG9tLEk9Yi5sZWZ0LEM9XCJzdGFydFwiPT09ZHx8XCJuZWFyZXN0XCI9PT1kP006XCJlbmRcIj09PWQ/eDpNK3kvMixSPVwiY2VudGVyXCI9PT1mP0krRS8yOlwiZW5kXCI9PT1mP1Y6SSxUPVtdLGs9MDtrPHAubGVuZ3RoO2srKyl7dmFyIEI9cFtrXSxEPUIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksTz1ELmhlaWdodCxYPUQud2lkdGgsWT1ELnRvcCxMPUQucmlnaHQsUz1ELmJvdHRvbSxqPUQubGVmdDtpZihcImlmLW5lZWRlZFwiPT09bCYmTT49MCYmST49MCYmeDw9diYmVjw9dyYmTT49WSYmeDw9UyYmST49aiYmVjw9TClyZXR1cm4gVDt2YXIgTj1nZXRDb21wdXRlZFN0eWxlKEIpLHE9cGFyc2VJbnQoTi5ib3JkZXJMZWZ0V2lkdGgsMTApLHo9cGFyc2VJbnQoTi5ib3JkZXJUb3BXaWR0aCwxMCksQT1wYXJzZUludChOLmJvcmRlclJpZ2h0V2lkdGgsMTApLEY9cGFyc2VJbnQoTi5ib3JkZXJCb3R0b21XaWR0aCwxMCksRz0wLEo9MCxLPVwib2Zmc2V0V2lkdGhcImluIEI/Qi5vZmZzZXRXaWR0aC1CLmNsaWVudFdpZHRoLXEtQTowLFA9XCJvZmZzZXRIZWlnaHRcImluIEI/Qi5vZmZzZXRIZWlnaHQtQi5jbGllbnRIZWlnaHQtei1GOjAsUT1cIm9mZnNldFdpZHRoXCJpbiBCPzA9PT1CLm9mZnNldFdpZHRoPzA6WC9CLm9mZnNldFdpZHRoOjAsVT1cIm9mZnNldEhlaWdodFwiaW4gQj8wPT09Qi5vZmZzZXRIZWlnaHQ/MDpPL0Iub2Zmc2V0SGVpZ2h0OjA7aWYoZz09PUIpRz1cInN0YXJ0XCI9PT1kP0M6XCJlbmRcIj09PWQ/Qy12OlwibmVhcmVzdFwiPT09ZD9yKEgsSCt2LHYseixGLEgrQyxIK0MreSx5KTpDLXYvMixKPVwic3RhcnRcIj09PWY/UjpcImNlbnRlclwiPT09Zj9SLXcvMjpcImVuZFwiPT09Zj9SLXc6cihXLFcrdyx3LHEsQSxXK1IsVytSK0UsRSksRz1NYXRoLm1heCgwLEcrSCksSj1NYXRoLm1heCgwLEorVyk7ZWxzZXtHPVwic3RhcnRcIj09PWQ/Qy1ZLXo6XCJlbmRcIj09PWQ/Qy1TK0YrUDpcIm5lYXJlc3RcIj09PWQ/cihZLFMsTyx6LEYrUCxDLEMreSx5KTpDLShZK08vMikrUC8yLEo9XCJzdGFydFwiPT09Zj9SLWotcTpcImNlbnRlclwiPT09Zj9SLShqK1gvMikrSy8yOlwiZW5kXCI9PT1mP1ItTCtBK0s6cihqLEwsWCxxLEErSyxSLFIrRSxFKTt2YXIgWj1CLnNjcm9sbExlZnQsJD1CLnNjcm9sbFRvcDtDKz0kLShHPU1hdGgubWF4KDAsTWF0aC5taW4oJCtHL1UsQi5zY3JvbGxIZWlnaHQtTy9VK1ApKSksUis9Wi0oSj1NYXRoLm1heCgwLE1hdGgubWluKForSi9RLEIuc2Nyb2xsV2lkdGgtWC9RK0spKSl9VC5wdXNoKHtlbDpCLHRvcDpHLGxlZnQ6Sn0pfXJldHVybiBUfTtleHBvcnR7aSBhcyBkZWZhdWx0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJ0Iiwibm9kZVR5cGUiLCJlIiwibiIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsImNsaWVudFdpZHRoIiwic2Nyb2xsV2lkdGgiLCJyIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImZyYW1lRWxlbWVudCIsImkiLCJvIiwibCIsImQiLCJ3aW5kb3ciLCJzY3JvbGxNb2RlIiwiYmxvY2siLCJmIiwiaW5saW5lIiwiaCIsImJvdW5kYXJ5IiwidSIsInNraXBPdmVyZmxvd0hpZGRlbkVsZW1lbnRzIiwicyIsIlR5cGVFcnJvciIsImEiLCJjIiwiZyIsImRvY3VtZW50Iiwic2Nyb2xsaW5nRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsInAiLCJtIiwicGFyZW50RWxlbWVudCIsImdldFJvb3ROb2RlIiwiaG9zdCIsInB1c2giLCJib2R5IiwidyIsInZpc3VhbFZpZXdwb3J0Iiwid2lkdGgiLCJpbm5lcldpZHRoIiwidiIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiVyIsInNjcm9sbFgiLCJwYWdlWE9mZnNldCIsIkgiLCJzY3JvbGxZIiwicGFnZVlPZmZzZXQiLCJiIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieSIsIkUiLCJNIiwidG9wIiwiViIsInJpZ2h0IiwieCIsImJvdHRvbSIsIkkiLCJsZWZ0IiwiQyIsIlIiLCJUIiwiayIsImxlbmd0aCIsIkIiLCJEIiwiTyIsIlgiLCJZIiwiTCIsIlMiLCJqIiwiTiIsInEiLCJwYXJzZUludCIsImJvcmRlckxlZnRXaWR0aCIsInoiLCJib3JkZXJUb3BXaWR0aCIsIkEiLCJib3JkZXJSaWdodFdpZHRoIiwiRiIsImJvcmRlckJvdHRvbVdpZHRoIiwiRyIsIkoiLCJLIiwib2Zmc2V0V2lkdGgiLCJQIiwib2Zmc2V0SGVpZ2h0IiwiUSIsIlUiLCJNYXRoIiwibWF4IiwiWiIsInNjcm9sbExlZnQiLCIkIiwic2Nyb2xsVG9wIiwibWluIiwiZWwiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-react/node_modules/compute-scroll-into-view/dist/index.mjs\n");

/***/ })

};
;