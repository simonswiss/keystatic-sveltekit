"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minimatch";
exports.ids = ["vendor-chunks/minimatch"];
exports.modules = {

/***/ "(ssr)/./node_modules/minimatch/dist/mjs/brace-expressions.js":
/*!**************************************************************!*\
  !*** ./node_modules/minimatch/dist/mjs/brace-expressions.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseClass: () => (/* binding */ parseClass)\n/* harmony export */ });\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    \"[:alnum:]\": [\n        \"\\\\p{L}\\\\p{Nl}\\\\p{Nd}\",\n        true\n    ],\n    \"[:alpha:]\": [\n        \"\\\\p{L}\\\\p{Nl}\",\n        true\n    ],\n    \"[:ascii:]\": [\n        \"\\\\x\" + \"00-\\\\x\" + \"7f\",\n        false\n    ],\n    \"[:blank:]\": [\n        \"\\\\p{Zs}\\\\t\",\n        true\n    ],\n    \"[:cntrl:]\": [\n        \"\\\\p{Cc}\",\n        true\n    ],\n    \"[:digit:]\": [\n        \"\\\\p{Nd}\",\n        true\n    ],\n    \"[:graph:]\": [\n        \"\\\\p{Z}\\\\p{C}\",\n        true,\n        true\n    ],\n    \"[:lower:]\": [\n        \"\\\\p{Ll}\",\n        true\n    ],\n    \"[:print:]\": [\n        \"\\\\p{C}\",\n        true\n    ],\n    \"[:punct:]\": [\n        \"\\\\p{P}\",\n        true\n    ],\n    \"[:space:]\": [\n        \"\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f\",\n        true\n    ],\n    \"[:upper:]\": [\n        \"\\\\p{Lu}\",\n        true\n    ],\n    \"[:word:]\": [\n        \"\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}\",\n        true\n    ],\n    \"[:xdigit:]\": [\n        \"A-Fa-f0-9\",\n        false\n    ]\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s)=>s.replace(/[[\\]\\\\-]/g, \"\\\\$&\");\n// escape all regexp magic characters\nconst regexpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges)=>ranges.join(\"\");\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position)=>{\n    const pos = position;\n    /* c8 ignore start */ if (glob.charAt(pos) !== \"[\") {\n        throw new Error(\"not in a brace expression\");\n    }\n    /* c8 ignore stop */ const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = \"\";\n    WHILE: while(i < glob.length){\n        const c = glob.charAt(i);\n        if ((c === \"!\" || c === \"^\") && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === \"]\" && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === \"\\\\\") {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n        // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === \"[\" && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)){\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return [\n                            \"$.\",\n                            false,\n                            glob.length - pos,\n                            true\n                        ];\n                    }\n                    i += cls.length;\n                    if (neg) negs.push(unip);\n                    else ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + \"-\" + braceEscape(c));\n            } else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = \"\";\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith(\"-]\", i + 1)) {\n            ranges.push(braceEscape(c + \"-\"));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith(\"-\", i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return [\n            \"\",\n            false,\n            0,\n            false\n        ];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return [\n            \"$.\",\n            false,\n            glob.length - pos,\n            true\n        ];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 && ranges.length === 1 && /^\\\\?.$/.test(ranges[0]) && !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [\n            regexpEscape(r),\n            false,\n            endPos - pos,\n            false\n        ];\n    }\n    const sranges = \"[\" + (negate ? \"^\" : \"\") + rangesToString(ranges) + \"]\";\n    const snegs = \"[\" + (negate ? \"\" : \"^\") + rangesToString(negs) + \"]\";\n    const comb = ranges.length && negs.length ? \"(\" + sranges + \"|\" + snegs + \")\" : ranges.length ? sranges : snegs;\n    return [\n        comb,\n        uflag,\n        endPos - pos,\n        true\n    ];\n}; //# sourceMappingURL=brace-expressions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2JyYWNlLWV4cHJlc3Npb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx3RUFBd0U7QUFDeEUsd0NBQXdDO0FBQ3hDLDhEQUE4RDtBQUM5RCxNQUFNQSxlQUFlO0lBQ2pCLGFBQWE7UUFBQztRQUF3QjtLQUFLO0lBQzNDLGFBQWE7UUFBQztRQUFpQjtLQUFLO0lBQ3BDLGFBQWE7UUFBQyxRQUFRLFdBQVc7UUFBTTtLQUFNO0lBQzdDLGFBQWE7UUFBQztRQUFjO0tBQUs7SUFDakMsYUFBYTtRQUFDO1FBQVc7S0FBSztJQUM5QixhQUFhO1FBQUM7UUFBVztLQUFLO0lBQzlCLGFBQWE7UUFBQztRQUFnQjtRQUFNO0tBQUs7SUFDekMsYUFBYTtRQUFDO1FBQVc7S0FBSztJQUM5QixhQUFhO1FBQUM7UUFBVTtLQUFLO0lBQzdCLGFBQWE7UUFBQztRQUFVO0tBQUs7SUFDN0IsYUFBYTtRQUFDO1FBQXlCO0tBQUs7SUFDNUMsYUFBYTtRQUFDO1FBQVc7S0FBSztJQUM5QixZQUFZO1FBQUM7UUFBK0I7S0FBSztJQUNqRCxjQUFjO1FBQUM7UUFBYTtLQUFNO0FBQ3RDO0FBQ0EsK0RBQStEO0FBQy9ELG1CQUFtQjtBQUNuQixNQUFNQyxjQUFjLENBQUNDLElBQU1BLEVBQUVDLE9BQU8sQ0FBQyxhQUFhO0FBQ2xELHFDQUFxQztBQUNyQyxNQUFNQyxlQUFlLENBQUNGLElBQU1BLEVBQUVDLE9BQU8sQ0FBQyw0QkFBNEI7QUFDbEUsNERBQTREO0FBQzVELE1BQU1FLGlCQUFpQixDQUFDQyxTQUFXQSxPQUFPQyxJQUFJLENBQUM7QUFDL0MsK0RBQStEO0FBQy9ELGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUseUNBQXlDO0FBQ3pDLGlFQUFpRTtBQUNqRSw2QkFBNkI7QUFDdEIsTUFBTUMsYUFBYSxDQUFDQyxNQUFNQztJQUM3QixNQUFNQyxNQUFNRDtJQUNaLG1CQUFtQixHQUNuQixJQUFJRCxLQUFLRyxN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U0FBU1UsSUFBSSxDQUFDM0IsTUFBTSxDQUFDLEVBQUUsS0FDdkIsQ0FBQ2EsUUFBUTtRQUNULE1BQU1lLElBQUk1QixNQUFNLENBQUMsRUFBRSxDQUFDaUIsTUFBTSxLQUFLLElBQUlqQixNQUFNLENBQUMsRUFBRSxDQUFDNkIsS0FBSyxDQUFDLENBQUMsS0FBSzdCLE1BQU0sQ0FBQyxFQUFFO1FBQ2xFLE9BQU87WUFBQ0YsYUFBYThCO1lBQUk7WUFBT2QsU0FBU1Q7WUFBSztTQUFNO0lBQ3hEO0lBQ0EsTUFBTXlCLFVBQVUsTUFBT2pCLENBQUFBLFNBQVMsTUFBTSxFQUFDLElBQUtkLGVBQWVDLFVBQVU7SUFDckUsTUFBTStCLFFBQVEsTUFBT2xCLENBQUFBLFNBQVMsS0FBSyxHQUFFLElBQUtkLGVBQWVTLFFBQVE7SUFDakUsTUFBTXdCLE9BQU9oQyxPQUFPaUIsTUFBTSxJQUFJVCxLQUFLUyxNQUFNLEdBQ25DLE1BQU1hLFVBQVUsTUFBTUMsUUFBUSxNQUM5Qi9CLE9BQU9pQixNQUFNLEdBQ1RhLFVBQ0FDO0lBQ1YsT0FBTztRQUFDQztRQUFNckI7UUFBT0csU0FBU1Q7UUFBSztLQUFLO0FBQzVDLEVBQUUsQ0FDRiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2JyYWNlLWV4cHJlc3Npb25zLmpzPzU5ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHJhbnNsYXRlIHRoZSB2YXJpb3VzIHBvc2l4IGNoYXJhY3RlciBjbGFzc2VzIGludG8gdW5pY29kZSBwcm9wZXJ0aWVzXG4vLyB0aGlzIHdvcmtzIGFjcm9zcyBhbGwgdW5pY29kZSBsb2NhbGVzXG4vLyB7IDxwb3NpeCBjbGFzcz46IFs8dHJhbnNsYXRpb24+LCAvdSBmbGFnIHJlcXVpcmVkLCBuZWdhdGVkXVxuY29uc3QgcG9zaXhDbGFzc2VzID0ge1xuICAgICdbOmFsbnVtOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9XFxcXHB7TmR9JywgdHJ1ZV0sXG4gICAgJ1s6YWxwaGE6XSc6IFsnXFxcXHB7TH1cXFxccHtObH0nLCB0cnVlXSxcbiAgICAnWzphc2NpaTpdJzogWydcXFxceCcgKyAnMDAtXFxcXHgnICsgJzdmJywgZmFsc2VdLFxuICAgICdbOmJsYW5rOl0nOiBbJ1xcXFxwe1pzfVxcXFx0JywgdHJ1ZV0sXG4gICAgJ1s6Y250cmw6XSc6IFsnXFxcXHB7Q2N9JywgdHJ1ZV0sXG4gICAgJ1s6ZGlnaXQ6XSc6IFsnXFxcXHB7TmR9JywgdHJ1ZV0sXG4gICAgJ1s6Z3JhcGg6XSc6IFsnXFxcXHB7Wn1cXFxccHtDfScsIHRydWUsIHRydWVdLFxuICAgICdbOmxvd2VyOl0nOiBbJ1xcXFxwe0xsfScsIHRydWVdLFxuICAgICdbOnByaW50Ol0nOiBbJ1xcXFxwe0N9JywgdHJ1ZV0sXG4gICAgJ1s6cHVuY3Q6XSc6IFsnXFxcXHB7UH0nLCB0cnVlXSxcbiAgICAnWzpzcGFjZTpdJzogWydcXFxccHtafVxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGYnLCB0cnVlXSxcbiAgICAnWzp1cHBlcjpdJzogWydcXFxccHtMdX0nLCB0cnVlXSxcbiAgICAnWzp3b3JkOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9XFxcXHB7TmR9XFxcXHB7UGN9JywgdHJ1ZV0sXG4gICAgJ1s6eGRpZ2l0Ol0nOiBbJ0EtRmEtZjAtOScsIGZhbHNlXSxcbn07XG4vLyBvbmx5IG5lZWQgdG8gZXNjYXBlIGEgZmV3IHRoaW5ncyBpbnNpZGUgb2YgYnJhY2UgZXhwcmVzc2lvbnNcbi8vIGVzY2FwZXM6IFsgXFwgXSAtXG5jb25zdCBicmFjZUVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1tbXFxdXFxcXC1dL2csICdcXFxcJCYnKTtcbi8vIGVzY2FwZSBhbGwgcmVnZXhwIG1hZ2ljIGNoYXJhY3RlcnNcbmNvbnN0IHJlZ2V4cEVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4vLyBldmVyeXRoaW5nIGhhcyBhbHJlYWR5IGJlZW4gZXNjYXBlZCwgd2UganVzdCBoYXZlIHRvIGpvaW5cbmNvbnN0IHJhbmdlc1RvU3RyaW5nID0gKHJhbmdlcykgPT4gcmFuZ2VzLmpvaW4oJycpO1xuLy8gdGFrZXMgYSBnbG9iIHN0cmluZyBhdCBhIHBvc2l4IGJyYWNlIGV4cHJlc3Npb24sIGFuZCByZXR1cm5zXG4vLyBhbiBlcXVpdmFsZW50IHJlZ3VsYXIgZXhwcmVzc2lvbiBzb3VyY2UsIGFuZCBib29sZWFuIGluZGljYXRpbmdcbi8vIHdoZXRoZXIgdGhlIC91IGZsYWcgbmVlZHMgdG8gYmUgYXBwbGllZCwgYW5kIHRoZSBudW1iZXIgb2YgY2hhcnNcbi8vIGNvbnN1bWVkIHRvIHBhcnNlIHRoZSBjaGFyYWN0ZXIgY2xhc3MuXG4vLyBUaGlzIGFsc28gcmVtb3ZlcyBvdXQgb2Ygb3JkZXIgcmFuZ2VzLCBhbmQgcmV0dXJucyAoJC4pIGlmIHRoZVxuLy8gZW50aXJlIGNsYXNzIGp1c3Qgbm8gZ29vZC5cbmV4cG9ydCBjb25zdCBwYXJzZUNsYXNzID0gKGdsb2IsIHBvc2l0aW9uKSA9PiB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb247XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGdsb2IuY2hhckF0KHBvcykgIT09ICdbJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbiBhIGJyYWNlIGV4cHJlc3Npb24nKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICBjb25zdCBuZWdzID0gW107XG4gICAgbGV0IGkgPSBwb3MgKyAxO1xuICAgIGxldCBzYXdTdGFydCA9IGZhbHNlO1xuICAgIGxldCB1ZmxhZyA9IGZhbHNlO1xuICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgIGxldCBuZWdhdGUgPSBmYWxzZTtcbiAgICBsZXQgZW5kUG9zID0gcG9zO1xuICAgIGxldCByYW5nZVN0YXJ0ID0gJyc7XG4gICAgV0hJTEU6IHdoaWxlIChpIDwgZ2xvYi5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYyA9IGdsb2IuY2hhckF0KGkpO1xuICAgICAgICBpZiAoKGMgPT09ICchJyB8fCBjID09PSAnXicpICYmIGkgPT09IHBvcyArIDEpIHtcbiAgICAgICAgICAgIG5lZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ10nICYmIHNhd1N0YXJ0ICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgZW5kUG9zID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzYXdTdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGlmICghZXNjYXBpbmcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNjYXBlZCBcXCBjaGFyLCBmYWxsIHRocm91Z2ggYW5kIHRyZWF0IGxpa2Ugbm9ybWFsIGNoYXJcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ1snICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgLy8gZWl0aGVyIGEgcG9zaXggY2xhc3MsIGEgY29sbGF0aW9uIGVxdWl2YWxlbnQsIG9yIGp1c3QgYSBbXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjbHMsIFt1bmlwLCB1LCBuZWddXSBvZiBPYmplY3QuZW50cmllcyhwb3NpeENsYXNzZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aChjbHMsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludmFsaWQsIFthLVtdIGlzIGZpbmUsIGJ1dCBub3QgW2EtWzphbHBoYV1dXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyckLicsIGZhbHNlLCBnbG9iLmxlbmd0aCAtIHBvcywgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSArPSBjbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmVncy5wdXNoKHVuaXApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh1bmlwKTtcbiAgICAgICAgICAgICAgICAgICAgdWZsYWcgPSB1ZmxhZyB8fCB1O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBXSElMRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGl0J3MganVzdCBhIG5vcm1hbCBjaGFyYWN0ZXIsIGVmZmVjdGl2ZWx5XG4gICAgICAgIGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChyYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAvLyB0aHJvdyB0aGlzIHJhbmdlIGF3YXkgaWYgaXQncyBub3QgdmFsaWQsIGJ1dCBvdGhlcnNcbiAgICAgICAgICAgIC8vIGNhbiBzdGlsbCBtYXRjaC5cbiAgICAgICAgICAgIGlmIChjID4gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKHJhbmdlU3RhcnQpICsgJy0nICsgYnJhY2VFc2NhcGUoYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSAnJztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBtaWdodCBiZSB0aGUgc3RhcnQgb2YgYSByYW5nZS5cbiAgICAgICAgLy8gY2FuIGJlIGVpdGhlciBjLWQgb3IgYy1dIG9yIGM8bW9yZS4uLj5dIG9yIGNdIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aCgnLV0nLCBpICsgMSkpIHtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMgKyAnLScpKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbG9iLnN0YXJ0c1dpdGgoJy0nLCBpICsgMSkpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBjO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IHRoZSBzdGFydCBvZiBhIHJhbmdlLCBqdXN0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICByYW5nZXMucHVzaChicmFjZUVzY2FwZShjKSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKGVuZFBvcyA8IGkpIHtcbiAgICAgICAgLy8gZGlkbid0IHNlZSB0aGUgZW5kIG9mIHRoZSBjbGFzcywgbm90IGEgdmFsaWQgY2xhc3MsXG4gICAgICAgIC8vIGJ1dCBtaWdodCBzdGlsbCBiZSB2YWxpZCBhcyBhIGxpdGVyYWwgbWF0Y2guXG4gICAgICAgIHJldHVybiBbJycsIGZhbHNlLCAwLCBmYWxzZV07XG4gICAgfVxuICAgIC8vIGlmIHdlIGdvdCBubyByYW5nZXMgYW5kIG5vIG5lZ2F0ZXMsIHRoZW4gd2UgaGF2ZSBhIHJhbmdlIHRoYXRcbiAgICAvLyBjYW5ub3QgcG9zc2libHkgbWF0Y2ggYW55dGhpbmcsIGFuZCB0aGF0IHBvaXNvbnMgdGhlIHdob2xlIGdsb2JcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgIW5lZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbJyQuJywgZmFsc2UsIGdsb2IubGVuZ3RoIC0gcG9zLCB0cnVlXTtcbiAgICB9XG4gICAgLy8gaWYgd2UgZ290IG9uZSBwb3NpdGl2ZSByYW5nZSwgYW5kIGl0J3MgYSBzaW5nbGUgY2hhcmFjdGVyLCB0aGVuIHRoYXQnc1xuICAgIC8vIG5vdCBhY3R1YWxseSBhIG1hZ2ljIHBhdHRlcm4sIGl0J3MganVzdCB0aGF0IG9uZSBsaXRlcmFsIGNoYXJhY3Rlci5cbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyZWF0IHRoYXQgYXMgXCJtYWdpY1wiLCB3ZSBzaG91bGQganVzdCByZXR1cm4gdGhlIGxpdGVyYWxcbiAgICAvLyBjaGFyYWN0ZXIuIFtfXSBpcyBhIHBlcmZlY3RseSB2YWxpZCB3YXkgdG8gZXNjYXBlIGdsb2IgbWFnaWMgY2hhcnMuXG4gICAgaWYgKG5lZ3MubGVuZ3RoID09PSAwICYmXG4gICAgICAgIHJhbmdlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgL15cXFxcPy4kLy50ZXN0KHJhbmdlc1swXSkgJiZcbiAgICAgICAgIW5lZ2F0ZSkge1xuICAgICAgICBjb25zdCByID0gcmFuZ2VzWzBdLmxlbmd0aCA9PT0gMiA/IHJhbmdlc1swXS5zbGljZSgtMSkgOiByYW5nZXNbMF07XG4gICAgICAgIHJldHVybiBbcmVnZXhwRXNjYXBlKHIpLCBmYWxzZSwgZW5kUG9zIC0gcG9zLCBmYWxzZV07XG4gICAgfVxuICAgIGNvbnN0IHNyYW5nZXMgPSAnWycgKyAobmVnYXRlID8gJ14nIDogJycpICsgcmFuZ2VzVG9TdHJpbmcocmFuZ2VzKSArICddJztcbiAgICBjb25zdCBzbmVncyA9ICdbJyArIChuZWdhdGUgPyAnJyA6ICdeJykgKyByYW5nZXNUb1N0cmluZyhuZWdzKSArICddJztcbiAgICBjb25zdCBjb21iID0gcmFuZ2VzLmxlbmd0aCAmJiBuZWdzLmxlbmd0aFxuICAgICAgICA/ICcoJyArIHNyYW5nZXMgKyAnfCcgKyBzbmVncyArICcpJ1xuICAgICAgICA6IHJhbmdlcy5sZW5ndGhcbiAgICAgICAgICAgID8gc3Jhbmdlc1xuICAgICAgICAgICAgOiBzbmVncztcbiAgICByZXR1cm4gW2NvbWIsIHVmbGFnLCBlbmRQb3MgLSBwb3MsIHRydWVdO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyYWNlLWV4cHJlc3Npb25zLmpzLm1hcCJdLCJuYW1lcyI6WyJwb3NpeENsYXNzZXMiLCJicmFjZUVzY2FwZSIsInMiLCJyZXBsYWNlIiwicmVnZXhwRXNjYXBlIiwicmFuZ2VzVG9TdHJpbmciLCJyYW5nZXMiLCJqb2luIiwicGFyc2VDbGFzcyIsImdsb2IiLCJwb3NpdGlvbiIsInBvcyIsImNoYXJBdCIsIkVycm9yIiwibmVncyIsImkiLCJzYXdTdGFydCIsInVmbGFnIiwiZXNjYXBpbmciLCJuZWdhdGUiLCJlbmRQb3MiLCJyYW5nZVN0YXJ0IiwiV0hJTEUiLCJsZW5ndGgiLCJjIiwiY2xzIiwidW5pcCIsInUiLCJuZWciLCJPYmplY3QiLCJlbnRyaWVzIiwic3RhcnRzV2l0aCIsInB1c2giLCJ0ZXN0IiwiciIsInNsaWNlIiwic3JhbmdlcyIsInNuZWdzIiwiY29tYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/mjs/brace-expressions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/mjs/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/minimatch/dist/mjs/escape.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   escape: () => (/* binding */ escape)\n/* harmony export */ });\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */ const escape = (s, { windowsPathsNoEscape = false } = {})=>{\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape ? s.replace(/[?*()[\\]]/g, \"[$&]\") : s.replace(/[?*()[\\]\\\\]/g, \"\\\\$&\");\n}; //# sourceMappingURL=escape.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2VzY2FwZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7O0NBUUMsR0FDTSxNQUFNQSxTQUFTLENBQUNDLEdBQUcsRUFBRUMsdUJBQXVCLEtBQUssRUFBRyxHQUFHLENBQUMsQ0FBQztJQUM1RCx3REFBd0Q7SUFDeEQsNERBQTREO0lBQzVELHNEQUFzRDtJQUN0RCxPQUFPQSx1QkFDREQsRUFBRUUsT0FBTyxDQUFDLGNBQWMsVUFDeEJGLEVBQUVFLE9BQU8sQ0FBQyxnQkFBZ0I7QUFDcEMsRUFBRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvZXNjYXBlLmpzPzU2NGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFc2NhcGUgYWxsIG1hZ2ljIGNoYXJhY3RlcnMgaW4gYSBnbG9iIHBhdHRlcm4uXG4gKlxuICogSWYgdGhlIHtAbGluayB3aW5kb3dzUGF0aHNOb0VzY2FwZSB8IEdsb2JPcHRpb25zLndpbmRvd3NQYXRoc05vRXNjYXBlfVxuICogb3B0aW9uIGlzIHVzZWQsIHRoZW4gY2hhcmFjdGVycyBhcmUgZXNjYXBlZCBieSB3cmFwcGluZyBpbiBgW11gLCBiZWNhdXNlXG4gKiBhIG1hZ2ljIGNoYXJhY3RlciB3cmFwcGVkIGluIGEgY2hhcmFjdGVyIGNsYXNzIGNhbiBvbmx5IGJlIHNhdGlzZmllZCBieVxuICogdGhhdCBleGFjdCBjaGFyYWN0ZXIuICBJbiB0aGlzIG1vZGUsIGBcXGAgaXMgX25vdF8gZXNjYXBlZCwgYmVjYXVzZSBpdCBpc1xuICogbm90IGludGVycHJldGVkIGFzIGEgbWFnaWMgY2hhcmFjdGVyLCBidXQgaW5zdGVhZCBhcyBhIHBhdGggc2VwYXJhdG9yLlxuICovXG5leHBvcnQgY29uc3QgZXNjYXBlID0gKHMsIHsgd2luZG93c1BhdGhzTm9Fc2NhcGUgPSBmYWxzZSwgfSA9IHt9KSA9PiB7XG4gICAgLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgK0AhIGJlY2F1c2Ugd2UgZXNjYXBlIHRoZSBwYXJlbnNcbiAgICAvLyB0aGF0IG1ha2UgdGhvc2UgbWFnaWMsIGFuZCBlc2NhcGluZyAhIGFzIFshXSBpc24ndCB2YWxpZCxcbiAgICAvLyBiZWNhdXNlIFshXV0gaXMgYSB2YWxpZCBnbG9iIGNsYXNzIG1lYW5pbmcgbm90ICddJy5cbiAgICByZXR1cm4gd2luZG93c1BhdGhzTm9Fc2NhcGVcbiAgICAgICAgPyBzLnJlcGxhY2UoL1s/KigpW1xcXV0vZywgJ1skJl0nKVxuICAgICAgICA6IHMucmVwbGFjZSgvWz8qKClbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzY2FwZS5qcy5tYXAiXSwibmFtZXMiOlsiZXNjYXBlIiwicyIsIndpbmRvd3NQYXRoc05vRXNjYXBlIiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/mjs/escape.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/mjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/minimatch/dist/mjs/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLOBSTAR: () => (/* binding */ GLOBSTAR),\n/* harmony export */   Minimatch: () => (/* binding */ Minimatch),\n/* harmony export */   braceExpand: () => (/* binding */ braceExpand),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   escape: () => (/* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_2__.escape),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   makeRe: () => (/* binding */ makeRe),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   minimatch: () => (/* binding */ minimatch),\n/* harmony export */   sep: () => (/* binding */ sep),\n/* harmony export */   unescape: () => (/* reexport safe */ _unescape_js__WEBPACK_IMPORTED_MODULE_3__.unescape)\n/* harmony export */ });\n/* harmony import */ var brace_expansion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! brace-expansion */ \"(ssr)/./node_modules/brace-expansion/index.js\");\n/* harmony import */ var _brace_expressions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./brace-expressions.js */ \"(ssr)/./node_modules/minimatch/dist/mjs/brace-expressions.js\");\n/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./escape.js */ \"(ssr)/./node_modules/minimatch/dist/mjs/escape.js\");\n/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./unescape.js */ \"(ssr)/./node_modules/minimatch/dist/mjs/unescape.js\");\n\n\n\n\nconst minimatch = (p, pattern, options = {})=>{\n    assertValidPattern(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (minimatch);\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext)=>(f)=>!f.startsWith(\".\") && f.endsWith(ext);\nconst starDotExtTestDot = (ext)=>(f)=>f.endsWith(ext);\nconst starDotExtTestNocase = (ext)=>{\n    ext = ext.toLowerCase();\n    return (f)=>!f.startsWith(\".\") && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext)=>{\n    ext = ext.toLowerCase();\n    return (f)=>f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f)=>!f.startsWith(\".\") && f.includes(\".\");\nconst starDotStarTestDot = (f)=>f !== \".\" && f !== \"..\" && f.includes(\".\");\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f)=>f !== \".\" && f !== \"..\" && f.startsWith(\".\");\nconst starRE = /^\\*+$/;\nconst starTest = (f)=>f.length !== 0 && !f.startsWith(\".\");\nconst starTestDot = (f)=>f.length !== 0 && f !== \".\" && f !== \"..\";\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExt([\n        $0\n    ]);\n    if (!ext) return noext;\n    ext = ext.toLowerCase();\n    return (f)=>noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExtDot([\n        $0\n    ]);\n    if (!ext) return noext;\n    ext = ext.toLowerCase();\n    return (f)=>noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExtDot([\n        $0\n    ]);\n    return !ext ? noext : (f)=>noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExt([\n        $0\n    ]);\n    return !ext ? noext : (f)=>noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0])=>{\n    const len = $0.length;\n    return (f)=>f.length === len && !f.startsWith(\".\");\n};\nconst qmarksTestNoExtDot = ([$0])=>{\n    const len = $0.length;\n    return (f)=>f.length === len && f !== \".\" && f !== \"..\";\n};\n/* c8 ignore start */ const defaultPlatform = typeof process === \"object\" && process ? typeof process.env === \"object\" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : \"posix\";\nconst path = {\n    win32: {\n        sep: \"\\\\\"\n    },\n    posix: {\n        sep: \"/\"\n    }\n};\n/* c8 ignore stop */ const sep = defaultPlatform === \"win32\" ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nconst GLOBSTAR = Symbol(\"globstar **\");\nminimatch.GLOBSTAR = GLOBSTAR;\nconst plTypes = {\n    \"!\": {\n        open: \"(?:(?!(?:\",\n        close: \"))[^/]*?)\"\n    },\n    \"?\": {\n        open: \"(?:\",\n        close: \")?\"\n    },\n    \"+\": {\n        open: \"(?:\",\n        close: \")+\"\n    },\n    \"*\": {\n        open: \"(?:\",\n        close: \")*\"\n    },\n    \"@\": {\n        open: \"(?:\",\n        close: \")\"\n    }\n};\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = \"[^/]\";\n// * => any number of characters\nconst star = qmark + \"*?\";\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";\n// \"abc\" -> { a:true, b:true, c:true }\nconst charSet = (s)=>s.split(\"\").reduce((set, c)=>{\n        set[c] = true;\n        return set;\n    }, {});\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet(\"().*{}+?[]^$\\\\!\");\n// characters that indicate we have to add the pattern start\nconst addPatternStartSet = charSet(\"[.(\");\nconst filter = (pattern, options = {})=>(p)=>minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {})=>Object.assign({}, a, b);\nconst defaults = (def)=>{\n    if (!def || typeof def !== \"object\" || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {})=>orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}){\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        unescape: (s, options = {})=>orig.unescape(s, ext(def, options)),\n        escape: (s, options = {})=>orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {})=>orig.filter(pattern, ext(def, options)),\n        defaults: (options)=>orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {})=>orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {})=>orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {})=>orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {})=>{\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [\n            pattern\n        ];\n    }\n    return brace_expansion__WEBPACK_IMPORTED_MODULE_0__(pattern);\n};\nminimatch.braceExpand = braceExpand;\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern)=>{\n    if (typeof pattern !== \"string\") {\n        throw new TypeError(\"invalid pattern\");\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError(\"pattern is too long\");\n    }\n};\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {})=>new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nconst match = (list, pattern, options = {})=>{\n    const mm = new Minimatch(pattern, options);\n    list = list.filter((f)=>mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globUnescape = (s)=>s.replace(/\\\\(.)/g, \"$1\");\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\nclass Minimatch {\n    constructor(pattern, options = {}){\n        assertValidPattern(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === \"win32\";\n        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, \"/\");\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set){\n            for (const part of pattern){\n                if (typeof part !== \"string\") return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) {}\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === \"#\") {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [\n            ...new Set(this.braceExpand())\n        ];\n        if (options.debug) {\n            this.debug = (...args)=>console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map((s)=>this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __)=>{\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === \"\" && s[1] === \"\" && (s[2] === \"?\" || !globMagic.test(s[2])) && !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [\n                        ...s.slice(0, 4),\n                        ...s.slice(4).map((ss)=>this.parse(ss))\n                    ];\n                } else if (isDrive) {\n                    return [\n                        s[0],\n                        ...s.slice(1).map((ss)=>this.parse(ss))\n                    ];\n                }\n            }\n            return s.map((ss)=>this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter((s)=>s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for(let i = 0; i < this.set.length; i++){\n                const p = this.set[i];\n                if (p[0] === \"\" && p[1] === \"\" && this.globParts[i][2] === \"?\" && typeof p[3] === \"string\" && /^[a-z]:$/i.test(p[3])) {\n                    p[2] = \"?\";\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for(let i = 0; i < globParts.length; i++){\n                for(let j = 0; j < globParts[i].length; j++){\n                    if (globParts[i][j] === \"**\") {\n                        globParts[i][j] = \"*\";\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        } else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        } else {\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map((parts)=>{\n            let gs = -1;\n            while(-1 !== (gs = parts.indexOf(\"**\", gs + 1))){\n                let i = gs;\n                while(parts[i + 1] === \"**\"){\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map((parts)=>{\n            parts = parts.reduce((set, part)=>{\n                const prev = set[set.length - 1];\n                if (part === \"**\" && prev === \"**\") {\n                    return set;\n                }\n                if (part === \"..\") {\n                    if (prev && prev !== \"..\" && prev !== \".\" && prev !== \"**\") {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [\n                \"\"\n            ] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for(let i = 1; i < parts.length - 1; i++){\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === \"\" && parts[0] === \"\") continue;\n                    if (p === \".\" || p === \"\") {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === \".\" && parts.length === 2 && (parts[1] === \".\" || parts[1] === \"\")) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while(-1 !== (dd = parts.indexOf(\"..\", dd + 1))){\n                const p = parts[dd - 1];\n                if (p && p !== \".\" && p !== \"..\" && p !== \"**\") {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        }while (didSomething);\n        return parts.length === 0 ? [\n            \"\"\n        ] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts){\n                let gs = -1;\n                while(-1 !== (gs = parts.indexOf(\"**\", gs + 1))){\n                    let gss = gs;\n                    while(parts[gss + 1] === \"**\"){\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== \"..\") continue;\n                    if (!p || p === \".\" || p === \"..\" || !p2 || p2 === \".\" || p2 === \"..\") {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = \"**\";\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for(let i = 1; i < parts.length - 1; i++){\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === \"\" && parts[0] === \"\") continue;\n                        if (p === \".\" || p === \"\") {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === \".\" && parts.length === 2 && (parts[1] === \".\" || parts[1] === \"\")) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while(-1 !== (dd = parts.indexOf(\"..\", dd + 1))){\n                    const p = parts[dd - 1];\n                    if (p && p !== \".\" && p !== \"..\" && p !== \"**\") {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === \"**\";\n                        const splin = needDot ? [\n                            \".\"\n                        ] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0) parts.push(\"\");\n                        dd -= 2;\n                    }\n                }\n            }\n        }while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for(let i = 0; i < globParts.length - 1; i++){\n            for(let j = i + 1; j < globParts.length; j++){\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (!matched) continue;\n                globParts[i] = matched;\n                globParts[j] = [];\n            }\n        }\n        return globParts.filter((gs)=>gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = \"\";\n        while(ai < a.length && bi < b.length){\n            if (a[ai] === b[bi]) {\n                result.push(which === \"b\" ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            } else if (emptyGSMatch && a[ai] === \"**\" && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            } else if (emptyGSMatch && b[bi] === \"**\" && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            } else if (a[ai] === \"*\" && b[bi] && (this.options.dot || !b[bi].startsWith(\".\")) && b[bi] !== \"**\") {\n                if (which === \"b\") return false;\n                which = \"a\";\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            } else if (b[bi] === \"*\" && a[ai] && (this.options.dot || !a[ai].startsWith(\".\")) && a[ai] !== \"**\") {\n                if (which === \"a\") return false;\n                which = \"b\";\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            } else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate) return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for(let i = 0; i < pattern.length && pattern.charAt(i) === \"!\"; i++){\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset) this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // a UNC pattern like //?/c:/* can match a path like c:/x\n        // and vice versa\n        if (this.isWindows) {\n            const fileUNC = file[0] === \"\" && file[1] === \"\" && file[2] === \"?\" && typeof file[3] === \"string\" && /^[a-z]:$/i.test(file[3]);\n            const patternUNC = pattern[0] === \"\" && pattern[1] === \"\" && pattern[2] === \"?\" && typeof pattern[3] === \"string\" && /^[a-z]:$/i.test(pattern[3]);\n            if (fileUNC && patternUNC) {\n                const fd = file[3];\n                const pd = pattern[3];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    file[3] = pd;\n                }\n            } else if (patternUNC && typeof file[0] === \"string\") {\n                const pd = pattern[3];\n                const fd = file[0];\n                if (pd.toLowerCase() === fd.toLowerCase()) {\n                    pattern[3] = fd;\n                    pattern = pattern.slice(3);\n                }\n            } else if (fileUNC && typeof pattern[0] === \"string\") {\n                const fd = file[3];\n                if (fd.toLowerCase() === pattern[0].toLowerCase()) {\n                    pattern[0] = fd;\n                    file = file.slice(3);\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug(\"matchOne\", this, {\n            file,\n            pattern\n        });\n        this.debug(\"matchOne\", file.length, pattern.length);\n        for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){\n            this.debug(\"matchOne loop\");\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */ if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */ if (p === GLOBSTAR) {\n                this.debug(\"GLOBSTAR\", [\n                    pattern,\n                    p,\n                    f\n                ]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug(\"** at the end\");\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for(; fi < fl; fi++){\n                        if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\") return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while(fr < fl){\n                    var swallowee = file[fr];\n                    this.debug(\"\\nglobstar while\", file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug(\"globstar found match!\", fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    } else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {\n                            this.debug(\"dot detected!\", file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug(\"globstar swallow a segment, and continue\");\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */ if (partial) {\n                    // ran out of file\n                    this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */ return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === \"string\") {\n                hit = f === p;\n                this.debug(\"string match\", p, f, hit);\n            } else {\n                hit = p.test(f);\n                this.debug(\"pattern match\", p, f, hit);\n            }\n            if (!hit) return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        } else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        } else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === \"\";\n        /* c8 ignore start */ } else {\n            // should be unreachable.\n            throw new Error(\"wtf?\");\n        }\n    /* c8 ignore stop */ }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        assertValidPattern(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === \"**\") return GLOBSTAR;\n        if (pattern === \"\") return \"\";\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if (m = pattern.match(starRE)) {\n            fastTest = options.dot ? starTestDot : starTest;\n        } else if (m = pattern.match(starDotExtRE)) {\n            fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);\n        } else if (m = pattern.match(qmarksRE)) {\n            fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);\n        } else if (m = pattern.match(starDotStarRE)) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        } else if (m = pattern.match(dotStarRE)) {\n            fastTest = dotStarTest;\n        }\n        let re = \"\";\n        let hasMagic = false;\n        let escaping = false;\n        // ? => one single character\n        const patternListStack = [];\n        const negativeLists = [];\n        let stateChar = false;\n        let uflag = false;\n        let pl;\n        // . and .. never match anything that doesn't start with .,\n        // even when options.dot is set.  However, if the pattern\n        // starts with ., then traversal patterns can match.\n        let dotTravAllowed = pattern.charAt(0) === \".\";\n        let dotFileAllowed = options.dot || dotTravAllowed;\n        const patternStart = ()=>dotTravAllowed ? \"\" : dotFileAllowed ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";\n        const subPatternStart = (p)=>p.charAt(0) === \".\" ? \"\" : options.dot ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";\n        const clearStateChar = ()=>{\n            if (stateChar) {\n                // we had some state-tracking character\n                // that wasn't consumed by this pass.\n                switch(stateChar){\n                    case \"*\":\n                        re += star;\n                        hasMagic = true;\n                        break;\n                    case \"?\":\n                        re += qmark;\n                        hasMagic = true;\n                        break;\n                    default:\n                        re += \"\\\\\" + stateChar;\n                        break;\n                }\n                this.debug(\"clearStateChar %j %j\", stateChar, re);\n                stateChar = false;\n            }\n        };\n        for(let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++){\n            this.debug(\"%s\t%s %s %j\", pattern, i, re, c);\n            // skip over any that are escaped.\n            if (escaping) {\n                // completely not allowed, even escaped.\n                // should be impossible.\n                /* c8 ignore start */ if (c === \"/\") {\n                    return false;\n                }\n                /* c8 ignore stop */ if (reSpecials[c]) {\n                    re += \"\\\\\";\n                }\n                re += c;\n                escaping = false;\n                continue;\n            }\n            switch(c){\n                // Should already be path-split by now.\n                /* c8 ignore start */ case \"/\":\n                    {\n                        return false;\n                    }\n                /* c8 ignore stop */ case \"\\\\\":\n                    clearStateChar();\n                    escaping = true;\n                    continue;\n                // the various stateChar values\n                // for the \"extglob\" stuff.\n                case \"?\":\n                case \"*\":\n                case \"+\":\n                case \"@\":\n                case \"!\":\n                    this.debug(\"%s\t%s %s %j <-- stateChar\", pattern, i, re, c);\n                    // if we already have a stateChar, then it means\n                    // that there was something like ** or +? in there.\n                    // Handle the stateChar, then proceed with this one.\n                    this.debug(\"call clearStateChar %j\", stateChar);\n                    clearStateChar();\n                    stateChar = c;\n                    // if extglob is disabled, then +(asdf|foo) isn't a thing.\n                    // just clear the statechar *now*, rather than even diving into\n                    // the patternList stuff.\n                    if (options.noext) clearStateChar();\n                    continue;\n                case \"(\":\n                    {\n                        if (!stateChar) {\n                            re += \"\\\\(\";\n                            continue;\n                        }\n                        const plEntry = {\n                            type: stateChar,\n                            start: i - 1,\n                            reStart: re.length,\n                            open: plTypes[stateChar].open,\n                            close: plTypes[stateChar].close\n                        };\n                        this.debug(this.pattern, \"\t\", plEntry);\n                        patternListStack.push(plEntry);\n                        // negation is (?:(?!(?:js)(?:<rest>))[^/]*)\n                        re += plEntry.open;\n                        // next entry starts with a dot maybe?\n                        if (plEntry.start === 0 && plEntry.type !== \"!\") {\n                            dotTravAllowed = true;\n                            re += subPatternStart(pattern.slice(i + 1));\n                        }\n                        this.debug(\"plType %j %j\", stateChar, re);\n                        stateChar = false;\n                        continue;\n                    }\n                case \")\":\n                    {\n                        const plEntry = patternListStack[patternListStack.length - 1];\n                        if (!plEntry) {\n                            re += \"\\\\)\";\n                            continue;\n                        }\n                        patternListStack.pop();\n                        // closing an extglob\n                        clearStateChar();\n                        hasMagic = true;\n                        pl = plEntry;\n                        // negation is (?:(?!js)[^/]*)\n                        // The others are (?:<pattern>)<type>\n                        re += pl.close;\n                        if (pl.type === \"!\") {\n                            negativeLists.push(Object.assign(pl, {\n                                reEnd: re.length\n                            }));\n                        }\n                        continue;\n                    }\n                case \"|\":\n                    {\n                        const plEntry = patternListStack[patternListStack.length - 1];\n                        if (!plEntry) {\n                            re += \"\\\\|\";\n                            continue;\n                        }\n                        clearStateChar();\n                        re += \"|\";\n                        // next subpattern can start with a dot?\n                        if (plEntry.start === 0 && plEntry.type !== \"!\") {\n                            dotTravAllowed = true;\n                            re += subPatternStart(pattern.slice(i + 1));\n                        }\n                        continue;\n                    }\n                // these are mostly the same in regexp and glob\n                case \"[\":\n                    // swallow any state-tracking char before the [\n                    clearStateChar();\n                    const [src, needUflag, consumed, magic] = (0,_brace_expressions_js__WEBPACK_IMPORTED_MODULE_1__.parseClass)(pattern, i);\n                    if (consumed) {\n                        re += src;\n                        uflag = uflag || needUflag;\n                        i += consumed - 1;\n                        hasMagic = hasMagic || magic;\n                    } else {\n                        re += \"\\\\[\";\n                    }\n                    continue;\n                case \"]\":\n                    re += \"\\\\\" + c;\n                    continue;\n                default:\n                    // swallow any state char that wasn't consumed\n                    clearStateChar();\n                    re += regExpEscape(c);\n                    break;\n            } // switch\n        } // for\n        // handle the case where we had a +( thing at the *end*\n        // of the pattern.\n        // each pattern list stack adds 3 chars, and we need to go through\n        // and escape any | chars that were passed through as-is for the regexp.\n        // Go through and escape them, taking care not to double-escape any\n        // | chars that were already escaped.\n        for(pl = patternListStack.pop(); pl; pl = patternListStack.pop()){\n            let tail;\n            tail = re.slice(pl.reStart + pl.open.length);\n            this.debug(this.pattern, \"setting tail\", re, pl);\n            // maybe some even number of \\, then maybe 1 \\, followed by a |\n            tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2)=>{\n                if (!$2) {\n                    // the | isn't already escaped, so escape it.\n                    $2 = \"\\\\\";\n                // should already be done\n                /* c8 ignore start */ }\n                /* c8 ignore stop */ // need to escape all those slashes *again*, without escaping the\n                // one that we need for escaping the | character.  As it works out,\n                // escaping an even number of slashes can be done by simply repeating\n                // it exactly after itself.  That's why this trick works.\n                //\n                // I am sorry that you have to see this.\n                return $1 + $1 + $2 + \"|\";\n            });\n            this.debug(\"tail=%j\\n   %s\", tail, tail, pl, re);\n            const t = pl.type === \"*\" ? star : pl.type === \"?\" ? qmark : \"\\\\\" + pl.type;\n            hasMagic = true;\n            re = re.slice(0, pl.reStart) + t + \"\\\\(\" + tail;\n        }\n        // handle trailing things that only matter at the very end.\n        clearStateChar();\n        if (escaping) {\n            // trailing \\\\\n            re += \"\\\\\\\\\";\n        }\n        // only need to apply the nodot start if the re starts with\n        // something that could conceivably capture a dot\n        const addPatternStart = addPatternStartSet[re.charAt(0)];\n        // Hack to work around lack of negative lookbehind in JS\n        // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n        // like 'a.xyz.yz' doesn't match.  So, the first negative\n        // lookahead, has to look ALL the way ahead, to the end of\n        // the pattern.\n        for(let n = negativeLists.length - 1; n > -1; n--){\n            const nl = negativeLists[n];\n            const nlBefore = re.slice(0, nl.reStart);\n            const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n            let nlAfter = re.slice(nl.reEnd);\n            const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;\n            // Handle nested stuff like *(*.js|!(*.json)), where open parens\n            // mean that we should *not* include the ) in the bit that is considered\n            // \"after\" the negated section.\n            const closeParensBefore = nlBefore.split(\")\").length;\n            const openParensBefore = nlBefore.split(\"(\").length - closeParensBefore;\n            let cleanAfter = nlAfter;\n            for(let i = 0; i < openParensBefore; i++){\n                cleanAfter = cleanAfter.replace(/\\)[+*?]?/, \"\");\n            }\n            nlAfter = cleanAfter;\n            const dollar = nlAfter === \"\" ? \"(?:$|\\\\/)\" : \"\";\n            re = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n        }\n        // if the re is not \"\" at this point, then we need to make sure\n        // it doesn't match against an empty path part.\n        // Otherwise a/* will match a/, which it should not.\n        if (re !== \"\" && hasMagic) {\n            re = \"(?=.)\" + re;\n        }\n        if (addPatternStart) {\n            re = patternStart() + re;\n        }\n        // if it's nocase, and the lcase/uppercase don't match, it's magic\n        if (options.nocase && !hasMagic && !options.nocaseMagicOnly) {\n            hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();\n        }\n        // skip the regexp for non-magical patterns\n        // unescape anything in it, though, so that it'll be\n        // an exact match against a file etc.\n        if (!hasMagic) {\n            return globUnescape(re);\n        }\n        const flags = (options.nocase ? \"i\" : \"\") + (uflag ? \"u\" : \"\");\n        try {\n            const ext = fastTest ? {\n                _glob: pattern,\n                _src: re,\n                test: fastTest\n            } : {\n                _glob: pattern,\n                _src: re\n            };\n            return Object.assign(new RegExp(\"^\" + re + \"$\", flags), ext);\n        /* c8 ignore start */ } catch (er) {\n            // should be impossible\n            // If it was an invalid regular expression, then it can't match\n            // anything.  This trick looks for a character after the end of\n            // the string, which is of course impossible, except in multi-line\n            // mode, but it's not a /m regex.\n            this.debug(\"invalid regexp\", er);\n            return new RegExp(\"$.\");\n        }\n    /* c8 ignore stop */ }\n    makeRe() {\n        if (this.regexp || this.regexp === false) return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n        const flags = options.nocase ? \"i\" : \"\";\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set.map((pattern)=>{\n            const pp = pattern.map((p)=>typeof p === \"string\" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src);\n            pp.forEach((p, i)=>{\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = \"(?:\\\\/|\" + twoStar + \"\\\\/)?\" + next;\n                    } else {\n                        pp[i] = twoStar;\n                    }\n                } else if (next === undefined) {\n                    pp[i - 1] = prev + \"(?:\\\\/|\" + twoStar + \")?\";\n                } else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + \"(?:\\\\/|\\\\/\" + twoStar + \"\\\\/)\" + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter((p)=>p !== GLOBSTAR).join(\"/\");\n        }).join(\"|\");\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = \"^(?:\" + re + \")$\";\n        // can match anything, as long as it's not this.\n        if (this.negate) re = \"^(?!\" + re + \").*$\";\n        try {\n            this.regexp = new RegExp(re, flags);\n        /* c8 ignore start */ } catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */ return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split(\"/\");\n        } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return [\n                \"\",\n                ...p.split(/\\/+/)\n            ];\n        } else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug(\"match\", f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === \"\";\n        }\n        if (f === \"/\" && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split(\"\\\\\").join(\"/\");\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, \"split\", ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, \"set\", set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for(let i = ff.length - 2; !filename && i >= 0; i--){\n                filename = ff[i];\n            }\n        }\n        for(let i = 0; i < set.length; i++){\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [\n                    filename\n                ];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */ \n\n/* c8 ignore stop */ minimatch.Minimatch = Minimatch;\nminimatch.escape = _escape_js__WEBPACK_IMPORTED_MODULE_2__.escape;\nminimatch.unescape = _unescape_js__WEBPACK_IMPORTED_MODULE_3__.unescape; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDZTtBQUNmO0FBQ0k7QUFDbEMsTUFBTUksWUFBWSxDQUFDQyxHQUFHQyxTQUFTQyxVQUFVLENBQUMsQ0FBQztJQUM5Q0MsbUJBQW1CRjtJQUNuQixvQ0FBb0M7SUFDcEMsSUFBSSxDQUFDQyxRQUFRRSxTQUFTLElBQUlILFFBQVFJLE1BQU0sQ0FBQyxPQUFPLEtBQUs7UUFDakQsT0FBTztJQUNYO0lBQ0EsT0FBTyxJQUFJQyxVQUFVTCxTQUFTQyxTQUFTSyxLQUFLLENBQUNQO0FBQ2pELEVBQUU7QUFDRixpRUFBZUQsU0FBU0EsRUFBQztBQUN6Qix3REFBd0Q7QUFDeEQsTUFBTVMsZUFBZTtBQUNyQixNQUFNQyxpQkFBaUIsQ0FBQ0MsTUFBUSxDQUFDQyxJQUFNLENBQUNBLEVBQUVDLFVBQVUsQ0FBQyxRQUFRRCxFQUFFRSxRQUFRLENBQUNIO0FBQ3hFLE1BQU1JLG9CQUFvQixDQUFDSixNQUFRLENBQUNDLElBQU1BLEVBQUVFLFFBQVEsQ0FBQ0g7QUFDckQsTUFBTUssdUJBQXVCLENBQUNMO0lBQzFCQSxNQUFNQSxJQUFJTSxXQUFXO0lBQ3JCLE9BQU8sQ0FBQ0wsSUFBTSxDQUFDQSxFQUFFQyxVQUFVLENBQUMsUUFBUUQsRUFBRUssV0FBVyxHQUFHSCxRQUFRLENBQUNIO0FBQ2pFO0FBQ0EsTUFBTU8sMEJBQTBCLENBQUNQO0lBQzdCQSxNQUFNQSxJQUFJTSxXQUFXO0lBQ3JCLE9BQU8sQ0FBQ0wsSUFBTUEsRUFBRUssV0FBVyxHQUFHSCxRQUFRLENBQUNIO0FBQzNDO0FBQ0EsTUFBTVEsZ0JBQWdCO0FBQ3RCLE1BQU1DLGtCQUFrQixDQUFDUixJQUFNLENBQUNBLEVBQUVDLFVBQVUsQ0FBQyxRQUFRRCxFQUFFUyxRQUFRLENBQUM7QUFDaEUsTUFBTUMscUJBQXFCLENBQUNWLElBQU1BLE1BQU0sT0FB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O29CQUNwQixPQUFPO2dCQUNYO2dCQUNBLE9BQU8sQ0FBQyxJQUFJLENBQUNuSSxNQUFNO1lBQ3ZCO1FBQ0o7UUFDQSwyREFBMkQ7UUFDM0QsOEJBQThCO1FBQzlCLElBQUk1RixRQUFRK04sVUFBVSxFQUFFO1lBQ3BCLE9BQU87UUFDWDtRQUNBLE9BQU8sSUFBSSxDQUFDbkksTUFBTTtJQUN0QjtJQUNBLE9BQU96QixTQUFTQyxHQUFHLEVBQUU7UUFDakIsT0FBT3ZFLFVBQVVzRSxRQUFRLENBQUNDLEtBQUtoRSxTQUFTO0lBQzVDO0FBQ0o7QUFDQSxtQkFBbUIsR0FDa0I7QUFDSTtBQUN6QyxrQkFBa0IsR0FDbEJQLFVBQVVPLFNBQVMsR0FBR0E7QUFDdEJQLFVBQVVGLE1BQU0sR0FBR0EsOENBQU1BO0FBQ3pCRSxVQUFVRCxRQUFRLEdBQUdBLGtEQUFRQSxFQUM3QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2luZGV4LmpzP2MzNjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGV4cGFuZCBmcm9tICdicmFjZS1leHBhbnNpb24nO1xuaW1wb3J0IHsgcGFyc2VDbGFzcyB9IGZyb20gJy4vYnJhY2UtZXhwcmVzc2lvbnMuanMnO1xuaW1wb3J0IHsgZXNjYXBlIH0gZnJvbSAnLi9lc2NhcGUuanMnO1xuaW1wb3J0IHsgdW5lc2NhcGUgfSBmcm9tICcuL3VuZXNjYXBlLmpzJztcbmV4cG9ydCBjb25zdCBtaW5pbWF0Y2ggPSAocCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pO1xuICAgIC8vIHNob3J0Y3V0OiBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICAgIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpLm1hdGNoKHApO1xufTtcbmV4cG9ydCBkZWZhdWx0IG1pbmltYXRjaDtcbi8vIE9wdGltaXplZCBjaGVja2luZyBmb3IgdGhlIG1vc3QgY29tbW9uIGdsb2IgcGF0dGVybnMuXG5jb25zdCBzdGFyRG90RXh0UkUgPSAvXlxcKisoW14rQCE/XFwqXFxbXFwoXSopJC87XG5jb25zdCBzdGFyRG90RXh0VGVzdCA9IChleHQpID0+IChmKSA9PiAhZi5zdGFydHNXaXRoKCcuJykgJiYgZi5lbmRzV2l0aChleHQpO1xuY29uc3Qgc3RhckRvdEV4dFRlc3REb3QgPSAoZXh0KSA9PiAoZikgPT4gZi5lbmRzV2l0aChleHQpO1xuY29uc3Qgc3RhckRvdEV4dFRlc3ROb2Nhc2UgPSAoZXh0KSA9PiB7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiAhZi5zdGFydHNXaXRoKCcuJykgJiYgZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3Qgc3RhckRvdEV4dFRlc3ROb2Nhc2VEb3QgPSAoZXh0KSA9PiB7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBzdGFyRG90U3RhclJFID0gL15cXCorXFwuXFwqKyQvO1xuY29uc3Qgc3RhckRvdFN0YXJUZXN0ID0gKGYpID0+ICFmLnN0YXJ0c1dpdGgoJy4nKSAmJiBmLmluY2x1ZGVzKCcuJyk7XG5jb25zdCBzdGFyRG90U3RhclRlc3REb3QgPSAoZikgPT4gZiAhPT0gJy4nICYmIGYgIT09ICcuLicgJiYgZi5pbmNsdWRlcygnLicpO1xuY29uc3QgZG90U3RhclJFID0gL15cXC5cXCorJC87XG5jb25zdCBkb3RTdGFyVGVzdCA9IChmKSA9PiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJyAmJiBmLnN0YXJ0c1dpdGgoJy4nKTtcbmNvbnN0IHN0YXJSRSA9IC9eXFwqKyQvO1xuY29uc3Qgc3RhclRlc3QgPSAoZikgPT4gZi5sZW5ndGggIT09IDAgJiYgIWYuc3RhcnRzV2l0aCgnLicpO1xuY29uc3Qgc3RhclRlc3REb3QgPSAoZikgPT4gZi5sZW5ndGggIT09IDAgJiYgZiAhPT0gJy4nICYmIGYgIT09ICcuLic7XG5jb25zdCBxbWFya3NSRSA9IC9eXFw/KyhbXitAIT9cXCpcXFtcXChdKik/JC87XG5jb25zdCBxbWFya3NUZXN0Tm9jYXNlID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHQoWyQwXSk7XG4gICAgaWYgKCFleHQpXG4gICAgICAgIHJldHVybiBub2V4dDtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+IG5vZXh0KGYpICYmIGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3ROb2Nhc2VEb3QgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dERvdChbJDBdKTtcbiAgICBpZiAoIWV4dClcbiAgICAgICAgcmV0dXJuIG5vZXh0O1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gbm9leHQoZikgJiYgZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdERvdCA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0RG90KFskMF0pO1xuICAgIHJldHVybiAhZXh0ID8gbm9leHQgOiAoZikgPT4gbm9leHQoZikgJiYgZi5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3QgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dChbJDBdKTtcbiAgICByZXR1cm4gIWV4dCA/IG5vZXh0IDogKGYpID0+IG5vZXh0KGYpICYmIGYuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0Tm9FeHQgPSAoWyQwXSkgPT4ge1xuICAgIGNvbnN0IGxlbiA9ICQwLmxlbmd0aDtcbiAgICByZXR1cm4gKGYpID0+IGYubGVuZ3RoID09PSBsZW4gJiYgIWYuc3RhcnRzV2l0aCgnLicpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3ROb0V4dERvdCA9IChbJDBdKSA9PiB7XG4gICAgY29uc3QgbGVuID0gJDAubGVuZ3RoO1xuICAgIHJldHVybiAoZikgPT4gZi5sZW5ndGggPT09IGxlbiAmJiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJztcbn07XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGRlZmF1bHRQbGF0Zm9ybSA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzc1xuICAgID8gKHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19NSU5JTUFUQ0hfVEVTVElOR19QTEFURk9STV9fKSB8fFxuICAgICAgICBwcm9jZXNzLnBsYXRmb3JtXG4gICAgOiAncG9zaXgnKTtcbmNvbnN0IHBhdGggPSB7XG4gICAgd2luMzI6IHsgc2VwOiAnXFxcXCcgfSxcbiAgICBwb3NpeDogeyBzZXA6ICcvJyB9LFxufTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5leHBvcnQgY29uc3Qgc2VwID0gZGVmYXVsdFBsYXRmb3JtID09PSAnd2luMzInID8gcGF0aC53aW4zMi5zZXAgOiBwYXRoLnBvc2l4LnNlcDtcbm1pbmltYXRjaC5zZXAgPSBzZXA7XG5leHBvcnQgY29uc3QgR0xPQlNUQVIgPSBTeW1ib2woJ2dsb2JzdGFyICoqJyk7XG5taW5pbWF0Y2guR0xPQlNUQVIgPSBHTE9CU1RBUjtcbmNvbnN0IHBsVHlwZXMgPSB7XG4gICAgJyEnOiB7IG9wZW46ICcoPzooPyEoPzonLCBjbG9zZTogJykpW14vXSo/KScgfSxcbiAgICAnPyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKT8nIH0sXG4gICAgJysnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJykrJyB9LFxuICAgICcqJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgICAnQCc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKScgfSxcbn07XG4vLyBhbnkgc2luZ2xlIHRoaW5nIG90aGVyIHRoYW4gL1xuLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgLyB3aGVuIHVzaW5nIG5ldyBSZWdFeHAoKVxuY29uc3QgcW1hcmsgPSAnW14vXSc7XG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuY29uc3Qgc3RhciA9IHFtYXJrICsgJyo/Jztcbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbmNvbnN0IHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFwvKSkuKSo/Jztcbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxuY29uc3QgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFwvfF4pXFxcXC4pLikqPyc7XG4vLyBcImFiY1wiIC0+IHsgYTp0cnVlLCBiOnRydWUsIGM6dHJ1ZSB9XG5jb25zdCBjaGFyU2V0ID0gKHMpID0+IHMuc3BsaXQoJycpLnJlZHVjZSgoc2V0LCBjKSA9PiB7XG4gICAgc2V0W2NdID0gdHJ1ZTtcbiAgICByZXR1cm4gc2V0O1xufSwge30pO1xuLy8gY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZXNjYXBlZCBpbiBSZWdFeHAuXG5jb25zdCByZVNwZWNpYWxzID0gY2hhclNldCgnKCkuKnt9Kz9bXV4kXFxcXCEnKTtcbi8vIGNoYXJhY3RlcnMgdGhhdCBpbmRpY2F0ZSB3ZSBoYXZlIHRvIGFkZCB0aGUgcGF0dGVybiBzdGFydFxuY29uc3QgYWRkUGF0dGVyblN0YXJ0U2V0ID0gY2hhclNldCgnWy4oJyk7XG5leHBvcnQgY29uc3QgZmlsdGVyID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gKHApID0+IG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKTtcbm1pbmltYXRjaC5maWx0ZXIgPSBmaWx0ZXI7XG5jb25zdCBleHQgPSAoYSwgYiA9IHt9KSA9PiBPYmplY3QuYXNzaWduKHt9LCBhLCBiKTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0cyA9IChkZWYpID0+IHtcbiAgICBpZiAoIWRlZiB8fCB0eXBlb2YgZGVmICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1pbmltYXRjaDtcbiAgICB9XG4gICAgY29uc3Qgb3JpZyA9IG1pbmltYXRjaDtcbiAgICBjb25zdCBtID0gKHAsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZyhwLCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obSwge1xuICAgICAgICBNaW5pbWF0Y2g6IGNsYXNzIE1pbmltYXRjaCBleHRlbmRzIG9yaWcuTWluaW1hdGNoIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRpYyBkZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLk1pbmltYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5lc2NhcGU6IChzLCBvcHRpb25zID0ge30pID0+IG9yaWcudW5lc2NhcGUocywgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBlc2NhcGU6IChzLCBvcHRpb25zID0ge30pID0+IG9yaWcuZXNjYXBlKHMsIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgZmlsdGVyOiAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLmZpbHRlcihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGRlZmF1bHRzOiAob3B0aW9ucykgPT4gb3JpZy5kZWZhdWx0cyhleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIG1ha2VSZTogKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5tYWtlUmUocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBicmFjZUV4cGFuZDogKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5icmFjZUV4cGFuZChwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIG1hdGNoOiAobGlzdCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLm1hdGNoKGxpc3QsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgc2VwOiBvcmlnLnNlcCxcbiAgICAgICAgR0xPQlNUQVI6IEdMT0JTVEFSLFxuICAgIH0pO1xufTtcbm1pbmltYXRjaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuLy8gQnJhY2UgZXhwYW5zaW9uOlxuLy8gYXtiLGN9ZCAtPiBhYmQgYWNkXG4vLyBhe2IsfWMgLT4gYWJjIGFjXG4vLyBhezAuLjN9ZCAtPiBhMGQgYTFkIGEyZCBhM2Rcbi8vIGF7Yixje2QsZX1mfWcgLT4gYWJnIGFjZGZnIGFjZWZnXG4vLyBhe2IsY31ke2UsZn1nIC0+IGFiZGVnIGFjZGVnIGFiZGVnIGFiZGZnXG4vL1xuLy8gSW52YWxpZCBzZXRzIGFyZSBub3QgZXhwYW5kZWQuXG4vLyBhezIuLn1iIC0+IGF7Mi4ufWJcbi8vIGF7Yn1jIC0+IGF7Yn1jXG5leHBvcnQgY29uc3QgYnJhY2VFeHBhbmQgPSAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pO1xuICAgIC8vIFRoYW5rcyB0byBZZXRpbmcgTGkgPGh0dHBzOi8vZ2l0aHViLmNvbS95ZXRpbmdsaT4gZm9yXG4gICAgLy8gaW1wcm92aW5nIHRoaXMgcmVnZXhwIHRvIGF2b2lkIGEgUmVET1MgdnVsbmVyYWJpbGl0eS5cbiAgICBpZiAob3B0aW9ucy5ub2JyYWNlIHx8ICEvXFx7KD86KD8hXFx7KS4pKlxcfS8udGVzdChwYXR0ZXJuKSkge1xuICAgICAgICAvLyBzaG9ydGN1dC4gbm8gbmVlZCB0byBleHBhbmQuXG4gICAgICAgIHJldHVybiBbcGF0dGVybl07XG4gICAgfVxuICAgIHJldHVybiBleHBhbmQocGF0dGVybik7XG59O1xubWluaW1hdGNoLmJyYWNlRXhwYW5kID0gYnJhY2VFeHBhbmQ7XG5jb25zdCBNQVhfUEFUVEVSTl9MRU5HVEggPSAxMDI0ICogNjQ7XG5jb25zdCBhc3NlcnRWYWxpZFBhdHRlcm4gPSAocGF0dGVybikgPT4ge1xuICAgIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXR0ZXJuJyk7XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9QQVRURVJOX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXR0ZXJuIGlzIHRvbyBsb25nJyk7XG4gICAgfVxufTtcbi8vIHBhcnNlIGEgY29tcG9uZW50IG9mIHRoZSBleHBhbmRlZCBzZXQuXG4vLyBBdCB0aGlzIHBvaW50LCBubyBwYXR0ZXJuIG1heSBjb250YWluIFwiL1wiIGluIGl0XG4vLyBzbyB3ZSdyZSBnb2luZyB0byByZXR1cm4gYSAyZCBhcnJheSwgd2hlcmUgZWFjaCBlbnRyeSBpcyB0aGUgZnVsbFxuLy8gcGF0dGVybiwgc3BsaXQgb24gJy8nLCBhbmQgdGhlbiB0dXJuZWQgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbi8vIEEgcmVnZXhwIGlzIG1hZGUgYXQgdGhlIGVuZCB3aGljaCBqb2lucyBlYWNoIGFycmF5IHdpdGggYW5cbi8vIGVzY2FwZWQgLywgYW5kIGFub3RoZXIgZnVsbCBvbmUgd2hpY2ggam9pbnMgZWFjaCByZWdleHAgd2l0aCB8LlxuLy9cbi8vIEZvbGxvd2luZyB0aGUgbGVhZCBvZiBCYXNoIDQuMSwgbm90ZSB0aGF0IFwiKipcIiBvbmx5IGhhcyBzcGVjaWFsIG1lYW5pbmdcbi8vIHdoZW4gaXQgaXMgdGhlICpvbmx5KiB0aGluZyBpbiBhIHBhdGggcG9ydGlvbi4gIE90aGVyd2lzZSwgYW55IHNlcmllc1xuLy8gb2YgKiBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xlICouICBHbG9ic3RhciBiZWhhdmlvciBpcyBlbmFibGVkIGJ5XG4vLyBkZWZhdWx0LCBhbmQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgb3B0aW9ucy5ub2dsb2JzdGFyLlxuZXhwb3J0IGNvbnN0IG1ha2VSZSA9IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucykubWFrZVJlKCk7XG5taW5pbWF0Y2gubWFrZVJlID0gbWFrZVJlO1xuZXhwb3J0IGNvbnN0IG1hdGNoID0gKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG1tID0gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICBsaXN0ID0gbGlzdC5maWx0ZXIoZiA9PiBtbS5tYXRjaChmKSk7XG4gICAgaWYgKG1tLm9wdGlvbnMubm9udWxsICYmICFsaXN0Lmxlbmd0aCkge1xuICAgICAgICBsaXN0LnB1c2gocGF0dGVybik7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufTtcbm1pbmltYXRjaC5tYXRjaCA9IG1hdGNoO1xuLy8gcmVwbGFjZSBzdHVmZiBsaWtlIFxcKiB3aXRoICpcbmNvbnN0IGdsb2JVbmVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJyk7XG5jb25zdCBnbG9iTWFnaWMgPSAvWz8qXXxbK0AhXVxcKC4qP1xcKXxcXFt8XFxdLztcbmNvbnN0IHJlZ0V4cEVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG5leHBvcnQgY2xhc3MgTWluaW1hdGNoIHtcbiAgICBvcHRpb25zO1xuICAgIHNldDtcbiAgICBwYXR0ZXJuO1xuICAgIHdpbmRvd3NQYXRoc05vRXNjYXBlO1xuICAgIG5vbmVnYXRlO1xuICAgIG5lZ2F0ZTtcbiAgICBjb21tZW50O1xuICAgIGVtcHR5O1xuICAgIHByZXNlcnZlTXVsdGlwbGVTbGFzaGVzO1xuICAgIHBhcnRpYWw7XG4gICAgZ2xvYlNldDtcbiAgICBnbG9iUGFydHM7XG4gICAgbm9jYXNlO1xuICAgIGlzV2luZG93cztcbiAgICBwbGF0Zm9ybTtcbiAgICB3aW5kb3dzTm9NYWdpY1Jvb3Q7XG4gICAgcmVnZXhwO1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybik7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gb3B0aW9ucy5wbGF0Zm9ybSB8fCBkZWZhdWx0UGxhdGZvcm07XG4gICAgICAgIHRoaXMuaXNXaW5kb3dzID0gdGhpcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbiAgICAgICAgdGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSA9XG4gICAgICAgICAgICAhIW9wdGlvbnMud2luZG93c1BhdGhzTm9Fc2NhcGUgfHwgb3B0aW9ucy5hbGxvd1dpbmRvd3NFc2NhcGUgPT09IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSkge1xuICAgICAgICAgICAgdGhpcy5wYXR0ZXJuID0gdGhpcy5wYXR0ZXJuLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzID0gISFvcHRpb25zLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9IG51bGw7XG4gICAgICAgIHRoaXMubmVnYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9uZWdhdGUgPSAhIW9wdGlvbnMubm9uZWdhdGU7XG4gICAgICAgIHRoaXMuY29tbWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFydGlhbCA9ICEhb3B0aW9ucy5wYXJ0aWFsO1xuICAgICAgICB0aGlzLm5vY2FzZSA9ICEhdGhpcy5vcHRpb25zLm5vY2FzZTtcbiAgICAgICAgdGhpcy53aW5kb3dzTm9NYWdpY1Jvb3QgPVxuICAgICAgICAgICAgb3B0aW9ucy53aW5kb3dzTm9NYWdpY1Jvb3QgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy53aW5kb3dzTm9NYWdpY1Jvb3RcbiAgICAgICAgICAgICAgICA6ICEhKHRoaXMuaXNXaW5kb3dzICYmIHRoaXMubm9jYXNlKTtcbiAgICAgICAgdGhpcy5nbG9iU2V0ID0gW107XG4gICAgICAgIHRoaXMuZ2xvYlBhcnRzID0gW107XG4gICAgICAgIHRoaXMuc2V0ID0gW107XG4gICAgICAgIC8vIG1ha2UgdGhlIHNldCBvZiByZWdleHBzIGV0Yy5cbiAgICAgICAgdGhpcy5tYWtlKCk7XG4gICAgfVxuICAgIGhhc01hZ2ljKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1hZ2ljYWxCcmFjZXMgJiYgdGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVidWcoLi4uXykgeyB9XG4gICAgbWFrZSgpIHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMucGF0dGVybjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gZW1wdHkgcGF0dGVybnMgYW5kIGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gICAgICAgIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgdGhpcy5jb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgICAgIHRoaXMuZW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAgMTogZmlndXJlIG91dCBuZWdhdGlvbiwgZXRjLlxuICAgICAgICB0aGlzLnBhcnNlTmVnYXRlKCk7XG4gICAgICAgIC8vIHN0ZXAgMjogZXhwYW5kIGJyYWNlc1xuICAgICAgICB0aGlzLmdsb2JTZXQgPSBbLi4ubmV3IFNldCh0aGlzLmJyYWNlRXhwYW5kKCkpXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcgPSAoLi4uYXJncykgPT4gY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5nbG9iU2V0KTtcbiAgICAgICAgLy8gc3RlcCAzOiBub3cgd2UgaGF2ZSBhIHNldCwgc28gdHVybiBlYWNoIG9uZSBpbnRvIGEgc2VyaWVzIG9mXG4gICAgICAgIC8vIHBhdGgtcG9ydGlvbiBtYXRjaGluZyBwYXR0ZXJucy5cbiAgICAgICAgLy8gVGhlc2Ugd2lsbCBiZSByZWdleHBzLCBleGNlcHQgaW4gdGhlIGNhc2Ugb2YgXCIqKlwiLCB3aGljaCBpc1xuICAgICAgICAvLyBzZXQgdG8gdGhlIEdMT0JTVEFSIG9iamVjdCBmb3IgZ2xvYnN0YXIgYmVoYXZpb3IsXG4gICAgICAgIC8vIGFuZCB3aWxsIG5vdCBjb250YWluIGFueSAvIGNoYXJhY3RlcnNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gRmlyc3QsIHdlIHByZXByb2Nlc3MgdG8gbWFrZSB0aGUgZ2xvYiBwYXR0ZXJuIHNldHMgYSBiaXQgc2ltcGxlclxuICAgICAgICAvLyBhbmQgZGVkdXBlZC4gIFRoZXJlIGFyZSBzb21lIHBlcmYta2lsbGluZyBwYXR0ZXJucyB0aGF0IGNhbiBjYXVzZVxuICAgICAgICAvLyBwcm9ibGVtcyB3aXRoIGEgZ2xvYiB3YWxrLCBidXQgd2UgY2FuIHNpbXBsaWZ5IHRoZW0gZG93biBhIGJpdC5cbiAgICAgICAgY29uc3QgcmF3R2xvYlBhcnRzID0gdGhpcy5nbG9iU2V0Lm1hcChzID0+IHRoaXMuc2xhc2hTcGxpdChzKSk7XG4gICAgICAgIHRoaXMuZ2xvYlBhcnRzID0gdGhpcy5wcmVwcm9jZXNzKHJhd0dsb2JQYXJ0cyk7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCB0aGlzLmdsb2JQYXJ0cyk7XG4gICAgICAgIC8vIGdsb2IgLS0+IHJlZ2V4cHNcbiAgICAgICAgbGV0IHNldCA9IHRoaXMuZ2xvYlBhcnRzLm1hcCgocywgXywgX18pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzV2luZG93cyAmJiB0aGlzLndpbmRvd3NOb01hZ2ljUm9vdCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGl0J3MgYSBkcml2ZSBvciB1bmMgcGF0aC5cbiAgICAgICAgICAgICAgICBjb25zdCBpc1VOQyA9IHNbMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIHNbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIChzWzJdID09PSAnPycgfHwgIWdsb2JNYWdpYy50ZXN0KHNbMl0pKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZ2xvYk1hZ2ljLnRlc3Qoc1szXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEcml2ZSA9IC9eW2Etel06L2kudGVzdChzWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNVTkMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5zLnNsaWNlKDAsIDQpLCAuLi5zLnNsaWNlKDQpLm1hcChzcyA9PiB0aGlzLnBhcnNlKHNzKSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RyaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbc1swXSwgLi4ucy5zbGljZSgxKS5tYXAoc3MgPT4gdGhpcy5wYXJzZShzcykpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcy5tYXAoc3MgPT4gdGhpcy5wYXJzZShzcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldCk7XG4gICAgICAgIC8vIGZpbHRlciBvdXQgZXZlcnl0aGluZyB0aGF0IGRpZG4ndCBjb21waWxlIHByb3Blcmx5LlxuICAgICAgICB0aGlzLnNldCA9IHNldC5maWx0ZXIocyA9PiBzLmluZGV4T2YoZmFsc2UpID09PSAtMSk7XG4gICAgICAgIC8vIGRvIG5vdCB0cmVhdCB0aGUgPyBpbiBVTkMgcGF0aHMgYXMgbWFnaWNcbiAgICAgICAgaWYgKHRoaXMuaXNXaW5kb3dzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuc2V0W2ldO1xuICAgICAgICAgICAgICAgIGlmIChwWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICBwWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsb2JQYXJ0c1tpXVsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwWzNdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAvXlthLXpdOiQvaS50ZXN0KHBbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMl0gPSAnPyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCB0aGlzLnNldCk7XG4gICAgfVxuICAgIC8vIHZhcmlvdXMgdHJhbnNmb3JtcyB0byBlcXVpdmFsZW50IHBhdHRlcm4gc2V0cyB0aGF0IGFyZVxuICAgIC8vIGZhc3RlciB0byBwcm9jZXNzIGluIGEgZmlsZXN5c3RlbSB3YWxrLiAgVGhlIGdvYWwgaXMgdG9cbiAgICAvLyBlbGltaW5hdGUgd2hhdCB3ZSBjYW4sIGFuZCBwdXNoIGFsbCAqKiBwYXR0ZXJucyBhcyBmYXJcbiAgICAvLyB0byB0aGUgcmlnaHQgYXMgcG9zc2libGUsIGV2ZW4gaWYgaXQgaW5jcmVhc2VzIHRoZSBudW1iZXJcbiAgICAvLyBvZiBwYXR0ZXJucyB0aGF0IHdlIGhhdmUgdG8gcHJvY2Vzcy5cbiAgICBwcmVwcm9jZXNzKGdsb2JQYXJ0cykge1xuICAgICAgICAvLyBpZiB3ZSdyZSBub3QgaW4gZ2xvYnN0YXIgbW9kZSwgdGhlbiB0dXJuIGFsbCAqKiBpbnRvICpcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub2dsb2JzdGFyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb2JQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ2xvYlBhcnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbG9iUGFydHNbaV1bal0gPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0c1tpXVtqXSA9ICcqJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9wdGltaXphdGlvbkxldmVsID0gMSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW1pemF0aW9uTGV2ZWwgPj0gMikge1xuICAgICAgICAgICAgLy8gYWdncmVzc2l2ZSBvcHRpbWl6YXRpb24gZm9yIHRoZSBwdXJwb3NlIG9mIGZzIHdhbGtpbmdcbiAgICAgICAgICAgIGdsb2JQYXJ0cyA9IHRoaXMuZmlyc3RQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKTtcbiAgICAgICAgICAgIGdsb2JQYXJ0cyA9IHRoaXMuc2Vjb25kUGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW1pemF0aW9uTGV2ZWwgPj0gMSkge1xuICAgICAgICAgICAgLy8ganVzdCBiYXNpYyBvcHRpbWl6YXRpb25zIHRvIHJlbW92ZSBzb21lIC4uIHBhcnRzXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmxldmVsT25lT3B0aW1pemUoZ2xvYlBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JQYXJ0cyA9IHRoaXMuYWRqYXNjZW50R2xvYnN0YXJPcHRpbWl6ZShnbG9iUGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iUGFydHM7XG4gICAgfVxuICAgIC8vIGp1c3QgZ2V0IHJpZCBvZiBhZGphc2NlbnQgKiogcG9ydGlvbnNcbiAgICBhZGphc2NlbnRHbG9ic3Rhck9wdGltaXplKGdsb2JQYXJ0cykge1xuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzLm1hcChwYXJ0cyA9PiB7XG4gICAgICAgICAgICBsZXQgZ3MgPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGdzID0gcGFydHMuaW5kZXhPZignKionLCBncyArIDEpKSkge1xuICAgICAgICAgICAgICAgIGxldCBpID0gZ3M7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcnRzW2kgKyAxXSA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBncykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZ3MsIGkgLSBncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZ2V0IHJpZCBvZiBhZGphc2NlbnQgKiogYW5kIHJlc29sdmUgLi4gcG9ydGlvbnNcbiAgICBsZXZlbE9uZU9wdGltaXplKGdsb2JQYXJ0cykge1xuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzLm1hcChwYXJ0cyA9PiB7XG4gICAgICAgICAgICBwYXJ0cyA9IHBhcnRzLnJlZHVjZSgoc2V0LCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHNldFtzZXQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcqKicgJiYgcHJldiA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2ICE9PSAnLi4nICYmIHByZXYgIT09ICcuJyAmJiBwcmV2ICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldC5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAwID8gWycnXSA6IHBhcnRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV2ZWxUd29GaWxlT3B0aW1pemUocGFydHMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnRzKSkge1xuICAgICAgICAgICAgcGFydHMgPSB0aGlzLnNsYXNoU3BsaXQocGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyA8cHJlPi88ZT4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgICAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzcXVlZXplIG91dCBVTkMgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgcCA9PT0gJycgJiYgcGFydHNbMF0gPT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwID09PSAnLicgfHwgcCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09PSAnLicgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFydHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgIChwYXJ0c1sxXSA9PT0gJy4nIHx8IHBhcnRzWzFdID09PSAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPHByZT4vPHA+Ly4uLzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgIGxldCBkZCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoLTEgIT09IChkZCA9IHBhcnRzLmluZGV4T2YoJy4uJywgZGQgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbZGQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocCAmJiBwICE9PSAnLicgJiYgcCAhPT0gJy4uJyAmJiBwICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShkZCAtIDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICBkZCAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlkU29tZXRoaW5nKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMCA/IFsnJ10gOiBwYXJ0cztcbiAgICB9XG4gICAgLy8gRmlyc3QgcGhhc2U6IHNpbmdsZS1wYXR0ZXJuIHByb2Nlc3NpbmdcbiAgICAvLyA8cHJlPiBpcyAxIG9yIG1vcmUgcG9ydGlvbnNcbiAgICAvLyA8cmVzdD4gaXMgMSBvciBtb3JlIHBvcnRpb25zXG4gICAgLy8gPHA+IGlzIGFueSBwb3J0aW9uIG90aGVyIHRoYW4gLiwgLi4sICcnLCBvciAqKlxuICAgIC8vIDxlPiBpcyAuIG9yICcnXG4gICAgLy9cbiAgICAvLyAqKi8uLiBpcyAqYnJ1dGFsKiBmb3IgZmlsZXN5c3RlbSB3YWxraW5nIHBlcmZvcm1hbmNlLCBiZWNhdXNlXG4gICAgLy8gaXQgZWZmZWN0aXZlbHkgcmVzZXRzIHRoZSByZWN1cnNpdmUgd2FsayBlYWNoIHRpbWUgaXQgb2NjdXJzLFxuICAgIC8vIGFuZCAqKiBjYW5ub3QgYmUgcmVkdWNlZCBvdXQgYnkgYSAuLiBwYXR0ZXJuIHBhcnQgbGlrZSBhIHJlZ2V4cFxuICAgIC8vIG9yIG1vc3Qgc3RyaW5ncyAob3RoZXIgdGhhbiAuLiwgLiwgYW5kICcnKSBjYW4gYmUuXG4gICAgLy9cbiAgICAvLyA8cHJlPi8qKi8uLi88cD4vPHA+LzxyZXN0PiAtPiB7PHByZT4vLi4vPHA+LzxwPi88cmVzdD4sPHByZT4vKiovPHA+LzxwPi88cmVzdD59XG4gICAgLy8gPHByZT4vPGU+LzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAvLyA8cHJlPi88cD4vLi4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgIC8vICoqLyoqLzxyZXN0PiAtPiAqKi88cmVzdD5cbiAgICAvL1xuICAgIC8vICoqLyovPHJlc3Q+IC0+ICovKiovPHJlc3Q+IDw9PSBub3QgdmFsaWQgYmVjYXVzZSAqKiBkb2Vzbid0IGZvbGxvd1xuICAgIC8vIHRoaXMgV09VTEQgYmUgYWxsb3dlZCBpZiAqKiBkaWQgZm9sbG93IHN5bWxpbmtzLCBvciAqIGRpZG4ndFxuICAgIGZpcnN0UGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cykge1xuICAgICAgICBsZXQgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gPHByZT4vKiovLi4vPHA+LzxwPi88cmVzdD4gLT4gezxwcmU+Ly4uLzxwPi88cD4vPHJlc3Q+LDxwcmU+LyoqLzxwPi88cD4vPHJlc3Q+fVxuICAgICAgICAgICAgZm9yIChsZXQgcGFydHMgb2YgZ2xvYlBhcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdzID0gLTE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZ3MgPSBwYXJ0cy5pbmRleE9mKCcqKicsIGdzICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBnc3MgPSBncztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcnRzW2dzcyArIDFdID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA8cHJlPi8qKi8qKi88cmVzdD4gLT4gPHByZT4vKiovPHJlc3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICBnc3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlZywgaWYgZ3MgaXMgMiBhbmQgZ3NzIGlzIDQsIHRoYXQgbWVhbnMgd2UgaGF2ZSAzICoqXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcnRzLCBhbmQgY2FuIHJlbW92ZSAyIG9mIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIGlmIChnc3MgPiBncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGdzICsgMSwgZ3NzIC0gZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydHNbZ3MgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2dzICsgMl07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAyID0gcGFydHNbZ3MgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09ICcuLicpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPT09ICcuLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFwMiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPT09ICcuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVkaXQgcGFydHMgaW4gcGxhY2UsIGFuZCBwdXNoIHRoZSBuZXcgb25lXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShncywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyID0gcGFydHMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyW2dzXSA9ICcqKic7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0cy5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZ3MtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gPHByZT4vPGU+LzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHNxdWVlemUgb3V0IFVOQyBwYXR0ZXJuc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgcCA9PT0gJycgJiYgcGFydHNbMF0gPT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgPT09ICcuJyB8fCBwID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0gPT09ICcuJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocGFydHNbMV0gPT09ICcuJyB8fCBwYXJ0c1sxXSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gPHByZT4vPHA+Ly4uLzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgICAgICBsZXQgZGQgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGRkID0gcGFydHMuaW5kZXhPZignLi4nLCBkZCArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbZGQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgJiYgcCAhPT0gJy4nICYmIHAgIT09ICcuLicgJiYgcCAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWREb3QgPSBkZCA9PT0gMSAmJiBwYXJ0c1tkZCArIDFdID09PSAnKionO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaW4gPSBuZWVkRG90ID8gWycuJ10gOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShkZCAtIDEsIDIsIC4uLnNwbGluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZCAtPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaWRTb21ldGhpbmcpO1xuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzO1xuICAgIH1cbiAgICAvLyBzZWNvbmQgcGhhc2U6IG11bHRpLXBhdHRlcm4gZGVkdXBlc1xuICAgIC8vIHs8cHJlPi8qLzxyZXN0Piw8cHJlPi88cD4vPHJlc3Q+fSAtPiA8cHJlPi8qLzxyZXN0PlxuICAgIC8vIHs8cHJlPi88cmVzdD4sPHByZT4vPHJlc3Q+fSAtPiA8cHJlPi88cmVzdD5cbiAgICAvLyB7PHByZT4vKiovPHJlc3Q+LDxwcmU+LzxyZXN0Pn0gLT4gPHByZT4vKiovPHJlc3Q+XG4gICAgLy9cbiAgICAvLyB7PHByZT4vKiovPHJlc3Q+LDxwcmU+LyoqLzxwPi88cmVzdD59IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgIC8vIF4tLSBub3QgdmFsaWQgYmVjYXVzZSAqKiBkb2Vucyd0IGZvbGxvdyBzeW1saW5rc1xuICAgIHNlY29uZFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbG9iUGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBnbG9iUGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkID0gdGhpcy5wYXJ0c01hdGNoKGdsb2JQYXJ0c1tpXSwgZ2xvYlBhcnRzW2pdLCAhdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBnbG9iUGFydHNbaV0gPSBtYXRjaGVkO1xuICAgICAgICAgICAgICAgIGdsb2JQYXJ0c1tqXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iUGFydHMuZmlsdGVyKGdzID0+IGdzLmxlbmd0aCk7XG4gICAgfVxuICAgIHBhcnRzTWF0Y2goYSwgYiwgZW1wdHlHU01hdGNoID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGFpID0gMDtcbiAgICAgICAgbGV0IGJpID0gMDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgd2hpY2ggPSAnJztcbiAgICAgICAgd2hpbGUgKGFpIDwgYS5sZW5ndGggJiYgYmkgPCBiLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGFbYWldID09PSBiW2JpXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHdoaWNoID09PSAnYicgPyBiW2JpXSA6IGFbYWldKTtcbiAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbXB0eUdTTWF0Y2ggJiYgYVthaV0gPT09ICcqKicgJiYgYltiaV0gPT09IGFbYWkgKyAxXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFbYWldKTtcbiAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW1wdHlHU01hdGNoICYmIGJbYmldID09PSAnKionICYmIGFbYWldID09PSBiW2JpICsgMV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiW2JpXSk7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFbYWldID09PSAnKicgJiZcbiAgICAgICAgICAgICAgICBiW2JpXSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMuZG90IHx8ICFiW2JpXS5zdGFydHNXaXRoKCcuJykpICYmXG4gICAgICAgICAgICAgICAgYltiaV0gIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICBpZiAod2hpY2ggPT09ICdiJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWNoID0gJ2EnO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFbYWldKTtcbiAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiW2JpXSA9PT0gJyonICYmXG4gICAgICAgICAgICAgICAgYVthaV0gJiZcbiAgICAgICAgICAgICAgICAodGhpcy5vcHRpb25zLmRvdCB8fCAhYVthaV0uc3RhcnRzV2l0aCgnLicpKSAmJlxuICAgICAgICAgICAgICAgIGFbYWldICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdoaWNoID09PSAnYScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGljaCA9ICdiJztcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiW2JpXSk7XG4gICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGZhbGwgb3V0IG9mIHRoZSBsb29wLCBpdCBtZWFucyB0aGV5IHR3byBhcmUgaWRlbnRpY2FsXG4gICAgICAgIC8vIGFzIGxvbmcgYXMgdGhlaXIgbGVuZ3RocyBtYXRjaFxuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VOZWdhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vbmVnYXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuO1xuICAgICAgICBsZXQgbmVnYXRlID0gZmFsc2U7XG4gICAgICAgIGxldCBuZWdhdGVPZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoICYmIHBhdHRlcm4uY2hhckF0KGkpID09PSAnISc7IGkrKykge1xuICAgICAgICAgICAgbmVnYXRlID0gIW5lZ2F0ZTtcbiAgICAgICAgICAgIG5lZ2F0ZU9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWdhdGVPZmZzZXQpXG4gICAgICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKG5lZ2F0ZU9mZnNldCk7XG4gICAgICAgIHRoaXMubmVnYXRlID0gbmVnYXRlO1xuICAgIH1cbiAgICAvLyBzZXQgcGFydGlhbCB0byB0cnVlIHRvIHRlc3QgaWYsIGZvciBleGFtcGxlLFxuICAgIC8vIFwiL2EvYlwiIG1hdGNoZXMgdGhlIHN0YXJ0IG9mIFwiLyovYi8qL2RcIlxuICAgIC8vIFBhcnRpYWwgbWVhbnMsIGlmIHlvdSBydW4gb3V0IG9mIGZpbGUgYmVmb3JlIHlvdSBydW5cbiAgICAvLyBvdXQgb2YgcGF0dGVybiwgdGhlbiB0aGF0J3MgZmluZSwgYXMgbG9uZyBhcyBhbGxcbiAgICAvLyB0aGUgcGFydHMgbWF0Y2guXG4gICAgbWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIGEgVU5DIHBhdHRlcm4gbGlrZSAvLz8vYzovKiBjYW4gbWF0Y2ggYSBwYXRoIGxpa2UgYzoveFxuICAgICAgICAvLyBhbmQgdmljZSB2ZXJzYVxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVVTkMgPSBmaWxlWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIGZpbGVbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgZmlsZVsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGZpbGVbM10gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChmaWxlWzNdKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5VTkMgPSBwYXR0ZXJuWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIHBhdHRlcm5bMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgcGF0dGVyblsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHBhdHRlcm5bM10gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwYXR0ZXJuWzNdKTtcbiAgICAgICAgICAgIGlmIChmaWxlVU5DICYmIHBhdHRlcm5VTkMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmZCA9IGZpbGVbM107XG4gICAgICAgICAgICAgICAgY29uc3QgcGQgPSBwYXR0ZXJuWzNdO1xuICAgICAgICAgICAgICAgIGlmIChmZC50b0xvd2VyQ2FzZSgpID09PSBwZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVbM10gPSBwZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXR0ZXJuVU5DICYmIHR5cGVvZiBmaWxlWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBkID0gcGF0dGVyblszXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmZCA9IGZpbGVbMF07XG4gICAgICAgICAgICAgICAgaWYgKHBkLnRvTG93ZXJDYXNlKCkgPT09IGZkLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblszXSA9IGZkO1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWxlVU5DICYmIHR5cGVvZiBwYXR0ZXJuWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZkID0gZmlsZVszXTtcbiAgICAgICAgICAgICAgICBpZiAoZmQudG9Mb3dlckNhc2UoKSA9PT0gcGF0dGVyblswXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5bMF0gPSBmZDtcbiAgICAgICAgICAgICAgICAgICAgZmlsZSA9IGZpbGUuc2xpY2UoMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlc29sdmUgYW5kIHJlZHVjZSAuIGFuZCAuLiBwb3J0aW9ucyBpbiB0aGUgZmlsZSBhcyB3ZWxsLlxuICAgICAgICAvLyBkb250JyBuZWVkIHRvIGRvIHRoZSBzZWNvbmQgcGhhc2UsIGJlY2F1c2UgaXQncyBvbmx5IG9uZSBzdHJpbmdbXVxuICAgICAgICBjb25zdCB7IG9wdGltaXphdGlvbkxldmVsID0gMSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW1pemF0aW9uTGV2ZWwgPj0gMikge1xuICAgICAgICAgICAgZmlsZSA9IHRoaXMubGV2ZWxUd29GaWxlT3B0aW1pemUoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCB0aGlzLCB7IGZpbGUsIHBhdHRlcm4gfSk7XG4gICAgICAgIHRoaXMuZGVidWcoJ21hdGNoT25lJywgZmlsZS5sZW5ndGgsIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgZmkgPSAwLCBwaSA9IDAsIGZsID0gZmlsZS5sZW5ndGgsIHBsID0gcGF0dGVybi5sZW5ndGg7IGZpIDwgZmwgJiYgcGkgPCBwbDsgZmkrKywgcGkrKykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUgbG9vcCcpO1xuICAgICAgICAgICAgdmFyIHAgPSBwYXR0ZXJuW3BpXTtcbiAgICAgICAgICAgIHZhciBmID0gZmlsZVtmaV07XG4gICAgICAgICAgICB0aGlzLmRlYnVnKHBhdHRlcm4sIHAsIGYpO1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGltcG9zc2libGUuXG4gICAgICAgICAgICAvLyBzb21lIGludmFsaWQgcmVnZXhwIHN0dWZmIGluIHRoZSBzZXQuXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICBpZiAocCA9PT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSk7XG4gICAgICAgICAgICAgICAgLy8gXCIqKlwiXG4gICAgICAgICAgICAgICAgLy8gYS8qKi9iLyoqL2Mgd291bGQgbWF0Y2ggdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICAgICAgICAvLyBhL2IveC95L3ovY1xuICAgICAgICAgICAgICAgIC8vIGEveC95L3ovYi9jXG4gICAgICAgICAgICAgICAgLy8gYS9iL3gvYi94L2NcbiAgICAgICAgICAgICAgICAvLyBhL2IvY1xuICAgICAgICAgICAgICAgIC8vIFRvIGRvIHRoaXMsIHRha2UgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyB0aGUgKiosIGFuZCBzZWUgaWYgaXQgd291bGQgbWF0Y2ggdGhlIGZpbGUgcmVtYWluZGVyLlxuICAgICAgICAgICAgICAgIC8vIElmIHNvLCByZXR1cm4gc3VjY2Vzcy5cbiAgICAgICAgICAgICAgICAvLyBJZiBub3QsIHRoZSAqKiBcInN3YWxsb3dzXCIgYSBzZWdtZW50LCBhbmQgdHJ5IGFnYWluLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVjdXJzaXZlbHkgYXdmdWwuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBhLyoqL2IvKiovYyBtYXRjaGluZyBhL2IveC95L3ovY1xuICAgICAgICAgICAgICAgIC8vIC0gYSBtYXRjaGVzIGFcbiAgICAgICAgICAgICAgICAvLyAtIGRvdWJsZXN0YXJcbiAgICAgICAgICAgICAgICAvLyAgIC0gbWF0Y2hPbmUoYi94L3kvei9jLCBiLyoqL2MpXG4gICAgICAgICAgICAgICAgLy8gICAgIC0gYiBtYXRjaGVzIGJcbiAgICAgICAgICAgICAgICAvLyAgICAgLSBkb3VibGVzdGFyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh4L3kvei9jLCBjKSAtPiBub1xuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeS96L2MsIGMpIC0+IG5vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh6L2MsIGMpIC0+IG5vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZShjLCBjKSB5ZXMsIGhpdFxuICAgICAgICAgICAgICAgIHZhciBmciA9IGZpO1xuICAgICAgICAgICAgICAgIHZhciBwciA9IHBpICsgMTtcbiAgICAgICAgICAgICAgICBpZiAocHIgPT09IHBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJyoqIGF0IHRoZSBlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIC8vIGhvd2V2ZXIsIGl0IHdpbGwgbm90IHN3YWxsb3cgLy54LCB1bmxlc3NcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICAvLyAuIGFuZCAuLiBhcmUgKm5ldmVyKiBtYXRjaGVkIGJ5ICoqLCBmb3IgZXhwbG9zaXZlbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgcmVhc29ucy5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlW2ZpXSA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVtmaV0gPT09ICcuLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIGZpbGVbZmldLmNoYXJBdCgwKSA9PT0gJy4nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgICAgICAgICAgIHdoaWxlIChmciA8IGZsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzd2FsbG93ZWUgPSBmaWxlW2ZyXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFhYWCByZW1vdmUgdGhpcyBzbGljZS4gIEp1c3QgcGFzcyB0aGUgc3RhcnQgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoT25lKGZpbGUuc2xpY2UoZnIpLCBwYXR0ZXJuLnNsaWNlKHByKSwgcGFydGlhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIGZvdW5kIG1hdGNoIScsIGZyLCBmbCwgc3dhbGxvd2VlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbid0IHN3YWxsb3cgXCIuXCIgb3IgXCIuLlwiIGV2ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBzd2FsbG93IFwiLmZvb1wiIHdoZW4gZXhwbGljaXRseSBhc2tlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzd2FsbG93ZWUgPT09ICcuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgc3dhbGxvd2VlLmNoYXJBdCgwKSA9PT0gJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ2RvdCBkZXRlY3RlZCEnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKiogc3dhbGxvd3MgYSBzZWdtZW50LCBhbmQgY29udGludWUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5vIG1hdGNoIHdhcyBmb3VuZC5cbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCBpbiBwYXJ0aWFsIG1vZGUsIHdlIGNhbid0IHNheSB0aGlzIGlzIG5lY2Vzc2FyaWx5IG92ZXIuXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBmaWxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ1xcbj4+PiBubyBtYXRjaCwgcGFydGlhbD8nLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnIgPT09IGZsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuICoqXG4gICAgICAgICAgICAvLyBub24tbWFnaWMgcGF0dGVybnMganVzdCBoYXZlIHRvIG1hdGNoIGV4YWN0bHlcbiAgICAgICAgICAgIC8vIHBhdHRlcm5zIHdpdGggbWFnaWMgaGF2ZSBiZWVuIHR1cm5lZCBpbnRvIHJlZ2V4cHMuXG4gICAgICAgICAgICBsZXQgaGl0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGhpdCA9IGYgPT09IHA7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zygnc3RyaW5nIG1hdGNoJywgcCwgZiwgaGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpdCA9IHAudGVzdChmKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdwYXR0ZXJuIG1hdGNoJywgcCwgZiwgaGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBlbmRpbmcgaW4gLyBtZWFucyB0aGF0IHdlJ2xsIGdldCBhIGZpbmFsIFwiXCJcbiAgICAgICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybi4gIFRoaXMgY2FuIG9ubHkgbWF0Y2ggYVxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIFwiXCIgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZS5cbiAgICAgICAgLy8gSWYgdGhlIGZpbGUgZW5kcyBpbiAvLCB0aGVuIGl0IGNhbiBvbmx5IG1hdGNoIGFcbiAgICAgICAgLy8gYSBwYXR0ZXJuIHRoYXQgZW5kcyBpbiAvLCB1bmxlc3MgdGhlIHBhdHRlcm4ganVzdFxuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgYW55IG1vcmUgZm9yIGl0LiBCdXQsIGEvYi8gc2hvdWxkICpub3QqXG4gICAgICAgIC8vIG1hdGNoIFwiYS9iLypcIiwgZXZlbiB0aG91Z2ggXCJcIiBtYXRjaGVzIGFnYWluc3QgdGhlXG4gICAgICAgIC8vIFteL10qPyBwYXR0ZXJuLCBleGNlcHQgaW4gcGFydGlhbCBtb2RlLCB3aGVyZSBpdCBtaWdodFxuICAgICAgICAvLyBzaW1wbHkgbm90IGJlIHJlYWNoZWQgeWV0LlxuICAgICAgICAvLyBIb3dldmVyLCBhL2IvIHNob3VsZCBzdGlsbCBzYXRpc2Z5IGEvKlxuICAgICAgICAvLyBub3cgZWl0aGVyIHdlIGZlbGwgb2ZmIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIG9yIHdlJ3JlIGRvbmUuXG4gICAgICAgIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgICAgICAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4gYW5kIGZpbGVuYW1lIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAvLyBhbiBleGFjdCBoaXQhXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaSA9PT0gZmwpIHtcbiAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZSwgYnV0IHN0aWxsIGhhZCBwYXR0ZXJuIGxlZnQuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9rIGlmIHdlJ3JlIGRvaW5nIHRoZSBtYXRjaCBhcyBwYXJ0IG9mXG4gICAgICAgICAgICAvLyBhIGdsb2IgZnMgdHJhdmVyc2FsLlxuICAgICAgICAgICAgcmV0dXJuIHBhcnRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGkgPT09IHBsKSB7XG4gICAgICAgICAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBvbmx5IGFjY2VwdGFibGUgaWYgd2UncmUgb24gdGhlIHZlcnkgbGFzdFxuICAgICAgICAgICAgLy8gZW1wdHkgc2VnbWVudCBvZiBhIGZpbGUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICAgICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgICAgICAgICByZXR1cm4gZmkgPT09IGZsIC0gMSAmJiBmaWxlW2ZpXSA9PT0gJyc7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSB1bnJlYWNoYWJsZS5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3RmPycpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgfVxuICAgIGJyYWNlRXhwYW5kKCkge1xuICAgICAgICByZXR1cm4gYnJhY2VFeHBhbmQodGhpcy5wYXR0ZXJuLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBwYXJzZShwYXR0ZXJuKSB7XG4gICAgICAgIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gc2hvcnRjdXRzXG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnKionKVxuICAgICAgICAgICAgcmV0dXJuIEdMT0JTVEFSO1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gJycpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIC8vIGZhciBhbmQgYXdheSwgdGhlIG1vc3QgY29tbW9uIGdsb2IgcGF0dGVybiBwYXJ0cyBhcmVcbiAgICAgICAgLy8gKiwgKi4qLCBhbmQgKi48ZXh0PiAgQWRkIGEgZmFzdCBjaGVjayBtZXRob2QgZm9yIHRob3NlLlxuICAgICAgICBsZXQgbTtcbiAgICAgICAgbGV0IGZhc3RUZXN0ID0gbnVsbDtcbiAgICAgICAgaWYgKChtID0gcGF0dGVybi5tYXRjaChzdGFyUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSBvcHRpb25zLmRvdCA/IHN0YXJUZXN0RG90IDogc3RhclRlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHN0YXJEb3RFeHRSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IChvcHRpb25zLm5vY2FzZVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICAgICAgPyBzdGFyRG90RXh0VGVzdE5vY2FzZURvdFxuICAgICAgICAgICAgICAgICAgICA6IHN0YXJEb3RFeHRUZXN0Tm9jYXNlXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHN0YXJEb3RFeHRUZXN0RG90XG4gICAgICAgICAgICAgICAgICAgIDogc3RhckRvdEV4dFRlc3QpKG1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChxbWFya3NSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IChvcHRpb25zLm5vY2FzZVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICAgICAgPyBxbWFya3NUZXN0Tm9jYXNlRG90XG4gICAgICAgICAgICAgICAgICAgIDogcW1hcmtzVGVzdE5vY2FzZVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICAgICAgPyBxbWFya3NUZXN0RG90XG4gICAgICAgICAgICAgICAgICAgIDogcW1hcmtzVGVzdCkobSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHN0YXJEb3RTdGFyUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSBvcHRpb25zLmRvdCA/IHN0YXJEb3RTdGFyVGVzdERvdCA6IHN0YXJEb3RTdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goZG90U3RhclJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gZG90U3RhclRlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlID0gJyc7XG4gICAgICAgIGxldCBoYXNNYWdpYyA9IGZhbHNlO1xuICAgICAgICBsZXQgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gPyA9PiBvbmUgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICBjb25zdCBwYXR0ZXJuTGlzdFN0YWNrID0gW107XG4gICAgICAgIGNvbnN0IG5lZ2F0aXZlTGlzdHMgPSBbXTtcbiAgICAgICAgbGV0IHN0YXRlQ2hhciA9IGZhbHNlO1xuICAgICAgICBsZXQgdWZsYWcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHBsO1xuICAgICAgICAvLyAuIGFuZCAuLiBuZXZlciBtYXRjaCBhbnl0aGluZyB0aGF0IGRvZXNuJ3Qgc3RhcnQgd2l0aCAuLFxuICAgICAgICAvLyBldmVuIHdoZW4gb3B0aW9ucy5kb3QgaXMgc2V0LiAgSG93ZXZlciwgaWYgdGhlIHBhdHRlcm5cbiAgICAgICAgLy8gc3RhcnRzIHdpdGggLiwgdGhlbiB0cmF2ZXJzYWwgcGF0dGVybnMgY2FuIG1hdGNoLlxuICAgICAgICBsZXQgZG90VHJhdkFsbG93ZWQgPSBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy4nO1xuICAgICAgICBsZXQgZG90RmlsZUFsbG93ZWQgPSBvcHRpb25zLmRvdCB8fCBkb3RUcmF2QWxsb3dlZDtcbiAgICAgICAgY29uc3QgcGF0dGVyblN0YXJ0ID0gKCkgPT4gZG90VHJhdkFsbG93ZWRcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogZG90RmlsZUFsbG93ZWRcbiAgICAgICAgICAgICAgICA/ICcoPyEoPzpefFxcXFwvKVxcXFwuezEsMn0oPzokfFxcXFwvKSknXG4gICAgICAgICAgICAgICAgOiAnKD8hXFxcXC4pJztcbiAgICAgICAgY29uc3Qgc3ViUGF0dGVyblN0YXJ0ID0gKHApID0+IHAuY2hhckF0KDApID09PSAnLidcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICA/ICcoPyEoPzpefFxcXFwvKVxcXFwuezEsMn0oPzokfFxcXFwvKSknXG4gICAgICAgICAgICAgICAgOiAnKD8hXFxcXC4pJztcbiAgICAgICAgY29uc3QgY2xlYXJTdGF0ZUNoYXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhdGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgaGFkIHNvbWUgc3RhdGUtdHJhY2tpbmcgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB3YXNuJ3QgY29uc3VtZWQgYnkgdGhpcyBwYXNzLlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3RhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlICs9IHFtYXJrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWFnaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZSArPSAnXFxcXCcgKyBzdGF0ZUNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnY2xlYXJTdGF0ZUNoYXIgJWogJWonLCBzdGF0ZUNoYXIsIHJlKTtcbiAgICAgICAgICAgICAgICBzdGF0ZUNoYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGM7IGkgPCBwYXR0ZXJuLmxlbmd0aCAmJiAoYyA9IHBhdHRlcm4uY2hhckF0KGkpKTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqJywgcGF0dGVybiwgaSwgcmUsIGMpO1xuICAgICAgICAgICAgLy8gc2tpcCBvdmVyIGFueSB0aGF0IGFyZSBlc2NhcGVkLlxuICAgICAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcGxldGVseSBub3QgYWxsb3dlZCwgZXZlbiBlc2NhcGVkLlxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIGlmIChyZVNwZWNpYWxzW2NdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmUgKz0gYztcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGFscmVhZHkgYmUgcGF0aC1zcGxpdCBieSBub3cuXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgY2FzZSAnLyc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgICAgICAgICAgICBjbGVhclN0YXRlQ2hhcigpO1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIC8vIHRoZSB2YXJpb3VzIHN0YXRlQ2hhciB2YWx1ZXNcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIFwiZXh0Z2xvYlwiIHN0dWZmLlxuICAgICAgICAgICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0AnOlxuICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqIDwtLSBzdGF0ZUNoYXInLCBwYXR0ZXJuLCBpLCByZSwgYyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXRlQ2hhciwgdGhlbiBpdCBtZWFuc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHRoZXJlIHdhcyBzb21ldGhpbmcgbGlrZSAqKiBvciArPyBpbiB0aGVyZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBzdGF0ZUNoYXIsIHRoZW4gcHJvY2VlZCB3aXRoIHRoaXMgb25lLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdjYWxsIGNsZWFyU3RhdGVDaGFyICVqJywgc3RhdGVDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVDaGFyID0gYztcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZXh0Z2xvYiBpcyBkaXNhYmxlZCwgdGhlbiArKGFzZGZ8Zm9vKSBpc24ndCBhIHRoaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGNsZWFyIHRoZSBzdGF0ZWNoYXIgKm5vdyosIHJhdGhlciB0aGFuIGV2ZW4gZGl2aW5nIGludG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdHRlcm5MaXN0IHN0dWZmLlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ub2V4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyU3RhdGVDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgJygnOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZSArPSAnXFxcXCgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxFbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHN0YXRlQ2hhcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlU3RhcnQ6IHJlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW46IHBsVHlwZXNbc3RhdGVDaGFyXS5vcGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IHBsVHlwZXNbc3RhdGVDaGFyXS5jbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdcXHQnLCBwbEVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybkxpc3RTdGFjay5wdXNoKHBsRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBuZWdhdGlvbiBpcyAoPzooPyEoPzpqcykoPzo8cmVzdD4pKVteL10qKVxuICAgICAgICAgICAgICAgICAgICByZSArPSBwbEVudHJ5Lm9wZW47XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHQgZW50cnkgc3RhcnRzIHdpdGggYSBkb3QgbWF5YmU/XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbEVudHJ5LnN0YXJ0ID09PSAwICYmIHBsRW50cnkudHlwZSAhPT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RUcmF2QWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZSArPSBzdWJQYXR0ZXJuU3RhcnQocGF0dGVybi5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ3BsVHlwZSAlaiAlaicsIHN0YXRlQ2hhciwgcmUpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZUNoYXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJyknOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsRW50cnkgPSBwYXR0ZXJuTGlzdFN0YWNrW3BhdHRlcm5MaXN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGxFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmUgKz0gJ1xcXFwpJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5MaXN0U3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsb3NpbmcgYW4gZXh0Z2xvYlxuICAgICAgICAgICAgICAgICAgICBjbGVhclN0YXRlQ2hhcigpO1xuICAgICAgICAgICAgICAgICAgICBoYXNNYWdpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBsID0gcGxFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hanMpW14vXSopXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvdGhlcnMgYXJlICg/OjxwYXR0ZXJuPik8dHlwZT5cbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gcGwuY2xvc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbC50eXBlID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlTGlzdHMucHVzaChPYmplY3QuYXNzaWduKHBsLCB7IHJlRW5kOiByZS5sZW5ndGggfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd8Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbEVudHJ5ID0gcGF0dGVybkxpc3RTdGFja1twYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBsRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlICs9ICdcXFxcfCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbGVhclN0YXRlQ2hhcigpO1xuICAgICAgICAgICAgICAgICAgICByZSArPSAnfCc7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHQgc3VicGF0dGVybiBjYW4gc3RhcnQgd2l0aCBhIGRvdD9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsRW50cnkuc3RhcnQgPT09IDAgJiYgcGxFbnRyeS50eXBlICE9PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdFRyYXZBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlICs9IHN1YlBhdHRlcm5TdGFydChwYXR0ZXJuLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBtb3N0bHkgdGhlIHNhbWUgaW4gcmVnZXhwIGFuZCBnbG9iXG4gICAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlLXRyYWNraW5nIGNoYXIgYmVmb3JlIHRoZSBbXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyU3RhdGVDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzcmMsIG5lZWRVZmxhZywgY29uc3VtZWQsIG1hZ2ljXSA9IHBhcnNlQ2xhc3MocGF0dGVybiwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3JjO1xuICAgICAgICAgICAgICAgICAgICAgICAgdWZsYWcgPSB1ZmxhZyB8fCBuZWVkVWZsYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IGNvbnN1bWVkIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01hZ2ljID0gaGFzTWFnaWMgfHwgbWFnaWM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZSArPSAnXFxcXFsnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgICAgICByZSArPSAnXFxcXCcgKyBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBzd2FsbG93IGFueSBzdGF0ZSBjaGFyIHRoYXQgd2Fzbid0IGNvbnN1bWVkXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyU3RhdGVDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlICs9IHJlZ0V4cEVzY2FwZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIHN3aXRjaFxuICAgICAgICB9IC8vIGZvclxuICAgICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgaGFkIGEgKyggdGhpbmcgYXQgdGhlICplbmQqXG4gICAgICAgIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICAgICAgICAvLyBlYWNoIHBhdHRlcm4gbGlzdCBzdGFjayBhZGRzIDMgY2hhcnMsIGFuZCB3ZSBuZWVkIHRvIGdvIHRocm91Z2hcbiAgICAgICAgLy8gYW5kIGVzY2FwZSBhbnkgfCBjaGFycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXMgZm9yIHRoZSByZWdleHAuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggYW5kIGVzY2FwZSB0aGVtLCB0YWtpbmcgY2FyZSBub3QgdG8gZG91YmxlLWVzY2FwZSBhbnlcbiAgICAgICAgLy8gfCBjaGFycyB0aGF0IHdlcmUgYWxyZWFkeSBlc2NhcGVkLlxuICAgICAgICBmb3IgKHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKTsgcGw7IHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKSkge1xuICAgICAgICAgICAgbGV0IHRhaWw7XG4gICAgICAgICAgICB0YWlsID0gcmUuc2xpY2UocGwucmVTdGFydCArIHBsLm9wZW4ubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc2V0dGluZyB0YWlsJywgcmUsIHBsKTtcbiAgICAgICAgICAgIC8vIG1heWJlIHNvbWUgZXZlbiBudW1iZXIgb2YgXFwsIHRoZW4gbWF5YmUgMSBcXCwgZm9sbG93ZWQgYnkgYSB8XG4gICAgICAgICAgICB0YWlsID0gdGFpbC5yZXBsYWNlKC8oKD86XFxcXHsyfSl7MCw2NH0pKFxcXFw/KVxcfC9nLCAoXywgJDEsICQyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEkMikge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgfCBpc24ndCBhbHJlYWR5IGVzY2FwZWQsIHNvIGVzY2FwZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgJDIgPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhbHJlYWR5IGJlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBlc2NhcGUgYWxsIHRob3NlIHNsYXNoZXMgKmFnYWluKiwgd2l0aG91dCBlc2NhcGluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBvbmUgdGhhdCB3ZSBuZWVkIGZvciBlc2NhcGluZyB0aGUgfCBjaGFyYWN0ZXIuICBBcyBpdCB3b3JrcyBvdXQsXG4gICAgICAgICAgICAgICAgLy8gZXNjYXBpbmcgYW4gZXZlbiBudW1iZXIgb2Ygc2xhc2hlcyBjYW4gYmUgZG9uZSBieSBzaW1wbHkgcmVwZWF0aW5nXG4gICAgICAgICAgICAgICAgLy8gaXQgZXhhY3RseSBhZnRlciBpdHNlbGYuICBUaGF0J3Mgd2h5IHRoaXMgdHJpY2sgd29ya3MuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJIGFtIHNvcnJ5IHRoYXQgeW91IGhhdmUgdG8gc2VlIHRoaXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuICQxICsgJDEgKyAkMiArICd8JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZygndGFpbD0lalxcbiAgICVzJywgdGFpbCwgdGFpbCwgcGwsIHJlKTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBwbC50eXBlID09PSAnKicgPyBzdGFyIDogcGwudHlwZSA9PT0gJz8nID8gcW1hcmsgOiAnXFxcXCcgKyBwbC50eXBlO1xuICAgICAgICAgICAgaGFzTWFnaWMgPSB0cnVlO1xuICAgICAgICAgICAgcmUgPSByZS5zbGljZSgwLCBwbC5yZVN0YXJ0KSArIHQgKyAnXFxcXCgnICsgdGFpbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgdHJhaWxpbmcgdGhpbmdzIHRoYXQgb25seSBtYXR0ZXIgYXQgdGhlIHZlcnkgZW5kLlxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpO1xuICAgICAgICBpZiAoZXNjYXBpbmcpIHtcbiAgICAgICAgICAgIC8vIHRyYWlsaW5nIFxcXFxcbiAgICAgICAgICAgIHJlICs9ICdcXFxcXFxcXCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBuZWVkIHRvIGFwcGx5IHRoZSBub2RvdCBzdGFydCBpZiB0aGUgcmUgc3RhcnRzIHdpdGhcbiAgICAgICAgLy8gc29tZXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgY2FwdHVyZSBhIGRvdFxuICAgICAgICBjb25zdCBhZGRQYXR0ZXJuU3RhcnQgPSBhZGRQYXR0ZXJuU3RhcnRTZXRbcmUuY2hhckF0KDApXTtcbiAgICAgICAgLy8gSGFjayB0byB3b3JrIGFyb3VuZCBsYWNrIG9mIG5lZ2F0aXZlIGxvb2tiZWhpbmQgaW4gSlNcbiAgICAgICAgLy8gQSBwYXR0ZXJuIGxpa2U6ICouISh4KS4hKHl8eikgbmVlZHMgdG8gZW5zdXJlIHRoYXQgYSBuYW1lXG4gICAgICAgIC8vIGxpa2UgJ2EueHl6Lnl6JyBkb2Vzbid0IG1hdGNoLiAgU28sIHRoZSBmaXJzdCBuZWdhdGl2ZVxuICAgICAgICAvLyBsb29rYWhlYWQsIGhhcyB0byBsb29rIEFMTCB0aGUgd2F5IGFoZWFkLCB0byB0aGUgZW5kIG9mXG4gICAgICAgIC8vIHRoZSBwYXR0ZXJuLlxuICAgICAgICBmb3IgKGxldCBuID0gbmVnYXRpdmVMaXN0cy5sZW5ndGggLSAxOyBuID4gLTE7IG4tLSkge1xuICAgICAgICAgICAgY29uc3QgbmwgPSBuZWdhdGl2ZUxpc3RzW25dO1xuICAgICAgICAgICAgY29uc3QgbmxCZWZvcmUgPSByZS5zbGljZSgwLCBubC5yZVN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IG5sRmlyc3QgPSByZS5zbGljZShubC5yZVN0YXJ0LCBubC5yZUVuZCAtIDgpO1xuICAgICAgICAgICAgbGV0IG5sQWZ0ZXIgPSByZS5zbGljZShubC5yZUVuZCk7XG4gICAgICAgICAgICBjb25zdCBubExhc3QgPSByZS5zbGljZShubC5yZUVuZCAtIDgsIG5sLnJlRW5kKSArIG5sQWZ0ZXI7XG4gICAgICAgICAgICAvLyBIYW5kbGUgbmVzdGVkIHN0dWZmIGxpa2UgKigqLmpzfCEoKi5qc29uKSksIHdoZXJlIG9wZW4gcGFyZW5zXG4gICAgICAgICAgICAvLyBtZWFuIHRoYXQgd2Ugc2hvdWxkICpub3QqIGluY2x1ZGUgdGhlICkgaW4gdGhlIGJpdCB0aGF0IGlzIGNvbnNpZGVyZWRcbiAgICAgICAgICAgIC8vIFwiYWZ0ZXJcIiB0aGUgbmVnYXRlZCBzZWN0aW9uLlxuICAgICAgICAgICAgY29uc3QgY2xvc2VQYXJlbnNCZWZvcmUgPSBubEJlZm9yZS5zcGxpdCgnKScpLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5QYXJlbnNCZWZvcmUgPSBubEJlZm9yZS5zcGxpdCgnKCcpLmxlbmd0aCAtIGNsb3NlUGFyZW5zQmVmb3JlO1xuICAgICAgICAgICAgbGV0IGNsZWFuQWZ0ZXIgPSBubEFmdGVyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcGVuUGFyZW5zQmVmb3JlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjbGVhbkFmdGVyID0gY2xlYW5BZnRlci5yZXBsYWNlKC9cXClbKyo/XT8vLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBubEFmdGVyID0gY2xlYW5BZnRlcjtcbiAgICAgICAgICAgIGNvbnN0IGRvbGxhciA9IG5sQWZ0ZXIgPT09ICcnID8gJyg/OiR8XFxcXC8pJyA6ICcnO1xuICAgICAgICAgICAgcmUgPSBubEJlZm9yZSArIG5sRmlyc3QgKyBubEFmdGVyICsgZG9sbGFyICsgbmxMYXN0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSByZSBpcyBub3QgXCJcIiBhdCB0aGlzIHBvaW50LCB0aGVuIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgbWF0Y2ggYWdhaW5zdCBhbiBlbXB0eSBwYXRoIHBhcnQuXG4gICAgICAgIC8vIE90aGVyd2lzZSBhLyogd2lsbCBtYXRjaCBhLywgd2hpY2ggaXQgc2hvdWxkIG5vdC5cbiAgICAgICAgaWYgKHJlICE9PSAnJyAmJiBoYXNNYWdpYykge1xuICAgICAgICAgICAgcmUgPSAnKD89LiknICsgcmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZFBhdHRlcm5TdGFydCkge1xuICAgICAgICAgICAgcmUgPSBwYXR0ZXJuU3RhcnQoKSArIHJlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGl0J3Mgbm9jYXNlLCBhbmQgdGhlIGxjYXNlL3VwcGVyY2FzZSBkb24ndCBtYXRjaCwgaXQncyBtYWdpY1xuICAgICAgICBpZiAob3B0aW9ucy5ub2Nhc2UgJiYgIWhhc01hZ2ljICYmICFvcHRpb25zLm5vY2FzZU1hZ2ljT25seSkge1xuICAgICAgICAgICAgaGFzTWFnaWMgPSBwYXR0ZXJuLnRvVXBwZXJDYXNlKCkgIT09IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIHRoZSByZWdleHAgZm9yIG5vbi1tYWdpY2FsIHBhdHRlcm5zXG4gICAgICAgIC8vIHVuZXNjYXBlIGFueXRoaW5nIGluIGl0LCB0aG91Z2gsIHNvIHRoYXQgaXQnbGwgYmVcbiAgICAgICAgLy8gYW4gZXhhY3QgbWF0Y2ggYWdhaW5zdCBhIGZpbGUgZXRjLlxuICAgICAgICBpZiAoIWhhc01hZ2ljKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYlVuZXNjYXBlKHJlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbGFncyA9IChvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnKSArICh1ZmxhZyA/ICd1JyA6ICcnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV4dCA9IGZhc3RUZXN0XG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIF9nbG9iOiBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICBfc3JjOiByZSxcbiAgICAgICAgICAgICAgICAgICAgdGVzdDogZmFzdFRlc3QsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBfZ2xvYjogcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgX3NyYzogcmUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBSZWdFeHAoJ14nICsgcmUgKyAnJCcsIGZsYWdzKSwgZXh0KTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGltcG9zc2libGVcbiAgICAgICAgICAgIC8vIElmIGl0IHdhcyBhbiBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhlbiBpdCBjYW4ndCBtYXRjaFxuICAgICAgICAgICAgLy8gYW55dGhpbmcuICBUaGlzIHRyaWNrIGxvb2tzIGZvciBhIGNoYXJhY3RlciBhZnRlciB0aGUgZW5kIG9mXG4gICAgICAgICAgICAvLyB0aGUgc3RyaW5nLCB3aGljaCBpcyBvZiBjb3Vyc2UgaW1wb3NzaWJsZSwgZXhjZXB0IGluIG11bHRpLWxpbmVcbiAgICAgICAgICAgIC8vIG1vZGUsIGJ1dCBpdCdzIG5vdCBhIC9tIHJlZ2V4LlxuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnaW52YWxpZCByZWdleHAnLCBlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnJC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIH1cbiAgICBtYWtlUmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAgICAgICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgICAgICAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gICAgICAgIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5zZXQ7XG4gICAgICAgIGlmICghc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZWdleHAgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0d29TdGFyID0gb3B0aW9ucy5ub2dsb2JzdGFyXG4gICAgICAgICAgICA/IHN0YXJcbiAgICAgICAgICAgIDogb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICA/IHR3b1N0YXJEb3RcbiAgICAgICAgICAgICAgICA6IHR3b1N0YXJOb0RvdDtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnO1xuICAgICAgICAvLyByZWdleHBpZnkgbm9uLWdsb2JzdGFyIHBhdHRlcm5zXG4gICAgICAgIC8vIGlmICoqIGlzIG9ubHkgaXRlbSwgdGhlbiB3ZSBqdXN0IGRvIG9uZSB0d29TdGFyXG4gICAgICAgIC8vIGlmICoqIGlzIGZpcnN0LCBhbmQgdGhlcmUgYXJlIG1vcmUsIHByZXBlbmQgKFxcL3x0d29TdGFyXFwvKT8gdG8gbmV4dFxuICAgICAgICAvLyBpZiAqKiBpcyBsYXN0LCBhcHBlbmQgKFxcL3R3b1N0YXJ8KSB0byBwcmV2aW91c1xuICAgICAgICAvLyBpZiAqKiBpcyBpbiB0aGUgbWlkZGxlLCBhcHBlbmQgKFxcL3xcXC90d29TdGFyXFwvKSB0byBwcmV2aW91c1xuICAgICAgICAvLyB0aGVuIGZpbHRlciBvdXQgR0xPQlNUQVIgc3ltYm9sc1xuICAgICAgICBsZXQgcmUgPSBzZXRcbiAgICAgICAgICAgIC5tYXAocGF0dGVybiA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcCA9IHBhdHRlcm4ubWFwKHAgPT4gdHlwZW9mIHAgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyByZWdFeHBFc2NhcGUocClcbiAgICAgICAgICAgICAgICA6IHAgPT09IEdMT0JTVEFSXG4gICAgICAgICAgICAgICAgICAgID8gR0xPQlNUQVJcbiAgICAgICAgICAgICAgICAgICAgOiBwLl9zcmMpO1xuICAgICAgICAgICAgcHAuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwcFtpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHBwW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocCAhPT0gR0xPQlNUQVIgfHwgcHJldiA9PT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgbmV4dCAhPT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9ICcoPzpcXFxcL3wnICsgdHdvU3RhciArICdcXFxcLyk/JyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcFtpXSA9IHR3b1N0YXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgLSAxXSA9IHByZXYgKyAnKD86XFxcXC98JyArIHR3b1N0YXIgKyAnKT8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ICE9PSBHTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICBwcFtpIC0gMV0gPSBwcmV2ICsgJyg/OlxcXFwvfFxcXFwvJyArIHR3b1N0YXIgKyAnXFxcXC8pJyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9IEdMT0JTVEFSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBwLmZpbHRlcihwID0+IHAgIT09IEdMT0JTVEFSKS5qb2luKCcvJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignfCcpO1xuICAgICAgICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gICAgICAgIC8vIGVuZGluZyBpbiBhICogb3IgKiogd2lsbCBtYWtlIGl0IGxlc3Mgc3RyaWN0LlxuICAgICAgICByZSA9ICdeKD86JyArIHJlICsgJykkJztcbiAgICAgICAgLy8gY2FuIG1hdGNoIGFueXRoaW5nLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoaXMuXG4gICAgICAgIGlmICh0aGlzLm5lZ2F0ZSlcbiAgICAgICAgICAgIHJlID0gJ14oPyEnICsgcmUgKyAnKS4qJCc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmUsIGZsYWdzKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGltcG9zc2libGVcbiAgICAgICAgICAgIHRoaXMucmVnZXhwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwO1xuICAgIH1cbiAgICBzbGFzaFNwbGl0KHApIHtcbiAgICAgICAgLy8gaWYgcCBzdGFydHMgd2l0aCAvLyBvbiB3aW5kb3dzLCB3ZSBwcmVzZXJ2ZSB0aGF0XG4gICAgICAgIC8vIHNvIHRoYXQgVU5DIHBhdGhzIGFyZW4ndCBicm9rZW4uICBPdGhlcndpc2UsIGFueSBudW1iZXIgb2ZcbiAgICAgICAgLy8gLyBjaGFyYWN0ZXJzIGFyZSBjb2FsZXNjZWQgaW50byBvbmUsIHVubGVzc1xuICAgICAgICAvLyBwcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgICAgaWYgKHRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwLnNwbGl0KCcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1dpbmRvd3MgJiYgL15cXC9cXC9bXlxcL10rLy50ZXN0KHApKSB7XG4gICAgICAgICAgICAvLyBhZGQgYW4gZXh0cmEgJycgZm9yIHRoZSBvbmUgd2UgbG9zZVxuICAgICAgICAgICAgcmV0dXJuIFsnJywgLi4ucC5zcGxpdCgvXFwvKy8pXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwLnNwbGl0KC9cXC8rLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2goZiwgcGFydGlhbCA9IHRoaXMucGFydGlhbCkge1xuICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybik7XG4gICAgICAgIC8vIHNob3J0LWNpcmN1aXQgaW4gdGhlIGNhc2Ugb2YgYnVzdGVkIHRoaW5ncy5cbiAgICAgICAgLy8gY29tbWVudHMsIGV0Yy5cbiAgICAgICAgaWYgKHRoaXMuY29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZiA9PT0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgPT09ICcvJyAmJiBwYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyB3aW5kb3dzOiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgICAgICAgaWYgKHRoaXMuaXNXaW5kb3dzKSB7XG4gICAgICAgICAgICBmID0gZi5zcGxpdCgnXFxcXCcpLmpvaW4oJy8nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmVhdCB0aGUgdGVzdCBwYXRoIGFzIGEgc2V0IG9mIHBhdGhwYXJ0cy5cbiAgICAgICAgY29uc3QgZmYgPSB0aGlzLnNsYXNoU3BsaXQoZik7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc3BsaXQnLCBmZik7XG4gICAgICAgIC8vIGp1c3QgT05FIG9mIHRoZSBwYXR0ZXJuIHNldHMgaW4gdGhpcy5zZXQgbmVlZHMgdG8gbWF0Y2hcbiAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGl0IHRvIGJlIHZhbGlkLiAgSWYgbmVnYXRpbmcsIHRoZW4ganVzdCBvbmVcbiAgICAgICAgLy8gbWF0Y2ggbWVhbnMgdGhhdCB3ZSBoYXZlIGZhaWxlZC5cbiAgICAgICAgLy8gRWl0aGVyIHdheSwgcmV0dXJuIG9uIHRoZSBmaXJzdCBoaXQuXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuc2V0O1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldCk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGJhc2VuYW1lIG9mIHRoZSBwYXRoIGJ5IGxvb2tpbmcgZm9yIHRoZSBsYXN0IG5vbi1lbXB0eSBzZWdtZW50XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGZmW2ZmLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZmYubGVuZ3RoIC0gMjsgIWZpbGVuYW1lICYmIGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmZltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHNldFtpXTtcbiAgICAgICAgICAgIGxldCBmaWxlID0gZmY7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYXRjaEJhc2UgJiYgcGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmaWxlID0gW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhpdCA9IHRoaXMubWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbCk7XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLm5lZ2F0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBoaXRzLiAgdGhpcyBpcyBzdWNjZXNzIGlmIGl0J3MgYSBuZWdhdGl2ZVxuICAgICAgICAvLyBwYXR0ZXJuLCBmYWlsdXJlIG90aGVyd2lzZS5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRzKGRlZikge1xuICAgICAgICByZXR1cm4gbWluaW1hdGNoLmRlZmF1bHRzKGRlZikuTWluaW1hdGNoO1xuICAgIH1cbn1cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IHsgZXNjYXBlIH0gZnJvbSAnLi9lc2NhcGUuanMnO1xuZXhwb3J0IHsgdW5lc2NhcGUgfSBmcm9tICcuL3VuZXNjYXBlLmpzJztcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5taW5pbWF0Y2guTWluaW1hdGNoID0gTWluaW1hdGNoO1xubWluaW1hdGNoLmVzY2FwZSA9IGVzY2FwZTtcbm1pbmltYXRjaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImV4cGFuZCIsInBhcnNlQ2xhc3MiLCJlc2NhcGUiLCJ1bmVzY2FwZSIsIm1pbmltYXRjaCIsInAiLCJwYXR0ZXJuIiwib3B0aW9ucyIsImFzc2VydFZhbGlkUGF0dGVybiIsIm5vY29tbWVudCIsImNoYXJBdCIsIk1pbmltYXRjaCIsIm1hdGNoIiwic3RhckRvdEV4dFJFIiwic3RhckRvdEV4dFRlc3QiLCJleHQiLCJmIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic3RhckRvdEV4dFRlc3REb3QiLCJzdGFyRG90RXh0VGVzdE5vY2FzZSIsInRvTG93ZXJDYXNlIiwic3RhckRvdEV4dFRlc3ROb2Nhc2VEb3QiLCJzdGFyRG90U3RhclJFIiwic3RhckRvdFN0YXJUZXN0IiwiaW5jbHVkZXMiLCJzdGFyRG90U3RhclRlc3REb3QiLCJkb3RTdGFyUkUiLCJkb3RTdGFyVGVzdCIsInN0YXJSRSIsInN0YXJUZXN0IiwibGVuZ3RoIiwic3RhclRlc3REb3QiLCJxbWFya3NSRSIsInFtYXJrc1Rlc3ROb2Nhc2UiLCIkMCIsIm5vZXh0IiwicW1hcmtzVGVzdE5vRXh0IiwicW1hcmtzVGVzdE5vY2FzZURvdCIsInFtYXJrc1Rlc3ROb0V4dERvdCIsInFtYXJrc1Rlc3REb3QiLCJxbWFya3NUZXN0IiwibGVuIiwiZGVmYXVsdFBsYXRmb3JtIiwicHJvY2VzcyIsImVudiIsIl9fTUlOSU1BVENIX1RFU1RJTkdfUExBVEZPUk1fXyIsInBsYXRmb3JtIiwicGF0aCIsIndpbjMyIiwic2VwIiwicG9zaXgiLCJHTE9CU1RBUiIsIlN5bWJvbCIsInBsVHlwZXMiLCJvcGVuIiwiY2xvc2UiLCJxbWFyayIsInN0YXIiLCJ0d29TdGFyRG90IiwidHdvU3Rhck5vRG90IiwiY2hhclNldCIsInMiLCJzcGxpdCIsInJlZHVjZSIsInNldCIsImMiLCJyZVNwZWNpYWxzIiwiYWRkUGF0dGVyblN0YXJ0U2V0IiwiZmlsdGVyIiwiYSIsImIiLCJPYmplY3QiLCJhc3NpZ24iLCJkZWZhdWx0cyIsImRlZiIsImtleXMiLCJvcmlnIiwibSIsImNvbnN0cnVjdG9yIiwibWFrZVJlIiwiYnJhY2VFeHBhbmQiLCJsaXN0Iiwibm9icmFjZSIsInRlc3QiLCJNQVhfUEFUVEVSTl9MRU5HVEgiLCJUeXBlRXJyb3IiLCJtbSIsIm5vbnVsbCIsInB1c2giLCJnbG9iVW5lc2NhcGUiLCJyZXBsYWNlIiwiZ2xvYk1hZ2ljIiwicmVnRXhwRXNjYXBlIiwiaXNXaW5kb3dzIiwid2luZG93c1BhdGhzTm9Fc2NhcGUiLCJhbGxvd1dpbmRvd3NFc2NhcGUiLCJwcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyIsInJlZ2V4cCIsIm5lZ2F0ZSIsIm5vbmVnYXRlIiwiY29tbWVudCIsImVtcHR5IiwicGFydGlhbCIsIm5vY2FzZSIsIndpbmRvd3NOb01hZ2ljUm9vdCIsInVuZGVmaW5lZCIsImdsb2JTZXQiLCJnbG9iUGFydHMiLCJtYWtlIiwiaGFzTWFnaWMiLCJtYWdpY2FsQnJhY2VzIiwicGFydCIsImRlYnVnIiwiXyIsInBhcnNlTmVnYXRlIiwiU2V0IiwiYXJncyIsImNvbnNvbGUiLCJlcnJvciIsInJhd0dsb2JQYXJ0cyIsIm1hcCIsInNsYXNoU3BsaXQiLCJwcmVwcm9jZXNzIiwiX18iLCJpc1VOQyIsImlzRHJpdmUiLCJzbGljZSIsInNzIiwicGFyc2UiLCJpbmRleE9mIiwiaSIsIm5vZ2xvYnN0YXIiLCJqIiwib3B0aW1pemF0aW9uTGV2ZWwiLCJmaXJzdFBoYXNlUHJlUHJvY2VzcyIsInNlY29uZFBoYXNlUHJlUHJvY2VzcyIsImxldmVsT25lT3B0aW1pemUiLCJhZGphc2NlbnRHbG9ic3Rhck9wdGltaXplIiwicGFydHMiLCJncyIsInNwbGljZSIsInByZXYiLCJwb3AiLCJsZXZlbFR3b0ZpbGVPcHRpbWl6ZSIsIkFycmF5IiwiaXNBcnJheSIsImRpZFNvbWV0aGluZyIsImRkIiwiZ3NzIiwibmV4dCIsInAyIiwib3RoZXIiLCJuZWVkRG90Iiwic3BsaW4iLCJtYXRjaGVkIiwicGFydHNNYXRjaCIsImVtcHR5R1NNYXRjaCIsImFpIiwiYmkiLCJyZXN1bHQiLCJ3aGljaCIsImRvdCIsIm5lZ2F0ZU9mZnNldCIsIm1hdGNoT25lIiwiZmlsZSIsImZpbGVVTkMiLCJwYXR0ZXJuVU5DIiwiZmQiLCJwZCIsImZpIiwicGkiLCJmbCIsInBsIiwiZnIiLCJwciIsInN3YWxsb3dlZSIsImhpdCIsIkVycm9yIiwiZmFzdFRlc3QiLCJyZSIsImVzY2FwaW5nIiwicGF0dGVybkxpc3RTdGFjayIsIm5lZ2F0aXZlTGlzdHMiLCJzdGF0ZUNoYXIiLCJ1ZmxhZyIsImRvdFRyYXZBbGxvd2VkIiwiZG90RmlsZUFsbG93ZWQiLCJwYXR0ZXJuU3RhcnQiLCJzdWJQYXR0ZXJuU3RhcnQiLCJjbGVhclN0YXRlQ2hhciIsInBsRW50cnkiLCJ0eXBlIiwic3RhcnQiLCJyZVN0YXJ0IiwicmVFbmQiLCJzcmMiLCJuZWVkVWZsYWciLCJjb25zdW1lZCIsIm1hZ2ljIiwidGFpbCIsIiQxIiwiJDIiLCJ0IiwiYWRkUGF0dGVyblN0YXJ0IiwibiIsIm5sIiwibmxCZWZvcmUiLCJubEZpcnN0IiwibmxBZnRlciIsIm5sTGFzdCIsImNsb3NlUGFyZW5zQmVmb3JlIiwib3BlblBhcmVuc0JlZm9yZSIsImNsZWFuQWZ0ZXIiLCJkb2xsYXIiLCJub2Nhc2VNYWdpY09ubHkiLCJ0b1VwcGVyQ2FzZSIsImZsYWdzIiwiX2dsb2IiLCJfc3JjIiwiUmVnRXhwIiwiZXIiLCJ0d29TdGFyIiwicHAiLCJmb3JFYWNoIiwiam9pbiIsImV4IiwiZmYiLCJmaWxlbmFtZSIsIm1hdGNoQmFzZSIsImZsaXBOZWdhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/mjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/mjs/unescape.js":
/*!*****************************************************!*\
  !*** ./node_modules/minimatch/dist/mjs/unescape.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unescape: () => (/* binding */ unescape)\n/* harmony export */ });\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */ const unescape = (s, { windowsPathsNoEscape = false } = {})=>{\n    return windowsPathsNoEscape ? s.replace(/\\[([^\\/\\\\])\\]/g, \"$1\") : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, \"$1$2\").replace(/\\\\([^\\/])/g, \"$1\");\n}; //# sourceMappingURL=unescape.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL3VuZXNjYXBlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sTUFBTUEsV0FBVyxDQUFDQyxHQUFHLEVBQUVDLHVCQUF1QixLQUFLLEVBQUcsR0FBRyxDQUFDLENBQUM7SUFDOUQsT0FBT0EsdUJBQ0RELEVBQUVFLE9BQU8sQ0FBQyxrQkFBa0IsUUFDNUJGLEVBQUVFLE9BQU8sQ0FBQyw2QkFBNkIsUUFBUUEsT0FBTyxDQUFDLGNBQWM7QUFDL0UsRUFBRSxDQUNGLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvdW5lc2NhcGUuanM/ZGE4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuLWVzY2FwZSBhIHN0cmluZyB0aGF0IGhhcyBiZWVuIGVzY2FwZWQgd2l0aCB7QGxpbmsgZXNjYXBlfS5cbiAqXG4gKiBJZiB0aGUge0BsaW5rIHdpbmRvd3NQYXRoc05vRXNjYXBlfSBvcHRpb24gaXMgdXNlZCwgdGhlbiBzcXVhcmUtYnJhY2VcbiAqIGVzY2FwZXMgYXJlIHJlbW92ZWQsIGJ1dCBub3QgYmFja3NsYXNoIGVzY2FwZXMuICBGb3IgZXhhbXBsZSwgaXQgd2lsbCB0dXJuXG4gKiB0aGUgc3RyaW5nIGAnWypdJ2AgaW50byBgKmAsIGJ1dCBpdCB3aWxsIG5vdCB0dXJuIGAnXFxcXConYCBpbnRvIGAnKidgLFxuICogYmVjdWFzZSBgXFxgIGlzIGEgcGF0aCBzZXBhcmF0b3IgaW4gYHdpbmRvd3NQYXRoc05vRXNjYXBlYCBtb2RlLlxuICpcbiAqIFdoZW4gYHdpbmRvd3NQYXRoc05vRXNjYXBlYCBpcyBub3Qgc2V0LCB0aGVuIGJvdGggYnJhY2UgZXNjYXBlcyBhbmRcbiAqIGJhY2tzbGFzaCBlc2NhcGVzIGFyZSByZW1vdmVkLlxuICpcbiAqIFNsYXNoZXMgKGFuZCBiYWNrc2xhc2hlcyBpbiBgd2luZG93c1BhdGhzTm9Fc2NhcGVgIG1vZGUpIGNhbm5vdCBiZSBlc2NhcGVkXG4gKiBvciB1bmVzY2FwZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB1bmVzY2FwZSA9IChzLCB7IHdpbmRvd3NQYXRoc05vRXNjYXBlID0gZmFsc2UsIH0gPSB7fSkgPT4ge1xuICAgIHJldHVybiB3aW5kb3dzUGF0aHNOb0VzY2FwZVxuICAgICAgICA/IHMucmVwbGFjZSgvXFxbKFteXFwvXFxcXF0pXFxdL2csICckMScpXG4gICAgICAgIDogcy5yZXBsYWNlKC8oKD8hXFxcXCkufF4pXFxbKFteXFwvXFxcXF0pXFxdL2csICckMSQyJykucmVwbGFjZSgvXFxcXChbXlxcL10pL2csICckMScpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZXNjYXBlLmpzLm1hcCJdLCJuYW1lcyI6WyJ1bmVzY2FwZSIsInMiLCJ3aW5kb3dzUGF0aHNOb0VzY2FwZSIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/mjs/unescape.js\n");

/***/ })

};
;