"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/js-base64";
exports.ids = ["vendor-chunks/js-base64"];
exports.modules = {

/***/ "(ssr)/./node_modules/js-base64/base64.mjs":
/*!*******************************************!*\
  !*** ./node_modules/js-base64/base64.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base64: () => (/* binding */ gBase64),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   atob: () => (/* binding */ _atob),\n/* harmony export */   atobPolyfill: () => (/* binding */ atobPolyfill),\n/* harmony export */   btoa: () => (/* binding */ _btoa),\n/* harmony export */   btoaPolyfill: () => (/* binding */ btoaPolyfill),\n/* harmony export */   btou: () => (/* binding */ btou),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeURI: () => (/* binding */ encodeURI),\n/* harmony export */   encodeURL: () => (/* binding */ encodeURI),\n/* harmony export */   extendBuiltins: () => (/* binding */ extendBuiltins),\n/* harmony export */   extendString: () => (/* binding */ extendString),\n/* harmony export */   extendUint8Array: () => (/* binding */ extendUint8Array),\n/* harmony export */   fromBase64: () => (/* binding */ decode),\n/* harmony export */   fromUint8Array: () => (/* binding */ fromUint8Array),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   toBase64: () => (/* binding */ encode),\n/* harmony export */   toUint8Array: () => (/* binding */ toUint8Array),\n/* harmony export */   utob: () => (/* binding */ utob),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */ const version = \"3.7.5\";\n/**\n * @deprecated use lowercase `version`.\n */ const VERSION = version;\nconst _hasatob = typeof atob === \"function\";\nconst _hasbtoa = typeof btoa === \"function\";\nconst _hasBuffer = typeof Buffer === \"function\";\nconst _TD = typeof TextDecoder === \"function\" ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === \"function\" ? new TextEncoder() : undefined;\nconst b64ch = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a)=>{\n    let tab = {};\n    a.forEach((c, i)=>tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === \"function\" ? Uint8Array.from.bind(Uint8Array) : (it)=>new Uint8Array(Array.prototype.slice.call(it, 0));\nconst _mkUriSafe = (src)=>src.replace(/=/g, \"\").replace(/[+\\/]/g, (m0)=>m0 == \"+\" ? \"-\" : \"_\");\nconst _tidyB64 = (s)=>s.replace(/[^A-Za-z0-9\\+\\/]/g, \"\");\n/**\n * polyfill version of `btoa`\n */ const btoaPolyfill = (bin)=>{\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = \"\";\n    const pad = bin.length % 3;\n    for(let i = 0; i < bin.length;){\n        if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) throw new TypeError(\"invalid character found\");\n        u32 = c0 << 16 | c1 << 8 | c2;\n        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */ const _btoa = _hasbtoa ? (bin)=>btoa(bin) : _hasBuffer ? (bin)=>Buffer.from(bin, \"binary\").toString(\"base64\") : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer ? (u8a)=>Buffer.from(u8a).toString(\"base64\") : (u8a)=>{\n    // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n    const maxargs = 0x1000;\n    let strs = [];\n    for(let i = 0, l = u8a.length; i < l; i += maxargs){\n        strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n    }\n    return _btoa(strs.join(\"\"));\n};\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 ยง5\n * @returns {string} Base64 string\n */ const fromUint8Array = (u8a, urlsafe = false)=>urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c)=>{\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c : cc < 0x800 ? _fromCC(0xc0 | cc >>> 6) + _fromCC(0x80 | cc & 0x3f) : _fromCC(0xe0 | cc >>> 12 & 0x0f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);\n    } else {\n        var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);\n        return _fromCC(0xf0 | cc >>> 18 & 0x07) + _fromCC(0x80 | cc >>> 12 & 0x3f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */ const utob = (u)=>u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer ? (s)=>Buffer.from(s, \"utf8\").toString(\"base64\") : _TE ? (s)=>_fromUint8Array(_TE.encode(s)) : (s)=>_btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */ const encode = (src, urlsafe = false)=>urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 ยง5.\n * @returns {string} Base64 string\n */ const encodeURI = (src)=>encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc)=>{\n    switch(cccc.length){\n        case 4:\n            var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3), offset = cp - 0x10000;\n            return _fromCC((offset >>> 10) + 0xD800) + _fromCC((offset & 0x3FF) + 0xDC00);\n        case 3:\n            return _fromCC((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));\n        default:\n            return _fromCC((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */ const btou = (b)=>b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */ const atobPolyfill = (asc)=>{\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, \"\");\n    if (!b64re.test(asc)) throw new TypeError(\"malformed base64.\");\n    asc += \"==\".slice(2 - (asc.length & 3));\n    let u24, bin = \"\", r1, r2;\n    for(let i = 0; i < asc.length;){\n        u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */ const _atob = _hasatob ? (asc)=>atob(_tidyB64(asc)) : _hasBuffer ? (asc)=>Buffer.from(asc, \"base64\").toString(\"binary\") : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer ? (a)=>_U8Afrom(Buffer.from(a, \"base64\")) : (a)=>_U8Afrom(_atob(a).split(\"\").map((c)=>c.charCodeAt(0)));\n/**\n * converts a Base64 string to a Uint8Array.\n */ const toUint8Array = (a)=>_toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer ? (a)=>Buffer.from(a, \"base64\").toString(\"utf8\") : _TD ? (a)=>_TD.decode(_toUint8Array(a)) : (a)=>btou(_atob(a));\nconst _unURI = (a)=>_tidyB64(a.replace(/[-_]/g, (m0)=>m0 == \"-\" ? \"+\" : \"/\"));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */ const decode = (src)=>_decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */ const isValid = (src)=>{\n    if (typeof src !== \"string\") return false;\n    const s = src.replace(/\\s+/g, \"\").replace(/={0,2}$/, \"\");\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v)=>{\n    return {\n        value: v,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */ const extendString = function() {\n    const _add = (name, body)=>Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add(\"fromBase64\", function() {\n        return decode(this);\n    });\n    _add(\"toBase64\", function(urlsafe) {\n        return encode(this, urlsafe);\n    });\n    _add(\"toBase64URI\", function() {\n        return encode(this, true);\n    });\n    _add(\"toBase64URL\", function() {\n        return encode(this, true);\n    });\n    _add(\"toUint8Array\", function() {\n        return toUint8Array(this);\n    });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */ const extendUint8Array = function() {\n    const _add = (name, body)=>Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add(\"toBase64\", function(urlsafe) {\n        return fromUint8Array(this, urlsafe);\n    });\n    _add(\"toBase64URI\", function() {\n        return fromUint8Array(this, true);\n    });\n    _add(\"toBase64URL\", function() {\n        return fromUint8Array(this, true);\n    });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */ const extendBuiltins = ()=>{\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins\n};\n// makecjs:CUT //\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// and finally,\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELE1BQU1BLFVBQVU7QUFDaEI7O0NBRUMsR0FDRCxNQUFNQyxVQUFVRDtBQUNoQixNQUFNRSxXQUFXLE9BQU9DLFNBQVM7QUFDakMsTUFBTUMsV0FBVyxPQUFPQyxTQUFTO0FBQ2pDLE1BQU1DLGFBQWEsT0FBT0MsV0FBVztBQUNyQyxNQUFNQyxNQUFNLE9BQU9DLGdCQUFnQixhQUFhLElBQUlBLGdCQUFnQkM7QUFDcEUsTUFBTUMsTUFBTSxPQUFPQyxnQkFBZ0IsYUFBYSxJQUFJQSxnQkFBZ0JGO0FBQ3BFLE1BQU1HLFFBQVE7QUFDZCxNQUFNQyxTQUFTQyxNQUFNQyxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDTDtBQUMxQyxNQUFNTSxTQUFTLENBQUMsQ0FBQ0M7SUFDYixJQUFJQyxNQUFNLENBQUM7SUFDWEQsRUFBRUUsT0FBTyxDQUFDLENBQUNDLEdBQUdDLElBQU1ILEdBQUcsQ0FBQ0UsRUFBRSxHQUFHQztJQUM3QixPQUFPSDtBQUNYLEdBQUdQO0FBQ0gsTUFBTVcsUUFBUTtBQUNkLE1BQU1DLFVBQVVDLE9BQU9DLFlBQVksQ0FBQ0MsSUFBSSxDQUFDRjtBQUN6QyxNQUFNRyxXQUFXLE9BQU9DLFdBQVdDLElBQUksS0FBSyxhQUN0Q0QsV0FBV0MsSUFBSSxDQUFDSCxJQUFJLENBQUNFLGNBQ3JCLENBQUNFLEtBQU8sSUFBSUYsV0FBV2hCLE1BQU1DLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNlLElBQUk7QUFDNUQsTUFBTUMsYUFBYSxDQUFDQyxNQUFRQSxJQUN2QkMsT0FBTyxDQUFDLE1BQU0sSUFBSUEsT0FBTyxDQUFDLFVBQVUsQ0FBQ0MsS0FBT0EsTUFBTSxNQUFNLE1BQU07QUFDbkUsTUFBTUMsV0FBVyxDQUFDQyxJQUFNQSxFQUFFSCxPQUFPLENBQUMscUJBQXFCO0FBQ3ZEOztDQUVDLEdBQ0QsTUFBTUksZUFBZSxDQUFDQztJQUNsQiw2QkFBNkI7SUFDN0IsSUFBSUMsS0FBS0MsSUFBSUMsSUFBSUMsSUFBSUMsTUFBTTtJQUMzQixNQUFNQyxNQUFNTixJQUFJTyxNQUFNLEdBQUc7SUFDekIsSUFBSyxJQUFJeEIsSUFBSSxHQUFHQSxJQUFJaUIsSUFBSU8sTUFBTSxFQUFHO1FBQzdCLElBQUksQ0FBQ0wsS0FBS0YsSUFBSVEsVUFBVSxDQUFDekIsSUFBRyxJQUFLLE9BQzdCLENBQUNvQixLQUFLSCxJQUFJUSxVQUFVLENBQUN6QixJQUFHLElBQUssT0FDN0IsQ0FBQ3FCLEtBQUtKLElBQUlRLFVBQVUsQ0FBQ3pCLElBQUcsSUFBSyxLQUM3QixNQUFNLElBQUkwQixVQUFVO1FBQ3hCUixNQUFNLE1BQU8sS0FBT0UsTUFBTSxJQUFLQztRQUMvQkMsT0FBT2hDLE1BQU0sQ0FBQzRCLE9BQU8sS0FBSyxHQUFHLEdBQ3ZCNUIsTUFBTSxDQUFDNEIsT0FBTyxLQUFLLEdBQUcsR0FDdEI1QixNQUFNLENBQUM0QixPQUFPLElBQUksR0FBRyxHQUNyQjVCLE1BQU0sQ0FBQzRCLE1BQU0sR0FBRztJQUMxQjtJQUNBLE9BQU9LLE1BQU1ELElBQUk3QixLQUFLLENBQUMsR0FBRzhCLE1BQU0sS0FBSyxNQUFNSSxTQUFTLENBQUNKLE9BQU9EO0FBQ2hFO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU1NLFFBQVFoRCxXQUFXLENBQUNxQyxNQUFRcEMsS0FBS29DLE9BQ2pDbkMsYUFBYSxDQUFDbUMsTUFBUWxDLE9BQU95QixJQUFJLENBQUNTLEtBQUssVUFBVVksUUFBUSxDQUFDLFlBQ3REYjtBQUNWLE1BQU1jLGtCQUFrQmhELGFBQ2xCLENBQUNpRCxNQUFRaEQsT0FBT3lCLElBQUksQ0FBQ3VCLEtBQUtGLFFBQVEsQ0FBQyxZQUNuQyxDQUFDRTtJQUNDLHlIQUF5SDtJQUN6SCxNQUFNQyxVQUFVO0lBQ2hCLElBQUlDLE9BQU8sRUFBRTtJQUNiLElBQUssSUFBSWpDLElBQUksR0FBR2tDLElBQUlILElBQUlQLE1BQU0sRUFBRXhCLElBQUlrQyxHQUFHbEMsS0FBS2dDLFFBQVM7UUFDakRDLEtBQUtFLElBQUksQ0FBQ2pDLFFBQVFrQyxLQUFLLENBQUMsTUFBTUwsSUFBSU0sUUFBUSxDQUFDckMsR0FBR0EsSUFBSWdDO0lBQ3REO0lBQ0EsT0FBT0osTUFBTUssS0FBS0ssSUFBSSxDQUFDO0FBQzNCO0FBQ0o7Ozs7Q0FJQyxHQUNELE1BQU1DLGlCQUFpQixDQUFDUixLQUFLUyxVQUFVLEtBQUssR0FBS0EsVUFBVTlCLFdBQVdvQixnQkFBZ0JDLFFBQVFELGdCQUFnQkM7QUFDOUcsOEVBQThFO0FBQzlFLG1FQUFtRTtBQUNuRSxxQ0FBcUM7QUFDckMsTUFBTVUsVUFBVSxDQUFDMUM7SUFDYixJQUFJQSxFQUFFeUIsTUFBTSxHQUFHLEdBQUc7UUFDZCxJQUFJa0IsS0FBSzNDLEVBQUUwQixVQUFVLENBQUM7UUFDdEIsT0FBT2lCLEtBQUssT0FBTzNDLElBQ2IyQyxLQUFLLFFBQVN4QyxRQUFRLE9BQVF3QyxPQUFPLEtBQ2pDeEMsUUFBUSxPQUFRd0MsS0FBSyxRQUNwQnhDLFFBQVEsT0FBUSxPQUFRLEtBQU0sUUFDM0JBLFFBQVEsT0FBUSxPQUFRLElBQUssUUFDN0JBLFFBQVEsT0FBUXdDLEtBQUs7SUFDdkMsT0FDSztRQUNELElBQUlBLEtBQUssVUFDSCxDQUFDM0MsRUFBRTBCLFVBQVUsQ0FBQyxLQUFLLE1BQUssSUFBSyxRQUM1QjFCLENBQUFBLEVBQUUwQixVQUFVLENBQUMsS0FBSyxNQUFLO1FBQzlCLE9BQVF2QixRQUFRLE9BQVEsT0FBUSxLQUFNLFFBQ2hDQSxRQUFRLE9BQVEsT0FBUSxLQUFNLFFBQzlCQSxRQUFRLE9BQVEsT0FBUSxJQUFLLFFBQzdCQSxRQUFRLE9BQVF3QyxLQUFLO0lBQy9CO0FBQ0o7QUFDQSxNQUFNQyxVQUFVO0FBQ2hCOzs7O0NBSUMsR0FDRCxNQUFNQyxPQUFPLENBQUNDLElBQU1BLEVBQUVqQyxPQUFPLENBQUMrQixTQUFTRjtBQUN2QyxFQUFFO0FBQ0YsTUFBTUssVUFBVWhFLGFBQ1YsQ0FBQ2lDLElBQU1oQyxPQUFPeUIsSUFBSSxDQUFDTyxHQUFHLFFBQVFjLFFBQVEsQ0FBQyxZQUN2QzFDLE1BQ0ksQ0FBQzRCLElBQU1lLGdCQUFnQjNDLElBQUk0RCxNQUFNLENBQUNoQyxNQUNsQyxDQUFDQSxJQUFNYSxNQUFNZ0IsS0FBSzdCO0FBQzVCOzs7O0NBSUMsR0FDRCxNQUFNZ0MsU0FBUyxDQUFDcEMsS0FBSzZCLFVBQVUsS0FBSyxHQUFLQSxVQUNuQzlCLFdBQVdvQyxRQUFRbkMsUUFDbkJtQyxRQUFRbkM7QUFDZDs7O0NBR0MsR0FDRCxNQUFNcUMsWUFBWSxDQUFDckMsTUFBUW9DLE9BQU9wQyxLQUFLO0FBQ3ZDLDhFQUE4RTtBQUM5RSxpRUFBaUU7QUFDakUscUNBQXFDO0FBQ3JDLE1BQU1zQyxVQUFVO0FBQ2hCLE1BQU1DLFVBQVUsQ0FBQ0M7SUFDYixPQUFRQSxLQUFLM0IsTUFBTTtRQUNmLEtBQUs7WUFDRCxJQUFJNEIsS0FBSyxDQUFFLE9BQU9ELEtBQUsxQixVQUFVLENBQUMsRUFBQyxLQUFNLEtBQ2xDLENBQUMsT0FBTzBCLEtBQUsxQixVQUFVLENBQUMsRUFBQyxLQUFNLEtBQy9CLENBQUMsT0FBTzBCLEtBQUsxQixVQUFVLENBQUMsRUFBQyxLQUFNLElBQy9CLE9BQU8wQixLQUFLMUIsVUFBVSxDQUFDLElBQUs0QixTQUFTRCxLQUFLO1lBQ2pELE9BQVFsRCxRQUFRLENBQUNtRCxXQUFXLEVBQUMsSUFBSyxVQUM1Qm5ELFFBQVEsQ0FBQ21ELFNBQVMsS0FBSSxJQUFLO1FBQ3JDLEtBQUs7WUFDRCxPQUFPbkQsUUFBUSxDQUFFLE9BQU9pRCxLQUFLMUIsVUFBVSxDQUFDLEVBQUMsS0FBTSxLQUN4QyxDQUFDLE9BQU8wQixLQUFLMUIsVUFBVSxDQUFDLEVBQUMsS0FBTSxJQUMvQixPQUFPMEIsS0FBSzFCLFVBQVUsQ0FBQztRQUNsQztZQUNJLE9BQU92QixRQUFRLENBQUUsT0FBT2lELEtBQUsxQixVQUFVLENBQUMsRUFBQyxLQUFNLElBQ3hDLE9BQU8wQixLQUFLMUIsVUFBVSxDQUFDO0lBQ3RDO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTTZCLE9BQU8sQ0FBQ0MsSUFBTUEsRUFBRTNDLE9BQU8sQ0FBQ3FDLFNBQVNDO0FBQ3ZDOztDQUVDLEdBQ0QsTUFBTU0sZUFBZSxDQUFDbEM7SUFDbEIsNkJBQTZCO0lBQzdCQSxNQUFNQSxJQUFJVixPQUFPLENBQUMsUUFBUTtJQUMxQixJQUFJLENBQUNYLE1BQU13RCxJQUFJLENBQUNuQyxNQUNaLE1BQU0sSUFBSUksVUFBVTtJQUN4QkosT0FBTyxLQUFLN0IsS0FBSyxDQUFDLElBQUs2QixDQUFBQSxJQUFJRSxNQUFNLEdBQUc7SUFDcEMsSUFBSWtDLEtBQUt6QyxNQUFNLElBQUkwQyxJQUFJQztJQUN2QixJQUFLLElBQUk1RCxJQUFJLEdBQUdBLElBQUlzQixJQUFJRSxNQUFNLEVBQUc7UUFDN0JrQyxNQUFNL0QsTUFBTSxDQUFDMkIsSUFBSXVDLE1BQU0sQ0FBQzdELEtBQUssSUFBSSxLQUMzQkwsTUFBTSxDQUFDMkIsSUFBSXVDLE1BQU0sQ0FBQzdELEtBQUssSUFBSSxLQUMzQixDQUFDMkQsS0FBS2hFLE1BQU0sQ0FBQzJCLElBQUl1QyxNQUFNLENBQUM3RCxLQUFLLEtBQUssSUFDakM0RCxDQUFBQSxLQUFLakUsTUFBTSxDQUFDMkIsSUFBSXVDLE1BQU0sQ0FBQzdELEtBQUs7UUFDbkNpQixPQUFPMEMsT0FBTyxLQUFLekQsUUFBUXdELE9BQU8sS0FBSyxPQUNqQ0UsT0FBTyxLQUFLMUQsUUFBUXdELE9BQU8sS0FBSyxLQUFLQSxPQUFPLElBQUksT0FDNUN4RCxRQUFRd0QsT0FBTyxLQUFLLEtBQUtBLE9BQU8sSUFBSSxLQUFLQSxNQUFNO0lBQzdEO0lBQ0EsT0FBT3pDO0FBQ1g7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTTZDLFFBQVFwRixXQUFXLENBQUM0QyxNQUFRM0MsS0FBS21DLFNBQVNRLFFBQzFDeEMsYUFBYSxDQUFDd0MsTUFBUXZDLE9BQU95QixJQUFJLENBQUNjLEtBQUssVUFBVU8sUUFBUSxDQUFDLFlBQ3REMkI7QUFDVixFQUFFO0FBQ0YsTUFBTU8sZ0JBQWdCakYsYUFDaEIsQ0FBQ2MsSUFBTVUsU0FBU3ZCLE9BQU95QixJQUFJLENBQUNaLEdBQUcsYUFDL0IsQ0FBQ0EsSUFBTVUsU0FBU3dELE1BQU1sRSxHQUFHb0UsS0FBSyxDQUFDLElBQUlDLEdBQUcsQ0FBQ2xFLENBQUFBLElBQUtBLEVBQUUwQixVQUFVLENBQUM7QUFDL0Q7O0NBRUMsR0FDRCxNQUFNeUMsZUFBZSxDQUFDdEUsSUFBTW1FLGNBQWNJLE9BQU92RTtBQUNqRCxFQUFFO0FBQ0YsTUFBTXdFLFVBQVV0RixhQUNWLENBQUNjLElBQU1iLE9BQU95QixJQUFJLENBQUNaLEdBQUcsVUFBVWlDLFFBQVEsQ0FBQyxVQUN6QzdDLE1BQ0ksQ0FBQ1ksSUFBTVosSUFBSXFGLE1BQU0sQ0FBQ04sY0FBY25FLE1BQ2hDLENBQUNBLElBQU0wRCxLQUFLUSxNQUFNbEU7QUFDNUIsTUFBTXVFLFNBQVMsQ0FBQ3ZFLElBQU1rQixTQUFTbEIsRUFBRWdCLE9BQU8sQ0FBQyxTQUFTLENBQUNDLEtBQU9BLE1BQU0sTUFBTSxNQUFNO0FBQzVFOzs7O0NBSUMsR0FDRCxNQUFNd0QsU0FBUyxDQUFDMUQsTUFBUXlELFFBQVFELE9BQU94RDtBQUN2Qzs7O0VBR0UsR0FDRixNQUFNMkQsVUFBVSxDQUFDM0Q7SUFDYixJQUFJLE9BQU9BLFFBQVEsVUFDZixPQUFPO0lBQ1gsTUFBTUksSUFBSUosSUFBSUMsT0FBTyxDQUFDLFFBQVEsSUFBSUEsT0FBTyxDQUFDLFdBQVc7SUFDckQsT0FBTyxDQUFDLG9CQUFvQjZDLElBQUksQ0FBQzFDLE1BQU0sQ0FBQyxvQkFBb0IwQyxJQUFJLENBQUMxQztBQUNyRTtBQUNBLEVBQUU7QUFDRixNQUFNd0QsVUFBVSxDQUFDQztJQUNiLE9BQU87UUFDSEMsT0FBT0Q7UUFBR0UsWUFBWTtRQUFPQyxVQUFVO1FBQU1DLGNBQWM7SUFDL0Q7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTUMsZUFBZTtJQUNqQixNQUFNQyxPQUFPLENBQUNDLE1BQU1DLE9BQVNDLE9BQU9DLGNBQWMsQ0FBQy9FLE9BQU9YLFNBQVMsRUFBRXVGLE1BQU1SLFFBQVFTO0lBQ25GRixLQUFLLGNBQWM7UUFBYyxPQUFPVCxPQUFPLElBQUk7SUFBRztJQUN0RFMsS0FBSyxZQUFZLFNBQVV0QyxPQUFPO1FBQUksT0FBT08sT0FBTyxJQUFJLEVBQUVQO0lBQVU7SUFDcEVzQyxLQUFLLGVBQWU7UUFBYyxPQUFPL0IsT0FBTyxJQUFJLEVBQUU7SUFBTztJQUM3RCtCLEtBQUssZUFBZTtRQUFjLE9BQU8vQixPQUFPLElBQUksRUFBRTtJQUFPO0lBQzdEK0IsS0FBSyxnQkFBZ0I7UUFBYyxPQUFPWixhQUFhLElBQUk7SUFBRztBQUNsRTtBQUNBOztDQUVDLEdBQ0QsTUFBTWlCLG1CQUFtQjtJQUNyQixNQUFNTCxPQUFPLENBQUNDLE1BQU1DLE9BQVNDLE9BQU9DLGNBQWMsQ0FBQzNFLFdBQVdmLFNBQVMsRUFBRXVGLE1BQU1SLFFBQVFTO0lBQ3ZGRixLQUFLLFlBQVksU0FBVXRDLE9BQU87UUFBSSxPQUFPRCxlQUFlLElBQUksRUFBRUM7SUFBVTtJQUM1RXNDLEtBQUssZUFBZTtRQUFjLE9BQU92QyxlQUFlLElBQUksRUFBRTtJQUFPO0lBQ3JFdUMsS0FBSyxlQUFlO1FBQWMsT0FBT3ZDLGVBQWUsSUFBSSxFQUFFO0lBQU87QUFDekU7QUFDQTs7Q0FFQyxHQUNELE1BQU02QyxpQkFBaUI7SUFDbkJQO0lBQ0FNO0FBQ0o7QUFDQSxNQUFNRSxVQUFVO0lBQ1o3RyxTQUFTQTtJQUNUQyxTQUFTQTtJQUNURSxNQUFNbUY7SUFDTk4sY0FBY0E7SUFDZDNFLE1BQU0rQztJQUNOWixjQUFjQTtJQUNkc0UsWUFBWWpCO0lBQ1prQixVQUFVeEM7SUFDVkEsUUFBUUE7SUFDUkMsV0FBV0E7SUFDWHdDLFdBQVd4QztJQUNYSixNQUFNQTtJQUNOVSxNQUFNQTtJQUNOZSxRQUFRQTtJQUNSQyxTQUFTQTtJQUNUL0IsZ0JBQWdCQTtJQUNoQjJCLGNBQWNBO0lBQ2RXLGNBQWNBO0lBQ2RNLGtCQUFrQkE7SUFDbEJDLGdCQUFnQkE7QUFDcEI7QUFDQSxpQkFBaUI7QUFDRTtBQUNBO0FBQ007QUFDRDtBQUNDO0FBQ0Q7QUFDUTtBQUNGO0FBQ2Q7QUFDRTtBQUNHO0FBQ2E7QUFDbEI7QUFDRTtBQUNDO0FBQ087QUFDRjtBQUNBO0FBQ0k7QUFDRjtBQUMxQixlQUFlO0FBQ2MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5tanM/ZmQ3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBiYXNlNjQudHNcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxuICogICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqICBSZWZlcmVuY2VzOlxuICogICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjRcbiAqXG4gKiBAYXV0aG9yIERhbiBLb2dhaSAoaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpKVxuICovXG5jb25zdCB2ZXJzaW9uID0gJzMuNy41Jztcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGxvd2VyY2FzZSBgdmVyc2lvbmAuXG4gKi9cbmNvbnN0IFZFUlNJT04gPSB2ZXJzaW9uO1xuY29uc3QgX2hhc2F0b2IgPSB0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IF9oYXNidG9hID0gdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbic7XG5jb25zdCBfaGFzQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IF9URCA9IHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBUZXh0RGVjb2RlcigpIDogdW5kZWZpbmVkO1xuY29uc3QgX1RFID0gdHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nID8gbmV3IFRleHRFbmNvZGVyKCkgOiB1bmRlZmluZWQ7XG5jb25zdCBiNjRjaCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5jb25zdCBiNjRjaHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChiNjRjaCk7XG5jb25zdCBiNjR0YWIgPSAoKGEpID0+IHtcbiAgICBsZXQgdGFiID0ge307XG4gICAgYS5mb3JFYWNoKChjLCBpKSA9PiB0YWJbY10gPSBpKTtcbiAgICByZXR1cm4gdGFiO1xufSkoYjY0Y2hzKTtcbmNvbnN0IGI2NHJlID0gL14oPzpbQS1aYS16XFxkK1xcL117NH0pKj8oPzpbQS1aYS16XFxkK1xcL117Mn0oPzo9PSk/fFtBLVphLXpcXGQrXFwvXXszfT0/KT8kLztcbmNvbnN0IF9mcm9tQ0MgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmJpbmQoU3RyaW5nKTtcbmNvbnN0IF9VOEFmcm9tID0gdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gVWludDhBcnJheS5mcm9tLmJpbmQoVWludDhBcnJheSlcbiAgICA6IChpdCkgPT4gbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaXQsIDApKTtcbmNvbnN0IF9ta1VyaVNhZmUgPSAoc3JjKSA9PiBzcmNcbiAgICAucmVwbGFjZSgvPS9nLCAnJykucmVwbGFjZSgvWytcXC9dL2csIChtMCkgPT4gbTAgPT0gJysnID8gJy0nIDogJ18nKTtcbmNvbnN0IF90aWR5QjY0ID0gKHMpID0+IHMucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKTtcbi8qKlxuICogcG9seWZpbGwgdmVyc2lvbiBvZiBgYnRvYWBcbiAqL1xuY29uc3QgYnRvYVBvbHlmaWxsID0gKGJpbikgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdwb2x5ZmlsbGVkJyk7XG4gICAgbGV0IHUzMiwgYzAsIGMxLCBjMiwgYXNjID0gJyc7XG4gICAgY29uc3QgcGFkID0gYmluLmxlbmd0aCAlIDM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOykge1xuICAgICAgICBpZiAoKGMwID0gYmluLmNoYXJDb2RlQXQoaSsrKSkgPiAyNTUgfHxcbiAgICAgICAgICAgIChjMSA9IGJpbi5jaGFyQ29kZUF0KGkrKykpID4gMjU1IHx8XG4gICAgICAgICAgICAoYzIgPSBiaW4uY2hhckNvZGVBdChpKyspKSA+IDI1NSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2hhcmFjdGVyIGZvdW5kJyk7XG4gICAgICAgIHUzMiA9IChjMCA8PCAxNikgfCAoYzEgPDwgOCkgfCBjMjtcbiAgICAgICAgYXNjICs9IGI2NGNoc1t1MzIgPj4gMTggJiA2M11cbiAgICAgICAgICAgICsgYjY0Y2hzW3UzMiA+PiAxMiAmIDYzXVxuICAgICAgICAgICAgKyBiNjRjaHNbdTMyID4+IDYgJiA2M11cbiAgICAgICAgICAgICsgYjY0Y2hzW3UzMiAmIDYzXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZCA/IGFzYy5zbGljZSgwLCBwYWQgLSAzKSArIFwiPT09XCIuc3Vic3RyaW5nKHBhZCkgOiBhc2M7XG59O1xuLyoqXG4gKiBkb2VzIHdoYXQgYHdpbmRvdy5idG9hYCBvZiB3ZWIgYnJvd3NlcnMgZG8uXG4gKiBAcGFyYW0ge1N0cmluZ30gYmluIGJpbmFyeSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICovXG5jb25zdCBfYnRvYSA9IF9oYXNidG9hID8gKGJpbikgPT4gYnRvYShiaW4pXG4gICAgOiBfaGFzQnVmZmVyID8gKGJpbikgPT4gQnVmZmVyLmZyb20oYmluLCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgIDogYnRvYVBvbHlmaWxsO1xuY29uc3QgX2Zyb21VaW50OEFycmF5ID0gX2hhc0J1ZmZlclxuICAgID8gKHU4YSkgPT4gQnVmZmVyLmZyb20odThhKS50b1N0cmluZygnYmFzZTY0JylcbiAgICA6ICh1OGEpID0+IHtcbiAgICAgICAgLy8gY2YuIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNzEwMDAxL2hvdy10by1jb252ZXJ0LXVpbnQ4LWFycmF5LXRvLWJhc2U2NC1lbmNvZGVkLXN0cmluZy8xMjcxMzMyNiMxMjcxMzMyNlxuICAgICAgICBjb25zdCBtYXhhcmdzID0gMHgxMDAwO1xuICAgICAgICBsZXQgc3RycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHU4YS5sZW5ndGg7IGkgPCBsOyBpICs9IG1heGFyZ3MpIHtcbiAgICAgICAgICAgIHN0cnMucHVzaChfZnJvbUNDLmFwcGx5KG51bGwsIHU4YS5zdWJhcnJheShpLCBpICsgbWF4YXJncykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2J0b2Eoc3Rycy5qb2luKCcnKSk7XG4gICAgfTtcbi8qKlxuICogY29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VybHNhZmVdIFVSTC1hbmQtZmlsZW5hbWUtc2FmZSBhIGxhIFJGQzQ2NDggwqc1XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gKi9cbmNvbnN0IGZyb21VaW50OEFycmF5ID0gKHU4YSwgdXJsc2FmZSA9IGZhbHNlKSA9PiB1cmxzYWZlID8gX21rVXJpU2FmZShfZnJvbVVpbnQ4QXJyYXkodThhKSkgOiBfZnJvbVVpbnQ4QXJyYXkodThhKTtcbi8vIFRoaXMgdHJpY2sgaXMgZm91bmQgYnJva2VuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzEzMFxuLy8gY29uc3QgdXRvYiA9IChzcmM6IHN0cmluZykgPT4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHNyYykpO1xuLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuY29uc3QgY2JfdXRvYiA9IChjKSA9PiB7XG4gICAgaWYgKGMubGVuZ3RoIDwgMikge1xuICAgICAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJldHVybiBjYyA8IDB4ODAgPyBjXG4gICAgICAgICAgICA6IGNjIDwgMHg4MDAgPyAoX2Zyb21DQygweGMwIHwgKGNjID4+PiA2KSlcbiAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSlcbiAgICAgICAgICAgICAgICA6IChfZnJvbUNDKDB4ZTAgfCAoKGNjID4+PiAxMikgJiAweDBmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY2MgPSAweDEwMDAwXG4gICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMCkgLSAweEQ4MDApICogMHg0MDBcbiAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgxKSAtIDB4REMwMCk7XG4gICAgICAgIHJldHVybiAoX2Zyb21DQygweGYwIHwgKChjYyA+Pj4gMTgpICYgMHgwNykpXG4gICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8ICgoY2MgPj4+IDEyKSAmIDB4M2YpKVxuICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoY2MgJiAweDNmKSkpO1xuICAgIH1cbn07XG5jb25zdCByZV91dG9iID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRkZdfFteXFx4MDAtXFx4N0ZdL2c7XG4vKipcbiAqIEBkZXByZWNhdGVkIHNob3VsZCBoYXZlIGJlZW4gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFVURi04IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gVVRGLTE2IHN0cmluZ1xuICovXG5jb25zdCB1dG9iID0gKHUpID0+IHUucmVwbGFjZShyZV91dG9iLCBjYl91dG9iKTtcbi8vXG5jb25zdCBfZW5jb2RlID0gX2hhc0J1ZmZlclxuICAgID8gKHMpID0+IEJ1ZmZlci5mcm9tKHMsICd1dGY4JykudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgOiBfVEVcbiAgICAgICAgPyAocykgPT4gX2Zyb21VaW50OEFycmF5KF9URS5lbmNvZGUocykpXG4gICAgICAgIDogKHMpID0+IF9idG9hKHV0b2IocykpO1xuLyoqXG4gKiBjb252ZXJ0cyBhIFVURi04LWVuY29kZWQgc3RyaW5nIHRvIGEgQmFzZTY0IHN0cmluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VybHNhZmVdIGlmIGB0cnVlYCBtYWtlIHRoZSByZXN1bHQgVVJMLXNhZmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBzdHJpbmdcbiAqL1xuY29uc3QgZW5jb2RlID0gKHNyYywgdXJsc2FmZSA9IGZhbHNlKSA9PiB1cmxzYWZlXG4gICAgPyBfbWtVcmlTYWZlKF9lbmNvZGUoc3JjKSlcbiAgICA6IF9lbmNvZGUoc3JjKTtcbi8qKlxuICogY29udmVydHMgYSBVVEYtOC1lbmNvZGVkIHN0cmluZyB0byBVUkwtc2FmZSBCYXNlNjQgUkZDNDY0OCDCpzUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gKi9cbmNvbnN0IGVuY29kZVVSSSA9IChzcmMpID0+IGVuY29kZShzcmMsIHRydWUpO1xuLy8gVGhpcyB0cmljayBpcyBmb3VuZCBicm9rZW4gaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWJhc2U2NC9pc3N1ZXMvMTMwXG4vLyBjb25zdCBidG91ID0gKHNyYzogc3RyaW5nKSA9PiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHNyYykpO1xuLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuY29uc3QgcmVfYnRvdSA9IC9bXFx4QzAtXFx4REZdW1xceDgwLVxceEJGXXxbXFx4RTAtXFx4RUZdW1xceDgwLVxceEJGXXsyfXxbXFx4RjAtXFx4RjddW1xceDgwLVxceEJGXXszfS9nO1xuY29uc3QgY2JfYnRvdSA9IChjY2NjKSA9PiB7XG4gICAgc3dpdGNoIChjY2NjLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB2YXIgY3AgPSAoKDB4MDcgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDE4KVxuICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCAxMilcbiAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgyKSkgPDwgNilcbiAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDMpKSwgb2Zmc2V0ID0gY3AgLSAweDEwMDAwO1xuICAgICAgICAgICAgcmV0dXJuIChfZnJvbUNDKChvZmZzZXQgPj4+IDEwKSArIDB4RDgwMClcbiAgICAgICAgICAgICAgICArIF9mcm9tQ0MoKG9mZnNldCAmIDB4M0ZGKSArIDB4REMwMCkpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2Zyb21DQygoKDB4MGYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDEyKVxuICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCA2KVxuICAgICAgICAgICAgICAgIHwgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBfZnJvbUNDKCgoMHgxZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgNilcbiAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSk7XG4gICAgfVxufTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgc2hvdWxkIGhhdmUgYmVlbiBpbnRlcm5hbCB1c2Ugb25seS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVVRGLTE2IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gVVRGLTggc3RyaW5nXG4gKi9cbmNvbnN0IGJ0b3UgPSAoYikgPT4gYi5yZXBsYWNlKHJlX2J0b3UsIGNiX2J0b3UpO1xuLyoqXG4gKiBwb2x5ZmlsbCB2ZXJzaW9uIG9mIGBhdG9iYFxuICovXG5jb25zdCBhdG9iUG9seWZpbGwgPSAoYXNjKSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ3BvbHlmaWxsZWQnKTtcbiAgICBhc2MgPSBhc2MucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgaWYgKCFiNjRyZS50ZXN0KGFzYykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21hbGZvcm1lZCBiYXNlNjQuJyk7XG4gICAgYXNjICs9ICc9PScuc2xpY2UoMiAtIChhc2MubGVuZ3RoICYgMykpO1xuICAgIGxldCB1MjQsIGJpbiA9ICcnLCByMSwgcjI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc2MubGVuZ3RoOykge1xuICAgICAgICB1MjQgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSA8PCAxOFxuICAgICAgICAgICAgfCBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSA8PCAxMlxuICAgICAgICAgICAgfCAocjEgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSkgPDwgNlxuICAgICAgICAgICAgfCAocjIgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSk7XG4gICAgICAgIGJpbiArPSByMSA9PT0gNjQgPyBfZnJvbUNDKHUyNCA+PiAxNiAmIDI1NSlcbiAgICAgICAgICAgIDogcjIgPT09IDY0ID8gX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUsIHUyNCA+PiA4ICYgMjU1KVxuICAgICAgICAgICAgICAgIDogX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUsIHUyNCA+PiA4ICYgMjU1LCB1MjQgJiAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gYmluO1xufTtcbi8qKlxuICogZG9lcyB3aGF0IGB3aW5kb3cuYXRvYmAgb2Ygd2ViIGJyb3dzZXJzIGRvLlxuICogQHBhcmFtIHtTdHJpbmd9IGFzYyBCYXNlNjQtZW5jb2RlZCBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGJpbmFyeSBzdHJpbmdcbiAqL1xuY29uc3QgX2F0b2IgPSBfaGFzYXRvYiA/IChhc2MpID0+IGF0b2IoX3RpZHlCNjQoYXNjKSlcbiAgICA6IF9oYXNCdWZmZXIgPyAoYXNjKSA9PiBCdWZmZXIuZnJvbShhc2MsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5JylcbiAgICAgICAgOiBhdG9iUG9seWZpbGw7XG4vL1xuY29uc3QgX3RvVWludDhBcnJheSA9IF9oYXNCdWZmZXJcbiAgICA/IChhKSA9PiBfVThBZnJvbShCdWZmZXIuZnJvbShhLCAnYmFzZTY0JykpXG4gICAgOiAoYSkgPT4gX1U4QWZyb20oX2F0b2IoYSkuc3BsaXQoJycpLm1hcChjID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuLyoqXG4gKiBjb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICovXG5jb25zdCB0b1VpbnQ4QXJyYXkgPSAoYSkgPT4gX3RvVWludDhBcnJheShfdW5VUkkoYSkpO1xuLy9cbmNvbnN0IF9kZWNvZGUgPSBfaGFzQnVmZmVyXG4gICAgPyAoYSkgPT4gQnVmZmVyLmZyb20oYSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCd1dGY4JylcbiAgICA6IF9URFxuICAgICAgICA/IChhKSA9PiBfVEQuZGVjb2RlKF90b1VpbnQ4QXJyYXkoYSkpXG4gICAgICAgIDogKGEpID0+IGJ0b3UoX2F0b2IoYSkpO1xuY29uc3QgX3VuVVJJID0gKGEpID0+IF90aWR5QjY0KGEucmVwbGFjZSgvWy1fXS9nLCAobTApID0+IG0wID09ICctJyA/ICcrJyA6ICcvJykpO1xuLyoqXG4gKiBjb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSBVVEYtOCBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjIEJhc2U2NCBzdHJpbmcuICBCb3RoIG5vcm1hbCBhbmQgVVJMLXNhZmUgYXJlIHN1cHBvcnRlZFxuICogQHJldHVybnMge3N0cmluZ30gVVRGLTggc3RyaW5nXG4gKi9cbmNvbnN0IGRlY29kZSA9IChzcmMpID0+IF9kZWNvZGUoX3VuVVJJKHNyYykpO1xuLyoqXG4gKiBjaGVjayBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgQmFzZTY0IHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHNyYyBhIHZhbHVlIHRvIGNoZWNrXG4gICovXG5jb25zdCBpc1ZhbGlkID0gKHNyYykgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHMgPSBzcmMucmVwbGFjZSgvXFxzKy9nLCAnJykucmVwbGFjZSgvPXswLDJ9JC8sICcnKTtcbiAgICByZXR1cm4gIS9bXlxcczAtOWEtekEtWlxcKy9dLy50ZXN0KHMpIHx8ICEvW15cXHMwLTlhLXpBLVpcXC1fXS8udGVzdChzKTtcbn07XG4vL1xuY29uc3QgX25vRW51bSA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHYsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfTtcbn07XG4vKipcbiAqIGV4dGVuZCBTdHJpbmcucHJvdG90eXBlIHdpdGggcmVsZXZhbnQgbWV0aG9kc1xuICovXG5jb25zdCBleHRlbmRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgX2FkZCA9IChuYW1lLCBib2R5KSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgbmFtZSwgX25vRW51bShib2R5KSk7XG4gICAgX2FkZCgnZnJvbUJhc2U2NCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZSh0aGlzKTsgfSk7XG4gICAgX2FkZCgndG9CYXNlNjQnLCBmdW5jdGlvbiAodXJsc2FmZSkgeyByZXR1cm4gZW5jb2RlKHRoaXMsIHVybHNhZmUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgX2FkZCgndG9CYXNlNjRVUkwnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGUodGhpcywgdHJ1ZSk7IH0pO1xuICAgIF9hZGQoJ3RvVWludDhBcnJheScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzKTsgfSk7XG59O1xuLyoqXG4gKiBleHRlbmQgVWludDhBcnJheS5wcm90b3R5cGUgd2l0aCByZWxldmFudCBtZXRob2RzXG4gKi9cbmNvbnN0IGV4dGVuZFVpbnQ4QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgX2FkZCA9IChuYW1lLCBib2R5KSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoVWludDhBcnJheS5wcm90b3R5cGUsIG5hbWUsIF9ub0VudW0oYm9keSkpO1xuICAgIF9hZGQoJ3RvQmFzZTY0JywgZnVuY3Rpb24gKHVybHNhZmUpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHVybHNhZmUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHRydWUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSTCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHRydWUpOyB9KTtcbn07XG4vKipcbiAqIGV4dGVuZCBCdWlsdGluIHByb3RvdHlwZXMgd2l0aCByZWxldmFudCBtZXRob2RzXG4gKi9cbmNvbnN0IGV4dGVuZEJ1aWx0aW5zID0gKCkgPT4ge1xuICAgIGV4dGVuZFN0cmluZygpO1xuICAgIGV4dGVuZFVpbnQ4QXJyYXkoKTtcbn07XG5jb25zdCBnQmFzZTY0ID0ge1xuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgVkVSU0lPTjogVkVSU0lPTixcbiAgICBhdG9iOiBfYXRvYixcbiAgICBhdG9iUG9seWZpbGw6IGF0b2JQb2x5ZmlsbCxcbiAgICBidG9hOiBfYnRvYSxcbiAgICBidG9hUG9seWZpbGw6IGJ0b2FQb2x5ZmlsbCxcbiAgICBmcm9tQmFzZTY0OiBkZWNvZGUsXG4gICAgdG9CYXNlNjQ6IGVuY29kZSxcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBlbmNvZGVVUkk6IGVuY29kZVVSSSxcbiAgICBlbmNvZGVVUkw6IGVuY29kZVVSSSxcbiAgICB1dG9iOiB1dG9iLFxuICAgIGJ0b3U6IGJ0b3UsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICBmcm9tVWludDhBcnJheTogZnJvbVVpbnQ4QXJyYXksXG4gICAgdG9VaW50OEFycmF5OiB0b1VpbnQ4QXJyYXksXG4gICAgZXh0ZW5kU3RyaW5nOiBleHRlbmRTdHJpbmcsXG4gICAgZXh0ZW5kVWludDhBcnJheTogZXh0ZW5kVWludDhBcnJheSxcbiAgICBleHRlbmRCdWlsdGluczogZXh0ZW5kQnVpbHRpbnMsXG59O1xuLy8gbWFrZWNqczpDVVQgLy9cbmV4cG9ydCB7IHZlcnNpb24gfTtcbmV4cG9ydCB7IFZFUlNJT04gfTtcbmV4cG9ydCB7IF9hdG9iIGFzIGF0b2IgfTtcbmV4cG9ydCB7IGF0b2JQb2x5ZmlsbCB9O1xuZXhwb3J0IHsgX2J0b2EgYXMgYnRvYSB9O1xuZXhwb3J0IHsgYnRvYVBvbHlmaWxsIH07XG5leHBvcnQgeyBkZWNvZGUgYXMgZnJvbUJhc2U2NCB9O1xuZXhwb3J0IHsgZW5jb2RlIGFzIHRvQmFzZTY0IH07XG5leHBvcnQgeyB1dG9iIH07XG5leHBvcnQgeyBlbmNvZGUgfTtcbmV4cG9ydCB7IGVuY29kZVVSSSB9O1xuZXhwb3J0IHsgZW5jb2RlVVJJIGFzIGVuY29kZVVSTCB9O1xuZXhwb3J0IHsgYnRvdSB9O1xuZXhwb3J0IHsgZGVjb2RlIH07XG5leHBvcnQgeyBpc1ZhbGlkIH07XG5leHBvcnQgeyBmcm9tVWludDhBcnJheSB9O1xuZXhwb3J0IHsgdG9VaW50OEFycmF5IH07XG5leHBvcnQgeyBleHRlbmRTdHJpbmcgfTtcbmV4cG9ydCB7IGV4dGVuZFVpbnQ4QXJyYXkgfTtcbmV4cG9ydCB7IGV4dGVuZEJ1aWx0aW5zIH07XG4vLyBhbmQgZmluYWxseSxcbmV4cG9ydCB7IGdCYXNlNjQgYXMgQmFzZTY0IH07XG4iXSwibmFtZXMiOlsidmVyc2lvbiIsIlZFUlNJT04iLCJfaGFzYXRvYiIsImF0b2IiLCJfaGFzYnRvYSIsImJ0b2EiLCJfaGFzQnVmZmVyIiwiQnVmZmVyIiwiX1REIiwiVGV4dERlY29kZXIiLCJ1bmRlZmluZWQiLCJfVEUiLCJUZXh0RW5jb2RlciIsImI2NGNoIiwiYjY0Y2hzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJiNjR0YWIiLCJhIiwidGFiIiwiZm9yRWFjaCIsImMiLCJpIiwiYjY0cmUiLCJfZnJvbUNDIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYmluZCIsIl9VOEFmcm9tIiwiVWludDhBcnJheSIsImZyb20iLCJpdCIsIl9ta1VyaVNhZmUiLCJzcmMiLCJyZXBsYWNlIiwibTAiLCJfdGlkeUI2NCIsInMiLCJidG9hUG9seWZpbGwiLCJiaW4iLCJ1MzIiLCJjMCIsImMxIiwiYzIiLCJhc2MiLCJwYWQiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiVHlwZUVycm9yIiwic3Vic3RyaW5nIiwiX2J0b2EiLCJ0b1N0cmluZyIsIl9mcm9tVWludDhBcnJheSIsInU4YSIsIm1heGFyZ3MiLCJzdHJzIiwibCIsInB1c2giLCJhcHBseSIsInN1YmFycmF5Iiwiam9pbiIsImZyb21VaW50OEFycmF5IiwidXJsc2FmZSIsImNiX3V0b2IiLCJjYyIsInJlX3V0b2IiLCJ1dG9iIiwidSIsIl9lbmNvZGUiLCJlbmNvZGUiLCJlbmNvZGVVUkkiLCJyZV9idG91IiwiY2JfYnRvdSIsImNjY2MiLCJjcCIsIm9mZnNldCIsImJ0b3UiLCJiIiwiYXRvYlBvbHlmaWxsIiwidGVzdCIsInUyNCIsInIxIiwicjIiLCJjaGFyQXQiLCJfYXRvYiIsIl90b1VpbnQ4QXJyYXkiLCJzcGxpdCIsIm1hcCIsInRvVWludDhBcnJheSIsIl91blVSSSIsIl9kZWNvZGUiLCJkZWNvZGUiLCJpc1ZhbGlkIiwiX25vRW51bSIsInYiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImV4dGVuZFN0cmluZyIsIl9hZGQiLCJuYW1lIiwiYm9keSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXh0ZW5kVWludDhBcnJheSIsImV4dGVuZEJ1aWx0aW5zIiwiZ0Jhc2U2NCIsImZyb21CYXNlNjQiLCJ0b0Jhc2U2NCIsImVuY29kZVVSTCIsIkJhc2U2NCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/js-base64/base64.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/js-base64/base64.mjs":
/*!*******************************************!*\
  !*** ./node_modules/js-base64/base64.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base64: () => (/* binding */ gBase64),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   atob: () => (/* binding */ _atob),\n/* harmony export */   atobPolyfill: () => (/* binding */ atobPolyfill),\n/* harmony export */   btoa: () => (/* binding */ _btoa),\n/* harmony export */   btoaPolyfill: () => (/* binding */ btoaPolyfill),\n/* harmony export */   btou: () => (/* binding */ btou),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeURI: () => (/* binding */ encodeURI),\n/* harmony export */   encodeURL: () => (/* binding */ encodeURI),\n/* harmony export */   extendBuiltins: () => (/* binding */ extendBuiltins),\n/* harmony export */   extendString: () => (/* binding */ extendString),\n/* harmony export */   extendUint8Array: () => (/* binding */ extendUint8Array),\n/* harmony export */   fromBase64: () => (/* binding */ decode),\n/* harmony export */   fromUint8Array: () => (/* binding */ fromUint8Array),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   toBase64: () => (/* binding */ encode),\n/* harmony export */   toUint8Array: () => (/* binding */ toUint8Array),\n/* harmony export */   utob: () => (/* binding */ utob),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */ const version = \"3.7.5\";\n/**\n * @deprecated use lowercase `version`.\n */ const VERSION = version;\nconst _hasatob = typeof atob === \"function\";\nconst _hasbtoa = typeof btoa === \"function\";\nconst _hasBuffer = typeof Buffer === \"function\";\nconst _TD = typeof TextDecoder === \"function\" ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === \"function\" ? new TextEncoder() : undefined;\nconst b64ch = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a)=>{\n    let tab = {};\n    a.forEach((c, i)=>tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === \"function\" ? Uint8Array.from.bind(Uint8Array) : (it)=>new Uint8Array(Array.prototype.slice.call(it, 0));\nconst _mkUriSafe = (src)=>src.replace(/=/g, \"\").replace(/[+\\/]/g, (m0)=>m0 == \"+\" ? \"-\" : \"_\");\nconst _tidyB64 = (s)=>s.replace(/[^A-Za-z0-9\\+\\/]/g, \"\");\n/**\n * polyfill version of `btoa`\n */ const btoaPolyfill = (bin)=>{\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = \"\";\n    const pad = bin.length % 3;\n    for(let i = 0; i < bin.length;){\n        if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) throw new TypeError(\"invalid character found\");\n        u32 = c0 << 16 | c1 << 8 | c2;\n        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */ const _btoa = _hasbtoa ? (bin)=>btoa(bin) : _hasBuffer ? (bin)=>Buffer.from(bin, \"binary\").toString(\"base64\") : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer ? (u8a)=>Buffer.from(u8a).toString(\"base64\") : (u8a)=>{\n    // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n    const maxargs = 0x1000;\n    let strs = [];\n    for(let i = 0, l = u8a.length; i < l; i += maxargs){\n        strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n    }\n    return _btoa(strs.join(\"\"));\n};\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 ยง5\n * @returns {string} Base64 string\n */ const fromUint8Array = (u8a, urlsafe = false)=>urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c)=>{\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c : cc < 0x800 ? _fromCC(0xc0 | cc >>> 6) + _fromCC(0x80 | cc & 0x3f) : _fromCC(0xe0 | cc >>> 12 & 0x0f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);\n    } else {\n        var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);\n        return _fromCC(0xf0 | cc >>> 18 & 0x07) + _fromCC(0x80 | cc >>> 12 & 0x3f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */ const utob = (u)=>u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer ? (s)=>Buffer.from(s, \"utf8\").toString(\"base64\") : _TE ? (s)=>_fromUint8Array(_TE.encode(s)) : (s)=>_btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */ const encode = (src, urlsafe = false)=>urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 ยง5.\n * @returns {string} Base64 string\n */ const encodeURI = (src)=>encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc)=>{\n    switch(cccc.length){\n        case 4:\n            var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3), offset = cp - 0x10000;\n            return _fromCC((offset >>> 10) + 0xD800) + _fromCC((offset & 0x3FF) + 0xDC00);\n        case 3:\n            return _fromCC((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));\n        default:\n            return _fromCC((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */ const btou = (b)=>b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */ const atobPolyfill = (asc)=>{\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, \"\");\n    if (!b64re.test(asc)) throw new TypeError(\"malformed base64.\");\n    asc += \"==\".slice(2 - (asc.length & 3));\n    let u24, bin = \"\", r1, r2;\n    for(let i = 0; i < asc.length;){\n        u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */ const _atob = _hasatob ? (asc)=>atob(_tidyB64(asc)) : _hasBuffer ? (asc)=>Buffer.from(asc, \"base64\").toString(\"binary\") : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer ? (a)=>_U8Afrom(Buffer.from(a, \"base64\")) : (a)=>_U8Afrom(_atob(a).split(\"\").map((c)=>c.charCodeAt(0)));\n/**\n * converts a Base64 string to a Uint8Array.\n */ const toUint8Array = (a)=>_toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer ? (a)=>Buffer.from(a, \"base64\").toString(\"utf8\") : _TD ? (a)=>_TD.decode(_toUint8Array(a)) : (a)=>btou(_atob(a));\nconst _unURI = (a)=>_tidyB64(a.replace(/[-_]/g, (m0)=>m0 == \"-\" ? \"+\" : \"/\"));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */ const decode = (src)=>_decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */ const isValid = (src)=>{\n    if (typeof src !== \"string\") return false;\n    const s = src.replace(/\\s+/g, \"\").replace(/={0,2}$/, \"\");\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v)=>{\n    return {\n        value: v,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */ const extendString = function() {\n    const _add = (name, body)=>Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add(\"fromBase64\", function() {\n        return decode(this);\n    });\n    _add(\"toBase64\", function(urlsafe) {\n        return encode(this, urlsafe);\n    });\n    _add(\"toBase64URI\", function() {\n        return encode(this, true);\n    });\n    _add(\"toBase64URL\", function() {\n        return encode(this, true);\n    });\n    _add(\"toUint8Array\", function() {\n        return toUint8Array(this);\n    });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */ const extendUint8Array = function() {\n    const _add = (name, body)=>Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add(\"toBase64\", function(urlsafe) {\n        return fromUint8Array(this, urlsafe);\n    });\n    _add(\"toBase64URI\", function() {\n        return fromUint8Array(this, true);\n    });\n    _add(\"toBase64URL\", function() {\n        return fromUint8Array(this, true);\n    });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */ const extendBuiltins = ()=>{\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins\n};\n// makecjs:CUT //\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// and finally,\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELE1BQU1BLFVBQVU7QUFDaEI7O0NBRUMsR0FDRCxNQUFNQyxVQUFVRDtBQUNoQixNQUFNRSxXQUFXLE9BQU9DLFNBQVM7QUFDakMsTUFBTUMsV0FBVyxPQUFPQyxTQUFTO0FBQ2pDLE1BQU1DLGFBQWEsT0FBT0MsV0FBVztBQUNyQyxNQUFNQyxNQUFNLE9BQU9DLGdCQUFnQixhQUFhLElBQUlBLGdCQUFnQkM7QUFDcEUsTUFBTUMsTUFBTSxPQUFPQyxnQkFBZ0IsYUFBYSxJQUFJQSxnQkFBZ0JGO0FBQ3BFLE1BQU1HLFFBQVE7QUFDZCxNQUFNQyxTQUFTQyxNQUFNQyxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDTDtBQUMxQyxNQUFNTSxTQUFTLENBQUMsQ0FBQ0M7SUFDYixJQUFJQyxNQUFNLENBQUM7SUFDWEQsRUFBRUUsT0FBTyxDQUFDLENBQUNDLEdBQUdDLElBQU1ILEdBQUcsQ0FBQ0UsRUFBRSxHQUFHQztJQUM3QixPQUFPSDtBQUNYLEdBQUdQO0FBQ0gsTUFBTVcsUUFBUTtBQUNkLE1BQU1DLFVBQVVDLE9BQU9DLFlBQVksQ0FBQ0MsSUFBSSxDQUFDRjtBQUN6QyxNQUFNRyxXQUFXLE9BQU9DLFdBQVdDLElBQUksS0FBSyxhQUN0Q0QsV0FBV0MsSUFBSSxDQUFDSCxJQUFJLENBQUNFLGNBQ3JCLENBQUNFLEtBQU8sSUFBSUYsV0FBV2hCLE1BQU1DLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNlLElBQUk7QUFDNUQsTUFBTUMsYUFBYSxDQUFDQyxNQUFRQSxJQUN2QkMsT0FBTyxDQUFDLE1BQU0sSUFBSUEsT0FBTyxDQUFDLFVBQVUsQ0FBQ0MsS0FBT0EsTUFBTSxNQUFNLE1BQU07QUFDbkUsTUFBTUMsV0FBVyxDQUFDQyxJQUFNQSxFQUFFSCxPQUFP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LGNBQWNBO0lBQ2RXLGNBQWNBO0lBQ2RNLGtCQUFrQkE7SUFDbEJDLGdCQUFnQkE7QUFDcEI7QUFDQSxpQkFBaUI7QUFDRTtBQUNBO0FBQ007QUFDRDtBQUNDO0FBQ0Q7QUFDUTtBQUNGO0FBQ2Q7QUFDRTtBQUNHO0FBQ2E7QUFDbEI7QUFDRTtBQUNDO0FBQ087QUFDRjtBQUNBO0FBQ0k7QUFDRjtBQUMxQixlQUFlO0FBQ2MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5tanM/ZmQ3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBiYXNlNjQudHNcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxuICogICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqICBSZWZlcmVuY2VzOlxuICogICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjRcbiAqXG4gKiBAYXV0aG9yIERhbiBLb2dhaSAoaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpKVxuICovXG5jb25zdCB2ZXJzaW9uID0gJzMuNy41Jztcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGxvd2VyY2FzZSBgdmVyc2lvbmAuXG4gKi9cbmNvbnN0IFZFUlNJT04gPSB2ZXJzaW9uO1xuY29uc3QgX2hhc2F0b2IgPSB0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IF9oYXNidG9hID0gdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbic7XG5jb25zdCBfaGFzQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IF9URCA9IHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBUZXh0RGVjb2RlcigpIDogdW5kZWZpbmVkO1xuY29uc3QgX1RFID0gdHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nID8gbmV3IFRleHRFbmNvZGVyKCkgOiB1bmRlZmluZWQ7XG5jb25zdCBiNjRjaCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5jb25zdCBiNjRjaHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChiNjRjaCk7XG5jb25zdCBiNjR0YWIgPSAoKGEpID0+IHtcbiAgICBsZXQgdGFiID0ge307XG4gICAgYS5mb3JFYWNoKChjLCBpKSA9PiB0YWJbY10gPSBpKTtcbiAgICByZXR1cm4gdGFiO1xufSkoYjY0Y2hzKTtcbmNvbnN0IGI2NHJlID0gL14oPzpbQS1aYS16XFxkK1xcL117NH0pKj8oPzpbQS1aYS16XFxkK1xcL117Mn0oPzo9PSk/fFtBLVphLXpcXGQrXFwvXXszfT0/KT8kLztcbmNvbnN0IF9mcm9tQ0MgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmJpbmQoU3RyaW5nKTtcbmNvbnN0IF9VOEFmcm9tID0gdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gVWludDhBcnJheS5mcm9tLmJpbmQoVWludDhBcnJheSlcbiAgICA6IChpdCkgPT4gbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaXQsIDApKTtcbmNvbnN0IF9ta1VyaVNhZmUgPSAoc3JjKSA9PiBzcmNcbiAgICAucmVwbGFjZSgvPS9nLCAnJykucmVwbGFjZSgvWytcXC9dL2csIChtMCkgPT4gbTAgPT0gJysnID8gJy0nIDogJ18nKTtcbmNvbnN0IF90aWR5QjY0ID0gKHMpID0+IHMucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKTtcbi8qKlxuICogcG9seWZpbGwgdmVyc2lvbiBvZiBgYnRvYWBcbiAqL1xuY29uc3QgYnRvYVBvbHlmaWxsID0gKGJpbikgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdwb2x5ZmlsbGVkJyk7XG4gICAgbGV0IHUzMiwgYzAsIGMxLCBjMiwgYXNjID0gJyc7XG4gICAgY29uc3QgcGFkID0gYmluLmxlbmd0aCAlIDM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOykge1xuICAgICAgICBpZiAoKGMwID0gYmluLmNoYXJDb2RlQXQoaSsrKSkgPiAyNTUgfHxcbiAgICAgICAgICAgIChjMSA9IGJpbi5jaGFyQ29kZUF0KGkrKykpID4gMjU1IHx8XG4gICAgICAgICAgICAoYzIgPSBiaW4uY2hhckNvZGVBdChpKyspKSA+IDI1NSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2hhcmFjdGVyIGZvdW5kJyk7XG4gICAgICAgIHUzMiA9IChjMCA8PCAxNikgfCAoYzEgPDwgOCkgfCBjMjtcbiAgICAgICAgYXNjICs9IGI2NGNoc1t1MzIgPj4gMTggJiA2M11cbiAgICAgICAgICAgICsgYjY0Y2hzW3UzMiA+PiAxMiAmIDYzXVxuICAgICAgICAgICAgKyBiNjRjaHNbdTMyID4+IDYgJiA2M11cbiAgICAgICAgICAgICsgYjY0Y2hzW3UzMiAmIDYzXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZCA/IGFzYy5zbGljZSgwLCBwYWQgLSAzKSArIFwiPT09XCIuc3Vic3RyaW5nKHBhZCkgOiBhc2M7XG59O1xuLyoqXG4gKiBkb2VzIHdoYXQgYHdpbmRvdy5idG9hYCBvZiB3ZWIgYnJvd3NlcnMgZG8uXG4gKiBAcGFyYW0ge1N0cmluZ30gYmluIGJpbmFyeSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICovXG5jb25zdCBfYnRvYSA9IF9oYXNidG9hID8gKGJpbikgPT4gYnRvYShiaW4pXG4gICAgOiBfaGFzQnVmZmVyID8gKGJpbikgPT4gQnVmZmVyLmZyb20oYmluLCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgIDogYnRvYVBvbHlmaWxsO1xuY29uc3QgX2Zyb21VaW50OEFycmF5ID0gX2hhc0J1ZmZlclxuICAgID8gKHU4YSkgPT4gQnVmZmVyLmZyb20odThhKS50b1N0cmluZygnYmFzZTY0JylcbiAgICA6ICh1OGEpID0+IHtcbiAgICAgICAgLy8gY2YuIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNzEwMDAxL2hvdy10by1jb252ZXJ0LXVpbnQ4LWFycmF5LXRvLWJhc2U2NC1lbmNvZGVkLXN0cmluZy8xMjcxMzMyNiMxMjcxMzMyNlxuICAgICAgICBjb25zdCBtYXhhcmdzID0gMHgxMDAwO1xuICAgICAgICBsZXQgc3RycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHU4YS5sZW5ndGg7IGkgPCBsOyBpICs9IG1heGFyZ3MpIHtcbiAgICAgICAgICAgIHN0cnMucHVzaChfZnJvbUNDLmFwcGx5KG51bGwsIHU4YS5zdWJhcnJheShpLCBpICsgbWF4YXJncykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2J0b2Eoc3Rycy5qb2luKCcnKSk7XG4gICAgfTtcbi8qKlxuICogY29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VybHNhZmVdIFVSTC1hbmQtZmlsZW5hbWUtc2FmZSBhIGxhIFJGQzQ2NDggwqc1XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gKi9cbmNvbnN0IGZyb21VaW50OEFycmF5ID0gKHU4YSwgdXJsc2FmZSA9IGZhbHNlKSA9PiB1cmxzYWZlID8gX21rVXJpU2FmZShfZnJvbVVpbnQ4QXJyYXkodThhKSkgOiBfZnJvbVVpbnQ4QXJyYXkodThhKTtcbi8vIFRoaXMgdHJpY2sgaXMgZm91bmQgYnJva2VuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzEzMFxuLy8gY29uc3QgdXRvYiA9IChzcmM6IHN0cmluZykgPT4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHNyYykpO1xuLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuY29uc3QgY2JfdXRvYiA9IChjKSA9PiB7XG4gICAgaWYgKGMubGVuZ3RoIDwgMikge1xuICAgICAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJldHVybiBjYyA8IDB4ODAgPyBjXG4gICAgICAgICAgICA6IGNjIDwgMHg4MDAgPyAoX2Zyb21DQygweGMwIHwgKGNjID4+PiA2KSlcbiAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSlcbiAgICAgICAgICAgICAgICA6IChfZnJvbUNDKDB4ZTAgfCAoKGNjID4+PiAxMikgJiAweDBmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY2MgPSAweDEwMDAwXG4gICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMCkgLSAweEQ4MDApICogMHg0MDBcbiAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgxKSAtIDB4REMwMCk7XG4gICAgICAgIHJldHVybiAoX2Zyb21DQygweGYwIHwgKChjYyA+Pj4gMTgpICYgMHgwNykpXG4gICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8ICgoY2MgPj4+IDEyKSAmIDB4M2YpKVxuICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoY2MgJiAweDNmKSkpO1xuICAgIH1cbn07XG5jb25zdCByZV91dG9iID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRkZdfFteXFx4MDAtXFx4N0ZdL2c7XG4vKipcbiAqIEBkZXByZWNhdGVkIHNob3VsZCBoYXZlIGJlZW4gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFVURi04IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gVVRGLTE2IHN0cmluZ1xuICovXG5jb25zdCB1dG9iID0gKHUpID0+IHUucmVwbGFjZShyZV91dG9iLCBjYl91dG9iKTtcbi8vXG5jb25zdCBfZW5jb2RlID0gX2hhc0J1ZmZlclxuICAgID8gKHMpID0+IEJ1ZmZlci5mcm9tKHMsICd1dGY4JykudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgOiBfVEVcbiAgICAgICAgPyAocykgPT4gX2Zyb21VaW50OEFycmF5KF9URS5lbmNvZGUocykpXG4gICAgICAgIDogKHMpID0+IF9idG9hKHV0b2IocykpO1xuLyoqXG4gKiBjb252ZXJ0cyBhIFVURi04LWVuY29kZWQgc3RyaW5nIHRvIGEgQmFzZTY0IHN0cmluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VybHNhZmVdIGlmIGB0cnVlYCBtYWtlIHRoZSByZXN1bHQgVVJMLXNhZmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBzdHJpbmdcbiAqL1xuY29uc3QgZW5jb2RlID0gKHNyYywgdXJsc2FmZSA9IGZhbHNlKSA9PiB1cmxzYWZlXG4gICAgPyBfbWtVcmlTYWZlKF9lbmNvZGUoc3JjKSlcbiAgICA6IF9lbmNvZGUoc3JjKTtcbi8qKlxuICogY29udmVydHMgYSBVVEYtOC1lbmNvZGVkIHN0cmluZyB0byBVUkwtc2FmZSBCYXNlNjQgUkZDNDY0OCDCpzUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gKi9cbmNvbnN0IGVuY29kZVVSSSA9IChzcmMpID0+IGVuY29kZShzcmMsIHRydWUpO1xuLy8gVGhpcyB0cmljayBpcyBmb3VuZCBicm9rZW4gaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWJhc2U2NC9pc3N1ZXMvMTMwXG4vLyBjb25zdCBidG91ID0gKHNyYzogc3RyaW5nKSA9PiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHNyYykpO1xuLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuY29uc3QgcmVfYnRvdSA9IC9bXFx4QzAtXFx4REZdW1xceDgwLVxceEJGXXxbXFx4RTAtXFx4RUZdW1xceDgwLVxceEJGXXsyfXxbXFx4RjAtXFx4RjddW1xceDgwLVxceEJGXXszfS9nO1xuY29uc3QgY2JfYnRvdSA9IChjY2NjKSA9PiB7XG4gICAgc3dpdGNoIChjY2NjLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB2YXIgY3AgPSAoKDB4MDcgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDE4KVxuICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCAxMilcbiAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgyKSkgPDwgNilcbiAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDMpKSwgb2Zmc2V0ID0gY3AgLSAweDEwMDAwO1xuICAgICAgICAgICAgcmV0dXJuIChfZnJvbUNDKChvZmZzZXQgPj4+IDEwKSArIDB4RDgwMClcbiAgICAgICAgICAgICAgICArIF9mcm9tQ0MoKG9mZnNldCAmIDB4M0ZGKSArIDB4REMwMCkpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2Zyb21DQygoKDB4MGYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDEyKVxuICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCA2KVxuICAgICAgICAgICAgICAgIHwgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBfZnJvbUNDKCgoMHgxZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgNilcbiAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSk7XG4gICAgfVxufTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgc2hvdWxkIGhhdmUgYmVlbiBpbnRlcm5hbCB1c2Ugb25seS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVVRGLTE2IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gVVRGLTggc3RyaW5nXG4gKi9cbmNvbnN0IGJ0b3UgPSAoYikgPT4gYi5yZXBsYWNlKHJlX2J0b3UsIGNiX2J0b3UpO1xuLyoqXG4gKiBwb2x5ZmlsbCB2ZXJzaW9uIG9mIGBhdG9iYFxuICovXG5jb25zdCBhdG9iUG9seWZpbGwgPSAoYXNjKSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ3BvbHlmaWxsZWQnKTtcbiAgICBhc2MgPSBhc2MucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgaWYgKCFiNjRyZS50ZXN0KGFzYykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21hbGZvcm1lZCBiYXNlNjQuJyk7XG4gICAgYXNjICs9ICc9PScuc2xpY2UoMiAtIChhc2MubGVuZ3RoICYgMykpO1xuICAgIGxldCB1MjQsIGJpbiA9ICcnLCByMSwgcjI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc2MubGVuZ3RoOykge1xuICAgICAgICB1MjQgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSA8PCAxOFxuICAgICAgICAgICAgfCBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSA8PCAxMlxuICAgICAgICAgICAgfCAocjEgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSkgPDwgNlxuICAgICAgICAgICAgfCAocjIgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSk7XG4gICAgICAgIGJpbiArPSByMSA9PT0gNjQgPyBfZnJvbUNDKHUyNCA+PiAxNiAmIDI1NSlcbiAgICAgICAgICAgIDogcjIgPT09IDY0ID8gX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUsIHUyNCA+PiA4ICYgMjU1KVxuICAgICAgICAgICAgICAgIDogX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUsIHUyNCA+PiA4ICYgMjU1LCB1MjQgJiAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gYmluO1xufTtcbi8qKlxuICogZG9lcyB3aGF0IGB3aW5kb3cuYXRvYmAgb2Ygd2ViIGJyb3dzZXJzIGRvLlxuICogQHBhcmFtIHtTdHJpbmd9IGFzYyBCYXNlNjQtZW5jb2RlZCBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGJpbmFyeSBzdHJpbmdcbiAqL1xuY29uc3QgX2F0b2IgPSBfaGFzYXRvYiA/IChhc2MpID0+IGF0b2IoX3RpZHlCNjQoYXNjKSlcbiAgICA6IF9oYXNCdWZmZXIgPyAoYXNjKSA9PiBCdWZmZXIuZnJvbShhc2MsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5JylcbiAgICAgICAgOiBhdG9iUG9seWZpbGw7XG4vL1xuY29uc3QgX3RvVWludDhBcnJheSA9IF9oYXNCdWZmZXJcbiAgICA/IChhKSA9PiBfVThBZnJvbShCdWZmZXIuZnJvbShhLCAnYmFzZTY0JykpXG4gICAgOiAoYSkgPT4gX1U4QWZyb20oX2F0b2IoYSkuc3BsaXQoJycpLm1hcChjID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuLyoqXG4gKiBjb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICovXG5jb25zdCB0b1VpbnQ4QXJyYXkgPSAoYSkgPT4gX3RvVWludDhBcnJheShfdW5VUkkoYSkpO1xuLy9cbmNvbnN0IF9kZWNvZGUgPSBfaGFzQnVmZmVyXG4gICAgPyAoYSkgPT4gQnVmZmVyLmZyb20oYSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCd1dGY4JylcbiAgICA6IF9URFxuICAgICAgICA/IChhKSA9PiBfVEQuZGVjb2RlKF90b1VpbnQ4QXJyYXkoYSkpXG4gICAgICAgIDogKGEpID0+IGJ0b3UoX2F0b2IoYSkpO1xuY29uc3QgX3VuVVJJID0gKGEpID0+IF90aWR5QjY0KGEucmVwbGFjZSgvWy1fXS9nLCAobTApID0+IG0wID09ICctJyA/ICcrJyA6ICcvJykpO1xuLyoqXG4gKiBjb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSBVVEYtOCBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjIEJhc2U2NCBzdHJpbmcuICBCb3RoIG5vcm1hbCBhbmQgVVJMLXNhZmUgYXJlIHN1cHBvcnRlZFxuICogQHJldHVybnMge3N0cmluZ30gVVRGLTggc3RyaW5nXG4gKi9cbmNvbnN0IGRlY29kZSA9IChzcmMpID0+IF9kZWNvZGUoX3VuVVJJKHNyYykpO1xuLyoqXG4gKiBjaGVjayBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgQmFzZTY0IHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHNyYyBhIHZhbHVlIHRvIGNoZWNrXG4gICovXG5jb25zdCBpc1ZhbGlkID0gKHNyYykgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHMgPSBzcmMucmVwbGFjZSgvXFxzKy9nLCAnJykucmVwbGFjZSgvPXswLDJ9JC8sICcnKTtcbiAgICByZXR1cm4gIS9bXlxcczAtOWEtekEtWlxcKy9dLy50ZXN0KHMpIHx8ICEvW15cXHMwLTlhLXpBLVpcXC1fXS8udGVzdChzKTtcbn07XG4vL1xuY29uc3QgX25vRW51bSA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHYsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfTtcbn07XG4vKipcbiAqIGV4dGVuZCBTdHJpbmcucHJvdG90eXBlIHdpdGggcmVsZXZhbnQgbWV0aG9kc1xuICovXG5jb25zdCBleHRlbmRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgX2FkZCA9IChuYW1lLCBib2R5KSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgbmFtZSwgX25vRW51bShib2R5KSk7XG4gICAgX2FkZCgnZnJvbUJhc2U2NCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZSh0aGlzKTsgfSk7XG4gICAgX2FkZCgndG9CYXNlNjQnLCBmdW5jdGlvbiAodXJsc2FmZSkgeyByZXR1cm4gZW5jb2RlKHRoaXMsIHVybHNhZmUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgX2FkZCgndG9CYXNlNjRVUkwnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGUodGhpcywgdHJ1ZSk7IH0pO1xuICAgIF9hZGQoJ3RvVWludDhBcnJheScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzKTsgfSk7XG59O1xuLyoqXG4gKiBleHRlbmQgVWludDhBcnJheS5wcm90b3R5cGUgd2l0aCByZWxldmFudCBtZXRob2RzXG4gKi9cbmNvbnN0IGV4dGVuZFVpbnQ4QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgX2FkZCA9IChuYW1lLCBib2R5KSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoVWludDhBcnJheS5wcm90b3R5cGUsIG5hbWUsIF9ub0VudW0oYm9keSkpO1xuICAgIF9hZGQoJ3RvQmFzZTY0JywgZnVuY3Rpb24gKHVybHNhZmUpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHVybHNhZmUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHRydWUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSTCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHRydWUpOyB9KTtcbn07XG4vKipcbiAqIGV4dGVuZCBCdWlsdGluIHByb3RvdHlwZXMgd2l0aCByZWxldmFudCBtZXRob2RzXG4gKi9cbmNvbnN0IGV4dGVuZEJ1aWx0aW5zID0gKCkgPT4ge1xuICAgIGV4dGVuZFN0cmluZygpO1xuICAgIGV4dGVuZFVpbnQ4QXJyYXkoKTtcbn07XG5jb25zdCBnQmFzZTY0ID0ge1xuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgVkVSU0lPTjogVkVSU0lPTixcbiAgICBhdG9iOiBfYXRvYixcbiAgICBhdG9iUG9seWZpbGw6IGF0b2JQb2x5ZmlsbCxcbiAgICBidG9hOiBfYnRvYSxcbiAgICBidG9hUG9seWZpbGw6IGJ0b2FQb2x5ZmlsbCxcbiAgICBmcm9tQmFzZTY0OiBkZWNvZGUsXG4gICAgdG9CYXNlNjQ6IGVuY29kZSxcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBlbmNvZGVVUkk6IGVuY29kZVVSSSxcbiAgICBlbmNvZGVVUkw6IGVuY29kZVVSSSxcbiAgICB1dG9iOiB1dG9iLFxuICAgIGJ0b3U6IGJ0b3UsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICBmcm9tVWludDhBcnJheTogZnJvbVVpbnQ4QXJyYXksXG4gICAgdG9VaW50OEFycmF5OiB0b1VpbnQ4QXJyYXksXG4gICAgZXh0ZW5kU3RyaW5nOiBleHRlbmRTdHJpbmcsXG4gICAgZXh0ZW5kVWludDhBcnJheTogZXh0ZW5kVWludDhBcnJheSxcbiAgICBleHRlbmRCdWlsdGluczogZXh0ZW5kQnVpbHRpbnMsXG59O1xuLy8gbWFrZWNqczpDVVQgLy9cbmV4cG9ydCB7IHZlcnNpb24gfTtcbmV4cG9ydCB7IFZFUlNJT04gfTtcbmV4cG9ydCB7IF9hdG9iIGFzIGF0b2IgfTtcbmV4cG9ydCB7IGF0b2JQb2x5ZmlsbCB9O1xuZXhwb3J0IHsgX2J0b2EgYXMgYnRvYSB9O1xuZXhwb3J0IHsgYnRvYVBvbHlmaWxsIH07XG5leHBvcnQgeyBkZWNvZGUgYXMgZnJvbUJhc2U2NCB9O1xuZXhwb3J0IHsgZW5jb2RlIGFzIHRvQmFzZTY0IH07XG5leHBvcnQgeyB1dG9iIH07XG5leHBvcnQgeyBlbmNvZGUgfTtcbmV4cG9ydCB7IGVuY29kZVVSSSB9O1xuZXhwb3J0IHsgZW5jb2RlVVJJIGFzIGVuY29kZVVSTCB9O1xuZXhwb3J0IHsgYnRvdSB9O1xuZXhwb3J0IHsgZGVjb2RlIH07XG5leHBvcnQgeyBpc1ZhbGlkIH07XG5leHBvcnQgeyBmcm9tVWludDhBcnJheSB9O1xuZXhwb3J0IHsgdG9VaW50OEFycmF5IH07XG5leHBvcnQgeyBleHRlbmRTdHJpbmcgfTtcbmV4cG9ydCB7IGV4dGVuZFVpbnQ4QXJyYXkgfTtcbmV4cG9ydCB7IGV4dGVuZEJ1aWx0aW5zIH07XG4vLyBhbmQgZmluYWxseSxcbmV4cG9ydCB7IGdCYXNlNjQgYXMgQmFzZTY0IH07XG4iXSwibmFtZXMiOlsidmVyc2lvbiIsIlZFUlNJT04iLCJfaGFzYXRvYiIsImF0b2IiLCJfaGFzYnRvYSIsImJ0b2EiLCJfaGFzQnVmZmVyIiwiQnVmZmVyIiwiX1REIiwiVGV4dERlY29kZXIiLCJ1bmRlZmluZWQiLCJfVEUiLCJUZXh0RW5jb2RlciIsImI2NGNoIiwiYjY0Y2hzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJiNjR0YWIiLCJhIiwidGFiIiwiZm9yRWFjaCIsImMiLCJpIiwiYjY0cmUiLCJfZnJvbUNDIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYmluZCIsIl9VOEFmcm9tIiwiVWludDhBcnJheSIsImZyb20iLCJpdCIsIl9ta1VyaVNhZmUiLCJzcmMiLCJyZXBsYWNlIiwibTAiLCJfdGlkeUI2NCIsInMiLCJidG9hUG9seWZpbGwiLCJiaW4iLCJ1MzIiLCJjMCIsImMxIiwiYzIiLCJhc2MiLCJwYWQiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiVHlwZUVycm9yIiwic3Vic3RyaW5nIiwiX2J0b2EiLCJ0b1N0cmluZyIsIl9mcm9tVWludDhBcnJheSIsInU4YSIsIm1heGFyZ3MiLCJzdHJzIiwibCIsInB1c2giLCJhcHBseSIsInN1YmFycmF5Iiwiam9pbiIsImZyb21VaW50OEFycmF5IiwidXJsc2FmZSIsImNiX3V0b2IiLCJjYyIsInJlX3V0b2IiLCJ1dG9iIiwidSIsIl9lbmNvZGUiLCJlbmNvZGUiLCJlbmNvZGVVUkkiLCJyZV9idG91IiwiY2JfYnRvdSIsImNjY2MiLCJjcCIsIm9mZnNldCIsImJ0b3UiLCJiIiwiYXRvYlBvbHlmaWxsIiwidGVzdCIsInUyNCIsInIxIiwicjIiLCJjaGFyQXQiLCJfYXRvYiIsIl90b1VpbnQ4QXJyYXkiLCJzcGxpdCIsIm1hcCIsInRvVWludDhBcnJheSIsIl91blVSSSIsIl9kZWNvZGUiLCJkZWNvZGUiLCJpc1ZhbGlkIiwiX25vRW51bSIsInYiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImV4dGVuZFN0cmluZyIsIl9hZGQiLCJuYW1lIiwiYm9keSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXh0ZW5kVWludDhBcnJheSIsImV4dGVuZEJ1aWx0aW5zIiwiZ0Jhc2U2NCIsImZyb21CYXNlNjQiLCJ0b0Jhc2U2NCIsImVuY29kZVVSTCIsIkJhc2U2NCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/js-base64/base64.mjs\n");

/***/ })

};
;