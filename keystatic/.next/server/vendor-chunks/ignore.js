/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ignore";
exports.ids = ["vendor-chunks/ignore"];
exports.modules = {

/***/ "(rsc)/./node_modules/ignore/index.js":
/*!**************************************!*\
  !*** ./node_modules/ignore/index.js ***!
  \**************************************/
/***/ ((module) => {

eval("// A simple implementation of make-array\nfunction makeArray(subject) {\n    return Array.isArray(subject) ? subject : [\n        subject\n    ];\n}\nconst EMPTY = \"\";\nconst SPACE = \" \";\nconst ESCAPE = \"\\\\\";\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/;\nconst REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\\\]|^)\\\\$/;\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/;\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g;\n// /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\nconst REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/;\nconst SLASH = \"/\";\n// Do not use ternary expression here, since \"istanbul ignore next\" is buggy\nlet TMP_KEY_IGNORE = \"node-ignore\";\n/* istanbul ignore else */ if (typeof Symbol !== \"undefined\") {\n    TMP_KEY_IGNORE = Symbol.for(\"node-ignore\");\n}\nconst KEY_IGNORE = TMP_KEY_IGNORE;\nconst define = (object, key, value)=>Object.defineProperty(object, key, {\n        value\n    });\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;\nconst RETURN_FALSE = ()=>false;\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = (range)=>range.replace(REGEX_REGEXP_RANGE, (match, from, to)=>from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);\n// See fixtures #59\nconst cleanRangeBackSlash = (slashes)=>{\n    const { length } = slashes;\n    return slashes.slice(0, length - length % 2);\n};\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n// '`foo/`' should not continue with the '`..`'\nconst REPLACERS = [\n    // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n    [\n        // (a\\ ) -> (a )\n        // (a  ) -> (a)\n        // (a \\ ) -> (a  )\n        /\\\\?\\s+$/,\n        (match)=>match.indexOf(\"\\\\\") === 0 ? SPACE : EMPTY\n    ],\n    // replace (\\ ) with ' '\n    [\n        /\\\\\\s/g,\n        ()=>SPACE\n    ],\n    // Escape metacharacters\n    // which is written down by users but means special for regular expressions.\n    // > There are 12 characters with special meanings:\n    // > - the backslash \\,\n    // > - the caret ^,\n    // > - the dollar sign $,\n    // > - the period or dot .,\n    // > - the vertical bar or pipe symbol |,\n    // > - the question mark ?,\n    // > - the asterisk or star *,\n    // > - the plus sign +,\n    // > - the opening parenthesis (,\n    // > - the closing parenthesis ),\n    // > - and the opening square bracket [,\n    // > - the opening curly brace {,\n    // > These special characters are often called \"metacharacters\".\n    [\n        /[\\\\$.|*+(){^]/g,\n        (match)=>`\\\\${match}`\n    ],\n    [\n        // > a question mark (?) matches a single character\n        /(?!\\\\)\\?/g,\n        ()=>\"[^/]\"\n    ],\n    // leading slash\n    [\n        // > A leading slash matches the beginning of the pathname.\n        // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n        // A leading slash matches the beginning of the pathname\n        /^\\//,\n        ()=>\"^\"\n    ],\n    // replace special metacharacter slash after the leading slash\n    [\n        /\\//g,\n        ()=>\"\\\\/\"\n    ],\n    [\n        // > A leading \"**\" followed by a slash means match in all directories.\n        // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n        // > the same as pattern \"foo\".\n        // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n        // >   under directory \"foo\".\n        // Notice that the '*'s have been replaced as '\\\\*'\n        /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n        // '**/foo' <-> 'foo'\n        ()=>\"^(?:.*\\\\/)?\"\n    ],\n    // starting\n    [\n        // there will be no leading '/'\n        //   (which has been replaced by section \"leading slash\")\n        // If starts with '**', adding a '^' to the regular expression also works\n        /^(?=[^^])/,\n        function startingReplacer() {\n            // If has a slash `/` at the beginning or middle\n            return !/\\/(?!$)/.test(this) ? \"(?:^|\\\\/)\" : \"^\";\n        }\n    ],\n    // two globstars\n    [\n        // Use lookahead assertions so that we could match more than one `'/**'`\n        /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n        // Zero, one or several directories\n        // should not use '*', or it will be replaced by the next replacer\n        // Check if it is not the last `'/**'`\n        (_, index, str)=>index + 6 < str.length ? \"(?:\\\\/[^\\\\/]+)*\" : \"\\\\/.+\"\n    ],\n    // normal intermediate wildcards\n    [\n        // Never replace escaped '*'\n        // ignore rule '\\*' will match the path '*'\n        // 'abc.*/' -> go\n        // 'abc.*'  -> skip this rule,\n        //    coz trailing single wildcard will be handed by [trailing wildcard]\n        /(^|[^\\\\]+)(\\\\\\*)+(?=.+)/g,\n        // '*.js' matches '.js'\n        // '*.js' doesn't match 'abc'\n        (_, p1, p2)=>{\n            // 1.\n            // > An asterisk \"*\" matches anything except a slash.\n            // 2.\n            // > Other consecutive asterisks are considered regular asterisks\n            // > and will match according to the previous rules.\n            const unescaped = p2.replace(/\\\\\\*/g, \"[^\\\\/]*\");\n            return p1 + unescaped;\n        }\n    ],\n    [\n        // unescape, revert step 3 except for back slash\n        // For example, if a user escape a '\\\\*',\n        // after step 3, the result will be '\\\\\\\\\\\\*'\n        /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\n        ()=>ESCAPE\n    ],\n    [\n        // '\\\\\\\\' -> '\\\\'\n        /\\\\\\\\/g,\n        ()=>ESCAPE\n    ],\n    [\n        // > The range notation, e.g. [a-zA-Z],\n        // > can be used to match one of the characters in a range.\n        // `\\` is escaped by step 3\n        /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\n        (match, leadEscape, range, endEscape, close)=>leadEscape === ESCAPE ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === \"]\" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : \"[]\" : \"[]\"\n    ],\n    // ending\n    [\n        // 'js' will not match 'js.'\n        // 'ab' will not match 'abc'\n        /(?:[^*])$/,\n        // WTF!\n        // https://git-scm.com/docs/gitignore\n        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n        // which re-fixes #24, #38\n        // > If there is a separator at the end of the pattern then the pattern\n        // > will only match directories, otherwise the pattern can match both\n        // > files and directories.\n        // 'js*' will not match 'a.js'\n        // 'js/' will not match 'a.js'\n        // 'js' will match 'a.js' and 'a.js/'\n        (match)=>/\\/$/.test(match) ? `${match}$` : `${match}(?=$|\\\\/$)`\n    ],\n    // trailing wildcard\n    [\n        /(\\^|\\\\\\/)?\\\\\\*$/,\n        (_, p1)=>{\n            const prefix = p1 ? `${p1}[^/]+` : \"[^/]*\";\n            return `${prefix}(?=$|\\\\/$)`;\n        }\n    ]\n];\n// A simple cache, because an ignore rule only has only one certain meaning\nconst regexCache = Object.create(null);\n// @param {pattern}\nconst makeRegex = (pattern, ignoreCase)=>{\n    let source = regexCache[pattern];\n    if (!source) {\n        source = REPLACERS.reduce((prev, current)=>prev.replace(current[0], current[1].bind(pattern)), pattern);\n        regexCache[pattern] = source;\n    }\n    return ignoreCase ? new RegExp(source, \"i\") : new RegExp(source);\n};\nconst isString = (subject)=>typeof subject === \"string\";\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = (pattern)=>pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf(\"#\") !== 0;\nconst splitPattern = (pattern)=>pattern.split(REGEX_SPLITALL_CRLF);\nclass IgnoreRule {\n    constructor(origin, pattern, negative, regex){\n        this.origin = origin;\n        this.pattern = pattern;\n        this.negative = negative;\n        this.regex = regex;\n    }\n}\nconst createRule = (pattern, ignoreCase)=>{\n    const origin = pattern;\n    let negative = false;\n    // > An optional prefix \"!\" which negates the pattern;\n    if (pattern.indexOf(\"!\") === 0) {\n        negative = true;\n        pattern = pattern.substr(1);\n    }\n    pattern = pattern// > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n    // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n    .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, \"!\")// > Put a backslash (\"\\\") in front of the first hash for patterns that\n    // >   begin with a hash.\n    .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, \"#\");\n    const regex = makeRegex(pattern, ignoreCase);\n    return new IgnoreRule(origin, pattern, negative, regex);\n};\nconst throwError = (message, Ctor)=>{\n    throw new Ctor(message);\n};\nconst checkPath = (path, originalPath, doThrow)=>{\n    if (!isString(path)) {\n        return doThrow(`path must be a string, but got \\`${originalPath}\\``, TypeError);\n    }\n    // We don't know if we should ignore EMPTY, so throw\n    if (!path) {\n        return doThrow(`path must not be empty`, TypeError);\n    }\n    // Check if it is a relative path\n    if (checkPath.isNotRelative(path)) {\n        const r = \"`path.relative()`d\";\n        return doThrow(`path should be a ${r} string, but got \"${originalPath}\"`, RangeError);\n    }\n    return true;\n};\nconst isNotRelative = (path)=>REGEX_TEST_INVALID_PATH.test(path);\ncheckPath.isNotRelative = isNotRelative;\ncheckPath.convert = (p)=>p;\nclass Ignore {\n    constructor({ ignorecase = true, ignoreCase = ignorecase, allowRelativePaths = false } = {}){\n        define(this, KEY_IGNORE, true);\n        this._rules = [];\n        this._ignoreCase = ignoreCase;\n        this._allowRelativePaths = allowRelativePaths;\n        this._initCache();\n    }\n    _initCache() {\n        this._ignoreCache = Object.create(null);\n        this._testCache = Object.create(null);\n    }\n    _addPattern(pattern) {\n        // #32\n        if (pattern && pattern[KEY_IGNORE]) {\n            this._rules = this._rules.concat(pattern._rules);\n            this._added = true;\n            return;\n        }\n        if (checkPattern(pattern)) {\n            const rule = createRule(pattern, this._ignoreCase);\n            this._added = true;\n            this._rules.push(rule);\n        }\n    }\n    // @param {Array<string> | string | Ignore} pattern\n    add(pattern) {\n        this._added = false;\n        makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);\n        // Some rules have just added to the ignore,\n        // making the behavior changed.\n        if (this._added) {\n            this._initCache();\n        }\n        return this;\n    }\n    // legacy\n    addPattern(pattern) {\n        return this.add(pattern);\n    }\n    //          |           ignored : unignored\n    // negative |   0:0   |   0:1   |   1:0   |   1:1\n    // -------- | ------- | ------- | ------- | --------\n    //     0    |  TEST   |  TEST   |  SKIP   |    X\n    //     1    |  TESTIF |  SKIP   |  TEST   |    X\n    // - SKIP: always skip\n    // - TEST: always test\n    // - TESTIF: only test if checkUnignored\n    // - X: that never happen\n    // @param {boolean} whether should check if the path is unignored,\n    //   setting `checkUnignored` to `false` could reduce additional\n    //   path matching.\n    // @returns {TestResult} true if a file is ignored\n    _testOne(path, checkUnignored) {\n        let ignored = false;\n        let unignored = false;\n        this._rules.forEach((rule)=>{\n            const { negative } = rule;\n            if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {\n                return;\n            }\n            const matched = rule.regex.test(path);\n            if (matched) {\n                ignored = !negative;\n                unignored = negative;\n            }\n        });\n        return {\n            ignored,\n            unignored\n        };\n    }\n    // @returns {TestResult}\n    _test(originalPath, cache, checkUnignored, slices) {\n        const path = originalPath && checkPath.convert(originalPath);\n        checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);\n        return this._t(path, cache, checkUnignored, slices);\n    }\n    _t(path, cache, checkUnignored, slices) {\n        if (path in cache) {\n            return cache[path];\n        }\n        if (!slices) {\n            // path/to/a.js\n            // ['path', 'to', 'a.js']\n            slices = path.split(SLASH);\n        }\n        slices.pop();\n        // If the path has no parent directory, just test it\n        if (!slices.length) {\n            return cache[path] = this._testOne(path, checkUnignored);\n        }\n        const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);\n        // If the path contains a parent directory, check the parent first\n        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);\n    }\n    ignores(path) {\n        return this._test(path, this._ignoreCache, false).ignored;\n    }\n    createFilter() {\n        return (path)=>!this.ignores(path);\n    }\n    filter(paths) {\n        return makeArray(paths).filter(this.createFilter());\n    }\n    // @returns {TestResult}\n    test(path) {\n        return this._test(path, this._testCache, true);\n    }\n}\nconst factory = (options)=>new Ignore(options);\nconst isPathValid = (path)=>checkPath(path && checkPath.convert(path), path, RETURN_FALSE);\nfactory.isPathValid = isPathValid;\n// Fixes typescript\nfactory.default = factory;\nmodule.exports = factory;\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if */ if (// Detect `process` so that it can run in browsers.\ntypeof process !== \"undefined\" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === \"win32\")) {\n    /* eslint no-control-regex: \"off\" */ const makePosix = (str)=>/^\\\\\\\\\\?\\\\/.test(str) || /[\"<>|\\u0000-\\u001F]+/u.test(str) ? str : str.replace(/\\\\/g, \"/\");\n    checkPath.convert = makePosix;\n    // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n    // 'd:\\\\foo'\n    const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i;\n    checkPath.isNotRelative = (path)=>REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvaWdub3JlL2luZGV4LmpzPzc2ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgbWFrZS1hcnJheVxuZnVuY3Rpb24gbWFrZUFycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHN1YmplY3QpXG4gICAgPyBzdWJqZWN0XG4gICAgOiBbc3ViamVjdF1cbn1cblxuY29uc3QgRU1QVFkgPSAnJ1xuY29uc3QgU1BBQ0UgPSAnICdcbmNvbnN0IEVTQ0FQRSA9ICdcXFxcJ1xuY29uc3QgUkVHRVhfVEVTVF9CTEFOS19MSU5FID0gL15cXHMrJC9cbmNvbnN0IFJFR0VYX0lOVkFMSURfVFJBSUxJTkdfQkFDS1NMQVNIID0gLyg/OlteXFxcXF18XilcXFxcJC9cbmNvbnN0IFJFR0VYX1JFUExBQ0VfTEVBRElOR19FWENBUEVEX0VYQ0xBTUFUSU9OID0gL15cXFxcIS9cbmNvbnN0IFJFR0VYX1JFUExBQ0VfTEVBRElOR19FWENBUEVEX0hBU0ggPSAvXlxcXFwjL1xuY29uc3QgUkVHRVhfU1BMSVRBTExfQ1JMRiA9IC9cXHI/XFxuL2dcbi8vIC9mb28sXG4vLyAuL2Zvbyxcbi8vIC4uL2Zvbyxcbi8vIC5cbi8vIC4uXG5jb25zdCBSRUdFWF9URVNUX0lOVkFMSURfUEFUSCA9IC9eXFwuKlxcL3xeXFwuKyQvXG5cbmNvbnN0IFNMQVNIID0gJy8nXG5cbi8vIERvIG5vdCB1c2UgdGVybmFyeSBleHByZXNzaW9uIGhlcmUsIHNpbmNlIFwiaXN0YW5idWwgaWdub3JlIG5leHRcIiBpcyBidWdneVxubGV0IFRNUF9LRVlfSUdOT1JFID0gJ25vZGUtaWdub3JlJ1xuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJykge1xuICBUTVBfS0VZX0lHTk9SRSA9IFN5bWJvbC5mb3IoJ25vZGUtaWdub3JlJylcbn1cbmNvbnN0IEtFWV9JR05PUkUgPSBUTVBfS0VZX0lHTk9SRVxuXG5jb25zdCBkZWZpbmUgPSAob2JqZWN0LCBrZXksIHZhbHVlKSA9PlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHt2YWx1ZX0pXG5cbmNvbnN0IFJFR0VYX1JFR0VYUF9SQU5HRSA9IC8oWzAtel0pLShbMC16XSkvZ1xuXG5jb25zdCBSRVRVUk5fRkFMU0UgPSAoKSA9PiBmYWxzZVxuXG4vLyBTYW5pdGl6ZSB0aGUgcmFuZ2Ugb2YgYSByZWd1bGFyIGV4cHJlc3Npb25cbi8vIFRoZSBjYXNlcyBhcmUgY29tcGxpY2F0ZWQsIHNlZSB0ZXN0IGNhc2VzIGZvciBkZXRhaWxzXG5jb25zdCBzYW5pdGl6ZVJhbmdlID0gcmFuZ2UgPT4gcmFuZ2UucmVwbGFjZShcbiAgUkVHRVhfUkVHRVhQX1JBTkdFLFxuICAobWF0Y2gsIGZyb20sIHRvKSA9PiBmcm9tLmNoYXJDb2RlQXQoMCkgPD0gdG8uY2hhckNvZGVBdCgwKVxuICAgID8gbWF0Y2hcbiAgICAvLyBJbnZhbGlkIHJhbmdlIChvdXQgb2Ygb3JkZXIpIHdoaWNoIGlzIG9rIGZvciBnaXRpZ25vcmUgcnVsZXMgYnV0XG4gICAgLy8gICBmYXRhbCBmb3IgSmF2YVNjcmlwdCByZWd1bGFyIGV4cHJlc3Npb24sIHNvIGVsaW1pbmF0ZSBpdC5cbiAgICA6IEVNUFRZXG4pXG5cbi8vIFNlZSBmaXh0dXJlcyAjNTlcbmNvbnN0IGNsZWFuUmFuZ2VCYWNrU2xhc2ggPSBzbGFzaGVzID0+IHtcbiAgY29uc3Qge2xlbmd0aH0gPSBzbGFzaGVzXG4gIHJldHVybiBzbGFzaGVzLnNsaWNlKDAsIGxlbmd0aCAtIGxlbmd0aCAlIDIpXG59XG5cbi8vID4gSWYgdGhlIHBhdHRlcm4gZW5kcyB3aXRoIGEgc2xhc2gsXG4vLyA+IGl0IGlzIHJlbW92ZWQgZm9yIHRoZSBwdXJwb3NlIG9mIHRoZSBmb2xsb3dpbmcgZGVzY3JpcHRpb24sXG4vLyA+IGJ1dCBpdCB3b3VsZCBvbmx5IGZpbmQgYSBtYXRjaCB3aXRoIGEgZGlyZWN0b3J5LlxuLy8gPiBJbiBvdGhlciB3b3JkcywgZm9vLyB3aWxsIG1hdGNoIGEgZGlyZWN0b3J5IGZvbyBhbmQgcGF0aHMgdW5kZXJuZWF0aCBpdCxcbi8vID4gYnV0IHdpbGwgbm90IG1hdGNoIGEgcmVndWxhciBmaWxlIG9yIGEgc3ltYm9saWMgbGluayBmb29cbi8vID4gICh0aGlzIGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgd2F5IGhvdyBwYXRoc3BlYyB3b3JrcyBpbiBnZW5lcmFsIGluIEdpdCkuXG4vLyAnYGZvby9gJyB3aWxsIG5vdCBtYXRjaCByZWd1bGFyIGZpbGUgJ2Bmb29gJyBvciBzeW1ib2xpYyBsaW5rICdgZm9vYCdcbi8vIC0+IGlnbm9yZS1ydWxlcyB3aWxsIG5vdCBkZWFsIHdpdGggaXQsIGJlY2F1c2UgaXQgY29zdHMgZXh0cmEgYGZzLnN0YXRgIGNhbGxcbi8vICAgICAgeW91IGNvdWxkIHVzZSBvcHRpb24gYG1hcms6IHRydWVgIHdpdGggYGdsb2JgXG5cbi8vICdgZm9vL2AnIHNob3VsZCBub3QgY29udGludWUgd2l0aCB0aGUgJ2AuLmAnXG5jb25zdCBSRVBMQUNFUlMgPSBbXG5cbiAgLy8gPiBUcmFpbGluZyBzcGFjZXMgYXJlIGlnbm9yZWQgdW5sZXNzIHRoZXkgYXJlIHF1b3RlZCB3aXRoIGJhY2tzbGFzaCAoXCJcXFwiKVxuICBbXG4gICAgLy8gKGFcXCApIC0+IChhIClcbiAgICAvLyAoYSAgKSAtPiAoYSlcbiAgICAvLyAoYSBcXCApIC0+IChhICApXG4gICAgL1xcXFw/XFxzKyQvLFxuICAgIG1hdGNoID0+IG1hdGNoLmluZGV4T2YoJ1xcXFwnKSA9PT0gMFxuICAgICAgPyBTUEFDRVxuICAgICAgOiBFTVBUWVxuICBdLFxuXG4gIC8vIHJlcGxhY2UgKFxcICkgd2l0aCAnICdcbiAgW1xuICAgIC9cXFxcXFxzL2csXG4gICAgKCkgPT4gU1BBQ0VcbiAgXSxcblxuICAvLyBFc2NhcGUgbWV0YWNoYXJhY3RlcnNcbiAgLy8gd2hpY2ggaXMgd3JpdHRlbiBkb3duIGJ5IHVzZXJzIGJ1dCBtZWFucyBzcGVjaWFsIGZvciByZWd1bGFyIGV4cHJlc3Npb25zLlxuXG4gIC8vID4gVGhlcmUgYXJlIDEyIGNoYXJhY3RlcnMgd2l0aCBzcGVjaWFsIG1lYW5pbmdzOlxuICAvLyA+IC0gdGhlIGJhY2tzbGFzaCBcXCxcbiAgLy8gPiAtIHRoZSBjYXJldCBeLFxuICAvLyA+IC0gdGhlIGRvbGxhciBzaWduICQsXG4gIC8vID4gLSB0aGUgcGVyaW9kIG9yIGRvdCAuLFxuICAvLyA+IC0gdGhlIHZlcnRpY2FsIGJhciBvciBwaXBlIHN5bWJvbCB8LFxuICAvLyA+IC0gdGhlIHF1ZXN0aW9uIG1hcmsgPyxcbiAgLy8gPiAtIHRoZSBhc3RlcmlzayBvciBzdGFyICosXG4gIC8vID4gLSB0aGUgcGx1cyBzaWduICssXG4gIC8vID4gLSB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyAoLFxuICAvLyA+IC0gdGhlIGNsb3NpbmcgcGFyZW50aGVzaXMgKSxcbiAgLy8gPiAtIGFuZCB0aGUgb3BlbmluZyBzcXVhcmUgYnJhY2tldCBbLFxuICAvLyA+IC0gdGhlIG9wZW5pbmcgY3VybHkgYnJhY2UgeyxcbiAgLy8gPiBUaGVzZSBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIG9mdGVuIGNhbGxlZCBcIm1ldGFjaGFyYWN0ZXJzXCIuXG4gIFtcbiAgICAvW1xcXFwkLnwqKygpe15dL2csXG4gICAgbWF0Y2ggPT4gYFxcXFwke21hdGNofWBcbiAgXSxcblxuICBbXG4gICAgLy8gPiBhIHF1ZXN0aW9uIG1hcmsgKD8pIG1hdGNoZXMgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgLyg/IVxcXFwpXFw/L2csXG4gICAgKCkgPT4gJ1teL10nXG4gIF0sXG5cbiAgLy8gbGVhZGluZyBzbGFzaFxuICBbXG5cbiAgICAvLyA+IEEgbGVhZGluZyBzbGFzaCBtYXRjaGVzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhdGhuYW1lLlxuICAgIC8vID4gRm9yIGV4YW1wbGUsIFwiLyouY1wiIG1hdGNoZXMgXCJjYXQtZmlsZS5jXCIgYnV0IG5vdCBcIm1vemlsbGEtc2hhMS9zaGExLmNcIi5cbiAgICAvLyBBIGxlYWRpbmcgc2xhc2ggbWF0Y2hlcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXRobmFtZVxuICAgIC9eXFwvLyxcbiAgICAoKSA9PiAnXidcbiAgXSxcblxuICAvLyByZXBsYWNlIHNwZWNpYWwgbWV0YWNoYXJhY3RlciBzbGFzaCBhZnRlciB0aGUgbGVhZGluZyBzbGFzaFxuICBbXG4gICAgL1xcLy9nLFxuICAgICgpID0+ICdcXFxcLydcbiAgXSxcblxuICBbXG4gICAgLy8gPiBBIGxlYWRpbmcgXCIqKlwiIGZvbGxvd2VkIGJ5IGEgc2xhc2ggbWVhbnMgbWF0Y2ggaW4gYWxsIGRpcmVjdG9yaWVzLlxuICAgIC8vID4gRm9yIGV4YW1wbGUsIFwiKiovZm9vXCIgbWF0Y2hlcyBmaWxlIG9yIGRpcmVjdG9yeSBcImZvb1wiIGFueXdoZXJlLFxuICAgIC8vID4gdGhlIHNhbWUgYXMgcGF0dGVybiBcImZvb1wiLlxuICAgIC8vID4gXCIqKi9mb28vYmFyXCIgbWF0Y2hlcyBmaWxlIG9yIGRpcmVjdG9yeSBcImJhclwiIGFueXdoZXJlIHRoYXQgaXMgZGlyZWN0bHlcbiAgICAvLyA+ICAgdW5kZXIgZGlyZWN0b3J5IFwiZm9vXCIuXG4gICAgLy8gTm90aWNlIHRoYXQgdGhlICcqJ3MgaGF2ZSBiZWVuIHJlcGxhY2VkIGFzICdcXFxcKidcbiAgICAvXlxcXipcXFxcXFwqXFxcXFxcKlxcXFxcXC8vLFxuXG4gICAgLy8gJyoqL2ZvbycgPC0+ICdmb28nXG4gICAgKCkgPT4gJ14oPzouKlxcXFwvKT8nXG4gIF0sXG5cbiAgLy8gc3RhcnRpbmdcbiAgW1xuICAgIC8vIHRoZXJlIHdpbGwgYmUgbm8gbGVhZGluZyAnLydcbiAgICAvLyAgICh3aGljaCBoYXMgYmVlbiByZXBsYWNlZCBieSBzZWN0aW9uIFwibGVhZGluZyBzbGFzaFwiKVxuICAgIC8vIElmIHN0YXJ0cyB3aXRoICcqKicsIGFkZGluZyBhICdeJyB0byB0aGUgcmVndWxhciBleHByZXNzaW9uIGFsc28gd29ya3NcbiAgICAvXig/PVteXl0pLyxcbiAgICBmdW5jdGlvbiBzdGFydGluZ1JlcGxhY2VyICgpIHtcbiAgICAgIC8vIElmIGhhcyBhIHNsYXNoIGAvYCBhdCB0aGUgYmVnaW5uaW5nIG9yIG1pZGRsZVxuICAgICAgcmV0dXJuICEvXFwvKD8hJCkvLnRlc3QodGhpcylcbiAgICAgICAgLy8gPiBQcmlvciB0byAyLjIyLjFcbiAgICAgICAgLy8gPiBJZiB0aGUgcGF0dGVybiBkb2VzIG5vdCBjb250YWluIGEgc2xhc2ggLyxcbiAgICAgICAgLy8gPiAgIEdpdCB0cmVhdHMgaXQgYXMgYSBzaGVsbCBnbG9iIHBhdHRlcm5cbiAgICAgICAgLy8gQWN0dWFsbHksIGlmIHRoZXJlIGlzIG9ubHkgYSB0cmFpbGluZyBzbGFzaCxcbiAgICAgICAgLy8gICBnaXQgYWxzbyB0cmVhdHMgaXQgYXMgYSBzaGVsbCBnbG9iIHBhdHRlcm5cblxuICAgICAgICAvLyBBZnRlciAyLjIyLjEgKGNvbXBhdGlibGUgYnV0IGNsZWFyZXIpXG4gICAgICAgIC8vID4gSWYgdGhlcmUgaXMgYSBzZXBhcmF0b3IgYXQgdGhlIGJlZ2lubmluZyBvciBtaWRkbGUgKG9yIGJvdGgpXG4gICAgICAgIC8vID4gb2YgdGhlIHBhdHRlcm4sIHRoZW4gdGhlIHBhdHRlcm4gaXMgcmVsYXRpdmUgdG8gdGhlIGRpcmVjdG9yeVxuICAgICAgICAvLyA+IGxldmVsIG9mIHRoZSBwYXJ0aWN1bGFyIC5naXRpZ25vcmUgZmlsZSBpdHNlbGYuXG4gICAgICAgIC8vID4gT3RoZXJ3aXNlIHRoZSBwYXR0ZXJuIG1heSBhbHNvIG1hdGNoIGF0IGFueSBsZXZlbCBiZWxvd1xuICAgICAgICAvLyA+IHRoZSAuZ2l0aWdub3JlIGxldmVsLlxuICAgICAgICA/ICcoPzpefFxcXFwvKSdcblxuICAgICAgICAvLyA+IE90aGVyd2lzZSwgR2l0IHRyZWF0cyB0aGUgcGF0dGVybiBhcyBhIHNoZWxsIGdsb2Igc3VpdGFibGUgZm9yXG4gICAgICAgIC8vID4gICBjb25zdW1wdGlvbiBieSBmbm1hdGNoKDMpXG4gICAgICAgIDogJ14nXG4gICAgfVxuICBdLFxuXG4gIC8vIHR3byBnbG9ic3RhcnNcbiAgW1xuICAgIC8vIFVzZSBsb29rYWhlYWQgYXNzZXJ0aW9ucyBzbyB0aGF0IHdlIGNvdWxkIG1hdGNoIG1vcmUgdGhhbiBvbmUgYCcvKionYFxuICAgIC9cXFxcXFwvXFxcXFxcKlxcXFxcXCooPz1cXFxcXFwvfCQpL2csXG5cbiAgICAvLyBaZXJvLCBvbmUgb3Igc2V2ZXJhbCBkaXJlY3Rvcmllc1xuICAgIC8vIHNob3VsZCBub3QgdXNlICcqJywgb3IgaXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgbmV4dCByZXBsYWNlclxuXG4gICAgLy8gQ2hlY2sgaWYgaXQgaXMgbm90IHRoZSBsYXN0IGAnLyoqJ2BcbiAgICAoXywgaW5kZXgsIHN0cikgPT4gaW5kZXggKyA2IDwgc3RyLmxlbmd0aFxuXG4gICAgICAvLyBjYXNlOiAvKiovXG4gICAgICAvLyA+IEEgc2xhc2ggZm9sbG93ZWQgYnkgdHdvIGNvbnNlY3V0aXZlIGFzdGVyaXNrcyB0aGVuIGEgc2xhc2ggbWF0Y2hlc1xuICAgICAgLy8gPiAgIHplcm8gb3IgbW9yZSBkaXJlY3Rvcmllcy5cbiAgICAgIC8vID4gRm9yIGV4YW1wbGUsIFwiYS8qKi9iXCIgbWF0Y2hlcyBcImEvYlwiLCBcImEveC9iXCIsIFwiYS94L3kvYlwiIGFuZCBzbyBvbi5cbiAgICAgIC8vICcvKiovJ1xuICAgICAgPyAnKD86XFxcXC9bXlxcXFwvXSspKidcblxuICAgICAgLy8gY2FzZTogLyoqXG4gICAgICAvLyA+IEEgdHJhaWxpbmcgYFwiLyoqXCJgIG1hdGNoZXMgZXZlcnl0aGluZyBpbnNpZGUuXG5cbiAgICAgIC8vICMyMTogZXZlcnl0aGluZyBpbnNpZGUgYnV0IGl0IHNob3VsZCBub3QgaW5jbHVkZSB0aGUgY3VycmVudCBmb2xkZXJcbiAgICAgIDogJ1xcXFwvLisnXG4gIF0sXG5cbiAgLy8gbm9ybWFsIGludGVybWVkaWF0ZSB3aWxkY2FyZHNcbiAgW1xuICAgIC8vIE5ldmVyIHJlcGxhY2UgZXNjYXBlZCAnKidcbiAgICAvLyBpZ25vcmUgcnVsZSAnXFwqJyB3aWxsIG1hdGNoIHRoZSBwYXRoICcqJ1xuXG4gICAgLy8gJ2FiYy4qLycgLT4gZ29cbiAgICAvLyAnYWJjLionICAtPiBza2lwIHRoaXMgcnVsZSxcbiAgICAvLyAgICBjb3ogdHJhaWxpbmcgc2luZ2xlIHdpbGRjYXJkIHdpbGwgYmUgaGFuZGVkIGJ5IFt0cmFpbGluZyB3aWxkY2FyZF1cbiAgICAvKF58W15cXFxcXSspKFxcXFxcXCopKyg/PS4rKS9nLFxuXG4gICAgLy8gJyouanMnIG1hdGNoZXMgJy5qcydcbiAgICAvLyAnKi5qcycgZG9lc24ndCBtYXRjaCAnYWJjJ1xuICAgIChfLCBwMSwgcDIpID0+IHtcbiAgICAgIC8vIDEuXG4gICAgICAvLyA+IEFuIGFzdGVyaXNrIFwiKlwiIG1hdGNoZXMgYW55dGhpbmcgZXhjZXB0IGEgc2xhc2guXG4gICAgICAvLyAyLlxuICAgICAgLy8gPiBPdGhlciBjb25zZWN1dGl2ZSBhc3Rlcmlza3MgYXJlIGNvbnNpZGVyZWQgcmVndWxhciBhc3Rlcmlza3NcbiAgICAgIC8vID4gYW5kIHdpbGwgbWF0Y2ggYWNjb3JkaW5nIHRvIHRoZSBwcmV2aW91cyBydWxlcy5cbiAgICAgIGNvbnN0IHVuZXNjYXBlZCA9IHAyLnJlcGxhY2UoL1xcXFxcXCovZywgJ1teXFxcXC9dKicpXG4gICAgICByZXR1cm4gcDEgKyB1bmVzY2FwZWRcbiAgICB9XG4gIF0sXG5cbiAgW1xuICAgIC8vIHVuZXNjYXBlLCByZXZlcnQgc3RlcCAzIGV4Y2VwdCBmb3IgYmFjayBzbGFzaFxuICAgIC8vIEZvciBleGFtcGxlLCBpZiBhIHVzZXIgZXNjYXBlIGEgJ1xcXFwqJyxcbiAgICAvLyBhZnRlciBzdGVwIDMsIHRoZSByZXN1bHQgd2lsbCBiZSAnXFxcXFxcXFxcXFxcKidcbiAgICAvXFxcXFxcXFxcXFxcKD89WyQufCorKCl7Xl0pL2csXG4gICAgKCkgPT4gRVNDQVBFXG4gIF0sXG5cbiAgW1xuICAgIC8vICdcXFxcXFxcXCcgLT4gJ1xcXFwnXG4gICAgL1xcXFxcXFxcL2csXG4gICAgKCkgPT4gRVNDQVBFXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gVGhlIHJhbmdlIG5vdGF0aW9uLCBlLmcuIFthLXpBLVpdLFxuICAgIC8vID4gY2FuIGJlIHVzZWQgdG8gbWF0Y2ggb25lIG9mIHRoZSBjaGFyYWN0ZXJzIGluIGEgcmFuZ2UuXG5cbiAgICAvLyBgXFxgIGlzIGVzY2FwZWQgYnkgc3RlcCAzXG4gICAgLyhcXFxcKT9cXFsoW15cXF0vXSo/KShcXFxcKikoJHxcXF0pL2csXG4gICAgKG1hdGNoLCBsZWFkRXNjYXBlLCByYW5nZSwgZW5kRXNjYXBlLCBjbG9zZSkgPT4gbGVhZEVzY2FwZSA9PT0gRVNDQVBFXG4gICAgICAvLyAnXFxcXFtiYXJdJyAtPiAnXFxcXFxcXFxbYmFyXFxcXF0nXG4gICAgICA/IGBcXFxcWyR7cmFuZ2V9JHtjbGVhblJhbmdlQmFja1NsYXNoKGVuZEVzY2FwZSl9JHtjbG9zZX1gXG4gICAgICA6IGNsb3NlID09PSAnXSdcbiAgICAgICAgPyBlbmRFc2NhcGUubGVuZ3RoICUgMiA9PT0gMFxuICAgICAgICAgIC8vIEEgbm9ybWFsIGNhc2UsIGFuZCBpdCBpcyBhIHJhbmdlIG5vdGF0aW9uXG4gICAgICAgICAgLy8gJ1tiYXJdJ1xuICAgICAgICAgIC8vICdbYmFyXFxcXFxcXFxdJ1xuICAgICAgICAgID8gYFske3Nhbml0aXplUmFuZ2UocmFuZ2UpfSR7ZW5kRXNjYXBlfV1gXG4gICAgICAgICAgLy8gSW52YWxpZCByYW5nZSBub3RhdG9uXG4gICAgICAgICAgLy8gJ1tiYXJcXFxcXScgLT4gJ1tiYXJcXFxcXFxcXF0nXG4gICAgICAgICAgOiAnW10nXG4gICAgICAgIDogJ1tdJ1xuICBdLFxuXG4gIC8vIGVuZGluZ1xuICBbXG4gICAgLy8gJ2pzJyB3aWxsIG5vdCBtYXRjaCAnanMuJ1xuICAgIC8vICdhYicgd2lsbCBub3QgbWF0Y2ggJ2FiYydcbiAgICAvKD86W14qXSkkLyxcblxuICAgIC8vIFdURiFcbiAgICAvLyBodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0aWdub3JlXG4gICAgLy8gY2hhbmdlcyBpbiBbMi4yMi4xXShodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0aWdub3JlLzIuMjIuMSlcbiAgICAvLyB3aGljaCByZS1maXhlcyAjMjQsICMzOFxuXG4gICAgLy8gPiBJZiB0aGVyZSBpcyBhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuIHRoZW4gdGhlIHBhdHRlcm5cbiAgICAvLyA+IHdpbGwgb25seSBtYXRjaCBkaXJlY3Rvcmllcywgb3RoZXJ3aXNlIHRoZSBwYXR0ZXJuIGNhbiBtYXRjaCBib3RoXG4gICAgLy8gPiBmaWxlcyBhbmQgZGlyZWN0b3JpZXMuXG5cbiAgICAvLyAnanMqJyB3aWxsIG5vdCBtYXRjaCAnYS5qcydcbiAgICAvLyAnanMvJyB3aWxsIG5vdCBtYXRjaCAnYS5qcydcbiAgICAvLyAnanMnIHdpbGwgbWF0Y2ggJ2EuanMnIGFuZCAnYS5qcy8nXG4gICAgbWF0Y2ggPT4gL1xcLyQvLnRlc3QobWF0Y2gpXG4gICAgICAvLyBmb28vIHdpbGwgbm90IG1hdGNoICdmb28nXG4gICAgICA/IGAke21hdGNofSRgXG4gICAgICAvLyBmb28gbWF0Y2hlcyAnZm9vJyBhbmQgJ2Zvby8nXG4gICAgICA6IGAke21hdGNofSg/PSR8XFxcXC8kKWBcbiAgXSxcblxuICAvLyB0cmFpbGluZyB3aWxkY2FyZFxuICBbXG4gICAgLyhcXF58XFxcXFxcLyk/XFxcXFxcKiQvLFxuICAgIChfLCBwMSkgPT4ge1xuICAgICAgY29uc3QgcHJlZml4ID0gcDFcbiAgICAgICAgLy8gJ1xcXic6XG4gICAgICAgIC8vICcvKicgZG9lcyBub3QgbWF0Y2ggRU1QVFlcbiAgICAgICAgLy8gJy8qJyBkb2VzIG5vdCBtYXRjaCBldmVyeXRoaW5nXG5cbiAgICAgICAgLy8gJ1xcXFxcXC8nOlxuICAgICAgICAvLyAnYWJjLyonIGRvZXMgbm90IG1hdGNoICdhYmMvJ1xuICAgICAgICA/IGAke3AxfVteL10rYFxuXG4gICAgICAgIC8vICdhKicgbWF0Y2hlcyAnYSdcbiAgICAgICAgLy8gJ2EqJyBtYXRjaGVzICdhYSdcbiAgICAgICAgOiAnW14vXSonXG5cbiAgICAgIHJldHVybiBgJHtwcmVmaXh9KD89JHxcXFxcLyQpYFxuICAgIH1cbiAgXSxcbl1cblxuLy8gQSBzaW1wbGUgY2FjaGUsIGJlY2F1c2UgYW4gaWdub3JlIHJ1bGUgb25seSBoYXMgb25seSBvbmUgY2VydGFpbiBtZWFuaW5nXG5jb25zdCByZWdleENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4vLyBAcGFyYW0ge3BhdHRlcm59XG5jb25zdCBtYWtlUmVnZXggPSAocGF0dGVybiwgaWdub3JlQ2FzZSkgPT4ge1xuICBsZXQgc291cmNlID0gcmVnZXhDYWNoZVtwYXR0ZXJuXVxuXG4gIGlmICghc291cmNlKSB7XG4gICAgc291cmNlID0gUkVQTEFDRVJTLnJlZHVjZShcbiAgICAgIChwcmV2LCBjdXJyZW50KSA9PiBwcmV2LnJlcGxhY2UoY3VycmVudFswXSwgY3VycmVudFsxXS5iaW5kKHBhdHRlcm4pKSxcbiAgICAgIHBhdHRlcm5cbiAgICApXG4gICAgcmVnZXhDYWNoZVtwYXR0ZXJuXSA9IHNvdXJjZVxuICB9XG5cbiAgcmV0dXJuIGlnbm9yZUNhc2VcbiAgICA/IG5ldyBSZWdFeHAoc291cmNlLCAnaScpXG4gICAgOiBuZXcgUmVnRXhwKHNvdXJjZSlcbn1cblxuY29uc3QgaXNTdHJpbmcgPSBzdWJqZWN0ID0+IHR5cGVvZiBzdWJqZWN0ID09PSAnc3RyaW5nJ1xuXG4vLyA+IEEgYmxhbmsgbGluZSBtYXRjaGVzIG5vIGZpbGVzLCBzbyBpdCBjYW4gc2VydmUgYXMgYSBzZXBhcmF0b3IgZm9yIHJlYWRhYmlsaXR5LlxuY29uc3QgY2hlY2tQYXR0ZXJuID0gcGF0dGVybiA9PiBwYXR0ZXJuXG4gICYmIGlzU3RyaW5nKHBhdHRlcm4pXG4gICYmICFSRUdFWF9URVNUX0JMQU5LX0xJTkUudGVzdChwYXR0ZXJuKVxuICAmJiAhUkVHRVhfSU5WQUxJRF9UUkFJTElOR19CQUNLU0xBU0gudGVzdChwYXR0ZXJuKVxuXG4gIC8vID4gQSBsaW5lIHN0YXJ0aW5nIHdpdGggIyBzZXJ2ZXMgYXMgYSBjb21tZW50LlxuICAmJiBwYXR0ZXJuLmluZGV4T2YoJyMnKSAhPT0gMFxuXG5jb25zdCBzcGxpdFBhdHRlcm4gPSBwYXR0ZXJuID0+IHBhdHRlcm4uc3BsaXQoUkVHRVhfU1BMSVRBTExfQ1JMRilcblxuY2xhc3MgSWdub3JlUnVsZSB7XG4gIGNvbnN0cnVjdG9yIChcbiAgICBvcmlnaW4sXG4gICAgcGF0dGVybixcbiAgICBuZWdhdGl2ZSxcbiAgICByZWdleFxuICApIHtcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpblxuICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm5cbiAgICB0aGlzLm5lZ2F0aXZlID0gbmVnYXRpdmVcbiAgICB0aGlzLnJlZ2V4ID0gcmVnZXhcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVSdWxlID0gKHBhdHRlcm4sIGlnbm9yZUNhc2UpID0+IHtcbiAgY29uc3Qgb3JpZ2luID0gcGF0dGVyblxuICBsZXQgbmVnYXRpdmUgPSBmYWxzZVxuXG4gIC8vID4gQW4gb3B0aW9uYWwgcHJlZml4IFwiIVwiIHdoaWNoIG5lZ2F0ZXMgdGhlIHBhdHRlcm47XG4gIGlmIChwYXR0ZXJuLmluZGV4T2YoJyEnKSA9PT0gMCkge1xuICAgIG5lZ2F0aXZlID0gdHJ1ZVxuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnN1YnN0cigxKVxuICB9XG5cbiAgcGF0dGVybiA9IHBhdHRlcm5cbiAgLy8gPiBQdXQgYSBiYWNrc2xhc2ggKFwiXFxcIikgaW4gZnJvbnQgb2YgdGhlIGZpcnN0IFwiIVwiIGZvciBwYXR0ZXJucyB0aGF0XG4gIC8vID4gICBiZWdpbiB3aXRoIGEgbGl0ZXJhbCBcIiFcIiwgZm9yIGV4YW1wbGUsIGBcIlxcIWltcG9ydGFudCEudHh0XCJgLlxuICAucmVwbGFjZShSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9FWENMQU1BVElPTiwgJyEnKVxuICAvLyA+IFB1dCBhIGJhY2tzbGFzaCAoXCJcXFwiKSBpbiBmcm9udCBvZiB0aGUgZmlyc3QgaGFzaCBmb3IgcGF0dGVybnMgdGhhdFxuICAvLyA+ICAgYmVnaW4gd2l0aCBhIGhhc2guXG4gIC5yZXBsYWNlKFJFR0VYX1JFUExBQ0VfTEVBRElOR19FWENBUEVEX0hBU0gsICcjJylcblxuICBjb25zdCByZWdleCA9IG1ha2VSZWdleChwYXR0ZXJuLCBpZ25vcmVDYXNlKVxuXG4gIHJldHVybiBuZXcgSWdub3JlUnVsZShcbiAgICBvcmlnaW4sXG4gICAgcGF0dGVybixcbiAgICBuZWdhdGl2ZSxcbiAgICByZWdleFxuICApXG59XG5cbmNvbnN0IHRocm93RXJyb3IgPSAobWVzc2FnZSwgQ3RvcikgPT4ge1xuICB0aHJvdyBuZXcgQ3RvcihtZXNzYWdlKVxufVxuXG5jb25zdCBjaGVja1BhdGggPSAocGF0aCwgb3JpZ2luYWxQYXRoLCBkb1Rocm93KSA9PiB7XG4gIGlmICghaXNTdHJpbmcocGF0aCkpIHtcbiAgICByZXR1cm4gZG9UaHJvdyhcbiAgICAgIGBwYXRoIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCBnb3QgXFxgJHtvcmlnaW5hbFBhdGh9XFxgYCxcbiAgICAgIFR5cGVFcnJvclxuICAgIClcbiAgfVxuXG4gIC8vIFdlIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIGlnbm9yZSBFTVBUWSwgc28gdGhyb3dcbiAgaWYgKCFwYXRoKSB7XG4gICAgcmV0dXJuIGRvVGhyb3coYHBhdGggbXVzdCBub3QgYmUgZW1wdHlgLCBUeXBlRXJyb3IpXG4gIH1cblxuICAvLyBDaGVjayBpZiBpdCBpcyBhIHJlbGF0aXZlIHBhdGhcbiAgaWYgKGNoZWNrUGF0aC5pc05vdFJlbGF0aXZlKHBhdGgpKSB7XG4gICAgY29uc3QgciA9ICdgcGF0aC5yZWxhdGl2ZSgpYGQnXG4gICAgcmV0dXJuIGRvVGhyb3coXG4gICAgICBgcGF0aCBzaG91bGQgYmUgYSAke3J9IHN0cmluZywgYnV0IGdvdCBcIiR7b3JpZ2luYWxQYXRofVwiYCxcbiAgICAgIFJhbmdlRXJyb3JcbiAgICApXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBpc05vdFJlbGF0aXZlID0gcGF0aCA9PiBSRUdFWF9URVNUX0lOVkFMSURfUEFUSC50ZXN0KHBhdGgpXG5cbmNoZWNrUGF0aC5pc05vdFJlbGF0aXZlID0gaXNOb3RSZWxhdGl2ZVxuY2hlY2tQYXRoLmNvbnZlcnQgPSBwID0+IHBcblxuY2xhc3MgSWdub3JlIHtcbiAgY29uc3RydWN0b3IgKHtcbiAgICBpZ25vcmVjYXNlID0gdHJ1ZSxcbiAgICBpZ25vcmVDYXNlID0gaWdub3JlY2FzZSxcbiAgICBhbGxvd1JlbGF0aXZlUGF0aHMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBkZWZpbmUodGhpcywgS0VZX0lHTk9SRSwgdHJ1ZSlcblxuICAgIHRoaXMuX3J1bGVzID0gW11cbiAgICB0aGlzLl9pZ25vcmVDYXNlID0gaWdub3JlQ2FzZVxuICAgIHRoaXMuX2FsbG93UmVsYXRpdmVQYXRocyA9IGFsbG93UmVsYXRpdmVQYXRoc1xuICAgIHRoaXMuX2luaXRDYWNoZSgpXG4gIH1cblxuICBfaW5pdENhY2hlICgpIHtcbiAgICB0aGlzLl9pZ25vcmVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB0aGlzLl90ZXN0Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIH1cblxuICBfYWRkUGF0dGVybiAocGF0dGVybikge1xuICAgIC8vICMzMlxuICAgIGlmIChwYXR0ZXJuICYmIHBhdHRlcm5bS0VZX0lHTk9SRV0pIHtcbiAgICAgIHRoaXMuX3J1bGVzID0gdGhpcy5fcnVsZXMuY29uY2F0KHBhdHRlcm4uX3J1bGVzKVxuICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2hlY2tQYXR0ZXJuKHBhdHRlcm4pKSB7XG4gICAgICBjb25zdCBydWxlID0gY3JlYXRlUnVsZShwYXR0ZXJuLCB0aGlzLl9pZ25vcmVDYXNlKVxuICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlXG4gICAgICB0aGlzLl9ydWxlcy5wdXNoKHJ1bGUpXG4gICAgfVxuICB9XG5cbiAgLy8gQHBhcmFtIHtBcnJheTxzdHJpbmc+IHwgc3RyaW5nIHwgSWdub3JlfSBwYXR0ZXJuXG4gIGFkZCAocGF0dGVybikge1xuICAgIHRoaXMuX2FkZGVkID0gZmFsc2VcblxuICAgIG1ha2VBcnJheShcbiAgICAgIGlzU3RyaW5nKHBhdHRlcm4pXG4gICAgICAgID8gc3BsaXRQYXR0ZXJuKHBhdHRlcm4pXG4gICAgICAgIDogcGF0dGVyblxuICAgICkuZm9yRWFjaCh0aGlzLl9hZGRQYXR0ZXJuLCB0aGlzKVxuXG4gICAgLy8gU29tZSBydWxlcyBoYXZlIGp1c3QgYWRkZWQgdG8gdGhlIGlnbm9yZSxcbiAgICAvLyBtYWtpbmcgdGhlIGJlaGF2aW9yIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuX2FkZGVkKSB7XG4gICAgICB0aGlzLl9pbml0Q2FjaGUoKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBsZWdhY3lcbiAgYWRkUGF0dGVybiAocGF0dGVybikge1xuICAgIHJldHVybiB0aGlzLmFkZChwYXR0ZXJuKVxuICB9XG5cbiAgLy8gICAgICAgICAgfCAgICAgICAgICAgaWdub3JlZCA6IHVuaWdub3JlZFxuICAvLyBuZWdhdGl2ZSB8ICAgMDowICAgfCAgIDA6MSAgIHwgICAxOjAgICB8ICAgMToxXG4gIC8vIC0tLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0gfCAtLS0tLS0tIHwgLS0tLS0tLS1cbiAgLy8gICAgIDAgICAgfCAgVEVTVCAgIHwgIFRFU1QgICB8ICBTS0lQICAgfCAgICBYXG4gIC8vICAgICAxICAgIHwgIFRFU1RJRiB8ICBTS0lQICAgfCAgVEVTVCAgIHwgICAgWFxuXG4gIC8vIC0gU0tJUDogYWx3YXlzIHNraXBcbiAgLy8gLSBURVNUOiBhbHdheXMgdGVzdFxuICAvLyAtIFRFU1RJRjogb25seSB0ZXN0IGlmIGNoZWNrVW5pZ25vcmVkXG4gIC8vIC0gWDogdGhhdCBuZXZlciBoYXBwZW5cblxuICAvLyBAcGFyYW0ge2Jvb2xlYW59IHdoZXRoZXIgc2hvdWxkIGNoZWNrIGlmIHRoZSBwYXRoIGlzIHVuaWdub3JlZCxcbiAgLy8gICBzZXR0aW5nIGBjaGVja1VuaWdub3JlZGAgdG8gYGZhbHNlYCBjb3VsZCByZWR1Y2UgYWRkaXRpb25hbFxuICAvLyAgIHBhdGggbWF0Y2hpbmcuXG5cbiAgLy8gQHJldHVybnMge1Rlc3RSZXN1bHR9IHRydWUgaWYgYSBmaWxlIGlzIGlnbm9yZWRcbiAgX3Rlc3RPbmUgKHBhdGgsIGNoZWNrVW5pZ25vcmVkKSB7XG4gICAgbGV0IGlnbm9yZWQgPSBmYWxzZVxuICAgIGxldCB1bmlnbm9yZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5fcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgIGNvbnN0IHtuZWdhdGl2ZX0gPSBydWxlXG4gICAgICBpZiAoXG4gICAgICAgIHVuaWdub3JlZCA9PT0gbmVnYXRpdmUgJiYgaWdub3JlZCAhPT0gdW5pZ25vcmVkXG4gICAgICAgIHx8IG5lZ2F0aXZlICYmICFpZ25vcmVkICYmICF1bmlnbm9yZWQgJiYgIWNoZWNrVW5pZ25vcmVkXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoZWQgPSBydWxlLnJlZ2V4LnRlc3QocGF0aClcblxuICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgaWdub3JlZCA9ICFuZWdhdGl2ZVxuICAgICAgICB1bmlnbm9yZWQgPSBuZWdhdGl2ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgaWdub3JlZCxcbiAgICAgIHVuaWdub3JlZFxuICAgIH1cbiAgfVxuXG4gIC8vIEByZXR1cm5zIHtUZXN0UmVzdWx0fVxuICBfdGVzdCAob3JpZ2luYWxQYXRoLCBjYWNoZSwgY2hlY2tVbmlnbm9yZWQsIHNsaWNlcykge1xuICAgIGNvbnN0IHBhdGggPSBvcmlnaW5hbFBhdGhcbiAgICAgIC8vIFN1cHBvcnRzIG51bGxhYmxlIHBhdGhcbiAgICAgICYmIGNoZWNrUGF0aC5jb252ZXJ0KG9yaWdpbmFsUGF0aClcblxuICAgIGNoZWNrUGF0aChcbiAgICAgIHBhdGgsXG4gICAgICBvcmlnaW5hbFBhdGgsXG4gICAgICB0aGlzLl9hbGxvd1JlbGF0aXZlUGF0aHNcbiAgICAgICAgPyBSRVRVUk5fRkFMU0VcbiAgICAgICAgOiB0aHJvd0Vycm9yXG4gICAgKVxuXG4gICAgcmV0dXJuIHRoaXMuX3QocGF0aCwgY2FjaGUsIGNoZWNrVW5pZ25vcmVkLCBzbGljZXMpXG4gIH1cblxuICBfdCAocGF0aCwgY2FjaGUsIGNoZWNrVW5pZ25vcmVkLCBzbGljZXMpIHtcbiAgICBpZiAocGF0aCBpbiBjYWNoZSkge1xuICAgICAgcmV0dXJuIGNhY2hlW3BhdGhdXG4gICAgfVxuXG4gICAgaWYgKCFzbGljZXMpIHtcbiAgICAgIC8vIHBhdGgvdG8vYS5qc1xuICAgICAgLy8gWydwYXRoJywgJ3RvJywgJ2EuanMnXVxuICAgICAgc2xpY2VzID0gcGF0aC5zcGxpdChTTEFTSClcbiAgICB9XG5cbiAgICBzbGljZXMucG9wKClcblxuICAgIC8vIElmIHRoZSBwYXRoIGhhcyBubyBwYXJlbnQgZGlyZWN0b3J5LCBqdXN0IHRlc3QgaXRcbiAgICBpZiAoIXNsaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjYWNoZVtwYXRoXSA9IHRoaXMuX3Rlc3RPbmUocGF0aCwgY2hlY2tVbmlnbm9yZWQpXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fdChcbiAgICAgIHNsaWNlcy5qb2luKFNMQVNIKSArIFNMQVNILFxuICAgICAgY2FjaGUsXG4gICAgICBjaGVja1VuaWdub3JlZCxcbiAgICAgIHNsaWNlc1xuICAgIClcblxuICAgIC8vIElmIHRoZSBwYXRoIGNvbnRhaW5zIGEgcGFyZW50IGRpcmVjdG9yeSwgY2hlY2sgdGhlIHBhcmVudCBmaXJzdFxuICAgIHJldHVybiBjYWNoZVtwYXRoXSA9IHBhcmVudC5pZ25vcmVkXG4gICAgICAvLyA+IEl0IGlzIG5vdCBwb3NzaWJsZSB0byByZS1pbmNsdWRlIGEgZmlsZSBpZiBhIHBhcmVudCBkaXJlY3Rvcnkgb2ZcbiAgICAgIC8vID4gICB0aGF0IGZpbGUgaXMgZXhjbHVkZWQuXG4gICAgICA/IHBhcmVudFxuICAgICAgOiB0aGlzLl90ZXN0T25lKHBhdGgsIGNoZWNrVW5pZ25vcmVkKVxuICB9XG5cbiAgaWdub3JlcyAocGF0aCkge1xuICAgIHJldHVybiB0aGlzLl90ZXN0KHBhdGgsIHRoaXMuX2lnbm9yZUNhY2hlLCBmYWxzZSkuaWdub3JlZFxuICB9XG5cbiAgY3JlYXRlRmlsdGVyICgpIHtcbiAgICByZXR1cm4gcGF0aCA9PiAhdGhpcy5pZ25vcmVzKHBhdGgpXG4gIH1cblxuICBmaWx0ZXIgKHBhdGhzKSB7XG4gICAgcmV0dXJuIG1ha2VBcnJheShwYXRocykuZmlsdGVyKHRoaXMuY3JlYXRlRmlsdGVyKCkpXG4gIH1cblxuICAvLyBAcmV0dXJucyB7VGVzdFJlc3VsdH1cbiAgdGVzdCAocGF0aCkge1xuICAgIHJldHVybiB0aGlzLl90ZXN0KHBhdGgsIHRoaXMuX3Rlc3RDYWNoZSwgdHJ1ZSlcbiAgfVxufVxuXG5jb25zdCBmYWN0b3J5ID0gb3B0aW9ucyA9PiBuZXcgSWdub3JlKG9wdGlvbnMpXG5cbmNvbnN0IGlzUGF0aFZhbGlkID0gcGF0aCA9PlxuICBjaGVja1BhdGgocGF0aCAmJiBjaGVja1BhdGguY29udmVydChwYXRoKSwgcGF0aCwgUkVUVVJOX0ZBTFNFKVxuXG5mYWN0b3J5LmlzUGF0aFZhbGlkID0gaXNQYXRoVmFsaWRcblxuLy8gRml4ZXMgdHlwZXNjcmlwdFxuZmFjdG9yeS5kZWZhdWx0ID0gZmFjdG9yeVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnlcblxuLy8gV2luZG93c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKFxuICAvLyBEZXRlY3QgYHByb2Nlc3NgIHNvIHRoYXQgaXQgY2FuIHJ1biBpbiBicm93c2Vycy5cbiAgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICYmIChcbiAgICBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5JR05PUkVfVEVTVF9XSU4zMlxuICAgIHx8IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgKVxuKSB7XG4gIC8qIGVzbGludCBuby1jb250cm9sLXJlZ2V4OiBcIm9mZlwiICovXG4gIGNvbnN0IG1ha2VQb3NpeCA9IHN0ciA9PiAvXlxcXFxcXFxcXFw/XFxcXC8udGVzdChzdHIpXG4gIHx8IC9bXCI8PnxcXHUwMDAwLVxcdTAwMUZdKy91LnRlc3Qoc3RyKVxuICAgID8gc3RyXG4gICAgOiBzdHIucmVwbGFjZSgvXFxcXC9nLCAnLycpXG5cbiAgY2hlY2tQYXRoLmNvbnZlcnQgPSBtYWtlUG9zaXhcblxuICAvLyAnQzpcXFxcZm9vJyAgICAgPC0gJ0M6XFxcXGZvbycgaGFzIGJlZW4gY29udmVydGVkIHRvICdDOi8nXG4gIC8vICdkOlxcXFxmb28nXG4gIGNvbnN0IFJFR0lYX0lTX1dJTkRPV1NfUEFUSF9BQlNPTFVURSA9IC9eW2Etel06XFwvL2lcbiAgY2hlY2tQYXRoLmlzTm90UmVsYXRpdmUgPSBwYXRoID0+XG4gICAgUkVHSVhfSVNfV0lORE9XU19QQVRIX0FCU09MVVRFLnRlc3QocGF0aClcbiAgICB8fCBpc05vdFJlbGF0aXZlKHBhdGgpXG59XG4iXSwibmFtZXMiOlsibWFrZUFycmF5Iiwic3ViamVjdCIsIkFycmF5IiwiaXNBcnJheSIsIkVNUFRZIiwiU1BBQ0UiLCJFU0NBUEUiLCJSRUdFWF9URVNUX0JMQU5LX0xJTkUiLCJSRUdFWF9JTlZBTElEX1RSQUlMSU5HX0JBQ0tTTEFTSCIsIlJFR0VYX1JFUExBQ0VfTEVBRElOR19FWENBUEVEX0VYQ0xBTUFUSU9OIiwiUkVHRVhfUkVQTEFDRV9MRUFESU5HX0VYQ0FQRURfSEFTSCIsIlJFR0VYX1NQTElUQUxMX0NSTEYiLCJSRUdFWF9URVNUX0lOVkFMSURfUEFUSCIsIlNMQVNIIiwiVE1QX0tFWV9JR05PUkUiLCJTeW1ib2wiLCJmb3IiLCJLRVlfSUdOT1JFIiwiZGVmaW5lIiwib2JqZWN0Iiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIlJFR0VYX1JFR0VYUF9SQU5HRSIsIlJFVFVSTl9GQUxTRSIsInNhbml0aXplUmFuZ2UiLCJyYW5nZSIsInJlcGxhY2UiLCJtYXRjaCIsImZyb20iLCJ0byIsImNoYXJDb2RlQXQiLCJjbGVhblJhbmdlQmFja1NsYXNoIiwic2xhc2hlcyIsImxlbmd0aCIsInNsaWNlIiwiUkVQTEFDRVJTIiwiaW5kZXhPZiIsInN0YXJ0aW5nUmVwbGFjZXIiLCJ0ZXN0IiwiXyIsImluZGV4Iiwic3RyIiwicDEiLCJwMiIsInVuZXNjYXBlZCIsImxlYWRFc2NhcGUiLCJlbmRFc2NhcGUiLCJjbG9zZSIsInByZWZpeCIsInJlZ2V4Q2FjaGUiLCJjcmVhdGUiLCJtYWtlUmVnZXgiLCJwYXR0ZXJuIiwiaWdub3JlQ2FzZSIsInNvdXJjZSIsInJlZHVjZSIsInByZXYiLCJjdXJyZW50IiwiYmluZCIsIlJlZ0V4cCIsImlzU3RyaW5nIiwiY2hlY2tQYXR0ZXJuIiwic3BsaXRQYXR0ZXJuIiwic3BsaXQiLCJJZ25vcmVSdWxlIiwiY29uc3RydWN0b3IiLCJvcmlnaW4iLCJuZWdhdGl2ZSIsInJlZ2V4IiwiY3JlYXRlUnVsZSIsInN1YnN0ciIsInRocm93RXJyb3IiLCJtZXNzYWdlIiwiQ3RvciIsImNoZWNrUGF0aCIsInBhdGgiLCJvcmlnaW5hbFBhdGgiLCJkb1Rocm93IiwiVHlwZUVycm9yIiwiaXNOb3RSZWxhdGl2ZSIsInIiLCJSYW5nZUVycm9yIiwiY29udmVydCIsInAiLCJJZ25vcmUiLCJpZ25vcmVjYXNlIiwiYWxsb3dSZWxhdGl2ZVBhdGhzIiwiX3J1bGVzIiwiX2lnbm9yZUNhc2UiLCJfYWxsb3dSZWxhdGl2ZVBhdGhzIiwiX2luaXRDYWNoZSIsIl9pZ25vcmVDYWNoZSIsIl90ZXN0Q2FjaGUiLCJfYWRkUGF0dGVybiIsImNvbmNhdCIsIl9hZGRlZCIsInJ1bGUiLCJwdXNoIiwiYWRkIiwiZm9yRWFjaCIsImFkZFBhdHRlcm4iLCJfdGVzdE9uZSIsImNoZWNrVW5pZ25vcmVkIiwiaWdub3JlZCIsInVuaWdub3JlZCIsIm1hdGNoZWQiLCJfdGVzdCIsImNhY2hlIiwic2xpY2VzIiwiX3QiLCJwb3AiLCJwYXJlbnQiLCJqb2luIiwiaWdub3JlcyIsImNyZWF0ZUZpbHRlciIsImZpbHRlciIsInBhdGhzIiwiZmFjdG9yeSIsIm9wdGlvbnMiLCJpc1BhdGhWYWxpZCIsImRlZmF1bHQiLCJtb2R1bGUiLCJleHBvcnRzIiwicHJvY2VzcyIsImVudiIsIklHTk9SRV9URVNUX1dJTjMyIiwicGxhdGZvcm0iLCJtYWtlUG9zaXgiLCJSRUdJWF9JU19XSU5ET1dTX1BBVEhfQUJTT0xVVEUiXSwibWFwcGluZ3MiOiJBQUFBLHdDQUF3QztBQUN4QyxTQUFTQSxVQUFXQyxPQUFPO0lBQ3pCLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQ0YsV0FDakJBLFVBQ0E7UUFBQ0E7S0FBUTtBQUNmO0FBRUEsTUFBTUcsUUFBUTtBQUNkLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLG1DQUFtQztBQUN6QyxNQUFNQyw0Q0FBNEM7QUFDbEQsTUFBTUMscUNBQXFDO0FBQzNDLE1BQU1DLHNCQUFzQjtBQUM1QixRQUFRO0FBQ1IsU0FBUztBQUNULFVBQVU7QUFDVixJQUFJO0FBQ0osS0FBSztBQUNMLE1BQU1DLDBCQUEwQjtB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TyxDQUFDUCxPQUFPQSxNQUFNcEQ7QUFFbkQ4RixRQUFRRSxXQUFXLEdBQUdBO0FBRXRCLG1CQUFtQjtBQUNuQkYsUUFBUUcsT0FBTyxHQUFHSDtBQUVsQkksT0FBT0MsT0FBTyxHQUFHTDtBQUVqQixVQUFVO0FBQ1YsaUVBQWlFO0FBQ2pFLHNCQUFzQixHQUN0QixJQUNFLG1EQUFtRDtBQUNuRCxPQUFPTSxZQUFZLGVBRWpCQSxDQUFBQSxRQUFRQyxHQUFHLElBQUlELFFBQVFDLEdBQUcsQ0FBQ0MsaUJBQWlCLElBQ3pDRixRQUFRRyxRQUFRLEtBQUssT0FBTSxHQUVoQztJQUNBLGtDQUFrQyxHQUNsQyxNQUFNQyxZQUFZdEYsQ0FBQUEsTUFBTyxZQUFZSCxJQUFJLENBQUNHLFFBQ3ZDLHdCQUF3QkgsSUFBSSxDQUFDRyxPQUM1QkEsTUFDQUEsSUFBSWYsT0FBTyxDQUFDLE9BQU87SUFFdkJnRCxVQUFVUSxPQUFPLEdBQUc2QztJQUVwQix5REFBeUQ7SUFDekQsWUFBWTtJQUNaLE1BQU1DLGlDQUFpQztJQUN2Q3RELFVBQVVLLGFBQWEsR0FBR0osQ0FBQUEsT0FDeEJxRCwrQkFBK0IxRixJQUFJLENBQUNxQyxTQUNqQ0ksY0FBY0o7QUFDckIiLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaWdub3JlL2luZGV4LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ignore/index.js\n");

/***/ })

};
;